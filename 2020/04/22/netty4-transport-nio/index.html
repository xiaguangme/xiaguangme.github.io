<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="羽衣">
  <meta name="keywords" content="spring dubbo netty kafka 源码剖析 java 程序">
  <title>netty之nio传输层 - Code to 60 码到60岁</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.18.1/styles/github-gist.min.css" />


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_ijqayz9ro8k.css">




<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Code to 60 码到60岁</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">
              <i class="iconfont icon-home-fill"></i>
              首页</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/think/">
              
              零碎思索记录</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/program-language-practice">
              
              编程语言实践</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/opensource-code-study">
              
              开源项目学习</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/book-paper-study">
              
              书籍论文学习</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/life">
              
              美食旅行运动</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">
              <i class="iconfont icon-user-fill"></i>
              关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/c-1.jpeg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.1)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <div class="mt-3 post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2020-04-22 07:47">
                    星期三, 四月 22日 2020, 7:47 早上
                  </time>
                </div>
              

              <div class="mt-1">
                
                  
                  <span class="post-meta mr-2">
                    <i class="iconfont icon-chart"></i>
                    6.4k 字
                  </span>
                

                
                  
                  <span class="post-meta mr-2">
                      <i class="iconfont icon-clock-fill"></i>
                    
                    
                    104
                     分钟
                  </span>
                

                
              </div>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <!-- <div class="d-none d-lg-block col-lg-2"></div> -->
    <div class="col-lg-10 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h2 id="nio基本处理逻辑"><a href="#nio基本处理逻辑" class="headerlink" title="nio基本处理逻辑"></a>nio基本处理逻辑</h2><p><a href="https://images.cnblogs.com/cnblogs_com/simoncook/1602252/o_nio%E5%9F%BA%E6%9C%AC%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91.png" target="_blank" rel="noopener">查看这里</a><br><img src="https://images.cnblogs.com/cnblogs_com/simoncook/1602252/o_nio%E5%9F%BA%E6%9C%AC%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91.png" srcset="/img/loading.gif" alt="nio基本处理逻辑" />  </p>
<h2 id="Selector的处理"><a href="#Selector的处理" class="headerlink" title="Selector的处理"></a>Selector的处理</h2><h3 id="Selector实例构建"><a href="#Selector实例构建" class="headerlink" title="Selector实例构建"></a>Selector实例构建</h3><p>NioEventLoop.openSelector()方法先用JDK API构建出来的Selector再用反射将其中的selectedKeys、publicSelectedKeys替换成他优化过的SelectedSelectionKeySet实例。<br>JDK API构建出来的Selector 代码：  </p>
<pre><code class="hljs java"><span class="hljs-comment">// NioEventLoop</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SelectorProvider provider; <span class="hljs-comment">// SelectorProvider.provider() 直接用JDK提供的prodvider prodiver一下，在mac上返回值是sun.nio.ch.KQueueSelectorProvider@1b26f7b2 对应的selector实现是sun.nio.ch.KQueueSelectorImpl@23fe1d71</span>
unwrappedSelector = provider.openSelector();
<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SelectorTuple(unwrappedSelector,
                                 <span class="hljs-keyword">new</span> SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));</code></pre>
<p>unwrappedSelector是指我们通常用JDK的API构建出来的Selector，实际netty使用的是经过他自己优化过的<code>SelectorTuple</code>。下面有分析<code>SelectorTuple</code>。 </p>
<p>用反射方法替换：<br>io.netty.channel.nio.NioEventLoop.openSelector() 用法反射的方式将netty声明的SelectedSelectionKeySet实例selectedKeySet (netty的SelectedSelectionKeySet类继承了java.util.AbstractSet)赋值给了selectorImplClass。因为SelectedSelectionKeySet更快，参见下面SelectorTuple分析部分。<br>selectorImplClass是什么呢？就是各平台的Selector的实现，netty是怎么获取的呢？<br>直接加载”sun.nio.ch.SelectorImpl”即可。<br>而且用这种方式替换完之后，每次select之后，只要处理(跌代理里面的key)刚才这个SelectedSelectionKeySet实例selectedKeys(selectedKeySet会赋值给selectedKeys)，这个实例也是NioEventLoop的实例变量。简单地说，每次select之后，选中的有事件的key就已经在<code>NioEventLoop</code>的实例变量<code>selectedKeys</code>字段中了。   </p>
<h3 id="SelectorTuple分析"><a href="#SelectorTuple分析" class="headerlink" title="SelectorTuple分析"></a>SelectorTuple分析</h3><p>SelectorTuple依靠<code>SelectedSelectionKeySetSelector</code>和<code>SelectedSelectionKeySet</code>完成优化，<code>SelectedSelectionKeySet</code>内部采用了==数组来替换了JDK实现中的hashset==来维护SelectionKey，提升了add reset 与迭代的效率。<strong>真是佩服</strong>！    </p>
<pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectedSelectionKeySet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet</span>&lt;<span class="hljs-title">SelectionKey</span>&gt; </span>&#123;

    SelectionKey[] keys;
    <span class="hljs-keyword">int</span> size;
<span class="hljs-comment">// ......</span>

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(SelectionKey o)</span> </span>&#123;
        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;
            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;
        &#125;

        keys[size++] = o;
        <span class="hljs-keyword">if</span> (size == keys.length) &#123;
            increaseCapacity();
        &#125;

        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;
    &#125;

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;
        Arrays.fill(keys, start, size, <span class="hljs-keyword">null</span>);
        size = <span class="hljs-number">0</span>;
    &#125;
&#125;
<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectedSelectionKeySetSelector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Selector</span> </span>&#123;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SelectedSelectionKeySet selectionKeys;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Selector delegate;

    SelectedSelectionKeySetSelector(Selector delegate, SelectedSelectionKeySet selectionKeys) &#123;
        <span class="hljs-keyword">this</span>.delegate = delegate;
        <span class="hljs-keyword">this</span>.selectionKeys = selectionKeys;
    &#125;
&#125;

<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectorTuple</span> </span>&#123;
    <span class="hljs-keyword">final</span> Selector unwrappedSelector;
    <span class="hljs-keyword">final</span> Selector selector;

    SelectorTuple(Selector unwrappedSelector) &#123;
        <span class="hljs-keyword">this</span>.unwrappedSelector = unwrappedSelector;
        <span class="hljs-keyword">this</span>.selector = unwrappedSelector;
    &#125;

    SelectorTuple(Selector unwrappedSelector, Selector selector) &#123;
        <span class="hljs-keyword">this</span>.unwrappedSelector = unwrappedSelector;
        <span class="hljs-keyword">this</span>.selector = selector;
    &#125;
&#125;</code></pre>

<h2 id="ServerSocketChannel创建与初始化"><a href="#ServerSocketChannel创建与初始化" class="headerlink" title="ServerSocketChannel创建与初始化"></a>ServerSocketChannel创建与初始化</h2><h3 id="ServerSocketChannel创建过程"><a href="#ServerSocketChannel创建过程" class="headerlink" title="ServerSocketChannel创建过程"></a>ServerSocketChannel创建过程</h3><p>bind的时候会创建ServerSocketChannel，并丢给NioServerSocketChannel实例的ch字段<br>调用栈：  </p>
<pre><code class="hljs java">Thread [main] (Suspended (modification of field ch in AbstractNioChannel))	
io.netty.channel.socket.nio.NioServerSocketChannel(io.netty.channel.nio.AbstractNioChannel).&lt;init&gt;(io.netty.channel.Channel, java.nio.channels.SelectableChannel, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">85</span>	
io.netty.channel.socket.nio.NioServerSocketChannel(io.netty.channel.nio.AbstractNioMessageChannel).&lt;init&gt;(io.netty.channel.Channel, java.nio.channels.SelectableChannel, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">42</span>	
io.netty.channel.socket.nio.NioServerSocketChannel.&lt;init&gt;(java.nio.channels.ServerSocketChannel) line: <span class="hljs-number">88</span>	
io.netty.channel.socket.nio.NioServerSocketChannel.&lt;init&gt;() line: <span class="hljs-number">74</span>	
sun.reflect.NativeConstructorAccessorImpl.newInstance0(java.lang.reflect.Constructor&lt;?&gt;, java.lang.Object[]) line: not available [<span class="hljs-keyword">native</span> method]	
sun.reflect.NativeConstructorAccessorImpl.newInstance(java.lang.Object[]) line: <span class="hljs-number">62</span>	
sun.reflect.DelegatingConstructorAccessorImpl.newInstance(java.lang.Object[]) line: <span class="hljs-number">45</span>	
java.lang.reflect.Constructor&lt;T&gt;.newInstance(java.lang.Object...) line: <span class="hljs-number">423</span>	
io.netty.channel.ReflectiveChannelFactory&lt;T&gt;.newChannel() line: <span class="hljs-number">44</span>	
io.netty.bootstrap.ServerBootstrap(io.netty.bootstrap.AbstractBootstrap&lt;B,C&gt;).initAndRegister() line: <span class="hljs-number">320</span>	
io.netty.bootstrap.ServerBootstrap(io.netty.bootstrap.AbstractBootstrap&lt;B,C&gt;).doBind(java.net.SocketAddress) line: <span class="hljs-number">282</span>	
io.netty.bootstrap.ServerBootstrap(io.netty.bootstrap.AbstractBootstrap&lt;B,C&gt;).bind(java.net.SocketAddress) line: <span class="hljs-number">278</span>	
org.restexpress.RestExpress.bind(java.net.InetSocketAddress) line: <span class="hljs-number">709</span>	
org.restexpress.RestExpress.bind(java.lang.String, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">686</span>	
com.code260.ss.resetexpress.RestExpressApp1.main(java.lang.String[]) line: <span class="hljs-number">26</span></code></pre>

<h2 id="bind的处理"><a href="#bind的处理" class="headerlink" title="bind的处理"></a>bind的处理</h2><h3 id="AbstractBootstrap-doBind逻辑"><a href="#AbstractBootstrap-doBind逻辑" class="headerlink" title="AbstractBootstrap doBind逻辑"></a>AbstractBootstrap doBind逻辑</h3><p>NioServerSocketChannel类继承体系：  </p>
<pre><code class="hljs java"><span class="hljs-comment">// AttributeMap体系</span>
<span class="hljs-number">251</span> AttributeMap
--<span class="hljs-number">251.2</span> DefaultAttributeMap
----<span class="hljs-number">251.2</span><span class="hljs-number">.1</span> AbstractChannel
------<span class="hljs-number">251.2</span><span class="hljs-number">.1</span><span class="hljs-number">.7</span> AbstractNioChannel
--------<span class="hljs-number">251.2</span><span class="hljs-number">.1</span><span class="hljs-number">.7</span><span class="hljs-number">.1</span> AbstractNioMessageChannel
----------<span class="hljs-number">251.2</span><span class="hljs-number">.1</span><span class="hljs-number">.7</span><span class="hljs-number">.1</span><span class="hljs-number">.5</span> NioServerSocketChannel

<span class="hljs-comment">// Channel体系</span>
--<span class="hljs-number">463.1</span> Channel
----<span class="hljs-number">463.1</span><span class="hljs-number">.2</span> AbstractChannel  <span class="hljs-comment">// 与pipeline绑定。 构建时就会创建pipeline，newChannelPipeline。</span>
------<span class="hljs-number">463.1</span><span class="hljs-number">.2</span><span class="hljs-number">.7</span> AbstractNioChannel  <span class="hljs-comment">// 支持多种不同实现的SelectableChannel，ServerSocketChannel与SocketChannel都是SelectableChannel的实现。支持构建AbstractNioChannel时指定感兴趣的事件(readInterestOp)并与该Channel实例绑定(会赋值给实例字段readInterestOp)，且在该类构造方法中将channel设置为非阻塞。可见，其意在Select的Channel与感兴趣的事件的封装  </span>
--------<span class="hljs-number">463.1</span><span class="hljs-number">.2</span><span class="hljs-number">.7</span><span class="hljs-number">.1</span> AbstractNioMessageChannel <span class="hljs-comment">// 意在定义读写Message(其实就是消息对象，一个Object或者一组Object)接口。并对doWrite做了一些实现。</span>
----------<span class="hljs-number">463.1</span><span class="hljs-number">.2</span><span class="hljs-number">.7</span><span class="hljs-number">.1</span><span class="hljs-number">.5</span> NioServerSocketChannel</code></pre>

<ol>
<li>initAndRegister并返回ChannelFuture实例，具体逻辑参见下面小节  </li>
<li>doBind0  交由boss线程去做真正bind动作</li>
</ol>
<h4 id="io-netty-bootstrap-AbstractBootstrap-initAndRegister-逻辑"><a href="#io-netty-bootstrap-AbstractBootstrap-initAndRegister-逻辑" class="headerlink" title="io.netty.bootstrap.AbstractBootstrap.initAndRegister()逻辑"></a>io.netty.bootstrap.AbstractBootstrap.initAndRegister()逻辑</h4><ol>
<li><strong>==创建Channel==</strong>，即<strong>==ServerSocketChannel==</strong>实例，并将值包装到netty自己封装的NioServerSocketChannel中。channel = channelFactory.newChannel();  </li>
<li><strong>==初始化channel==</strong>。init(channel);根据io.netty.bootstrap.AbstractBootstrap.options给Channel<strong>==配置一些参数==</strong>。server端chanel的参数有{SO_BACKLOG=1024, SO_REUSEADDR=true, CONNECT_TIMEOUT_MILLIS=10000, SO_RCVBUF=262140, RCVBUF_ALLOCATOR=io.netty.channel.AdaptiveRecvByteBufAllocator@17cdf2d0}。并在Channel对应的pipeline上<strong>==绑定ChannelInitializer==</strong>。  </li>
<li><strong>==注册Channel==</strong>，先 <strong>==选出一个Executor即NioEventLoop==</strong> ， 选的方法逻辑在io.netty.util.concurrent.DefaultEventExecutorChooserFactory$PowerOfTwoEventExecutorChooser@15cafec7  中 executors[idx.getAndIncrement() &amp; executors.length - 1]。然后用io.netty.channel.SingleThreadEventLoop.register(Channel)<strong>==注册Channel到Exceutor(即NioEventLoop)中==</strong>。注册时限看是否是当前EventLoop（对于单线程执行器来说就是看是否是本线程），如果是 直接注册，如果不是则new一个Runnbale出来把注册逻辑包进去 并交给当前eventLoop执行这个runnable。<br>注册的细节是： io.netty.channel.AbstractChannel.AbstractUnsafe.register(EventLoop, ChannelPromise)<br>执行的细节是： io.netty.util.concurrent.SingleThreadEventExecutor.execute(Runnable)<br>内部实现是将task放到io.netty.util.concurrent.SingleThreadEventExecutor.taskQueue这个队列中，这个队列目前实现是io.netty.util.internal.shaded.org.jctools.queues.MpscUnboundedArrayQueue。并在此时判断是否是本线程，如果不实现本线程就<strong>==把对应的线程给启动==</strong>了。<br>io.netty.channel.AbstractChannel.AbstractUnsafe.register0(ChannelPromise)  这是 <strong>==register的后处理==</strong> ：  </li>
</ol>
<ul>
<li>先设置ChannelPromise为成功</li>
<li>重要的事情之一：  就是会触发ChannelInboundHandler的channelRegistered事件，这是业务侧可以定制的，执行是在boss线程做的  </li>
<li>绑定成功了 然后 触发active事件，是否绑定成功的判断方式是：  <pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isActive</span><span class="hljs-params">()</span> </span>&#123;
       <span class="hljs-keyword">return</span> javaChannel().socket().isBound();
   &#125;</code></pre>
其实就是靠JDK的API isBound完成<br>register0的提交方式就是靠下面这种代码完成，netty中有好多这种代码，应该包装一下： <pre><code class="hljs java"><span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;
    register0(promise);
&#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-keyword">try</span> &#123;
        eventLoop.execute(<span class="hljs-keyword">new</span> Runnable() &#123;
            <span class="hljs-meta">@Override</span>
            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;
                register0(promise);
            &#125;
        &#125;);
    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
        logger.warn(
                <span class="hljs-string">"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;"</span>,
                AbstractChannel.<span class="hljs-keyword">this</span>, t);
        closeForcibly();
        closeFuture.setClosed();
        safeSetFailure(promise, t);
    &#125;
&#125;</code></pre>

</li>
</ul>
<p>上述逻辑因为==是异步==的，所以==可能执行不完==，所以接下来要做出处理：  </p>
<pre><code class="hljs java"><span class="hljs-comment">// regFuture就是上面初始化并注册的返回的Future，此处先判断他是否完成  </span>
<span class="hljs-keyword">if</span> (regFuture.isDone()) &#123;
    <span class="hljs-comment">// At this point we know that the registration was complete and successful.</span>
    ChannelPromise promise = channel.newPromise();
    doBind0(regFuture, channel, localAddress, promise); <span class="hljs-comment">// 真正的做bind，在boss线程。且此处是regFuture已经完成的情况下 那就不要用回调了就直接调用doBind0就行了。  </span>
    <span class="hljs-keyword">return</span> promise;
&#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-comment">// Registration future is almost always fulfilled already, but just in case it's not.</span>
    <span class="hljs-keyword">final</span> PendingRegistrationPromise promise = <span class="hljs-keyword">new</span> PendingRegistrationPromise(channel);
    regFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123; <span class="hljs-comment">// 给regFuture注册监听器，等他完成后回调这里，妙啊</span>
        <span class="hljs-meta">@Override</span>
        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
            Throwable cause = future.cause();
            <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;
                <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span>
                <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span>
                promise.setFailure(cause);
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span>
                <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span>
                promise.registered();

                doBind0(regFuture, channel, localAddress, promise); <span class="hljs-comment">// 真正的做bind，在boss线程</span>
            &#125;
        &#125;
    &#125;);
    <span class="hljs-keyword">return</span> promise;
&#125;</code></pre>

<p>io.netty.util.concurrent.SingleThreadEventExecutor.startThread() 启动线程的写法值得学习，确保正好启动一次。<br>addTaskWakesUp？？  </p>
<pre><code class="hljs java"><span class="hljs-keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;
           wakeup(inEventLoop);
       &#125;</code></pre>
<ol start="4">
<li>创建PendingRegistrationPromise。 对初始化和注册过的ChannelFuture增加监听器，监听ChannelFutureListener.operationComplete完成后回调。因为上面初始化并注册那事是异步的，可能这时还没完成。<br>// 3的wakeup和4要看下<br>以上都没涉及到真正bind端口的地方  </li>
</ol>
<h4 id="真正bind"><a href="#真正bind" class="headerlink" title="真正bind"></a>真正bind</h4><p>调用栈：  </p>
<pre><code class="hljs java"><span class="hljs-comment">// Thread [boss-0] (Suspended)	</span>
io.netty.channel.socket.nio.NioServerSocketChannel.doBind(java.net.SocketAddress) line: <span class="hljs-number">130</span>	
io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).bind(java.net.SocketAddress, io.netty.channel.ChannelPromise) line: <span class="hljs-number">562</span>	
io.netty.channel.DefaultChannelPipeline$HeadContext.bind(io.netty.channel.ChannelHandlerContext, java.net.SocketAddress, io.netty.channel.ChannelPromise) line: <span class="hljs-number">1332</span>	
io.netty.channel.DefaultChannelPipeline$HeadContext(io.netty.channel.AbstractChannelHandlerContext).invokeBind(java.net.SocketAddress, io.netty.channel.ChannelPromise) line: <span class="hljs-number">501</span>	
io.netty.channel.DefaultChannelPipeline$TailContext(io.netty.channel.AbstractChannelHandlerContext).bind(java.net.SocketAddress, io.netty.channel.ChannelPromise) line: <span class="hljs-number">486</span>	
io.netty.channel.DefaultChannelPipeline.bind(java.net.SocketAddress, io.netty.channel.ChannelPromise) line: <span class="hljs-number">984</span>	
io.netty.channel.socket.nio.NioServerSocketChannel(io.netty.channel.AbstractChannel).bind(java.net.SocketAddress, io.netty.channel.ChannelPromise) line: <span class="hljs-number">258</span>	
io.netty.bootstrap.AbstractBootstrap$<span class="hljs-number">2</span>.run() line: <span class="hljs-number">366</span>	
io.netty.util.concurrent.AbstractEventExecutor.safeExecute(java.lang.Runnable) line: <span class="hljs-number">163</span>	
io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).runAllTasks(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">404</span>	
io.netty.channel.nio.NioEventLoop.run() line: <span class="hljs-number">495</span>	
io.netty.util.concurrent.SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>	
java.lang.Thread.run() line: <span class="hljs-number">748</span></code></pre>
<p>boss线程中NioServerSocketChannel.doBind这才是真正bind端口的地方，调用栈如上，代码如下：    </p>
<pre><code class="hljs java"><span class="hljs-comment">// NioServerSocketChannel</span>
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind</span><span class="hljs-params">(SocketAddress localAddress)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
        <span class="hljs-keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="hljs-number">7</span>) &#123;
            javaChannel().bind(localAddress, config.getBacklog());
        &#125; <span class="hljs-keyword">else</span> &#123;
            javaChannel().socket().bind(localAddress, config.getBacklog());
        &#125;
    &#125;</code></pre>

<h2 id="select和业务处理过程的抽象与逻辑组织"><a href="#select和业务处理过程的抽象与逻辑组织" class="headerlink" title="select和业务处理过程的抽象与逻辑组织"></a>select和业务处理过程的抽象与逻辑组织</h2><h3 id="NioEventLoop主要逻辑"><a href="#NioEventLoop主要逻辑" class="headerlink" title="NioEventLoop主要逻辑"></a>NioEventLoop主要逻辑</h3><ol>
<li>根据select策略处理select的事情，可能情况包括：  </li>
<li>根据ioRatio配比进行selectkey的处理(即IO事件)还是跑所有任务(业务逻辑、自定义事件等)。<br>关于selectkey的处理：<br>Field selectedKeysField = selectorImplClass.getDeclaredField(“selectedKeys”);<br>Field publicSelectedKeysField = selectorImplClass.getDeclaredField(“publicSelectedKeys”);</li>
</ol>
<p>sun.nio.ch.KQueueSelectorImpl@153cf15c<br>3. 处理异常，注意此处抓的是Throwable异常，这样能防止线程跑飞。目前的异常处理是打了警告日志并sleep 1s防止CPU被完全吃掉。   </p>
<h2 id="注册OP-ACCEPT事件"><a href="#注册OP-ACCEPT事件" class="headerlink" title="注册OP_ACCEPT事件"></a>注册OP_ACCEPT事件</h2><p>真正注册accept事件的地方：<br>先注册感兴趣的事件为0，注册出key：  </p>
<pre><code class="hljs java">Thread [boss-<span class="hljs-number">0</span>] (Suspended (breakpoint at line <span class="hljs-number">386</span> in io.netty.channel.nio.AbstractNioChannel))	
	io.netty.channel.socket.nio.NioServerSocketChannel(io.netty.channel.nio.AbstractNioChannel).doRegister() line: <span class="hljs-number">386</span>	
	io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).register0(io.netty.channel.ChannelPromise) line: <span class="hljs-number">508</span>	
	io.netty.channel.AbstractChannel$AbstractUnsafe.access$<span class="hljs-number">200</span>(io.netty.channel.AbstractChannel$AbstractUnsafe, io.netty.channel.ChannelPromise) line: <span class="hljs-number">427</span>	
	io.netty.channel.AbstractChannel$AbstractUnsafe$<span class="hljs-number">1</span>.run() line: <span class="hljs-number">486</span>	
	io.netty.util.concurrent.AbstractEventExecutor.safeExecute(java.lang.Runnable) line: <span class="hljs-number">163</span>	
	io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).runAllTasks(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">404</span>	
	io.netty.channel.nio.NioEventLoop.run() line: <span class="hljs-number">495</span>	
	io.netty.util.concurrent.SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>	
	java.lang.Thread.run() line: <span class="hljs-number">748</span></code></pre>
<p>代码</p>
<pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.nio.AbstractNioChannel.doRegister()</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    <span class="hljs-keyword">boolean</span> selected = <span class="hljs-keyword">false</span>;
    <span class="hljs-keyword">for</span> (;;) &#123;
        <span class="hljs-keyword">try</span> &#123;
            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);
            <span class="hljs-keyword">return</span>;
        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;
            <span class="hljs-keyword">if</span> (!selected) &#123;
                <span class="hljs-comment">// Force the Selector to select now as the "canceled" SelectionKey may still be</span>
                <span class="hljs-comment">// cached and not removed because no Select.select(..) operation was called yet.</span>
                eventLoop().selectNow();
                selected = <span class="hljs-keyword">true</span>;
            &#125; <span class="hljs-keyword">else</span> &#123;
                <span class="hljs-comment">// We forced a select operation on the selector before but the SelectionKey is still cached</span>
                <span class="hljs-comment">// for whatever reason. JDK bug ?</span>
                <span class="hljs-keyword">throw</span> e;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<p>再在doBeginRead中注册16，真正注册：<br>boss调用栈：  </p>
<pre><code class="hljs java">Thread [boss-<span class="hljs-number">0</span>] (Suspended (breakpoint at line <span class="hljs-number">420</span> in io.netty.channel.nio.AbstractNioChannel))	
	io.netty.channel.socket.nio.NioServerSocketChannel(io.netty.channel.nio.AbstractNioChannel).doBeginRead() line: <span class="hljs-number">420</span>	
	io.netty.channel.socket.nio.NioServerSocketChannel(io.netty.channel.nio.AbstractNioMessageChannel).doBeginRead() line: <span class="hljs-number">55</span>	
	io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).beginRead() line: <span class="hljs-number">851</span>	
	io.netty.channel.DefaultChannelPipeline$HeadContext.read(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">1360</span>	
	io.netty.channel.DefaultChannelPipeline$HeadContext(io.netty.channel.AbstractChannelHandlerContext).invokeRead() line: <span class="hljs-number">693</span>	
	io.netty.channel.DefaultChannelPipeline$TailContext(io.netty.channel.AbstractChannelHandlerContext).read() line: <span class="hljs-number">673</span>	
	io.netty.channel.DefaultChannelPipeline.read() line: <span class="hljs-number">1015</span>	
	io.netty.channel.socket.nio.NioServerSocketChannel(io.netty.channel.AbstractChannel).read() line: <span class="hljs-number">288</span>	
	io.netty.channel.DefaultChannelPipeline$HeadContext.readIfIsAutoRead() line: <span class="hljs-number">1420</span>	
	io.netty.channel.DefaultChannelPipeline$HeadContext.channelActive(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">1398</span>	
	io.netty.channel.DefaultChannelPipeline$HeadContext(io.netty.channel.AbstractChannelHandlerContext).invokeChannelActive() line: <span class="hljs-number">213</span>	
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(io.netty.channel.AbstractChannelHandlerContext) line: <span class="hljs-number">199</span>	
	io.netty.channel.DefaultChannelPipeline.fireChannelActive() line: <span class="hljs-number">906</span>	
	io.netty.channel.AbstractChannel$AbstractUnsafe$<span class="hljs-number">2</span>.run() line: <span class="hljs-number">573</span>	
	io.netty.util.concurrent.AbstractEventExecutor.safeExecute(java.lang.Runnable) line: <span class="hljs-number">163</span>	
	io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).runAllTasks(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">404</span>	
	io.netty.channel.nio.NioEventLoop.run() line: <span class="hljs-number">495</span>	
	io.netty.util.concurrent.SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>	
	java.lang.Thread.run() line: <span class="hljs-number">748</span></code></pre>
<p>代码：  </p>
<pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.nio.AbstractNioChannel.doBeginRead()</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span>
    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;
    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;
        <span class="hljs-keyword">return</span>;
    &#125;

    readPending = <span class="hljs-keyword">true</span>;

    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();
    <span class="hljs-keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;
        selectionKey.interestOps(interestOps | readInterestOp); <span class="hljs-comment">// accept的readInterestOp是16</span>
    &#125;
&#125;</code></pre>
<h2 id="select出OP-ACCEPT的处理与SocketChannel的创建"><a href="#select出OP-ACCEPT的处理与SocketChannel的创建" class="headerlink" title="select出OP_ACCEPT的处理与SocketChannel的创建"></a>select出OP_ACCEPT的处理与SocketChannel的创建</h2><p>也就是在run方法中select的逻辑：<br>在策略判断时如果<strong>有任务</strong>的情况下会做io.netty.channel.nio.NioEventLoop.selectNowSupplier的get方法调用，这个方法中会selectNow：<br>在策略判断时如果<strong>没有任务</strong>的话，策略判断则会返回-1即SelectStrategy.SELECT，并执行带超时时间参数的select：  </p>
<pre><code class="hljs java"><span class="hljs-keyword">case</span> SelectStrategy.SELECT:
                       select(wakenUp.getAndSet(<span class="hljs-keyword">false</span>));</code></pre>
<p>此时会走下面的调用栈：  </p>
<pre><code class="hljs java">SelectedSelectionKeySetSelector.select(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">62</span>	
NioEventLoop.select(<span class="hljs-keyword">boolean</span>) line: <span class="hljs-number">786</span>	
NioEventLoop.run() line: <span class="hljs-number">434</span>	
SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>	
Thread.run() line: <span class="hljs-number">748</span></code></pre>

<p>关于io.netty.channel.SelectStrategy.calculateStrategy(IntSupplier, boolean)策略的返回值整理情况如下：<br>① -2，跳过本次处理；目前还未构造出这种场景。<br>② -3，忙等也是跳过；目前还未构造出这种场景。<br>③ -1，没有任务时需要select，并判断是否要wakeup；没有任务时就是这种这种场景。<br>④ &gt;=0的其他值，也就是default，啥都不干往下走，走处理selectkey(即IO事件)或者所有任务(业务逻辑等)。<br>io.netty.channel.DefaultSelectStrategy.calculateStrategy(IntSupplier, boolean)  计算逻辑分析：<br>如果没有任务了 就返回 SelectStrategy.SELECT<br>如果有任务  就io.netty.channel.nio.NioEventLoop.new IntSupplier() {…}.() selectNow一次，注意这个<code>selectNow</code>是NioEventLoop的selectNow方法，但是最终还会对应到JDK的Selector的selectNow上去。   </p>
<h3 id="io-netty-channel-nio-NioEventLoop-select-boolean-分析"><a href="#io-netty-channel-nio-NioEventLoop-select-boolean-分析" class="headerlink" title="io.netty.channel.nio.NioEventLoop.select(boolean)分析"></a>io.netty.channel.nio.NioEventLoop.select(boolean)分析</h3><ol>
<li><p>select时超时时间怎么定<br>这个有超时时间的select，超时时间这个值是怎么确定的？<br>deadline减去当前时间(这两个都是用纳秒计量)后四舍五入到毫秒粒度<br>deadline又是怎么计算的？<br>默认值是1s，如果scheduledTaskQueue中有调度任务，以优先级队列顶部的scheduledTask的调度时间结合当前时间算出deadline。  </p>
</li>
<li><p>该select(boolean)的逻辑和避免epoll select空转bug的规避<br>整体是一个spin循环包起来的逻辑<br>如果deadline已到，则selector.selectNow();并退出spin循环。<br>如果有任务且wakeup是false(是false要将其设置成true)，则selector.selectNow();并退出spin循环。<br>上面两种情况都没命中则selector.select(timeoutMillis);并计数。如果selected到key了或者oldWakenUp为true或者wakenUp字段为true或者有任务或者有调度任务都退出spin循环。<br>如果在这个spin循环中seletc次数大于SELECTOR_AUTO_REBUILD_THRESHOLD（默认值512），则重建这个方法内局部变量Selector实例，并将之前selector上的事件注册到这个新的上面来。这个处理就是为了规避linux上epoll的bug，epoll可能select方法会直接返回，即使没有超时并且也没有IO事件到达，这就是著名的epoll bug，这是一个比较严重的bug，它会导致线程陷入死循环，会让CPU飙到100%。<a href="https://www.cnblogs.com/devilwind/p/8351732.html" target="_blank" rel="noopener">参见这里</a><br>相关代码：  </p>
<pre><code class="hljs java">io.netty.channel.nio.NioEventLoop.rebuildSelector0()
SelectionKey newKey = key.channel().register(newSelectorTuple.unwrappedSelector, interestOps, a);</code></pre>

</li>
</ol>
<h3 id="Selector到key之后的处理"><a href="#Selector到key之后的处理" class="headerlink" title="Selector到key之后的处理"></a>Selector到key之后的处理</h3><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ioRatio = <span class="hljs-keyword">this</span>.ioRatio;
<span class="hljs-keyword">if</span> (ioRatio == <span class="hljs-number">100</span>) &#123;
    <span class="hljs-keyword">try</span> &#123;
        processSelectedKeys();
    &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-comment">// Ensure we always run tasks.</span>
        runAllTasks();
    &#125;
&#125; <span class="hljs-keyword">else</span> &#123;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioStartTime = System.nanoTime();
    <span class="hljs-keyword">try</span> &#123;
        processSelectedKeys();
    &#125; <span class="hljs-keyword">finally</span> &#123;
        <span class="hljs-comment">// Ensure we always run tasks.</span>
        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioTime = System.nanoTime() - ioStartTime;
        runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);
    &#125;
&#125;</code></pre>
<h3 id="processSelectedKeys"><a href="#processSelectedKeys" class="headerlink" title="processSelectedKeys"></a>processSelectedKeys</h3><p>调用栈 ：  </p>
<pre><code class="hljs java">NioServerSocketChannel.doReadMessages(List&lt;Object&gt;) line: <span class="hljs-number">143</span>	
AbstractNioMessageChannel$NioMessageUnsafe.read() line: <span class="hljs-number">75</span>	
NioEventLoop.processSelectedKey(SelectionKey, AbstractNioChannel) line: <span class="hljs-number">677</span>	
NioEventLoop.processSelectedKeysOptimized() line: <span class="hljs-number">612</span>	
NioEventLoop.processSelectedKeys() line: <span class="hljs-number">529</span>	
NioEventLoop.run() line: <span class="hljs-number">491</span>	
SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>	
Thread.run() line: <span class="hljs-number">748</span></code></pre>
<p>涉及的部分代码：<br>有accept出SocketChannel的关键部分  </p>
<pre><code class="hljs java"><span class="hljs-comment">// NioEventLoop</span>
<span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;
    unsafe.read(); <span class="hljs-comment">// unsafe是io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe</span>
&#125;
<span class="hljs-comment">//  NioServerSocketChannel</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doReadMessages</span><span class="hljs-params">(List&lt;Object&gt; buf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;
    SocketChannel ch = SocketUtils.accept(javaChannel());

    <span class="hljs-keyword">try</span> &#123;
        <span class="hljs-keyword">if</span> (ch != <span class="hljs-keyword">null</span>) &#123;
            buf.add(<span class="hljs-keyword">new</span> NioSocketChannel(<span class="hljs-keyword">this</span>, ch));
            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
        &#125;
    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;
        logger.warn(<span class="hljs-string">"Failed to create a new channel from an accepted socket."</span>, t);

        <span class="hljs-keyword">try</span> &#123;
            ch.close();
        &#125; <span class="hljs-keyword">catch</span> (Throwable t2) &#123;
            logger.warn(<span class="hljs-string">"Failed to close a socket."</span>, t2);
        &#125;
    &#125;

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<h2 id="注册OP-READ事件"><a href="#注册OP-READ事件" class="headerlink" title="注册OP_READ事件"></a>注册OP_READ事件</h2><p>woker调用栈：<br>注册出key：</p>
<pre><code class="hljs java">Thread [worker-<span class="hljs-number">0</span>] (Suspended (breakpoint at line <span class="hljs-number">386</span> in io.netty.channel.nio.AbstractNioChannel))	
	io.netty.channel.socket.nio.NioSocketChannel(io.netty.channel.nio.AbstractNioChannel).doRegister() line: <span class="hljs-number">386</span>	
	io.netty.channel.socket.nio.NioSocketChannel$NioSocketChannelUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).register0(io.netty.channel.ChannelPromise) line: <span class="hljs-number">508</span>	
	io.netty.channel.AbstractChannel$AbstractUnsafe.access$<span class="hljs-number">200</span>(io.netty.channel.AbstractChannel$AbstractUnsafe, io.netty.channel.ChannelPromise) line: <span class="hljs-number">427</span>	
	io.netty.channel.AbstractChannel$AbstractUnsafe$<span class="hljs-number">1</span>.run() line: <span class="hljs-number">486</span>	
	io.netty.util.concurrent.AbstractEventExecutor.safeExecute(java.lang.Runnable) line: <span class="hljs-number">163</span>	
	io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).runAllTasks(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">404</span>	
	io.netty.channel.nio.NioEventLoop.run() line: <span class="hljs-number">495</span>	
	io.netty.util.concurrent.SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>	
	java.lang.Thread.run() line: <span class="hljs-number">748</span></code></pre>
<p>真正注册：  </p>
<pre><code class="hljs java">Thread [worker-<span class="hljs-number">0</span>] (Suspended (breakpoint at line <span class="hljs-number">420</span> in io.netty.channel.nio.AbstractNioChannel))	
	io.netty.channel.socket.nio.NioSocketChannel(io.netty.channel.nio.AbstractNioChannel).doBeginRead() line: <span class="hljs-number">420</span>	
	io.netty.channel.socket.nio.NioSocketChannel$NioSocketChannelUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).beginRead() line: <span class="hljs-number">851</span>	
	io.netty.channel.DefaultChannelPipeline$HeadContext.read(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">1360</span>	
	io.netty.channel.DefaultChannelPipeline$HeadContext(io.netty.channel.AbstractChannelHandlerContext).invokeRead() line: <span class="hljs-number">693</span>	
	io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).read() line: <span class="hljs-number">673</span>	
	io.netty.handler.timeout.ReadTimeoutHandler(io.netty.channel.ChannelDuplexHandler).read(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">95</span>	
	io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).invokeRead() line: <span class="hljs-number">693</span>	
	io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).read() line: <span class="hljs-number">673</span>	
	io.netty.handler.codec.http.HttpResponseEncoder(io.netty.channel.ChannelOutboundHandlerAdapter).read(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">93</span>	
	io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).invokeRead() line: <span class="hljs-number">693</span>	
	io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).read() line: <span class="hljs-number">673</span>	
	io.netty.handler.stream.ChunkedWriteHandler(io.netty.channel.ChannelDuplexHandler).read(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">95</span>	
	io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).invokeRead() line: <span class="hljs-number">693</span>	
	io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).read() line: <span class="hljs-number">673</span>	
	io.netty.handler.codec.http.HttpContentCompressor(io.netty.channel.ChannelDuplexHandler).read(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">95</span>	
	io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).invokeRead() line: <span class="hljs-number">693</span>	
	io.netty.channel.DefaultChannelPipeline$TailContext(io.netty.channel.AbstractChannelHandlerContext).read() line: <span class="hljs-number">673</span>	
	io.netty.channel.DefaultChannelPipeline.read() line: <span class="hljs-number">1015</span>	
	io.netty.channel.socket.nio.NioSocketChannel(io.netty.channel.AbstractChannel).read() line: <span class="hljs-number">288</span>	
	io.netty.channel.DefaultChannelPipeline$HeadContext.readIfIsAutoRead() line: <span class="hljs-number">1420</span>	
	io.netty.channel.DefaultChannelPipeline$HeadContext.channelActive(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">1398</span>	
	io.netty.channel.DefaultChannelPipeline$HeadContext(io.netty.channel.AbstractChannelHandlerContext).invokeChannelActive() line: <span class="hljs-number">213</span>	
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(io.netty.channel.AbstractChannelHandlerContext) line: <span class="hljs-number">199</span>	
	io.netty.channel.DefaultChannelPipeline.fireChannelActive() line: <span class="hljs-number">906</span>	
	io.netty.channel.socket.nio.NioSocketChannel$NioSocketChannelUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).register0(io.netty.channel.ChannelPromise) line: <span class="hljs-number">522</span>	
	io.netty.channel.AbstractChannel$AbstractUnsafe.access$<span class="hljs-number">200</span>(io.netty.channel.AbstractChannel$AbstractUnsafe, io.netty.channel.ChannelPromise) line: <span class="hljs-number">427</span>	
	io.netty.channel.AbstractChannel$AbstractUnsafe$<span class="hljs-number">1</span>.run() line: <span class="hljs-number">486</span>	
	io.netty.util.concurrent.AbstractEventExecutor.safeExecute(java.lang.Runnable) line: <span class="hljs-number">163</span>	
	io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).runAllTasks(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">404</span>	
	io.netty.channel.nio.NioEventLoop.run() line: <span class="hljs-number">495</span>	
	io.netty.util.concurrent.SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>	
	java.lang.Thread.run() line: <span class="hljs-number">748</span></code></pre>

<h2 id="select出OP-READ的处理与buf的读取"><a href="#select出OP-READ的处理与buf的读取" class="headerlink" title="select出OP_READ的处理与buf的读取"></a>select出OP_READ的处理与buf的读取</h2><p>读取数据线程栈：  </p>
<pre><code class="hljs java">Thread [worker-<span class="hljs-number">2</span>] (Suspended (breakpoint at line <span class="hljs-number">57</span> in HttpContentDecoder))	
	HttpContentDecompressor(HttpContentDecoder).decode(ChannelHandlerContext, HttpObject, List&lt;Object&gt;) line: <span class="hljs-number">57</span>	
	HttpContentDecompressor(HttpContentDecoder).decode(ChannelHandlerContext, Object, List) line: <span class="hljs-number">47</span>	
	HttpContentDecompressor(MessageToMessageDecoder&lt;I&gt;).channelRead(ChannelHandlerContext, Object) line: <span class="hljs-number">88</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelRead(Object) line: <span class="hljs-number">362</span>	
	AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext, Object) line: <span class="hljs-number">348</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelRead(Object) line: <span class="hljs-number">340</span>	
	ByteToMessageDecoder.fireChannelRead(ChannelHandlerContext, CodecOutputList, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">323</span>	
	ByteToMessageDecoder.fireChannelRead(ChannelHandlerContext, List&lt;Object&gt;, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">310</span>	
	HttpRequestDecoder(ByteToMessageDecoder).callDecode(ChannelHandlerContext, ByteBuf, List&lt;Object&gt;) line: <span class="hljs-number">426</span>	
	HttpRequestDecoder(ByteToMessageDecoder).channelRead(ChannelHandlerContext, Object) line: <span class="hljs-number">278</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelRead(Object) line: <span class="hljs-number">362</span>	
	AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext, Object) line: <span class="hljs-number">348</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelRead(Object) line: <span class="hljs-number">340</span>	
	PipelineInitializer$ChannelActiveTester(ChannelInboundHandlerAdapter).channelRead(ChannelHandlerContext, Object) line: <span class="hljs-number">86</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelRead(Object) line: <span class="hljs-number">362</span>	
	AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext, Object) line: <span class="hljs-number">348</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelRead(Object) line: <span class="hljs-number">340</span>	
	ReadTimeoutHandler(IdleStateHandler).channelRead(ChannelHandlerContext, Object) line: <span class="hljs-number">286</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelRead(Object) line: <span class="hljs-number">362</span>	
	AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext, Object) line: <span class="hljs-number">348</span>	
	DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).fireChannelRead(Object) line: <span class="hljs-number">340</span>	
	DefaultChannelPipeline$HeadContext.channelRead(ChannelHandlerContext, Object) line: <span class="hljs-number">1408</span>	
	DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).invokeChannelRead(Object) line: <span class="hljs-number">362</span>	
	AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext, Object) line: <span class="hljs-number">348</span>	
	DefaultChannelPipeline.fireChannelRead(Object) line: <span class="hljs-number">930</span>	
	NioSocketChannel$NioSocketChannelUnsafe(AbstractNioByteChannel$NioByteUnsafe).read() line: <span class="hljs-number">163</span>	
	NioEventLoop.processSelectedKey(SelectionKey, AbstractNioChannel) line: <span class="hljs-number">677</span>	
	NioEventLoop.processSelectedKeysOptimized() line: <span class="hljs-number">612</span>	
	NioEventLoop.processSelectedKeys() line: <span class="hljs-number">529</span>	
	NioEventLoop.run() line: <span class="hljs-number">491</span>	
	SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>	
	Thread.run() line: <span class="hljs-number">748</span></code></pre>
<p>在processSelectedKey之后会用 NioSocketChannelUnsafe将数据读到Buf中。再交给Pipeline触发后面的每一个handler。<br>此处要注意下读的时候 selectkey的attachment中放的是啥：  </p>
<pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKeysOptimized</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; selectedKeys.size; ++i) &#123;
        <span class="hljs-keyword">final</span> SelectionKey k = selectedKeys.keys[i];
        <span class="hljs-comment">// null out entry in the array to allow to have it GC'ed once the Channel close</span>
        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2363</span>
        selectedKeys.keys[i] = <span class="hljs-keyword">null</span>;

        <span class="hljs-keyword">final</span> Object a = k.attachment(); <span class="hljs-comment">// 附件中放的是AbstractNioChannel  AbstractNioChannel中有unsafe对象，unsafe中能关联读取用的buf。</span>

        <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> AbstractNioChannel) &#123;
            processSelectedKey(k, (AbstractNioChannel) a);

            <span class="hljs-comment">// ...</span>
        &#125;
        
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKey</span><span class="hljs-params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;
    <span class="hljs-keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe(); <span class="hljs-comment">// AbstractNioChannel中有unsafe对象</span>
    <span class="hljs-comment">// ...</span>
     <span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;
            unsafe.read();
        &#125;</code></pre>
<h2 id="写出数据的处理"><a href="#写出数据的处理" class="headerlink" title="写出数据的处理"></a>写出数据的处理</h2><p>写数据的处理可以在SocketChannelImpl [entry] - write(ByteBuffer)    处打方法断点观察。<br>调用堆栈如下：  </p>
<pre><code class="hljs java">Thread [worker-<span class="hljs-number">3</span>] (Suspended (entry into method write in SocketChannelImpl))	
	SocketChannelImpl.write(ByteBuffer) line: <span class="hljs-number">458</span>	
	NioSocketChannel.doWrite(ChannelOutboundBuffer) line: <span class="hljs-number">405</span>	
	NioSocketChannel$NioSocketChannelUnsafe(AbstractChannel$AbstractUnsafe).flush0() line: <span class="hljs-number">938</span>	
	NioSocketChannel$NioSocketChannelUnsafe(AbstractNioChannel$AbstractNioUnsafe).flush0() line: <span class="hljs-number">360</span>	
	NioSocketChannel$NioSocketChannelUnsafe(AbstractChannel$AbstractUnsafe).flush() line: <span class="hljs-number">905</span>	
	DefaultChannelPipeline$HeadContext.flush(ChannelHandlerContext) line: <span class="hljs-number">1370</span>	
	DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).invokeFlush0() line: <span class="hljs-number">776</span>	
	DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).invokeFlush() line: <span class="hljs-number">768</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).flush() line: <span class="hljs-number">749</span>	
	ReadTimeoutHandler(ChannelDuplexHandler).flush(ChannelHandlerContext) line: <span class="hljs-number">117</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush0() line: <span class="hljs-number">776</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush() line: <span class="hljs-number">768</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).flush() line: <span class="hljs-number">749</span>	
	HttpResponseEncoder(ChannelOutboundHandlerAdapter).flush(ChannelHandlerContext) line: <span class="hljs-number">115</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush0() line: <span class="hljs-number">776</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush() line: <span class="hljs-number">768</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).flush() line: <span class="hljs-number">749</span>	
	ChunkedWriteHandler.doFlush(ChannelHandlerContext) line: <span class="hljs-number">335</span>	
	ChunkedWriteHandler.channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">148</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>	
	AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>	
	HttpContentDecompressor(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>	
	AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>	
	HttpRequestDecoder(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>	
	AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>	
	PipelineInitializer$ChannelActiveTester(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>	
	AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>	
	ReadTimeoutHandler(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>	
	AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>	
	DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>	
	DefaultChannelPipeline$HeadContext.channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">1431</span>	
	DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>	
	AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>	
	DefaultChannelPipeline.fireChannelWritabilityChanged() line: <span class="hljs-number">942</span>	
	ChannelOutboundBuffer$<span class="hljs-number">2</span>.run() line: <span class="hljs-number">608</span>	
	AbstractEventExecutor.safeExecute(Runnable) line: <span class="hljs-number">163</span>	
	NioEventLoop(SingleThreadEventExecutor).runAllTasks(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">404</span>	
	NioEventLoop.run() line: <span class="hljs-number">495</span>	
	SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>	
	Thread.run() line: <span class="hljs-number">748</span></code></pre>
<p>核心逻辑在：<br>io.netty.channel.socket.nio.NioSocketChannel.doWrite(ChannelOutboundBuffer)  </p>
<pre><code class="hljs java"> <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: &#123;
    <span class="hljs-comment">// Only one ByteBuf so use non-gathering write</span>
    <span class="hljs-comment">// Zero length buffers are not added to nioBuffers by ChannelOutboundBuffer, so there is no need</span>
    <span class="hljs-comment">// to check if the total size of all the buffers is non-zero.</span>
    ByteBuffer buffer = nioBuffers[<span class="hljs-number">0</span>];
    <span class="hljs-keyword">int</span> attemptedBytes = buffer.remaining();
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> localWrittenBytes = ch.write(buffer);
    <span class="hljs-keyword">if</span> (localWrittenBytes &lt;= <span class="hljs-number">0</span>) &#123;
        incompleteWrite(<span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">return</span>;
    &#125;
    adjustMaxBytesPerGatheringWrite(attemptedBytes, localWrittenBytes, maxBytesPerGatheringWrite);
    in.removeBytes(localWrittenBytes);
    --writeSpinCount;
    <span class="hljs-keyword">break</span>;
&#125;</code></pre>
<p><strong>writeSpinCount</strong>默认是16，也就说说写出线程会尝试写16次，如果ch.write写不出去了再调用incompleteWrite，incompleteWrite里会注册OP_WRITE事件，此处是个优化，不是一上来就注册事件，是先尝试写，写不了再注册。  </p>
<h2 id="注册OP-WRITE事件"><a href="#注册OP-WRITE事件" class="headerlink" title="注册OP_WRITE事件"></a>注册OP_WRITE事件</h2><p>需要构造较大的响应包，在本地才能观察到。 我构造了将近200万字符，才达能目的。<br>注册的地方打断点在 SelectionKeyImpl [entry] - interestOps(int)    遍可以观察<br>堆栈如下：  </p>
<pre><code class="hljs java">Thread [worker-<span class="hljs-number">3</span>] (Suspended (entry into method interestOps in SelectionKeyImpl))	
	SelectionKeyImpl.interestOps(<span class="hljs-keyword">int</span>) line: <span class="hljs-number">82</span>	
	NioSocketChannel(AbstractNioByteChannel).setOpWrite() line: <span class="hljs-number">332</span>	
	NioSocketChannel(AbstractNioByteChannel).incompleteWrite(<span class="hljs-keyword">boolean</span>) line: <span class="hljs-number">289</span>	
	NioSocketChannel.doWrite(ChannelOutboundBuffer) line: <span class="hljs-number">407</span>	
	NioSocketChannel$NioSocketChannelUnsafe(AbstractChannel$AbstractUnsafe).flush0() line: <span class="hljs-number">938</span>	
	NioSocketChannel$NioSocketChannelUnsafe(AbstractNioChannel$AbstractNioUnsafe).flush0() line: <span class="hljs-number">360</span>	
	NioSocketChannel$NioSocketChannelUnsafe(AbstractChannel$AbstractUnsafe).flush() line: <span class="hljs-number">905</span>	
	DefaultChannelPipeline$HeadContext.flush(ChannelHandlerContext) line: <span class="hljs-number">1370</span>	
	DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).invokeFlush0() line: <span class="hljs-number">776</span>	
	DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).invokeFlush() line: <span class="hljs-number">768</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).flush() line: <span class="hljs-number">749</span>	
	ReadTimeoutHandler(ChannelDuplexHandler).flush(ChannelHandlerContext) line: <span class="hljs-number">117</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush0() line: <span class="hljs-number">776</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush() line: <span class="hljs-number">768</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).flush() line: <span class="hljs-number">749</span>	
	HttpResponseEncoder(ChannelOutboundHandlerAdapter).flush(ChannelHandlerContext) line: <span class="hljs-number">115</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush0() line: <span class="hljs-number">776</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush() line: <span class="hljs-number">768</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).flush() line: <span class="hljs-number">749</span>	
	ChunkedWriteHandler.doFlush(ChannelHandlerContext) line: <span class="hljs-number">335</span>	
	ChunkedWriteHandler.channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">148</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>	
	AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>	
	HttpContentDecompressor(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>	
	AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>	
	HttpRequestDecoder(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>	
	AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>	
	PipelineInitializer$ChannelActiveTester(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>	
	AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>	
	ReadTimeoutHandler(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>	
	DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>	
	AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>	
	DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>	
	DefaultChannelPipeline$HeadContext.channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">1431</span>	
	DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>	
	AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>	
	DefaultChannelPipeline.fireChannelWritabilityChanged() line: <span class="hljs-number">942</span>	
	ChannelOutboundBuffer$<span class="hljs-number">2</span>.run() line: <span class="hljs-number">608</span>	
	AbstractEventExecutor.safeExecute(Runnable) line: <span class="hljs-number">163</span>	
	NioEventLoop(SingleThreadEventExecutor).runAllTasks(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">404</span>	
	NioEventLoop.run() line: <span class="hljs-number">495</span>	
	SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>	
	Thread.run() line: <span class="hljs-number">748</span></code></pre>
<p>netty里核心代码在：  </p>
<pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.nio.AbstractNioByteChannel.setOpWrite()</span>
<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOpWrite</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-keyword">final</span> SelectionKey key = selectionKey();
    <span class="hljs-comment">// Check first if the key is still valid as it may be canceled as part of the deregistration</span>
    <span class="hljs-comment">// from the EventLoop</span>
    <span class="hljs-comment">// See https://github.com/netty/netty/issues/2104</span>
    <span class="hljs-keyword">if</span> (!key.isValid()) &#123;
        <span class="hljs-keyword">return</span>;
    &#125;
    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = key.interestOps();
    <span class="hljs-keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) == <span class="hljs-number">0</span>) &#123;
        key.interestOps(interestOps | SelectionKey.OP_WRITE);
    &#125;
&#125;</code></pre>

<h2 id="select出OP-WRITE的处理与buf的写出"><a href="#select出OP-WRITE的处理与buf的写出" class="headerlink" title="select出OP_WRITE的处理与buf的写出"></a>select出OP_WRITE的处理与buf的写出</h2><p>注册完之后再select到的写逻辑复用io.netty.channel.socket.nio.NioSocketChannel.doWrite(ChannelOutboundBuffer)<br>调用栈如下：  </p>
<pre><code class="hljs java">Thread [worker-<span class="hljs-number">3</span>] (Suspended (entry into method write in SocketChannelImpl))	
	SocketChannelImpl.write(ByteBuffer) line: <span class="hljs-number">458</span>	
	NioSocketChannel.doWrite(ChannelOutboundBuffer) line: <span class="hljs-number">405</span>	
	NioSocketChannel$NioSocketChannelUnsafe(AbstractChannel$AbstractUnsafe).flush0() line: <span class="hljs-number">938</span>	
	NioSocketChannel$NioSocketChannelUnsafe(AbstractNioChannel$AbstractNioUnsafe).forceFlush() line: <span class="hljs-number">367</span>	
	NioEventLoop.processSelectedKey(SelectionKey, AbstractNioChannel) line: <span class="hljs-number">671</span>	
	NioEventLoop.processSelectedKeysOptimized() line: <span class="hljs-number">612</span>	
	NioEventLoop.processSelectedKeys() line: <span class="hljs-number">529</span>	
	NioEventLoop.run() line: <span class="hljs-number">491</span>	
	SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>	
	Thread.run() line: <span class="hljs-number">748</span></code></pre>

<h2 id="main线程与boss线程切换，boss线程与worker线程切换"><a href="#main线程与boss线程切换，boss线程与worker线程切换" class="headerlink" title="main线程与boss线程切换，boss线程与worker线程切换"></a>main线程与boss线程切换，boss线程与worker线程切换</h2><p>boss与worker的NioEventLoop的spin run是什么时候启动触发的<br>main启动boss  </p>
<pre><code class="hljs java">Thread [main] (Suspended (breakpoint at line <span class="hljs-number">707</span> in java.lang.Thread))	
	owns: java.lang.Thread  (id=<span class="hljs-number">80</span>)	
	java.lang.Thread.start() line: <span class="hljs-number">707</span>	
	io.netty.util.concurrent.ThreadPerTaskExecutor.execute(java.lang.Runnable) line: <span class="hljs-number">33</span>	
	io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).doStartThread() line: <span class="hljs-number">894</span>	
	io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).startThread() line: <span class="hljs-number">865</span>	
	io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).execute(java.lang.Runnable) line: <span class="hljs-number">758</span>	
	io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).register(io.netty.channel.EventLoop, io.netty.channel.ChannelPromise) line: <span class="hljs-number">483</span>	
	io.netty.channel.nio.NioEventLoop(io.netty.channel.SingleThreadEventLoop).register(io.netty.channel.ChannelPromise) line: <span class="hljs-number">80</span>	
	io.netty.channel.nio.NioEventLoop(io.netty.channel.SingleThreadEventLoop).register(io.netty.channel.Channel) line: <span class="hljs-number">74</span>	
	io.netty.channel.nio.NioEventLoopGroup(io.netty.channel.MultithreadEventLoopGroup).register(io.netty.channel.Channel) line: <span class="hljs-number">86</span>	
	io.netty.bootstrap.ServerBootstrap(io.netty.bootstrap.AbstractBootstrap&lt;B,C&gt;).initAndRegister() line: <span class="hljs-number">333</span>	
	io.netty.bootstrap.ServerBootstrap(io.netty.bootstrap.AbstractBootstrap&lt;B,C&gt;).doBind(java.net.SocketAddress) line: <span class="hljs-number">282</span>	
	io.netty.bootstrap.ServerBootstrap(io.netty.bootstrap.AbstractBootstrap&lt;B,C&gt;).bind(java.net.SocketAddress) line: <span class="hljs-number">278</span>	
	org.restexpress.RestExpress.bind(java.net.InetSocketAddress) line: <span class="hljs-number">709</span>	
	org.restexpress.RestExpress.bind(java.lang.String, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">686</span>	
	com.code260.ss.resetexpress.RestExpressApp1.main(java.lang.String[]) line: <span class="hljs-number">26</span></code></pre>
<p>boss启动worker  </p>
<pre><code class="hljs java">Thread [boss-<span class="hljs-number">0</span>] (Suspended (breakpoint at line <span class="hljs-number">707</span> in java.lang.Thread))	
	owns: java.lang.Thread  (id=<span class="hljs-number">102</span>)	
	java.lang.Thread.start() line: <span class="hljs-number">707</span>	
	io.netty.util.concurrent.ThreadPerTaskExecutor.execute(java.lang.Runnable) line: <span class="hljs-number">33</span>	
	io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).doStartThread() line: <span class="hljs-number">894</span>	
	io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).startThread() line: <span class="hljs-number">865</span>	
	io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).execute(java.lang.Runnable) line: <span class="hljs-number">758</span>	
	io.netty.channel.socket.nio.NioSocketChannel$NioSocketChannelUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).register(io.netty.channel.EventLoop, io.netty.channel.ChannelPromise) line: <span class="hljs-number">483</span>	
	io.netty.channel.nio.NioEventLoop(io.netty.channel.SingleThreadEventLoop).register(io.netty.channel.ChannelPromise) line: <span class="hljs-number">80</span>	
	io.netty.channel.nio.NioEventLoop(io.netty.channel.SingleThreadEventLoop).register(io.netty.channel.Channel) line: <span class="hljs-number">74</span>	
	io.netty.channel.nio.NioEventLoopGroup(io.netty.channel.MultithreadEventLoopGroup).register(io.netty.channel.Channel) line: <span class="hljs-number">86</span>	
	io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor.channelRead(io.netty.channel.ChannelHandlerContext, java.lang.Object) line: <span class="hljs-number">255</span>	
	io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).invokeChannelRead(java.lang.Object) line: <span class="hljs-number">362</span>	
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(io.netty.channel.AbstractChannelHandlerContext, java.lang.Object) line: <span class="hljs-number">348</span>	
	io.netty.channel.DefaultChannelPipeline$HeadContext(io.netty.channel.AbstractChannelHandlerContext).fireChannelRead(java.lang.Object) line: <span class="hljs-number">340</span>	
	io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(io.netty.channel.ChannelHandlerContext, java.lang.Object) line: <span class="hljs-number">1408</span>	
	io.netty.channel.DefaultChannelPipeline$HeadContext(io.netty.channel.AbstractChannelHandlerContext).invokeChannelRead(java.lang.Object) line: <span class="hljs-number">362</span>	
	io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(io.netty.channel.AbstractChannelHandlerContext, java.lang.Object) line: <span class="hljs-number">348</span>	
	io.netty.channel.DefaultChannelPipeline.fireChannelRead(java.lang.Object) line: <span class="hljs-number">930</span>	
	io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe.read() line: <span class="hljs-number">93</span>	
	io.netty.channel.nio.NioEventLoop.processSelectedKey(java.nio.channels.SelectionKey, io.netty.channel.nio.AbstractNioChannel) line: <span class="hljs-number">677</span>	
	io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized() line: <span class="hljs-number">612</span>	
	io.netty.channel.nio.NioEventLoop.processSelectedKeys() line: <span class="hljs-number">529</span>	
	io.netty.channel.nio.NioEventLoop.run() line: <span class="hljs-number">491</span>	
	io.netty.util.concurrent.SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>	
	java.lang.Thread.run() line: <span class="hljs-number">748</span></code></pre>

<h2 id="selector与线程绑定的问题"><a href="#selector与线程绑定的问题" class="headerlink" title="selector与线程绑定的问题"></a>selector与线程绑定的问题</h2><p>一个selector对应一个channel，一个selector又对应固定的一个线程，所以一个channel上的数据<strong>多次读取不会在不同线程漂移</strong>。<br>当然，一个线程可以对应多个channel，但因为一个selector又对应固定的一个线程，所以这些channel用的同一个selector。  </p>
<h2 id="多boss问题也即多accept问题"><a href="#多boss问题也即多accept问题" class="headerlink" title="多boss问题也即多accept问题"></a>多boss问题也即多accept问题</h2><p>什么时候用多accept？<br>一般是用在多个端口bind，或者一个端口不同ip网卡平面bind时，多accept(即boss)线程才有意义。否则一个port通常只能bind出一个ServerSocketChannel出来，一个channel又对应一个Selector，一个Selector又对应一个线程在spin的方式去select，所以多个线程对一个bind也没用。如果把一个selector对应到多个线程去用问题在于，selector的方法线程不安全，对应到多个线程会有问题。<br>当然后来的JDK版本，包括linux开始支持一个port+ip可以被多个进程多次绑定，这样多accept就有意义了。参见 《NIO trick and trap》这个ppt的 题外:SO_REUSEPORT 关键字。 应用场景是 “适合大量短连接的web server”</p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/opensource-code-study/">opensource-code-study</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/java/">java</a>
                    
                      <a class="hover-with-bg" href="/tags/netty4%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">netty4源码分析</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/04/20/netty4-pooled-buffer/">
                        <span class="hidden-mobile">netty之池化buffer</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>






<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "netty之nio传输层&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>














  <script  src="https://cdn.staticfile.org/mermaid/8.4.8/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>





</body>
</html>
