<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="羽衣">
  <meta name="keywords" content="spring dubbo netty kafka 源码剖析 java 程序">
  <title>《汇编语言程序设计》读书笔记 - Code to 60</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/9.18.1/styles/github-gist.min.css" />


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_ijqayz9ro8k.css">




<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 40vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Code to 60</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">
              <i class="iconfont icon-home-fill"></i>
              首页</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/think/">
              
              零碎思索记录</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/program-language-practice">
              
              编程语言实践</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/opensource-code-study">
              
              开源项目学习</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/book-paper-study">
              
              书籍论文学习</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/life">
              
              美食旅行运动</a>
          </li>
        
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">
              <i class="iconfont icon-user-fill"></i>
              关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/c-1.jpeg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.1)">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <div class="mt-3 post-meta">
                  <i class="iconfont icon-date-fill" aria-hidden="true"></i>
                  <time datetime="2022-07-31 19:57">
                    星期日, 七月 31日 2022, 7:57 晚上
                  </time>
                </div>
              

              <div class="mt-1">
                
                  
                  <span class="post-meta mr-2">
                    <i class="iconfont icon-chart"></i>
                    14.8k 字
                  </span>
                

                
                  
                  <span class="post-meta mr-2">
                      <i class="iconfont icon-clock-fill"></i>
                    
                    
                    187
                     分钟
                  </span>
                

                
              </div>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <!-- <div class="d-none d-lg-block col-lg-2"></div> -->
    <div class="col-lg-10 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <div class="post-content mx-auto" id="post">
            
            <article class="markdown-body">
              <h1 id="《汇编语言程序设计》读书笔记"><a href="#《汇编语言程序设计》读书笔记" class="headerlink" title="《汇编语言程序设计》读书笔记"></a>《汇编语言程序设计》读书笔记</h1><p><a href="https://book.douban.com/subject/1446250/" target="_blank" rel="noopener">https://book.douban.com/subject/1446250/</a>  </p>
<p><img src="https://img2.doubanio.com/view/subject/l/public/s1581632.jpg" srcset="/img/loading.gif" alt=""></p>
<p>作者: [Richard Blum](<a href="https://book.douban.com/search/Richard" target="_blank" rel="noopener">https://book.douban.com/search/Richard</a> Blum)<br>出版社: <a href="https://book.douban.com/press/2793" target="_blank" rel="noopener">机械工业出版社</a><br>译者: <a href="https://book.douban.com/search/马朝晖" target="_blank" rel="noopener">马朝晖</a></p>
<p>ISBN: 9787111175322</p>
<h2 id="不同语法"><a href="#不同语法" class="headerlink" title="不同语法"></a>不同语法</h2><p>汇编语言有多重语法格式，不同的汇编器使用不同的语法编写程序。</p>
<p>x86汇编的两种语法：intel语法和AT&amp;T语法  </p>
<blockquote>
<p>x86汇编一直存在两种不同的语法:</p>
<ol>
<li>在intel的官方文档中使用intel语法，Windows也使用intel语<ol>
<li>而<strong>UNIX平台</strong>的汇编器一直使用<strong>AT&amp;T语法</strong></li>
</ol>
</li>
</ol>
<p><strong>movI %edx,%eax     #AT&amp;T写法</strong>这条指令</p>
<p>如果用intel语法来写，就是mov eax,edx，</p>
<ol>
<li><strong>寄存器名不加%号</strong>，</li>
<li><strong>源操作数和目标操作数的位置互换</strong>，</li>
<li><strong>字长也不是用指令的后缀l表示而是用另外的方式表示</strong>。</li>
</ol>
<p>详细可以参考Linux Assembly HOWTO（<a href="http://tldp.org/" target="_blank" rel="noopener">http://tldp.org/</a> HOWTO/Assembly-HOWTO/，后文简称[AssemblyHOWTO]）。</p>
</blockquote>
<h2 id="处理器相关"><a href="#处理器相关" class="headerlink" title="处理器相关"></a>处理器相关</h2><h3 id="主要组件"><a href="#主要组件" class="headerlink" title="主要组件"></a>主要组件</h3><p>处理器的主要组件：</p>
<ul>
<li>控制单元。intel的NetBurst技术包括的特性：<ul>
<li>指令预取和解码</li>
<li>分支预测</li>
<li>乱序执行</li>
<li>退役</li>
</ul>
</li>
<li>执行单元</li>
<li>标志</li>
<li>寄存器</li>
</ul>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>IA-32系列处理器的寄存器：</p>
<ul>
<li>通用寄存器。8个32位寄存器，用于正在处理的数据。</li>
<li>段寄存器。6个16位寄存器，用于处理内存访问。</li>
<li>指令指针寄存器。单一的32位寄存器，指向要执行的下一条指令码。</li>
<li>浮点数据寄存器。8个80位寄存器，用于浮点数学数据。</li>
<li>控制寄存器。5个32位寄存器，用于确定处理器的操作模式。</li>
<li>调试寄存器。8个32位寄存器，用于在调试处理器时包含信息。</li>
</ul>
<h4 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h4><p>E/ABCD/X;E/DS/I;E/SB/P</p>
<p>虽说都是通用寄存器，但是每个寄存器都有其不同的作用，在读完全部汇编语言的知识后才能真正理解。</p>
<ul>
<li>EAX。用于操作数和结果数据的累加器。</li>
<li>EBX。指向数据内存段中的数据指针。</li>
<li>ECX。字符串和循环数据的计数器。</li>
<li>EDX。I/O指针。</li>
<li>EDI。用于字符串操作的<strong>目标</strong>的数据指针。</li>
<li>ESI。用于字符串操作的<strong>源</strong>的数据指针。</li>
<li>ESP。堆栈指针。</li>
<li>EBP。堆栈数据指针。</li>
</ul>
<p>32位的E/ABCD/X寄存器也可以通过16位和8位的名称引用。以EAX为例：</p>
<ul>
<li>AL低8位</li>
<li>AH 8-15位</li>
<li>AX 低16位</li>
</ul>
<h4 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h4><p>6个16位。CDEFG/S,SS</p>
<p>CS DS SS  分别对应代码段的指针、数据段的指针、堆栈段的指针</p>
<p>ES FS GS 对应三个附加段指针</p>
<h4 id="指令指针寄存器"><a href="#指令指针寄存器" class="headerlink" title="指令指针寄存器"></a>指令指针寄存器</h4><p>指令指针寄存器即EIP寄存器，也叫PC寄存器。他跟踪要执行的下一条指令码。</p>
<h4 id="控制寄存器"><a href="#控制寄存器" class="headerlink" title="控制寄存器"></a>控制寄存器</h4><p>5个32位寄存器。CR/01234。</p>
<p>不能直接访问控制寄存器中的值，但是可以传送给通用寄存器。</p>
<h4 id="标志-EFLAGS寄存器"><a href="#标志-EFLAGS寄存器" class="headerlink" title="标志/EFLAGS寄存器"></a>标志/EFLAGS寄存器</h4><p>单一的32位寄存器。 是可以用于确定程序的功能是否成功执行的唯一途径。比如减法，如果结果为负值，那么处理器内就有一个专门的标志被设置。</p>
<p>按照功能标志被分为三组：</p>
<ul>
<li>状态标志。用于表明处理器进行数学运算的结果。比如：CF 进位标志，最高位是否产生了进位或者借位。SF 符号标志，有符号数的符号位。</li>
<li>控制标志。目前只有一个，DF，即方向标志，用于控制处理器处理字符串的方式。DF设置为1，字符串指令<strong>自动递减内存地址</strong>以便达到字符串的下一个字节。DF设置为0，字符串指令<strong>自动递增内存地址</strong>以便达到字符串的下一个字节。</li>
<li>系统标志。用于控制操作系统级别的操作，应用程序不应该试图修改系统标志。比如IF是中断使能标志，控制处理器如何响应从外部源接收到的信号。</li>
</ul>
<p>条件传送指令使用的特定位在下表中介绍：</p>
<table>
<thead>
<tr>
<th>EFLAGS位</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>CF</td>
<td>进位标志（Carry）</td>
<td>数学表达式产生了进位或者借位 0:没产生; 1:产生了</td>
</tr>
<tr>
<td>OF</td>
<td>溢出标志（Overflow）</td>
<td>整数值过大或者过小</td>
</tr>
<tr>
<td>PF</td>
<td>奇偶校验（Parity）</td>
<td>寄存器包含数学操作造成的错误数据</td>
</tr>
<tr>
<td>SF</td>
<td>符号标志（sign）</td>
<td>指出结果为正还是负</td>
</tr>
<tr>
<td>ZF</td>
<td>零标志（zero）</td>
<td>数学操作的结果为零</td>
</tr>
</tbody></table>
<h4 id="调试器中寄存器信息"><a href="#调试器中寄存器信息" class="headerlink" title="调试器中寄存器信息"></a>调试器中寄存器信息</h4><p>在我本机我尝试看了下调试器中寄存器信息如下：</p>
<pre><code class="hljs plain">(gdb) info reg
rax            0x40057d	4195709
rbx            0x0	0
rcx            0x4005a0	4195744
rdx            0x7fffffffe248	140737488347720
rsi            0x7fffffffe238	140737488347704
rdi            0x1	1
rbp            0x7fffffffe150	0x7fffffffe150
rsp            0x7fffffffe150	0x7fffffffe150
r8             0x7ffff7dd5e80	140737351868032
r9             0x0	0
r10            0x7fffffffdca0	140737488346272
r11            0x7ffff7a2f460	140737348039776
r12            0x400490	4195472
r13            0x7fffffffe230	140737488347696
r14            0x0	0
r15            0x0	0
rip            0x400581	0x400581 &lt;main+4&gt;
eflags         0x246	[ PF ZF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0</code></pre>

<p>64位的都是rxx。可以看到通用寄存器（包含堆栈指针等）、段寄存器、标志、指令指针寄存器等等。</p>
<h3 id="IA-32高级特性FPU-MMX-SSE-SSE2-SSE3"><a href="#IA-32高级特性FPU-MMX-SSE-SSE2-SSE3" class="headerlink" title="IA-32高级特性FPU/MMX/SSE/SSE2/SSE3"></a>IA-32高级特性FPU/MMX/SSE/SSE2/SSE3</h3><ul>
<li>x87浮点单元（FPU）。引入了附加的寄存器，FPU寄存器。包括：数据寄存器，状态寄存器，控制寄存器，标志寄存器，FIP寄存器，FDP寄存器，操作码寄存器。</li>
<li>多媒体扩展，MMX。支持单指令多数据的执行模型，SIMD。支持MMX的处理可以处理64位打包的字节/字/双字整数。</li>
<li>流化SIMD扩展，SSE。支持128位打包的单精度浮点数。SSE2支持128位打包双精度浮点数，128位打包的字节/字/双字/四字整数。SSE3没有支持新的数据类型，但是引入了几个新的指令用于处理XMM寄存器中的整数和浮点数。</li>
<li>现在稍新一点的CPU还有rdtscp lm constant_tsc SSE4_1 SSE4_2等特性</li>
</ul>
<h2 id="指令码、指令前缀"><a href="#指令码、指令前缀" class="headerlink" title="指令码、指令前缀"></a>指令码、指令前缀</h2><p>指令码  instruction code</p>
<p>所有的计算机处理器都按照制造厂商在处理器芯片内部定义的二进制代码操作数据。这些预置的代码被称为指令码。</p>
<p>指令指针和数指针</p>
<p>为了区分数据和指令码，用指令指针和数据指针跟踪数据和指令码的存储位置。</p>
<p><strong>IA-32指令码格式由四个主要部分构成：</strong></p>
<ul>
<li><strong>可选指令前缀</strong>。可以包含1个到4个修改操作码行为的1字节前缀。指令前缀按组又分成四种，每次每个组中的只能选一个：<ul>
<li><strong>锁定前缀和重复前缀</strong>。锁定前缀表示指令将独占地使用共享内存区域，对多处理器和超线程系统非常重要。重复前缀表示重复的功能（常常用在字符串处理时）</li>
<li><strong>段覆盖前缀和分支提示前缀</strong>。段覆盖前缀定义可以覆盖定义了的段寄存器值的指令。分支提示前缀尝试向处理器提供程序在条件跳转语句中最可能的路径线索。    </li>
<li><strong>操作数长度覆盖前缀</strong>。操作数长度覆盖前缀通知处理器，程序将在这个操作码之内，切换16位和32位的操作数长度。</li>
<li><strong>地址长度覆盖前缀</strong>。跟操作数长度覆盖前缀类似，只是此处切换的是16位和32位的内存地址。</li>
</ul>
</li>
<li><strong>操作码</strong>（opcode）。 唯一必选部分。定义要执行的功能。长度在1-3字节之间。</li>
<li><strong>可选的修饰符</strong>。一些操作码需要另外的修饰符来定义执行的过程中涉及到什么寄存器和什么内存位置。修饰符包含在三个单独的值中：<ul>
<li>寻址方式说明符字节（ModR/M）。组成是3个字段：Mod(2位 6-7) reg/opcode(3位 3-5) r/m(3位 0-2)</li>
<li>比例-索引-基址字节（SIB）。组成是3个字段：比例(2位 6-7) 索引(3位 3-5) 基址(3位 0-2)</li>
<li>1、2、4个的地址位移字节</li>
</ul>
</li>
<li><strong>可选的数据元素</strong>。指令码的最后一部分是该功能使用的数据元素。</li>
</ul>
<p><strong>最后注意区分<code>指令码</code>和<code>操作码</code></strong>。</p>
<h2 id="定义数据"><a href="#定义数据" class="headerlink" title="定义数据"></a>定义数据</h2><p>在汇编中定义数据有两种途径：<strong>使用内存位置和使用堆栈</strong>。</p>
<p>使用内存位置</p>
<pre><code class="hljs assembly">testvalue:
    .long 150
message:
    .ascii &quot;This is a test message&quot;
pi:
    .float 3.14159</code></pre>

<p>从上面示例开可以看出，有三个部分组成</p>
<ul>
<li>指向一个内存位置的标记。  可以理解成标签、变量名都行。</li>
<li>内存字节的数据类型。</li>
<li>默认值。</li>
</ul>
<p>使用内存中定义的数据：</p>
<pre><code class="hljs assembly">movl testvalue %ebx
addl $10 %ebx
movl %ebx testvalue</code></pre>

<p>从上面示例中可以看出，可以<strong>从变量中取出值放到寄存器中</strong>，然后也可以<strong>将寄存器中的值搬到变量地址（即可以理解成对变量赋值）</strong></p>
<p>使用堆栈</p>
<p>堆栈是特殊的内存区域，常用于函数之间传递数据。堆栈指针用于指向堆栈中下一个内存位置以便放入或者读取数据。</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>.long(32位整数和int相同) </li>
<li>.ascii(文本字符串)  </li>
<li>.float   </li>
<li>.asciz(以空字符结尾的文本字符串) </li>
<li>.byte(字节) </li>
<li>.double </li>
<li>.int(32位整数和long相同) </li>
<li>.octa(16字节整数) </li>
<li>.quad(8字节整数) </li>
<li>.short(16位整数) </li>
<li>.single(单精度浮点数同float)</li>
<li>.equ  可在数据段以定义静态数据符号。  .equ LINUX_SYS_CALL, 0x80    使用时 movl $LINUX_SYS_CALL, %eax</li>
<li>.fill  buffer:\n .fill 10000   改命令是汇编器自动创建10000个数据元素，默认每个字段为1字节。这种会被打包到应用程序中，可以通过观察应用程序的大小发现。</li>
<li>.comm  在bss段，声明未初始化的数据的通用内存区域。 格式 ： .comm symbol, length</li>
<li>.lcomm  在bss段，声明未初始化的数据的本地通用内存区域，只定义要多少空间，不需要指明类型。<strong>本地的意思是为了不会从本地汇编代码之外进行数据访问</strong>。</li>
</ul>
<p>附：</p>
<ul>
<li>.asciz 命令,不同于.ascii。.asciz命令会在声明的字符串末尾添加空字符，这种可以配合printf函数使用，详细的参见函数调用章节。</li>
<li>.lcomm 命令用于定义缓冲区，声明在.bss段。</li>
<li>可以一行定义多个值，可以理解成数组：size: \n .long 100,150,200,250。  每个long 4个字节，通过size+8可以访问200</li>
<li>bss和data中声明数据的一个区别是：bss段声明的数据不包含在可执行文件中。data段声明的数据必须包含在可执行程序中。</li>
</ul>
<h3 id="定义段"><a href="#定义段" class="headerlink" title="定义段"></a>定义段</h3><p>使用 .section命令声明段。详细的参见下面 程序组成章节。</p>
<p>.data   .bss  .text .radata</p>
<p>data段用于声明为程序存储数据元素的内存区域，<strong>在声明之后，这一段落不能扩展，在整个程序中保持静态</strong>。</p>
<p>bss段也是静态的内存段。这个段落中的缓冲区的内存区域是由0填充的。</p>
<p>文本段用于存储指令码。</p>
<p>.rodata，与.data段类似 但是这里定义的变量只能只读。</p>
<h3 id="定义标签"><a href="#定义标签" class="headerlink" title="定义标签"></a>定义标签</h3><p>.globl 也可以用于声明外部成名可以访问的程序标签。在文本段。</p>
<p>汇编程序必要的程序起始点就是用.globl声明，.globl _start 详细的参见 定义起始点 章节。</p>
<p>参见 x86 Assembly Language Reference Manual 文档的 Pseudo Operations 章节。<strong>比国内的材料讲的要全,但是没有示例</strong>，.section .text .long等都有阐述。  </p>
<p><strong>section data  text globl _start</strong>  </p>
<p>汇编程序中<strong>以.开头的名称，称为汇编指示</strong>（Assembler Directive）<strong>或伪操作</strong>（Pseudo-operation）。  </p>
<p>汇编指示并不是指令的助记符，不会被翻译成机器指令，而是给汇编器一些特殊指示。  </p>
<p><strong>.section指示把代码划分成若干个段</strong>（Section）  比如.section .data 也可以不写，直接.data，参见hellostring.s</p>
<p><strong>.data段保存程序的数据，是可读可写的，相当于C程序的全局变量</strong>。hello.s中没有定义数据，所以.data段是空的。  </p>
<p><strong>.text</strong>段保存代码，是只读和可执行的，后面那些指令都属于.text段**。  </p>
<p><strong>.gIobI告诉汇编器，_start这个符号要被链接器用到</strong>，所以<strong>要在目标文件的符号表中标记它是一个全局符号</strong>。  </p>
<p><strong>.align</strong>  </p>
<p>ALIGN bound  <strong>Bound 可取值有：1、2、4、8、16</strong>。当取值为 1 时，则下一个变量地址对齐于 1 字节边界（默认情况）。当取值为 2 时，<strong>则下一个变量对齐于偶数地址</strong>。当取值为 4 时，则下一个变量地址为 4 的倍数。当取值为 16 时，则下一个变量地址为 16 的倍数，即一个段落的边界。  简单地说：<strong>如果前面一个byte的变量地址到0x00404004h，接着用ALIGN 4 ，那么后面变量的地址就是00404008h了而不是00404005h。</strong></p>
<blockquote>
<p>为了满足对齐要求，汇编器会在变量前插入一个或多个空字节。为什么要对齐数据？因为，对于存储于偶地址和奇地址的数据来说，CPU 处理偶地址数据的速度要快得多。   <a href="http://c.biancheng.net/view/3515.html" target="_blank" rel="noopener">参考</a></p>
</blockquote>
<p><strong>.equ  与 =</strong></p>
<p>可以理解成定义一个常量,比如hello.s中改造成pseudo_op.s:</p>
<pre><code class="hljs ass"># pseudo_op.s
.section .data
.equ testval, 4

.section .text
.globl _start
_start:
movl $1, %eax
movl $testval, %ebx
int $0x80</code></pre>

<p>有人说equ不能对一个变量重复赋值，我试了下可以（估计这个说说法不是linux上跑的汇编（Linux下的AT&amp;T语法(即GNU as 汇编语法)））  </p>
<p>然后，同样的复制语义支持testval = 4 这种写法，但是不支持  testval equ 4这种写法（linux上验证的）</p>
<p><strong>.string</strong></p>
<p> 简单的理解成定义一个字符串。参见hellostring.s  </p>
<h2 id="工具相关"><a href="#工具相关" class="headerlink" title="工具相关"></a>工具相关</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>GNU汇编器。该汇编器不在单独的包中发布，是在binutils中一起发布。binutils中包括了addr2line,ar,as,c++filt,gprof,ld,nlmconv,nm,objcopy,objdump,ranlib,readelf,size,strings,strip,windres。</p>
<p>可以通过确认binutils包是否存在来判断其是否安装。</p>
<pre><code class="hljs bash">rpm -qa|grep binu                                                                                                                                                       
<span class="hljs-comment"># binutils-2.27-44.base.el7.x86_64</span>
cat /etc/redhat-release
<span class="hljs-comment"># CentOS Linux release 7.9.2009 (Core)</span>

<span class="hljs-comment"># 编译汇编</span>
as -o test.o test.s
<span class="hljs-comment"># 编译支持调试的目标文件</span>
as -gstabs -o test.o test.s</code></pre>

<p>简单c程序</p>
<pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"Hello World!\n"</span>);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
&#125;</code></pre>

<p>编译c，c编程汇编</p>
<pre><code class="hljs bash"><span class="hljs-comment"># 编译c  -o 编译又链接， -c只编译不链接</span>
gcc -o ctest ctest.c

./ctest
Hello World!

<span class="hljs-comment"># -gstabs编译带有调试信息</span>
gcc -gstabs -o ctest ctest.c

<span class="hljs-comment"># 将c编译到汇编 不用-o指定目标文件时结果就是放在与c同名的.s文件中</span>
gcc -S ctest.c

cat ctest.s</code></pre>

<p>c编译到汇编结果</p>
<pre><code class="hljs assembly">	.file	&quot;ctest.c&quot;
	.section	.rodata
.LC0:
	.string	&quot;Hello World!&quot;
	.text
	.globl	main
	.type	main, @function
main:
.LFB2:
	.cfi_startproc
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	$.LC0, %edi
	call	puts
	movl	$0, %edi
	call	exit
	.cfi_endproc
.LFE2:
	.size	main, .-main
	.ident	&quot;GCC: (GNU) 4.8.5 20150623 (Red Hat 4.8.5-44)&quot;
	.section	.note.GNU-stack,&quot;&quot;,@progbits</code></pre>

<h3 id="反编译objdump-gdb的disassemble"><a href="#反编译objdump-gdb的disassemble" class="headerlink" title="反编译objdump/gdb的disassemble"></a>反编译objdump/gdb的disassemble</h3><p>反编译可以用objdump也可以在gdb调试中用disassemble</p>
<pre><code class="hljs bash">objdump -d ctest
Disassembly of section .text:

0000000000400490 &lt;_start&gt;:
  400490:	31 ed                	xor    %ebp,%ebp
  400492:	49 89 d1             	mov    %rdx,%r9
  400495:	5e                   	pop    %rsi
  400496:	48 89 e2             	mov    %rsp,%rdx
  400499:	48 83 e4 f0          	and    <span class="hljs-variable">$0xfffffffffffffff0</span>,%rsp
  40049d:	50                   	push   %rax
  40049e:	54                   	push   %rsp
  40049f:	49 c7 c0 10 06 40 00 	mov    <span class="hljs-variable">$0x400610</span>,%r8
  4004a6:	48 c7 c1 a0 05 40 00 	mov    <span class="hljs-variable">$0x4005a0</span>,%rcx
  4004ad:	48 c7 c7 7d 05 40 00 	mov    <span class="hljs-variable">$0x40057d</span>,%rdi
  4004b4:	e8 a7 ff ff ff       	callq  400460 &lt;__libc_start_main@plt&gt;
  4004b9:	f4                   	hlt
  4004ba:	66 0f 1f 44 00 00    	nopw   0x0(%rax,%rax,1)</code></pre>

<p>gdb调试中反编译</p>
<pre><code class="hljs bash">(gdb) disassemble
Dump of assembler code <span class="hljs-keyword">for</span> <span class="hljs-keyword">function</span> main:
   0x000000000040057d &lt;+0&gt;:	push   %rbp
   0x000000000040057e &lt;+1&gt;:	mov    %rsp,%rbp
=&gt; 0x0000000000400581 &lt;+4&gt;:	mov    <span class="hljs-variable">$0x400630</span>,%edi
   0x0000000000400586 &lt;+9&gt;:	callq  0x400450 &lt;puts@plt&gt;
   0x000000000040058b &lt;+14&gt;:	mov    <span class="hljs-variable">$0x0</span>,%edi
   0x0000000000400590 &lt;+19&gt;:	callq  0x400480 &lt;<span class="hljs-built_in">exit</span>@plt&gt;
End of assembler dump.</code></pre>

<h3 id="连接与执行文件"><a href="#连接与执行文件" class="headerlink" title="连接与执行文件"></a>连接与执行文件</h3><p>连接使用ld</p>
<pre><code class="hljs bash">ld -o <span class="hljs-built_in">test</span> test.o</code></pre>

<h4 id="ELF文件格式-readelf工具"><a href="#ELF文件格式-readelf工具" class="headerlink" title="ELF文件格式/readelf工具"></a>ELF文件格式/readelf工具</h4><p>ELF文件格式是一个开放标准，各种UNIX系统的可执行文件都采用ELF格式，它有以下三种不同的类型： </p>
<ul>
<li>可重定位的目标文件（Relocatable，或者Object File）  </li>
<li>可执行文件（Executable）  </li>
<li>共享库（Shared Object，或者Shared Library）  </li>
</ul>
<p>readelf 工具可以读取elf文件信息。  </p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>用gdb调试，基础的b r这些就不提及了，跟汇编相关的有以下这些，有些在前文中已经提及。</p>
<ul>
<li>disassemble可以调试c程序时反汇编</li>
<li>info reg可以调试时查看寄存器信息</li>
<li>print/x $ebx  查看单个寄存器的值。print/x  显示十六进制   print/d 显示十进制  print/t显示二进制</li>
<li>x命令可以显示特定内存位置的值，类似print。x命令的格式有点复杂： x/nyz  。比如<strong>x/42cb &amp;oputput  表示以字符形式(y:c)展示output对应内存地址(&amp;output)的前42(n:42)个字节(z:b)</strong><ul>
<li>n是要显示的字段数（可以理解为长度）</li>
<li>y是输出格式<ul>
<li>c是字符</li>
<li>d是十进制</li>
<li>x是十六进制</li>
</ul>
</li>
<li>z是要显示的字段长度<ul>
<li>b用于字节</li>
<li>用于16位字  半字</li>
<li>w用于32位字</li>
</ul>
</li>
</ul>
</li>
<li>break 可以break 汇编的起始点，即 break _star</li>
<li>汇编调试需要加nop的问题   _start: 开始的第一条指令用nop 否则导致调试不能正常操作</li>
</ul>
<p>break _start示例：</p>
<pre><code class="hljs bash">╰─$ as -gstabs -o cpuid.o cpuid.s                                                                                                                                          
╭─simon@simon-c7-d1 ~/600.self/01.code/01.c_cpp/02.program_basic_study/cpuid
╰─$ ld -o cpuid cpuid.o
╭─simon@simon-c7-d1 ~/600.self/01.code/01.c_cpp/02.program_basic_study/cpuid
╰─$ ./cpuid
The processor Vendor ID is <span class="hljs-string">'GenuineIntel'</span>
╭─simon@simon-c7-d1 ~/600.self/01.code/01.c_cpp/02.program_basic_study/cpuid
╰─$ gdb ./cpuid
GNU gdb (GDB) Red Hat Enterprise Linux 7.6.1-120.el7
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type <span class="hljs-string">"show copying"</span>
and <span class="hljs-string">"show warranty"</span> <span class="hljs-keyword">for</span> details.
This GDB was configured as <span class="hljs-string">"x86_64-redhat-linux-gnu"</span>.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
Reading symbols from /home/simon/600.self/01.code/01.c_cpp/02.program_basic_study/cpuid/cpuid...done.
(gdb) b *_start
Breakpoint 1 at 0x4000b0: file cpuid.s, line 10.
(gdb) r
Starting program: /home/simon/600.self/01.code/01.c_cpp/02.program_basic_study/cpuid/./cpuid

Breakpoint 1, _start () at cpuid.s:10
10	    movl <span class="hljs-variable">$0</span>, %eax
(gdb)</code></pre>

<h3 id="静态库与动态共享库"><a href="#静态库与动态共享库" class="headerlink" title="静态库与动态共享库"></a>静态库与动态共享库</h3><h4 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h4><p>静态库是把多个目标文件打包在一起的一个文件。一般是.a扩展名。</p>
<p>连接静态库时，把其中声明的用到的函数拷贝一份到可执行文件中。</p>
<p>涉及处理静态库的工具是ar、nm：</p>
<ul>
<li>显示库文件中包含的目标文件，   ar t  libchap14.a</li>
<li>显示更详细的信息，ar tv  libchap14.a</li>
<li>nm显示存档文件的索引, nm -s libchap14.a|more</li>
<li>创建静态库，ar r libchap14.a  square.o cpuidinfo.o areafunc.o</li>
<li>gcc使用时， gcc -o inttest tnttest.c libchap14.a</li>
</ul>
<h4 id="动态共享库"><a href="#动态共享库" class="headerlink" title="动态共享库"></a>动态共享库</h4><p>共享库加载操作系统的通用区域中，程序运行时需要时，操作系统自动地把函数代码加载到内存中，并允许程序访问他。</p>
<p>处理共享库的工具：</p>
<ul>
<li>创建  gcc -shared -o libchap14.so.1 square.o cpuidinfo.o areafunc.o</li>
<li>编译时使用 gcc -o inttest -L. -lchap14 inttest.c</li>
<li>查看可执行文件依赖什么共享库  ldd inttest</li>
</ul>
<h4 id="动态共享库的路径问题"><a href="#动态共享库的路径问题" class="headerlink" title="动态共享库的路径问题"></a>动态共享库的路径问题</h4><p>有两种方式告诉程序查找动态共享库位于什么位置</p>
<ul>
<li>LD_LIBRARY_PATH对应的环境变量。多个用冒号:分隔</li>
<li>/etc/ld.so.conf 文件</li>
</ul>
<p><strong>修改完ld.so.conf 文件后，需要用法ldconfig命令刷新其cache。</strong></p>
<h2 id="程序组成"><a href="#程序组成" class="headerlink" title="程序组成"></a>程序组成</h2><h3 id="段"><a href="#段" class="headerlink" title="段"></a>段</h3><p>几个常用的段：</p>
<ul>
<li>数据段。.data   声明带有初始值的数据元素，一般是汇编程序中的变量。</li>
<li>只读数据段。 .rodata，与.data段类似 但是这里定义的变量只能只读。</li>
<li>bss段。.bss   声明使用0值初始化的元素，一般用作汇编程序中的缓冲区。</li>
<li>文本段。.text   <strong>必须有此段</strong>。这是声明指令代码的地方。</li>
</ul>
<p>使用 .section命令声明段。</p>
<h3 id="定义起始点"><a href="#定义起始点" class="headerlink" title="定义起始点"></a>定义起始点</h3><p>当汇编语言程序转换成可执行的文件时，连接器必须知道指令码中的<strong>起始点</strong>是什么。</p>
<p>_start标签用于表示程序应该从这条指令开始运行。声明方式用.globl命令(.globl 也可以用于声明外部成名可以访问的程序标签，比如外部汇编语言或者c程序使用的，便签可以粗略的理解成函数名)，如下：</p>
<p>.globl _start</p>
<p>_start:</p>
<p>示例参见下面的代码模板。</p>
<p>找不到起始点则报错如下：</p>
<p>ld: warning: <strong>cannot find entry symbol _start</strong>; defaulting to 0000000000400078</p>
<pre><code class="hljs bash">╭─simon@simon-c7-d1 ~/600.self/01.code/01.c_cpp/02.program_basic_study/no_start
╰─$ cat no_start.s
.section .text

movl <span class="hljs-variable">$1</span>, %eax
movl <span class="hljs-variable">$4</span>, %ebx
int <span class="hljs-variable">$0x80</span>
╭─simon@simon-c7-d1 ~/600.self/01.code/01.c_cpp/02.program_basic_study/no_start
╰─$ as -o no_start.o no_start.s                                                                                                                                             
╭─simon@simon-c7-d1 ~/600.self/01.code/01.c_cpp/02.program_basic_study/no_start
╰─$ ld -o no_start no_start.o
ld: warning: cannot find entry symbol _start; defaulting to 0000000000400078</code></pre>

<p>连接器可以用-e参数自定义起始点名称。</p>
<p><strong>ld -e _cus_start -o cus_start cus_start.o</strong></p>
<pre><code class="hljs bash">╰─$ cat cus_start.s
.section .text
.globl _cus_start
_cus_start:
movl <span class="hljs-variable">$1</span>, %eax
movl <span class="hljs-variable">$4</span>, %ebx
int <span class="hljs-variable">$0x80</span>

╭─simon@simon-c7-d1 ~/600.self/01.code/01.c_cpp/02.program_basic_study/custom_start
╰─$ as -o cus_start.o cus_start.s
╭─simon@simon-c7-d1 ~/600.self/01.code/01.c_cpp/02.program_basic_study/custom_start
╰─$ ld -e _cus_start -o cus_start cus_start.o
╭─simon@simon-c7-d1 ~/600.self/01.code/01.c_cpp/02.program_basic_study/custom_start
╰─$ ./cus_start
╭─simon@simon-c7-d1 ~/600.self/01.code/01.c_cpp/02.program_basic_study/custom_start
╰─$ <span class="hljs-built_in">echo</span> $?                                                                                                                                                                 
4</code></pre>



<h3 id="基本模板"><a href="#基本模板" class="headerlink" title="基本模板"></a>基本模板</h3><p>hello.s代码，仅仅设置返回值为4。</p>
<pre><code class="hljs assembly"># hello.s
#.section .data
# 有初始值的变量放在这里
#.section .bss
# 没有初始值的变量放在这里
.section .text
# 指令区域
.globl _start
# 程序起始点
_start:
movl $1, %eax
movl $4, %ebx
int $0x80</code></pre>

<p>编译、链接、执行、查看返回值  </p>
<pre><code class="hljs bash">as hello.s -o hello.o
ld hello.o -o hello
./hello
<span class="hljs-built_in">echo</span> $?
<span class="hljs-comment"># 4</span></code></pre>

<h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="传送数据"><a href="#传送数据" class="headerlink" title="传送数据"></a>传送数据</h2><p>用mov传送数据。</p>
<p>有movl movw movb movs等，区别在于大小：</p>
<ul>
<li>l用于32位字长</li>
<li>w用于16位字长 (配套ax bx等使用)</li>
<li>b用于8位字长 (配套al bl等使用)</li>
<li>s 用于处理字符串，在字符串章节再讨论</li>
</ul>
<p>传送不同的数据：</p>
<ul>
<li>传送立即数。 movl $0, %eax        movl $80, %ebx</li>
<li>在寄存器间传送数据。 movl %eax, %ecx</li>
<li>在内存和寄存器间传送数据。  movl value, %ecx</li>
<li>从寄存器传递给内存。 movl %ecx, value</li>
<li>使用变址的内存地址。变址内存模式（indexed memory model）。base_address(offset_address, index, size) 计算地址的方式为：base_address+offset_address+index*size。 如果其中的值为0，就可以忽略他们，但是仍需要用逗号作为占位符。</li>
<li>使用寄存器间接寻址。比如：movl $values, %edi    movl %ebx, (%edi)。 values前面加$表示取其地址，%edi外面加括号表示指令把ebx中的值传送给edi寄存器中包含的内存位置，不加括号表示指令将ebx中值传送到edi寄存器中。</li>
<li>使用寄存器间接相对地址寻址。比如：movl %edx, 4(%edi)  movl %edx, -4(%edi)。</li>
</ul>
<p>传送数据case：</p>
<pre><code class="hljs assembly">.section .data
    value:
    .int 1
    values:
    .int 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60
.section .text
.globl _start
_start:
    nop
    movl value, %ecx
    movl $100, %ecx
    movl %exc, value
    movl $1, %eax
    movl $0, %ebx
    movl $2, %edi
    movl values(, %edi, 4), %eax
    
    movl $values, %edi    
    movl %ebx, (%edi)
    
    movl %edx, 4(%edi)  
    movl %edx, -4(%edi)
    int $0x80</code></pre>

<h3 id="条件传送"><a href="#条件传送" class="headerlink" title="条件传送"></a>条件传送</h3><p>cmovx source, destination</p>
<p>x表示触发传送操作的条件，条件取决于EFLAGS寄存器中的当前值。</p>
<p>EFLAGS寄存器涉及条件传送的标志位的说明请参见EFLAGS章节。</p>
<h3 id="无符号条件传送"><a href="#无符号条件传送" class="headerlink" title="无符号条件传送"></a>无符号条件传送</h3><table>
<thead>
<tr>
<th>指令对</th>
<th>描述</th>
<th>EFLAGS状态</th>
</tr>
</thead>
<tbody><tr>
<td>CMOVA/CMOVNBE</td>
<td>大于/不小于等于</td>
<td>CF或者ZF=0</td>
</tr>
<tr>
<td>CMOVAE/CMOVNB</td>
<td>大于或者等于/不小于</td>
<td>CF=0</td>
</tr>
<tr>
<td>CMOVNC</td>
<td>无进位</td>
<td>CF=0</td>
</tr>
<tr>
<td>CMOVB/CMOVNAE</td>
<td>小于/不大于或者等于</td>
<td>CF=1</td>
</tr>
<tr>
<td>CMOVC</td>
<td>进位</td>
<td>CF=1</td>
</tr>
<tr>
<td>CMOVBE/CMOVNA</td>
<td>小于或者等于/不大于</td>
<td>CF或者ZF=1</td>
</tr>
<tr>
<td>CMOVE/CMOVZ</td>
<td>等于/零</td>
<td>ZF=1</td>
</tr>
<tr>
<td>CMOVNE/CMOVNZ</td>
<td>不等于/不为零</td>
<td>ZF=0</td>
</tr>
<tr>
<td>CMOVP/CMOVPE</td>
<td>奇偶校验/偶校验</td>
<td>PF=1</td>
</tr>
<tr>
<td>CMOVNP/CMOVPO</td>
<td>非奇偶校验/奇校验</td>
<td>PF=0</td>
</tr>
</tbody></table>
<p><strong>A 大于 B小于 C进位 N不是 P 奇偶校验 PE偶校验  PO奇校验</strong></p>
<h4 id="什么时候CF-0-cmp怎么比较"><a href="#什么时候CF-0-cmp怎么比较" class="headerlink" title="*什么时候CF=0 cmp怎么比较"></a>*什么时候CF=0 cmp怎么比较</h4><p>注意: A 是大于，即CF或者ZF=0。那么，<strong>什么时候CF或者ZF=0</strong>？</p>
<p>从下面的例子中可以看出：cmp %ebx, %eax时，当%eax&gt;%ebx时，不借位，即CF=0。</p>
<p><strong>cmp指令是拿第二个操作数减去第一个操作数，这个点一定要注意。</strong></p>
<h3 id="带符号的条件传送指令"><a href="#带符号的条件传送指令" class="headerlink" title="带符号的条件传送指令"></a>带符号的条件传送指令</h3><table>
<thead>
<tr>
<th>指令对</th>
<th>描述</th>
<th>EFLAGS状态</th>
</tr>
</thead>
<tbody><tr>
<td>CMOVGE/CMOVNL</td>
<td>大于或者等于/不小于</td>
<td>SF异或OF=0</td>
</tr>
<tr>
<td>CMOVL/CMOVNGE</td>
<td>小于/不大于或者等于</td>
<td>SF异或OF=1</td>
</tr>
<tr>
<td>CMOVLE/CMOVNG</td>
<td>小于或者等于/不大于</td>
<td>SF异或OF=1或者ZF=1</td>
</tr>
<tr>
<td>CMOVO</td>
<td>溢出</td>
<td>OF=1</td>
</tr>
<tr>
<td>CMOVNO</td>
<td>未溢出</td>
<td>OF=0</td>
</tr>
<tr>
<td>CMOVS</td>
<td>带符号（负）</td>
<td>SF=1</td>
</tr>
<tr>
<td>CMOVNS</td>
<td>无符号（非负）</td>
<td>SF=0</td>
</tr>
</tbody></table>
<p>G 大于 L小于 E等于 N不是 O溢出 S 带符号</p>
<h3 id="CMOV示例程序"><a href="#CMOV示例程序" class="headerlink" title="CMOV示例程序"></a>CMOV示例程序</h3><p>查找最大值：</p>
<pre><code class="hljs assembly">.section data
output:
.asciz &quot;The larget value is %d\n&quot;
values:
.int 105,235,61,315,134,221,53,145,117,5

.section text
.globl _start
&#96;_start:
  nop
  movl values， %ebx
  movl $1, %edi
loop:
  movl values(, %edi, 4), %eax
  cmp %ebx, %eax
  cmova %eax, %ebx
  inc %edi
  cmp $10, %edi
  jne loop
  pushl %ebx
  pushl $output
  call printf
  addl $8, %esp
  pushl $0
  call exit</code></pre>

<p><strong>cmp指令是拿第二个操作数减去第一个操作数，这个点一定要注意。</strong>当%eax&gt;%ebx时，不借位，即CF=0。</p>
<h3 id="交换指令-XCHG-CMPXCHG-CMPXCHG8B等"><a href="#交换指令-XCHG-CMPXCHG-CMPXCHG8B等" class="headerlink" title="交换指令 XCHG CMPXCHG CMPXCHG8B等"></a>交换指令 XCHG CMPXCHG CMPXCHG8B等</h3><table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>XCHG</td>
<td>在<strong>两个寄存器之间</strong>或者<strong>寄存器和内存之间</strong>就交换数据</td>
</tr>
<tr>
<td>BSWAP</td>
<td>反转一个32位寄存器中的字节顺序</td>
</tr>
<tr>
<td>XADD</td>
<td>交换两个值并把总和存储在目标操作数中</td>
</tr>
<tr>
<td>CMPXCHG</td>
<td>把一个值和一个外部值进行比较，并且交换它和另一个值</td>
</tr>
<tr>
<td>CMPXCHG8B</td>
<td>比较两个64位值并交换他们</td>
</tr>
</tbody></table>
<h4 id="XCHG-使用要点"><a href="#XCHG-使用要点" class="headerlink" title="XCHG 使用要点"></a>XCHG 使用要点</h4><ol>
<li>XCHG operand1  operand2，  <strong>operand1 operand 不能同时是内存地址</strong>,两个操作数可以是8 16 32位，但是两个操作数长度需要相同。</li>
<li>当一个操作数是内存位置时，处理器的LOCK信号被自动标明，防止在交换过程中任何其他处理器访问这个位置。LOCK处理是非常耗时的。</li>
</ol>
<p>冒泡排序case：</p>
<pre><code class="hljs assembly">.section .data
values:
  .int 105, 235, 61, 315, 134, 221, 53, 145, 117, 5


.section .text
.globl _start
_start:
  movl $values, %esi
  movl $9, %ecx
  movl $9, %ebx
loop:
  movl (%esi), %eax
  cmp %eax, 4(%esi)
  jge skip
  xchg %eax, 4(%esi)
  movl %eax, (%esi)
skip:
  add $4, %esi
  dec %ebx
  jnz loop
  dec %ecx
  jz end
  
  movl $values, %esi
  movl %ecx, %ebx
  jmp loop
end:
  movl $1, %eax
  movl $0, %ebx
  int $0x80</code></pre>



<h4 id="CMPXCHG-使用要点"><a href="#CMPXCHG-使用要点" class="headerlink" title="CMPXCHG 使用要点"></a>CMPXCHG 使用要点</h4><ol>
<li>cmpxchg指令<strong>比较目标操作数和EAX、AX、AL寄存器中的值</strong>，如果两个值相等，就把源操作数值加载到目标操作数中。如果不等，就把目标操作数值加载到EAX、AX、AL寄存器中。格式是：cmpxchg source, destination</li>
<li>如果是操作8字节的，请使用CMPXCHG8B</li>
</ol>
<h3 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h3><p>相关指令</p>
<ul>
<li>压栈：pushx source<ul>
<li>x 支持 l(32位) w(16位)</li>
<li>source数据元素支持:<ul>
<li>16位/32位寄存器</li>
<li>16位/32位内存值</li>
<li>16位段寄存器</li>
<li>8位/16位/32位立即数</li>
</ul>
</li>
</ul>
</li>
<li>出栈：popx destination<ul>
<li>destination接收的数据元素支持：<ul>
<li>16位/32位寄存器</li>
<li>16位段寄存器</li>
<li>16位/32位内存地址</li>
</ul>
</li>
</ul>
</li>
<li>压入和弹出所有寄存器<ul>
<li>pusha和popa （16位） pushad和popad （32位）</li>
<li>压入寄存器顺序：DI  SI BP  BX  DX CX AX</li>
<li>pushf和popf EFLAGS的低16位    pushfd和popfd EFLAGS的32位</li>
</ul>
</li>
<li><strong>push和pop不是把数据压入和弹出堆栈的唯一途径，我们也可以手动修改ESP寄存器作为内存指针，手工地把数据存放到内存中</strong>。通常做法是：很多程序是把ESP寄存器的值复制到EBP寄存器，而不是使用ESP寄存器本身。在汇编语言函数中经常使用EBP指针指向函数的工作堆栈空间基址。访问存储在堆栈中参数的指令<strong>相对于EBP值引用这些参数</strong>。</li>
</ul>
<h3 id="优化内存访问"><a href="#优化内存访问" class="headerlink" title="优化内存访问"></a>优化内存访问</h3><p>内存访问是处理器执行最慢的功能之一，奔腾4缓存块长度是64位，如果定义的元素超过64位块的边界，就必须用两次缓存操作才能获取或者存储内存中的数据元素，为了解决这个问题，intel建议：</p>
<ul>
<li>按照16字节边界对准16位数据</li>
<li>对准32位数据使它的基址是4的倍数</li>
<li>对准64位数据使它的基址是8的倍数</li>
<li>避免很多小的数据传输，而是用单一的大型数据传输</li>
<li>避免在堆栈中使用大的数据长度（比如80位和128位浮点值）</li>
</ul>
<p>gas汇编器支持.align命令用于在特定的内存边界对准定义的数据元素。</p>
<h2 id="控制流程"><a href="#控制流程" class="headerlink" title="控制流程"></a>控制流程</h2><h3 id="指令指针"><a href="#指令指针" class="headerlink" title="指令指针"></a>指令指针</h3><p>指令指针是确定程序中的哪一条指令是应该执行的下一条指令。</p>
<p>指令长度可能是多个字节，所以指向下一条指令的不仅仅是每次使指令指针递增1。</p>
<p>程序不能直接使用mov指令修改EIP寄存器的值。但是分支指令可以改动EIP寄存器的值。</p>
<h3 id="无条件分支"><a href="#无条件分支" class="headerlink" title="无条件分支"></a>无条件分支</h3><p>无条件分支有3种：</p>
<ul>
<li>跳转<ul>
<li>jmp location</li>
<li>location指要跳转的内存地址。</li>
</ul>
</li>
<li>中断<ul>
<li>中断分为软中断、硬中断。</li>
<li>使用带有0x80值的INT指令把控制转移给linux系统调用程序。</li>
<li>中断发生时，按照EAX寄存器的值执行子函数。如：在调用linux系统调用exit函数之前，把值1放到eax寄存器中。1是系统调用编号。 具体查看系统调用编号的办法参见《使用系统调》用这个部分。</li>
</ul>
</li>
<li>调用<ul>
<li>call address   address操作数引用程序中的标签，它被转换为函数中的第一条指令的内存地址。</li>
<li>调用完成后要跟返回指令  ret</li>
</ul>
</li>
</ul>
<h3 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h3><p>条件分支指令：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
<th>EFLAGS状态位</th>
</tr>
</thead>
<tbody><tr>
<td>JA</td>
<td>Jump if above</td>
<td>CF=0 and ZF=0</td>
</tr>
<tr>
<td>JAE</td>
<td>Jump if above or equal</td>
<td>CF=0</td>
</tr>
<tr>
<td>JB</td>
<td>Jump if below</td>
<td>CF=1</td>
</tr>
<tr>
<td>JBE Jump</td>
<td>if below or equal</td>
<td>CF=1 or ZF=1</td>
</tr>
<tr>
<td>JC</td>
<td>Jump if carry</td>
<td>CF=1</td>
</tr>
<tr>
<td>JCXZ</td>
<td>Jump if CX register is 0</td>
<td></td>
</tr>
<tr>
<td>JECXZ</td>
<td>Jump if ECX register is 0</td>
<td></td>
</tr>
<tr>
<td>JE</td>
<td>Jump if equal</td>
<td>ZF=1</td>
</tr>
<tr>
<td>JG</td>
<td>Jump if greater</td>
<td>ZF=0 and SF=OF</td>
</tr>
<tr>
<td>JGE</td>
<td>Jump if greater or equal</td>
<td>SF=OF</td>
</tr>
<tr>
<td>JL</td>
<td>Jump if less</td>
<td>SF&lt;&gt;OF</td>
</tr>
<tr>
<td>JLE</td>
<td>Jump if less or equal</td>
<td>ZF=1 or SF&lt;&gt;OF</td>
</tr>
<tr>
<td>JNA</td>
<td>Jump if not above</td>
<td>CF=1 or ZF=1</td>
</tr>
<tr>
<td>JNAE</td>
<td>Jump if not above or equal</td>
<td>CF=1</td>
</tr>
<tr>
<td>JNB</td>
<td>Jump if not below</td>
<td>CF=0</td>
</tr>
<tr>
<td>JNBE</td>
<td>Jump if not below or equal</td>
<td>CF=0 and ZF=0</td>
</tr>
<tr>
<td>JNC</td>
<td>Jump if not carry</td>
<td>CF=0</td>
</tr>
<tr>
<td>JNE</td>
<td>Jump if not equal</td>
<td>ZF=0</td>
</tr>
<tr>
<td>JNG</td>
<td>Jump if not greater</td>
<td>ZF=1 or SF&lt;&gt;OF</td>
</tr>
<tr>
<td>JNGE</td>
<td>Jump if not greater or equal</td>
<td>SF&lt;&gt;OF</td>
</tr>
<tr>
<td>JNL</td>
<td>Jump if not less</td>
<td>SF=OF</td>
</tr>
<tr>
<td>JNLE</td>
<td>Jump if not less or equal</td>
<td>ZF=0 and SF=OF</td>
</tr>
<tr>
<td>JNO</td>
<td>Jump if not overflow</td>
<td>OF=0</td>
</tr>
<tr>
<td>JNP</td>
<td>Jump if not parity</td>
<td>PF=0</td>
</tr>
<tr>
<td>JNS</td>
<td>Jump if not sign</td>
<td>SF=0</td>
</tr>
<tr>
<td>JNZ</td>
<td>Jump if not zero</td>
<td>ZF=0</td>
</tr>
<tr>
<td>JO</td>
<td>Jump if overflow</td>
<td>OF=1</td>
</tr>
<tr>
<td>JP</td>
<td>Jump if parity</td>
<td>PF=1</td>
</tr>
<tr>
<td>JPE</td>
<td>Jump if parity even</td>
<td>PF=1</td>
</tr>
<tr>
<td>JPO</td>
<td>Jump if parity odd</td>
<td>PF=0</td>
</tr>
<tr>
<td>JS</td>
<td>Jump if sign</td>
<td>SF=1</td>
</tr>
<tr>
<td>JZ</td>
<td>Jump if zero</td>
<td>ZF=1</td>
</tr>
</tbody></table>
<p><strong>对于计算无符号整数值时使用带有above、below关键字的指令。</strong></p>
<p><strong>对于计算有符号整数值时使用带有grater、less关键字的指令。</strong></p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><h4 id="CMP指令"><a href="#CMP指令" class="headerlink" title="CMP指令"></a>CMP指令</h4><ul>
<li>CMP指令格式是： cmp operand1, operand2    CMP指令是把第二个操作数和第一个操作数比较，背后是operand2-operand1，进而设置EFLAGS寄存器。 再配合上面的条件分支完成跳转。</li>
</ul>
<h4 id="专门设置进位标志的指令"><a href="#专门设置进位标志的指令" class="headerlink" title="专门设置进位标志的指令"></a>专门设置进位标志的指令</h4><p>除了cmp可以设置进位标志，也有专门的指令可以设置进位标注：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>CLC</td>
<td>Clear the carry flag (set it to zero)</td>
</tr>
<tr>
<td>CMC</td>
<td>Complement the carry flag (change it to the opposite of what is set)</td>
</tr>
<tr>
<td>STC</td>
<td>Set the carry flag (set it to one)</td>
</tr>
</tbody></table>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>循环指令：</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LOOP</td>
<td>Loop until the ECX register is zero</td>
</tr>
<tr>
<td>LOOPE/LOOPZ</td>
<td>Loop until either the ECX register is zero, or the ZF flag is not set</td>
</tr>
<tr>
<td>LOOPNE/LOOPNZ</td>
<td>Loop until either the ECX register is zero, or the ZF flag is set</td>
</tr>
</tbody></table>
<p>循环开始前，需要设置ECX寄存器的值，用于表示循环的次数，大致模板是：</p>
<pre><code class="hljs assembly">  mov $100, %ecx
loop1:
  loop loop1</code></pre>



<h2 id="数字与数学运算"><a href="#数字与数学运算" class="headerlink" title="数字与数学运算"></a>数字与数学运算</h2><h3 id="长度小的数传送给长度大的数"><a href="#长度小的数传送给长度大的数" class="headerlink" title="长度小的数传送给长度大的数"></a>长度小的数传送给长度大的数</h3><p>movzx source, destination 这条指令把长度小的无符号整数值（可以是寄存器，可以是内存值）传送给长度大的无符号整数值（智能是寄存器）。 source可以是8/16位，destination可以是16/32位。</p>
<p>movsx  与movzx类似，但是他解决的是<strong>传送有符号整数</strong>，比如-1，传送后要正确的为这个值设置高位为1（高位设置1表示负数）。</p>
<h3 id="四字带符号整数"><a href="#四字带符号整数" class="headerlink" title="四字带符号整数"></a>四字带符号整数</h3><p>.int .short .long 命令定义的带符号整数是双字的，<strong>用.quad命令可以创建四字的带符号整数（每个值8个字节）</strong>。</p>
<h3 id="MMX整数"><a href="#MMX整数" class="headerlink" title="MMX整数"></a>MMX整数</h3><ul>
<li><strong>一个MMX寄存器是64位</strong>的。  那么<strong>一个MMX寄存器里面就可以放多个整数（可以理解成一个数组），具体多少个，要看放的是字节整数，还是字整数，还是双字整数</strong>。详细的参见下面。</li>
<li>MMX整数包括<ul>
<li>64位打包字节整数 - 8个8位的字节整数</li>
<li>64位打包字整数 - 4个16位字整数</li>
<li>64位打包双字整数 - 2个32位双字整数。</li>
</ul>
</li>
<li>传送MMX整数：movq     操作mmx寄存器、sse寄存器或者64位内存地址（但是不能在内存位置之间传送mmx整数）。</li>
</ul>
<h3 id="SSE整数"><a href="#SSE整数" class="headerlink" title="SSE整数"></a>SSE整数</h3><ul>
<li>与MMX类似，只是SSE使用的是128位XMM寄存器（XMM与MMX很像，但是不同），因为长度扩大一倍，里面放置的数量也多一倍。比如可以放16个位的字节整数。</li>
<li>传送SSE整数：movdqa movdqu  (对齐16个字节边界的数据用A选项，否则用U选项)</li>
</ul>
<h3 id="传送浮点值"><a href="#传送浮点值" class="headerlink" title="传送浮点值"></a>传送浮点值</h3><ul>
<li>fld指令用于把浮点值传送如何传送出FPU寄存器。  格式是   fld  source</li>
</ul>
<p>IA-32指令集也提供一些预置浮点值，可以直接用指令把他们加载到FPU寄存器堆栈中。</p>
<table>
<thead>
<tr>
<th>指令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FLD1</td>
<td>Push +1.0 into the FPU stack</td>
</tr>
<tr>
<td>FLDL2T</td>
<td>Push log(base 2) 10 onto the FPU stack</td>
</tr>
<tr>
<td>FLDL2E</td>
<td>Push log(base 2) e onto the FPU stack</td>
</tr>
<tr>
<td>FLDPI</td>
<td>Push the value of pi onto the FPU stack</td>
</tr>
<tr>
<td>FLDLG2</td>
<td>Push log(base 10) 2 onto the FPU stack</td>
</tr>
<tr>
<td>FLDLN2</td>
<td>Push log(base e) 2 onto the FPU stack</td>
</tr>
<tr>
<td>FLDZ</td>
<td>Push +0.0 onto the FPU stack</td>
</tr>
</tbody></table>
<h3 id="长度小的打包数传送-转换给长度大的打包数"><a href="#长度小的打包数传送-转换给长度大的打包数" class="headerlink" title="长度小的打包数传送/转换给长度大的打包数"></a>长度小的打包数传送/转换给长度大的打包数</h3><p>movaps/movups/movss/movlps/movhps/movlhps/movhlps/movapd/movupd/movsd/movhpd/movlpd</p>
<p>cvtdq2pd/cvtdq2ps/cvtpd2da/CVTPD2PI/CVTPD2PS/CVTPI2PD/CVTPI2PS/CVTPS2DQ/CVTPS2PD/CVTPS2PI/CVTTPD2PI/CVTTPD2DQ/CVTTPS2DQ/CVTTPS2PI</p>
<h3 id="基本数学功能"><a href="#基本数学功能" class="headerlink" title="基本数学功能"></a>基本数学功能</h3><h4 id="简单加法（32位以内）"><a href="#简单加法（32位以内）" class="headerlink" title="简单加法（32位以内）"></a>简单加法（32位以内）</h4><p>add source destination  不能同时使用内存地址作为源和目标操作数。 结果存放在目标位置。 addb  addw addl  操作不同长度</p>
<p>adc source destination</p>
<h4 id="大数加法（超过32位）"><a href="#大数加法（超过32位）" class="headerlink" title="大数加法（超过32位）"></a>大数加法（超过32位）</h4><p>超过32位（且小于64位）的数字，要用两个32位的寄存器组合保存。 <strong>adc指令能将上一条add指令产生的进位自动加入这次运算</strong>，无需使用判断指令判断溢出寄存器后再操作。</p>
<p>adc示例程序：</p>
<pre><code class="hljs assembly">.section .data
data1:
    .quad 7252051615
data2:
    .quad 5732348928
output:
    .asciz &quot;The result is %qd\n&quot;
.section .text
.globl _start
_start:
    movl data1, %ebx
    movl data1+4, %eax
    movl data2, %edx
    movl data2+4, %ecx
    addl %ebx, %edx
    adcl %eax, %ecx
    pushl %ecx
    pushl %edx
    push $output
    call printf
    addl $12, %esp
    pushl $0
    call exit</code></pre>

<p>%qd 显示64位带符号整数值</p>
<p>adcl 紧接在addl后面  addl产生的进位被adcl透明处理</p>
<h4 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h4><p>sub   同add用法类似</p>
<p>sbb  同adc用法类似</p>
<h4 id="递增和递减"><a href="#递增和递减" class="headerlink" title="递增和递减"></a>递增和递减</h4><p>dec destination</p>
<p>inc destination</p>
<p>两条指令可以用于递增和递减，<strong>注意这两条指令用于无符号整数</strong>。</p>
<h4 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h4><p>mul source 无符号整数乘法</p>
<p><strong>乘法指令的目标操作数约定放在EAX、AX、AL中</strong>，具体到哪个，目标操作数和结果目标位置有点复杂：</p>
<ul>
<li>根据长度确定到哪个</li>
<li>由于乘法会产生很大的值，所以目标位置必须是源操作数的两倍长度。源值是8位，那么目标寄存器是AX。</li>
<li>但是当源值是16位时，目标寄存器却不是EAX，为了兼容，intel使用DX:AX寄存器对保存32位乘法结果值。</li>
<li>对于32位的源值，目标位置使用64位EDX:EAX寄存器对。</li>
</ul>
<p>总结：</p>
<table>
<thead>
<tr>
<th>源操作数长度</th>
<th>目标操作数</th>
<th>结果目标位置</th>
</tr>
</thead>
<tbody><tr>
<td>8位</td>
<td>AL</td>
<td>AX</td>
</tr>
<tr>
<td>16位</td>
<td>AX</td>
<td>DX:AX</td>
</tr>
<tr>
<td>32位</td>
<td>EAX</td>
<td>EDX:EAX(中文版有错，英文版本正确)</td>
</tr>
</tbody></table>
<p>示例程序：</p>
<pre><code class="hljs assembly">.section .data
data1:
    .int 315814
data2:
    .int 165432
result:
    .quad 0
output:
    .asciz &quot;The result is %qd\n&quot;
.section .text
.globl _start
_start:
    nop
    movl data1, %eax
    mull data2
    movl %eax, result
    movl %edx, result+4
    pushl %edx
    pushl %eax
    pushl $output
    call printf
    add $12, %esp
    pushl $0
    call exit</code></pre>

<p>mul用于无符号整数，imul用于带符号整数。</p>
<h4 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h4><p>div  divisor </p>
<p>divisor是除数，被除数是隐含的。 执行指令之前需要被将被除数放置到指定寄存器。</p>
<p>不同长度的被除数放置的寄存器略有差别：</p>
<ul>
<li>16位  AX寄存器</li>
<li>32位  DX:AX寄存器</li>
<li>64位 EDX:EAX寄存器</li>
</ul>
<p>被除数的长度和除数的长度一一搭配，64位被除数搭配32位除数，32位被除数搭配16位除数，16位被除数搭配8位除数。</p>
<p>除法的结果是两个单独的数字：商和余数。这两个值被存储在和被除数值使用的相同的寄存器中。</p>
<table>
<thead>
<tr>
<th>被除数寄存器</th>
<th>被除数长度</th>
<th>商寄存器</th>
<th>余数寄存器</th>
</tr>
</thead>
<tbody><tr>
<td>AX</td>
<td>16位</td>
<td>AL</td>
<td>AH</td>
</tr>
<tr>
<td>DX:AX</td>
<td>32位</td>
<td>AX</td>
<td>DX</td>
</tr>
<tr>
<td>EDX:EAX</td>
<td>64位</td>
<td>EAX</td>
<td>EDX</td>
</tr>
</tbody></table>
<p>idiv指令用法同div，只是他用在带符号的除法上。</p>
<h4 id="移位乘法-左移"><a href="#移位乘法-左移" class="headerlink" title="移位乘法 左移"></a>移位乘法 左移</h4><p>sal 向左算术移位</p>
<p>shl 向左逻辑移位 </p>
<p>两个指令用法相同</p>
<p>3种不同的使用格式：</p>
<p>sal destoination         // dest向左移一位，相当于x2</p>
<p>sal %cl, destination    // dest向左移cl寄存器中的值的位数</p>
<p>sal shifter, destination // dest向左移shifter值的位数</p>
<p>sal也是在其其结尾加上一个字符表示目标值的长度。比如sall</p>
<h4 id="移位除法-右移"><a href="#移位除法-右移" class="headerlink" title="移位除法 右移"></a>移位除法 右移</h4><p>shr       用于无符号整数</p>
<p>sar       可以用于有符号整数</p>
<h4 id="逻辑操作"><a href="#逻辑操作" class="headerlink" title="逻辑操作"></a>逻辑操作</h4><p>and or    xor  not</p>
<p>and  or  xor 使用格式相同</p>
<p>and source, destination</p>
<p>not指令使用单一操作数，既是源值也是目标结果位置。 </p>
<h4 id="位测试"><a href="#位测试" class="headerlink" title="位测试"></a>位测试</h4><p>有时候我们需要测试某个寄存器的某一位是否被设置了1。比如检查EFLAGS寄存器。</p>
<p>test指令被设计用来做此用途，其背后是执行and操作但是与and不同的<strong>特点在于其不修改目标值</strong>。</p>
<p>测试完了之后配合jnz使用</p>
<p>test $0x00200000, %eax</p>
<p>jnz cpuid</p>
<h3 id="使用FPU操作浮点数"><a href="#使用FPU操作浮点数" class="headerlink" title="使用FPU操作浮点数"></a>使用FPU操作浮点数</h3><h4 id="FPU基本概念"><a href="#FPU基本概念" class="headerlink" title="FPU基本概念"></a>FPU基本概念</h4><p>FPU包括8个80位的数据寄存器和3个16位寄存器，称为控制(control)、状态(status)和标记(tag)寄存器。</p>
<p>FPU的8个寄存器称为R0~R7,但是程序编写时不这么使用，FPU操作标准寄存器是把他连在一起连成一个堆栈，而且这个堆栈不太同于内存堆栈，他是循环使用，即最后一个连着第一个。</p>
<p>堆栈顶部的寄存器是st0，其余的是st1~st7。</p>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><pre><code class="hljs assembly">.section .data

value1:
    .int 40

value2:
   .float 92.4405

value3:
  .double 221.440321

.section bss
    .lcomm int1, 4
    .lcomm control, 2
    .lcomm status, 2
    .lcomm result, 2

.section text

.globl _start
_start:
    nop
    finit  &#x2F;&#x2F; 初始化FPU
    fstcw control &#x2F;&#x2F; 复制fpu的控制寄存器到内存
    fstsw status  &#x2F;&#x2F; 复制fpu的状态寄存器到内存
    filds value1 &#x2F;&#x2F; filds把一个双字整数值加载到fp寄存器中
   fists int1  &#x2F;&#x2F; fists获取fpu堆栈顶部的值（value1）赋值给相应位置（int1）
   flds value2 &#x2F;&#x2F; 加载单精度浮点数值  float
   fldl value3  &#x2F;&#x2F;  加载双精度浮点数值 double
   fst %st(4)   &#x2F;&#x2F; fst指令用于把st0寄存器的数据传送到另一个FPU寄存器（st4）
   fxch %st(1)   &#x2F;&#x2F; fxch指令用于交换st0寄存器和另一个FPU寄存器（st1）
   fstps result &#x2F;&#x2F; fstp指令复制fpu寄存器ST0中值到内存位置，之后把值从FPU寄存器堆栈中弹出。
   movl $1, %eax
   movl $0, %ebx
   int $0x80</code></pre>



<h4 id="基本浮点运算"><a href="#基本浮点运算" class="headerlink" title="基本浮点运算"></a>基本浮点运算</h4><p>fadd   浮点数加法</p>
<p>fdiv   浮点数除法</p>
<p>fdivr   反向浮点数除法  （反向是指目标值减去源值，并且结果存在目标操作数位置， 反向除法类似）</p>
<p>fmul   浮点数乘法</p>
<p>fsub   浮点数减法</p>
<p>fsubr   反向浮点数减法</p>
<p>fadd source // 内存中的source位置值与st0寄存器相加</p>
<p>fadd %st(x), %st(0)  // stx中的值与st0值相加，结果存在st0</p>
<p>fadd %st(0), %st(x)  // st0中的值与stx值相加，结果存在stx</p>
<p>faddp %st(0), %st(x)  // st0中的值与stx值相加，结果存在stx，并且弹出st0</p>
<p>faddp  // st0中的值与st1值相加，结果存在st1，并且弹出st0</p>
<h4 id="进阶浮点计算"><a href="#进阶浮点计算" class="headerlink" title="进阶浮点计算"></a>进阶浮点计算</h4><p>F2XM1 Computes 2 to the power of the value in ST0, minus 1</p>
<p>FABS Computes the absolute value of the value in ST0</p>
<p>FCHS Changes the sign of the value in ST0</p>
<p>FCOS Computes the cosine of the value in ST0</p>
<p>FPATAN Computes the partial arctangent of the value in ST0</p>
<p>FPREM Computes the partial remainders from dividing the value in ST0 by</p>
<p>the value in ST1</p>
<p>FPREM1 Computes the IEEE partial remainders from dividing the value in</p>
<p>ST0 by the value in ST1</p>
<p>FPTAN Computes the partial tangent of the value in ST0</p>
<p>FRNDINT Rounds the value in ST0 to the nearest integer</p>
<p>FSCALE Computes ST0 to the ST1st power</p>
<p>FSIN Computes the sine of the value in ST0</p>
<p>FSINCOS Computes both the sine and cosine of the value in ST0</p>
<p>FSQRT Computes the square root of the value in ST0</p>
<p>FYL2X Computes the value ST1 * log ST0 (base 2 log)</p>
<p>FYL2XP1 Computes the value ST1 * log (ST0 + 1) (base 2 log)</p>
<h2 id="处理字符串"><a href="#处理字符串" class="headerlink" title="处理字符串"></a>处理字符串</h2><h3 id="movs-CLD-STD-LEA-移动字符并自增移动光标"><a href="#movs-CLD-STD-LEA-移动字符并自增移动光标" class="headerlink" title="movs CLD STD LEA 移动字符并自增移动光标"></a>movs CLD STD LEA 移动字符并自增移动光标</h3><p>movs 把字符串从内存的一个位置传送到另一个位置。其目标操作数和源操作数都是隐含的。</p>
<p>源操作数的是ESI寄存器，其中放置的是要移动的字符串的内存地址。（source ）</p>
<p>目标操作数的是EDI寄存器，其中放置的是字符串要复制到的目的地内存地址。(destination)</p>
<p><strong>而且每次执行完movs后，EDI、ESI都会自动递增</strong>（有时也会递减，<strong>递增还是递减取决于EFLAGS寄存器中DF标志是否被清零</strong>），这样多次执行movs指令时，后面的字符开可以接着被mov。</p>
<p>为了达成DF被设置正确的值，也就是不断mov的字符串来自哪个方向（不断递增就是往右，不断递减就是往左），。可以用以下命令达成：</p>
<ul>
<li>CLD指令用于清零DF标志</li>
<li>STD用于设置DF标志</li>
</ul>
<p>除此之外，还有个LEA指令，用于把变量的内存地址送给寄存器，跟mov略有区别：</p>
<p>movl $output, %edi</p>
<p>lea output, %edi  // 少了一个$</p>
<h3 id="REP-重复执行传送字符串"><a href="#REP-重复执行传送字符串" class="headerlink" title="REP 重复执行传送字符串"></a>REP 重复执行传送字符串</h3><p><strong>rep与movsb一起使用，重复的每次传送1字节字符到另一个位置，直至ECX寄存器中值为。</strong></p>
<pre><code class="hljs assembly">.section .data
value1:
	.ascii &quot;This is a test string.\n&quot;

.section .bss
    .lcomm output, 23
.section .text
.globl _start
_start：
  nop
  leal value1, %esi
  leal output, %edi
  movl $23, %ecx
  cld
  rep movsb
  
  movl $1, %eax
  movl $0, %ebx
  int $0x80</code></pre>

<p>但是rep 如果配合movsl使用，那么要先用movsl传送，剩下的零头还是要用movsb传送。如果全用movsl传送，零头部分会发生错误。</p>
<pre><code class="hljs assembly">.section .data
string1:
	.asciz &quot;This is a test of the conversion program!\n&quot;
legth:
  .int 43
divisor:
  .int 4
.section .bss
    .lcomm buffer, 43
.section .text
.globl _start
_start：
  nop
  leal string1, %esi
  leal buffer, %edi
  movl length, %ecx
  shrl $2, %ecx  &#x2F;&#x2F; 除以4
  cld
  rep movsl
  
  movl length, %ecx
  andl $3, ecx  &#x2F;&#x2F; 相当于对4取模  相当于取余数
  rep movsb
  
  movl $1, %eax
  movl $0, %ebx
  int $0x80</code></pre>

<p>REP还有些类似指令：</p>
<p>REPE 等于时重复 </p>
<p>REPNE  不等于时重复</p>
<h3 id="LODS-STOS-存储和加载字符串"><a href="#LODS-STOS-存储和加载字符串" class="headerlink" title="LODS STOS 存储和加载字符串"></a>LODS STOS 存储和加载字符串</h3><p>LODS  用于把内存中的字符串值传送到EAX寄存器。</p>
<p>LODS指令使用ESI寄存器作为隐含源操作数。ESI必须要包含要操作的字符串所在的内存地址。</p>
<p>LODS指令按照加载的数据的数量递增或者递减ESI寄存器。</p>
<p>STOS SCAS都会利用EAX寄存器。</p>
<p>虽然能用REP指令配合LODS使用，但是实际意义不大，因为EAX只能放4个字节。</p>
<p><strong>STOS 是将寄存器中的字符传送到内存，配合REP使用，可以用在用0填充一段内存等场景</strong></p>
<h3 id="CMPS-比较字符串"><a href="#CMPS-比较字符串" class="headerlink" title="CMPS 比较字符串"></a>CMPS 比较字符串</h3><p>与前面的指令一样，隐含的源操作数是ESI，隐含的目标操作数是EDI。</p>
<p>CMPS会从源字符串减去目标字符串，并且适当地设置EFLAGS的标志位。</p>
<p>CMPS可以配合JE使用实现判断跳转。</p>
<p>CMPS也可以配合REP使用跨越多个字符比较。但是REP只关心ECX中的计数值。这个问题可以用REPE、REPNE、REPZ、REPNZ</p>
<p>比较规则是：</p>
<p>长度相同时，按ascii码表顺序（即字典顺序）。大写字母小于小写字母。</p>
<p>长度不同时：</p>
<p><strong>按照长度短的为准进行比较。但是有个特例，就是短字符串与等于长字符串中相同长度的字符时，那么长字符串大。</strong>    </p>
<h3 id="SCAS扫描字符串"><a href="#SCAS扫描字符串" class="headerlink" title="SCAS扫描字符串"></a>SCAS扫描字符串</h3><p>SCAS指令用于扫描字符串搜索一个或者多个字符。</p>
<p>SCAS的隐含的目标操作数是EDI寄存器。EDI寄存器中存放的是要扫描的目标字符串的内存地址。</p>
<p>SCAS的要扫描字符存放在EAX/AX/AL寄存器中。</p>
<p>SCAS同样后接长度字符形成：SCASB，SCASW，SCASL</p>
<p>SCAS与REPNE、REPE一起使用方便性就能体现出来了。<strong>注意：指令的语义是相反的，REPNE是指扫描到特定字符串时停止。</strong></p>
<p>当找到字符串时，EDI寄存器包含紧跟在定位到的字符串后面的内存地址。这是因为REPNE指令指定SCAS指令时是递增EDI寄存器。ECX寄存器包含搜索字符距离字符串末尾的位置。为了得到距离字符串开头的位置，需要用这个值减去字符串的长度并且反转符号。</p>
<p><strong>SCAS通过扫描字符串的结尾来确定字符串的长度。</strong></p>
<h2 id="使用函数"><a href="#使用函数" class="headerlink" title="使用函数"></a>使用函数</h2><h3 id="使用c库函数示例"><a href="#使用c库函数示例" class="headerlink" title="使用c库函数示例"></a>使用c库函数示例</h3><p>改造cpuid程序用printf函数输出：</p>
<pre><code class="hljs assembly">.section .data
output:
   .asciz &quot;The processor Vendor ID is &#39;%s&#39;\n&quot;

.section .bss
    .lcomm buffer, 12

.section .text
.globl _start
_start:
    movl $0, %eax
    cpuid
    movl $output, %edi
    movl %ebx, 28(%edi)
    movl %edx, 32(%edi)
    movl %ecx, 36(%edi)
    # 把参数传递给函数printf通过压栈完成， 压栈顺序与函数参数声明顺序相反
    pushl $buffer
    pushl $output
    call printf
    
    # addl指令用于清空为printf函数在栈中准备的参数
    addl $8, %esp
    
    # 给函数exit压栈参数
    pushl $0
    call exit
    #</code></pre>

<p>注意此处使用的是 <strong>.asciz 命令,不同于.ascii。.asciz命令会在声明的字符串末尾添加空字符</strong>。此处使用 .asciz是为了配合printf函数使用，printf函要求以空字符结尾的字符串作为输出字符串。</p>
<p><strong>.lcomm 命令用于定义缓冲区，声明在.bss段。</strong></p>
<p><strong>把参数传递给函数printf通过pushl压栈完成， 压栈顺序与函数参数声明顺序相反</strong></p>
<p>*<em>在汇编语言中使用c库函数时，必须把c库文件连接到程序的目标代码。标准的c动态库位于libc.so.x文件中，包括printf和exit函数。为了连接标准的c动态库，使用连接器的-l参数。注意连接时库名称规则：libc.so.x对应的库名称就是c，其余的都是固定格式。    *</em></p>
<p>*<em>ld -dynamic-linker /lib/ld-linux.so.2 -o cpuid2 -lc cpuid2.o 。 *</em></p>
<p><strong>连接时不仅仅要指定依赖的库，还要指定在运行时加载动态库的程序，对于linux来说ld-linux.so.2便是。</strong></p>
<p><strong>也直接用gcc编译，这样不用指定动态库加载器和链接动态库，gcc自动连接正确的c库函数，但是要将_start标签改为main标签。gcc -o cpuid2 cpuid2.s</strong></p>
<p><strong>c库函数的文档在man页第三部分</strong>：</p>
<p>man 3 exit</p>
<h3 id="汇编函数定义与访问"><a href="#汇编函数定义与访问" class="headerlink" title="汇编函数定义与访问"></a>汇编函数定义与访问</h3><p>定义的基本模板：</p>
<pre><code class="hljs assembly">.type area, @function
area:
    xxx
    
    ret
 
call area</code></pre>

<p>.type指令定义函数。</p>
<p>函数的结束由RET指令定义。</p>
<p>call指令用来访问（调用）函数。</p>
<p>函数的放置：汇编函数的定义可以放在调用的前面，也可以放在后面。</p>
<h3 id="函数参数传递"><a href="#函数参数传递" class="headerlink" title="函数参数传递"></a>函数参数传递</h3><p>参数的传递有三种方式：</p>
<ul>
<li>使用寄存器，比如eax，函数通过对eax的取值完成数据的获取，调用方通过给eax送值完成参数的传送。</li>
<li>使用全局数据，比如在.section .bss中定义了 .lcomm radius, 4   这样子函数中直接使用radius变量。</li>
<li>使用堆栈</li>
</ul>
<h3 id="堆栈与局部变量"><a href="#堆栈与局部变量" class="headerlink" title="堆栈与局部变量"></a>堆栈与局部变量</h3><h4 id="堆栈的结构（含局部变量）"><a href="#堆栈的结构（含局部变量）" class="headerlink" title="堆栈的结构（含局部变量）"></a>堆栈的结构（含局部变量）</h4><p>图1—–刚刚发起函数调用时刻，堆栈的整体布局是（注意此时用<strong>ESP</strong>相对寻址）：</p>
<pre><code class="hljs plain">+---------------------+
|                     |
+---------------------+
|                     |
+---------------------+
|                     |
+---------------------+
| function argument3  | 12(%esp)
+---------------------+
| function argument2  | 8(%esp)
+---------------------+
| function argument1  |  4(%esp)
+---------------------+
| return adress       |  (%esp)
+---------------------+</code></pre>

<p>图2—–执行到函数内部时（用了常用操作堆栈的模板代码，参见下面代码），堆栈的整体布局是（注意此时用<strong>EBP</strong>相对寻址）：</p>
<pre><code class="hljs plain">+---------------------+
|                     |
+---------------------+
|                     |
+---------------------+
|                     |
+---------------------+
| function argument3  | 16(%ebp)
+---------------------+
| function argument2  | 12(%ebp)
+---------------------+
| function argument1  |  8(%ebp)
+---------------------+
| return adress       |  4(%ebp)
+---------------------+
| old EBP value       |   (%ebp)
+---------------------+
| local varible1      | -4(%ebp)
+---------------------+
| local varible2      | -8(%ebp)
+---------------------+
| local varible3      |-12(%ebp)
+---------------------+
|                     |
+---------------------+
|                     |
+---------------------+
|                     |
+---------------------+</code></pre>

<p>涉及几个要点：</p>
<ul>
<li>堆栈指针存放在ESP。也称为，ESP寄存器用于指向内存中堆栈顶部。这个顶部是指调用方发起调用后的那个时刻的栈。此时栈顶对应的是返回地址。如果有pushl和popl操作，那么栈顶地址就会发生改变。即ESP寄存器中的值会发生改变。即，上面图1。</li>
<li><strong>栈的分配方向从大往小方向分配</strong>。<ul>
<li>为啥从大往小，参见 进程的内存空间结构 部分。</li>
<li><strong>预留（申请）栈空间</strong>，就是类似subl $8, %esp, <strong>是减去</strong>，因为从大往小方向分配嘛。  <strong>清空堆栈就是 addl</strong>。</li>
</ul>
</li>
<li>通常到执行到函数内部时（用了常用操作堆栈的模板代码，参见下面代码），堆栈整体布局是 函数参数、返回地址、旧的EBP的值、函数局部变量。即，上面图2。</li>
<li>图2为什么切换EBP相对寻址，而不是图1的ESP。<strong>因为函数中如果有把数据压入堆栈，那么ESP值就会发生改变。所以用EBP存放了在函数发生调用那一刻ESP的值。同时还为了能找到存放ESP值之前的EBP的值（有点绕口），就把EBP的值压入堆栈</strong>。这样就形成了图2的布局，此时EBP对应的是ESP的值，ESP是栈顶，栈顶此时又是旧的EBP值（刚压入进去的）</li>
<li>调用前，将参数压栈的顺序与函数声明的参数顺序相反。</li>
</ul>
<h4 id="函数常用操作堆栈的代码模板"><a href="#函数常用操作堆栈的代码模板" class="headerlink" title="函数常用操作堆栈的代码模板"></a>函数常用操作堆栈的代码模板</h4><p>上面部分讲的图2的堆栈结构及其关联的要点，都是建立这个函数常用操作堆栈的代码模板上的，具体代码模板是：</p>
<pre><code class="hljs assembly">function:
    pushl %ebp
    movl %esp, %ebp
    ...
    movl %eb, %esp
    popl %ebp
    ret</code></pre>



<h3 id="独立汇编库函数文件"><a href="#独立汇编库函数文件" class="headerlink" title="独立汇编库函数文件"></a>独立汇编库函数文件</h3><p>汇编定义的函数可以写在独立的源文件中，然后可以编译成独立的目标文件，但是在连接发起调用的目标文件时要带上被调用的函数对应的目标文件。至于怎么连接被调用的c库函数，前面 使用c库函数示例 有讲。</p>
<pre><code class="hljs shell">as -gstabs -o area.o area.s
as -gstabs -o functest4.o functest4s

ld -o functest4 functest.o area.o</code></pre>



<h3 id="Linux进程的内存空间结构与使用命令行参数"><a href="#Linux进程的内存空间结构与使用命令行参数" class="headerlink" title="Linux进程的内存空间结构与使用命令行参数"></a>Linux进程的内存空间结构与使用命令行参数</h3><p>linux为系统要执行的程序在内存中创建一个区域。每个程序都被分配到相同的寻你内存地址。操作系统再完成虚拟内存到物理内存的映射。</p>
<p>虚拟内存的地址空间是从0x80480000开始到0xbfffffff结束。</p>
<p>靠近0x80480000小的这一端存放程序代码和数据（来自.bss和.data段）。</p>
<p><strong>靠近0xbfffffff大的一端存放堆栈数据，从大往小分配，这样也解释了上个部分提到的堆栈为啥从大往小分配。</strong></p>
<p>另外，这个堆栈不仅仅包含函数调用堆栈，还包含其他一些要素，下面阐述。</p>
<p><strong>堆栈从大到小方向依次包括：</strong></p>
<p><strong>环境变量、命令行参数、指向环境变量的指针、0x00000000、指向命令行参数3的指针、指向命令行参数2的指针、指向命令行参数1的指针、程序名称、参数数目。</strong></p>
<p><strong>ESP指向参数数目这个条目。</strong></p>
<p>调试时需要的要点：</p>
<ul>
<li>print $esp    查看看esp值 即查看栈顶地址</li>
<li>x/20x 0xbffff950   显示从指定内存位置开始的20个字节，格式是十六进制</li>
<li>x/s 0xbffffa36   用x命令和指针对峙查看字符串值</li>
</ul>
<h2 id="使用系统调用"><a href="#使用系统调用" class="headerlink" title="使用系统调用"></a>使用系统调用</h2><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>使用cpuid指令结合输出和退出两个系统调用做个例子：</p>
<pre><code class="hljs assembly">.section .data
output:
   .ascii &quot;The processor Vendor ID is &#39;xxxxxxxxxxxx&#39;\n&quot;

#.section .bss

.section .text
.globl _start
_start:
    movl $0, %eax
    cpuid
    movl $output, %edi
    movl %ebx, 28(%edi)
    movl %edx, 32(%edi)
    movl %ecx, 36(%edi)
    # 开始向控制台输出的系统调用  strace看到的是write(6291690, NULL, 42)
    
    # 系统调用编号
    movl $4, %eax
    # 要写入的文件描述符  STDOUT 标准输出的文件描述符是1 
    movl $1, %ebx
    # 字符的开头
    movl $output, %ecx
    # 字符串的长度
    movl $42, %edx
    int $0x80
    # 到上面结束向控制台输出的系统调用 
    
    movl $1, %eax
    movl $0, %ebx
    int $0x80</code></pre>

<h3 id="查看系统调用编号"><a href="#查看系统调用编号" class="headerlink" title="查看系统调用编号"></a>查看系统调用编号</h3><p>查看系统调用编号</p>
<p>cat /usr/include/asm/unistd_32.h  </p>
<p>#define __NR_write 4</p>
<p>注意32位与64位不同</p>
<p>编译与执行：</p>
<pre><code class="hljs assembly">╰─$ as -o cpuid.o cpuid.s
╭─simon@simon-c7-d1 ~&#x2F;600.self&#x2F;01.code&#x2F;01.c_cpp&#x2F;02.program_basic_study&#x2F;cpuid
╰─$ ld -o cpuid cpuid.o
╭─simon@simon-c7-d1 ~&#x2F;600.self&#x2F;01.code&#x2F;01.c_cpp&#x2F;02.program_basic_study&#x2F;cpuid
╰─$ .&#x2F;cpuid
The processor Vendor ID is &#39;GenuineIntel&#39;</code></pre>

<h3 id="寄存器的使用约定"><a href="#寄存器的使用约定" class="headerlink" title="寄存器的使用约定"></a>寄存器的使用约定</h3><p>几个要点：</p>
<ul>
<li>eax存放 要调用的哪个系统调用的编号</li>
<li>ebx\ecx\edx\esi\edi 5个寄存器依次存放第1~5个参数</li>
<li>需要超过6个参数的系统调用，则我们需要在ebx中存放指向输入参数的内分位置的指针，输入参数按照连续的顺序存</li>
<li>参数传送顺序与系统调用声明参数的顺序相同</li>
<li>系统调用的返回值存放在eax寄存器</li>
<li>复杂的系统调用的返回值，需要在汇编中创建与之对应的结构接受，参见P276 sysinfo系统调用</li>
</ul>
<h3 id="strace"><a href="#strace" class="headerlink" title="strace"></a>strace</h3><p>-p pid  附加到现有进程</p>
<p>-o file 将结果写入文件</p>
<p>-c 可以统计时间和次数等</p>
<p>-e 指定输出的过滤表达式</p>
<p>通过strace也能发现用c库函数比在汇编中直接调用系统调用，要多出很多系统调用（加载动态加载器程序等），但话说回来，这个开销并不明显。</p>
<h2 id="使用内联汇编"><a href="#使用内联汇编" class="headerlink" title="使用内联汇编"></a>使用内联汇编</h2><h3 id="内联汇编关键字、防止编译器优化与扩展格式"><a href="#内联汇编关键字、防止编译器优化与扩展格式" class="headerlink" title="内联汇编关键字、防止编译器优化与扩展格式"></a>内联汇编关键字、防止编译器优化与扩展格式</h3><p>关键字分两组，不同标准使用不同的：</p>
<ul>
<li>asm与volatile</li>
<li>__asm__ 与__volatile__</li>
<li>volatile与__volatile__ 表示告知编译器不要优化此代码</li>
</ul>
<p>基本格式</p>
<p>asm(“assembly code”)</p>
<p>多行的用自己用\n 显式表示， 也可以用多个引号。</p>
<p>示例：</p>
<pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-keyword">int</span> a = <span class="hljs-number">10</span>;
<span class="hljs-keyword">int</span> b = <span class="hljs-number">20</span>;
<span class="hljs-keyword">int</span> result;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>
<span class="hljs-function"></span>&#123;
<span class="hljs-keyword">asm</span> ( “pusha\n\t”
  “movl a, %eax\n\t”
  “movl b, %ebx\n\t”
  “imull %ebx, %eax\n\t”
  “movl %eax, result\n\t”
  “popa”);
<span class="hljs-built_in">printf</span>(“the answer is %d\n”, result);
<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
&#125;</code></pre>

<p><strong>此时这种格式访问的ab变量都得是全局变量，不能是全局变量</strong>。后面扩展格式可以访问局部变量。</p>
<h4 id="扩展格式"><a href="#扩展格式" class="headerlink" title="扩展格式"></a>扩展格式</h4><p><strong>asm (“assembly code” : output location : input operands : changed registers)</strong></p>
<p><strong>用三个冒号连接了四个部分</strong>，具体释义：</p>
<ul>
<li>具体的汇编代码，用引号引起来</li>
<li>输出位置：包含内联汇编代码的输出值的寄存器和内存位置的列表</li>
<li>输入操作数：包含内联汇编代码输入值的寄存器和内存位置的列表</li>
<li>改动的寄存器：内联汇编代码改变的<strong>任何其他寄存器</strong>的列表 // 任何其他是指：内联代码中<strong>用到作为输入输出的</strong>就不用写在这，如果写了就会报错。所以很多时候，我们看到这部分没有。但是如果是用到的<strong>一些中间状态暂存的寄存器</strong>要写在这。详情参见P303</li>
</ul>
<p>对于第二和第三部分的输出位置和输入操作数的格式是：</p>
<p>“constraint” (variable)</p>
<p>约束是单一字符，但是对于输出值，这个单一字符前面还可以加个修饰符，也就是可以是两个字符。</p>
<p>约束字符有 abcdSDrqAftumoVing</p>
<p>修饰字符有+=%&amp;</p>
<p>约束与修饰符的具体含义参见P297 P298</p>
<p>a Use the %eax, %ax, or %al registers.</p>
<p>b Use the %ebx, %bx, or %bl registers.</p>
<p>c Use the %ecx, %cx, or %cl registers.</p>
<p>d Use the %edx, %dx, or $dl registers.</p>
<p>S Use the %esi or %si registers.</p>
<p>D Use the %edi or %di registers.</p>
<p>r Use any available general-purpose register.</p>
<p>q Use either the %eax, %ebx, %ecx, or %edx register.</p>
<p>A Use the %eax and the %edx registers for a 64-bit value.</p>
<p>f Use a floating-point register.</p>
<p>t Use the first (top) floating-point register.</p>
<p>u Use the second floating-point register.</p>
<p>m Use the variable’s memory location.</p>
<p>o Use an offset memory location.</p>
<p>V Use only a direct memory location.</p>
<p>i Use an immediate integer value.</p>
<p>n Use an immediate integer value with a known value.</p>
<p>g Use any register or memory location available.</p>
<p>+ The operand can be both read from and written to.</p>
<p>= The operand can only be written to.</p>
<p>% The operand can be switched with the next operand if necessary.</p>
<p>&amp; The operand can be deleted and reused before the inline functions complete.</p>
<p>具体示例参见下面使用变量章节。</p>
<h3 id="使用寄存器、c的变量、占位符"><a href="#使用寄存器、c的变量、占位符" class="headerlink" title="使用寄存器、c的变量、占位符"></a>使用寄存器、c的变量、占位符</h3><h4 id="使用寄存器"><a href="#使用寄存器" class="headerlink" title="使用寄存器"></a>使用寄存器</h4><p>基本格式访问的变量都得是全局变量，不能是全局变量，参见上面基本格式示例。</p>
<p>扩展格式可以访问局部变量：</p>
<pre><code class="hljs assembly">#include &lt;stdio.h&gt;
int main()
&#123;
int data1 &#x3D; 10;
int data2 &#x3D; 20;
int result;
asm (&quot;imull %%edx, %%ecx\n\t&quot;
    &quot;movl %%ecx, %%eax&quot;
    : &quot;&#x3D;a&quot;(result)
    : &quot;d&quot;(data1), &quot;c&quot;(data2));
printf(&quot;The result is %d\n&quot;, result);
return 0;
&#125;</code></pre>

<p>在扩展格式中使用寄存器必须是两个%。</p>
<h4 id="使用、引用与替换占位符"><a href="#使用、引用与替换占位符" class="headerlink" title="使用、引用与替换占位符"></a>使用、引用与替换占位符</h4><p>使用示例：</p>
<pre><code class="hljs assembly">asm (“assembly code”
: &quot;&#x3D;r&quot;(result)
: &quot;r&quot;(data1), &quot;r&quot;(data2));

&#x3D;&#x3D;&gt;

#include &lt;stdio.h&gt;
int main()
&#123;
int data1 &#x3D; 10;
int data2 &#x3D; 20;
int result;
asm (&quot;imull %1, %2\n\t&quot;
    &quot;movl %2, %0&quot;
    : &quot;&#x3D;r&quot;(result)
    : &quot;r&quot;(data1), &quot;r&quot;(data2));
printf(&quot;The result is %d\n&quot;, result);
return 0;
&#125;

&#x3D;&#x3D;&gt;

%0 will represent the register containing the result variable value.
%1 will represent the register containing the data1 variable value.
%2 will represent the register containing the data2 variable value.

0 1 2 依照 result data1  data2顺序来的，然后在汇编代码中使用他。编译器自己选择寄存器。</code></pre>

<p>%0  %1 %2这样的占位符不直观，可以使用占位符名称解决这个问题，如下：</p>
<pre><code class="hljs assembly">asm (&quot;imull %[value1], %[value2]&quot;
: [value2] &quot;&#x3D;r&quot;(data2)
: [value1] &quot;r&quot;(data1), &quot;0&quot;(data2));


&#x3D;&#x3D;&gt;

int main()
&#123;
int data1 &#x3D; 10;
int data2 &#x3D; 20;
asm (&quot;imull %[value1], %[value2]&quot;
    : [value2] &quot;&#x3D;r&quot;(data2)
    : [value1] &quot;r&quot;(data1), &quot;0&quot;(data2));
printf(&quot;The result is %d\n&quot;, data2);
return 0;
&#125;</code></pre>



<h2 id="参考材料"><a href="#参考材料" class="headerlink" title="参考材料"></a>参考材料</h2><p>汇编语言程序设计(美)布鲁姆 着,马朝晖 等….pdf</p>
<p>Professional Assembly Language.2005.pdf</p>
<p><a href="https://docs.oracle.com/cd/E19641-01/802-1948/802-1948.pdf" target="_blank" rel="noopener">x86 Assembly Language Reference Manual.pdf</a></p>

            </article>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/book-paper-study/">book-paper-study</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/assembly/">assembly</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2022/01/09/centos6.x-ssl-error-systemtap-env/">
                        <span class="hidden-mobile">centos 6.x ssl证书问题解决及systemtap环境准备</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener">
        <span>Fluid</span></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>






<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "《汇编语言程序设计》读书笔记&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>














  <script  src="https://cdn.staticfile.org/mermaid/8.4.8/mermaid.min.js" ></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({"theme":"default"});
    }
  </script>





</body>
</html>
