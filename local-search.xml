<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MetadataCache更新</title>
    <link href="/2020/04/22/kafka1-0-metadata-update/"/>
    <url>/2020/04/22/kafka1-0-metadata-update/</url>
    
    <content type="html"><![CDATA[<h2 id="MetadataCache什么时候更新"><a href="#MetadataCache什么时候更新" class="headerlink" title="MetadataCache什么时候更新"></a>MetadataCache什么时候更新</h2><p>updateCache方法用来更新缓存的。   </p><h3 id="发起线程-controller-event-thread"><a href="#发起线程-controller-event-thread" class="headerlink" title="发起线程  controller-event-thread"></a>发起线程  controller-event-thread</h3><h4 id="controller选举的时候"><a href="#controller选举的时候" class="headerlink" title="controller选举的时候"></a>controller选举的时候</h4><table><tr><td>CLASS_NAME   </td><td>  METHOD_NAME</td><td>    LINE_NUM</td></tr>  <tr><td>kafka/controller/KafkaController </td><td>  sendUpdateMetadataRequest </td><td>     1043</td></tr>  <tr><td>kafka/controller/KafkaController  </td><td> onControllerFailover  </td><td>    288</td></tr>  <tr><td>kafka/controller/KafkaController  </td><td> elect   </td><td>  1658</td></tr>  <tr><td>kafka/controller/KafkaController$Startup$   </td><td> process  </td><td> 1581</td></tr>  <tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1 </td><td>apply$mcV$sp </td><td>  53</td></tr>  <tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1 </td><td>apply  </td><td>   53</td></tr>  <tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1</td><td> apply  </td><td>   53</td></tr>  <tr><td>kafka/metrics/KafkaTimer</td><td> time </td><td>32</td></tr>  <tr><td>kafka/controller/ControllerEventManager$ControllerEventThread  </td><td>  doWork  </td><td>  64</td></tr>  <tr><td>kafka/utils/ShutdownableThread  </td><td>   run  </td><td>70</td></tr>  </table>  <p>启动的时候选举，启动这个动作也是个事件  </p><pre><code class="hljs scala"><span class="hljs-comment">// KafkaController.scala</span>  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Startup</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ControllerEvent</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">state</span> </span>= <span class="hljs-type">ControllerState</span>.<span class="hljs-type">ControllerChange</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process</span></span>(): <span class="hljs-type">Unit</span> = &#123;      registerSessionExpirationListener()      registerControllerChangeListener()      elect()    &#125;  &#125;</code></pre><h4 id="broker启动的时候"><a href="#broker启动的时候" class="headerlink" title="broker启动的时候"></a>broker启动的时候</h4><table><tr><td>CLASS_NAME  </td><td>   METHOD_NAME  </td><td>  LINE_NUM</td></tr><tr><td>kafka/controller/KafkaController  </td><td> sendUpdateMetadataRequest    </td><td> 1043</td></tr><tr><td>kafka/controller/KafkaController  </td><td> onBrokerStartup   </td><td>  387</td></tr><tr><td>kafka/controller/KafkaController$BrokerChange  </td><td>   process  </td><td> 1208</td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1 </td><td>apply$mcV$sp </td><td>  53</td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1 </td><td>apply </td><td>    53</td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1</td><td> apply </td><td>    53</td></tr><tr><td>kafka/metrics/KafkaTimer </td><td>time </td><td>32</td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread   </td><td> doWork </td><td>   64</td></tr><tr><td>kafka/utils/ShutdownableThread   </td><td>  run </td><td> 70</td></tr></table><h4 id="topic删除的时候"><a href="#topic删除的时候" class="headerlink" title="topic删除的时候"></a>topic删除的时候</h4><table><tr><td>CLASS_NAME  </td><td>   METHOD_NAME   </td><td>  LINE_NUM  </td></tr><tr><td>kafka/controller/KafkaController   </td><td> sendUpdateMetadataRequest    </td><td>  1043 </td></tr><tr><td>kafka/controller/TopicDeletionManager   </td><td> kafka$controller$TopicDeletionManager$$onTopicDeletion  </td><td>268  </td></tr><tr><td>kafka/controller/TopicDeletionManager$$anonfun$resumeDeletions$2  </td><td>apply   </td><td>   333  </td></tr><tr><td>kafka/controller/TopicDeletionManager$$anonfun$resumeDeletions$2  </td><td>apply  </td><td>    333  </td></tr><tr><td>scala/collection/immutable/Set$Set1    </td><td>  foreach  </td><td>  94   </td></tr><tr><td>kafka/controller/TopicDeletionManager   </td><td> resumeDeletions    </td><td>  333  </td></tr><tr><td>kafka/controller/TopicDeletionManager   </td><td> enqueueTopicsForDeletion  </td><td>110  </td></tr><tr><td>kafka/controller/KafkaController$TopicDeletion   </td><td>  process   </td><td> 1280 </td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1 </td><td> apply$mcV$sp  </td><td>  53   </td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1  </td><td>apply </td><td>     53   </td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1 </td><td> apply  </td><td>    53   </td></tr><tr><td>kafka/metrics/KafkaTimer  </td><td>time  </td><td>32   </td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread  </td><td>   doWork   </td><td>  64   </td></tr><tr><td>kafka/utils/ShutdownableThread    </td><td>  run   </td><td>70</td></tr></table>   <h4 id="topic创建或者修改的时候"><a href="#topic创建或者修改的时候" class="headerlink" title="topic创建或者修改的时候"></a>topic创建或者修改的时候</h4><table><tr><td>CLASS_NAME</td><td>    METHOD_NAME</td><td>    LINE_NUM</td></tr><tr><td>kafka/controller/ControllerBrokerRequestBatch</td><td>    updateMetadataRequestBrokerSet</td><td>    291</td></tr>  <tr><td>kafka/controller/ControllerBrokerRequestBatch    </td><td>newBatch    </td><td>294</td></tr>  <tr><td>kafka/controller/PartitionStateMachine    </td><td>handleStateChanges</td><td>    105</td></tr>  <tr><td>kafka/controller/KafkaController</td><td>    onNewPartitionCreation    </td><td>499</td></tr>  <tr><td>kafka/controller/KafkaController</td><td>    onNewTopicCreation</td><td>    485</td></tr>  <tr><td>kafka/controller/KafkaController$TopicChange</td><td>    process    </td><td>1237</td></tr>  <tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1</td><td>    apply$mcV$sp</td><td>    53</td></tr>  <tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1    </td><td>apply</td><td>    53</td></tr>  <tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1    </td><td>apply    </td><td>53</td></tr>  <tr><td>kafka/metrics/KafkaTimer</td><td>    time    </td><td>32</td></tr>  <tr><td>kafka/controller/ControllerEventManager$ControllerEventThread</td><td>    doWork    </td><td>64</td></tr>  <tr><td>kafka/utils/ShutdownableThread    </td><td>run    </td><td>70</td></tr>  </table>  <p>topic创建这个是从队列中拿到事件再处理的方式<br>队列是<code>kafka.controller.ControllerEventManager.queue</code><br>放入过程如下，本质还是监听zk的path的child的变化：  </p><table><tr><td>CLASS_NAME</td><td>    METHOD_NAME    </td><td>LINE_NUM</td></tr><tr><td>kafka/controller/ControllerEventManager</td><td>put</td><td>    44</td></tr><tr><td>kafka/controller/TopicChangeListener    </td><td>handleChildChange    </td><td>1712</td></tr><tr><td>org/I0Itec/zkclient/ZkClient$10    </td><td>run</td><td>    848</td></tr><tr><td>org/I0Itec/zkclient/ZkEventThread    </td><td>run</td><td>    85</td></tr></table><p>注册监听器的代码如下:  </p><pre><code class="hljs scala"><span class="hljs-comment">// class KafkaController</span>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">registerTopicChangeListener</span></span>() = &#123;    zkUtils.subscribeChildChanges(<span class="hljs-type">BrokerTopicsPath</span>, topicChangeListener)  &#125;</code></pre><p>顺带说一下有6个地方订阅了zk的子节点的变化：  </p><ul><li>DynamicConfigManager.startup</li><li>registerTopicChangeListener</li><li>registerIsrChangeNotificationListener</li><li>registerTopicDeletionListener</li><li>registerBrokerChangeListener</li><li>registerLogDirEventNotificationListener </li></ul><p>处理创建topic事件：  </p><pre><code class="hljs scala"><span class="hljs-comment">// ControllerChannelManager.scala  class ControllerBrokerRequestBatch</span>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sendRequestsToBrokers</span></span>(controllerEpoch: <span class="hljs-type">Int</span>) &#123;  <span class="hljs-comment">// .......</span>      <span class="hljs-keyword">val</span> updateMetadataRequest = &#123;        <span class="hljs-keyword">val</span> liveBrokers = <span class="hljs-keyword">if</span> (updateMetadataRequestVersion == <span class="hljs-number">0</span>) &#123;          <span class="hljs-comment">// .......</span>        &#125; <span class="hljs-keyword">else</span> &#123;          controllerContext.liveOrShuttingDownBrokers.map &#123; broker =&gt;            <span class="hljs-keyword">val</span> endPoints = broker.endPoints.map &#123; endPoint =&gt;              <span class="hljs-keyword">new</span> <span class="hljs-type">UpdateMetadataRequest</span>.<span class="hljs-type">EndPoint</span>(endPoint.host, endPoint.port, endPoint.securityProtocol, endPoint.listenerName)            &#125;            <span class="hljs-keyword">new</span> <span class="hljs-type">UpdateMetadataRequest</span>.<span class="hljs-type">Broker</span>(broker.id, endPoints.asJava, broker.rack.orNull)          &#125;        &#125;        <span class="hljs-keyword">new</span> <span class="hljs-type">UpdateMetadataRequest</span>.<span class="hljs-type">Builder</span>(updateMetadataRequestVersion, controllerId, controllerEpoch, partitionStates.asJava,          liveBrokers.asJava)      &#125;      updateMetadataRequestBrokerSet.foreach &#123; broker =&gt;        controller.sendRequest(broker, <span class="hljs-type">ApiKeys</span>.<span class="hljs-type">UPDATE_METADATA</span>, updateMetadataRequest, <span class="hljs-literal">null</span>)      &#125;      <span class="hljs-comment">// .......</span>    &#125;</code></pre><p>topic创建时更新metadata再进一步的过程<br>构建发送请求事件放入发送队列等待发送线程发送<br>构建发送请求事件代码如下：  </p><pre><code class="hljs scala"><span class="hljs-comment">// ControllerChannelManager</span>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sendRequest</span></span>(brokerId: <span class="hljs-type">Int</span>, apiKey: <span class="hljs-type">ApiKeys</span>, request: <span class="hljs-type">AbstractRequest</span>.<span class="hljs-type">Builder</span>[_ &lt;: <span class="hljs-type">AbstractRequest</span>],                  callback: <span class="hljs-type">AbstractResponse</span> =&gt; <span class="hljs-type">Unit</span> = <span class="hljs-literal">null</span>) &#123;    brokerLock synchronized &#123;      <span class="hljs-keyword">val</span> stateInfoOpt = brokerStateInfo.get(brokerId)      stateInfoOpt <span class="hljs-keyword">match</span> &#123;        <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(stateInfo) =&gt;          stateInfo.messageQueue.put(<span class="hljs-type">QueueItem</span>(apiKey, request, callback))        <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt;          warn(<span class="hljs-string">"Not sending request %s to broker %d, since it is offline."</span>.format(request, brokerId))      &#125;    &#125;  &#125;</code></pre><p>调用栈：  </p><table><tr><td>CLASS_NAME</td><td>METHOD_NAME</td><td>LINE_NUM</td></tr><tr><td>kafka/controller/ControllerChannelManager</td><td>sendRequest</td><td>81</td></tr><tr><td>kafka/controller/KafkaController</td><td>sendRequest</td><td>662</td></tr><tr><td>kafka/controller/ControllerBrokerRequestBatch$$anonfun$sendRequestsToBrokers$2</td><td>apply</td><td>405</td></tr><tr><td>kafka/controller/ControllerBrokerRequestBatch$$anonfun$sendRequestsToBrokers$2</td><td>apply</td><td>405</td></tr><tr><td>scala/collection/mutable/HashMap$$anonfun$foreach$1</td><td>apply</td><td>130</td></tr><tr><td>scala/collection/mutable/HashMap$$anonfun$foreach$1</td><td>apply</td><td>130</td></tr><tr><td>scala/collection/mutable/HashTable$class</td><td>foreachEntry</td><td>241</td></tr><tr><td>scala/collection/mutable/HashMap</td><td>foreachEntry</td><td>40</td></tr><tr><td>scala/collection/mutable/HashMap</td><td>foreach</td><td>130</td></tr><tr><td>kafka/controller/ControllerBrokerRequestBatch</td><td>sendRequestsToBrokers</td><td>502</td></tr><tr><td>kafka/controller/PartitionStateMachine</td><td>handleStateChanges</td><td>105</td></tr><tr><td>kafka/controller/KafkaController</td><td>onNewPartitionCreation</td><td>499</td></tr><tr><td>kafka/controller/KafkaController</td><td>onNewTopicCreation</td><td>485</td></tr><tr><td>kafka/controller/KafkaController$TopicChange</td><td>process</td><td>1237</td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1</td><td>apply$mcV$sp</td><td>53</td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1</td><td>apply</td><td>53</td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1</td><td>apply</td><td>53</td></tr><tr><td>kafka/metrics/KafkaTimer</td><td>time</td><td>32</td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread</td><td>doWork</td><td>64</td></tr><tr><td>kafka/utils/ShutdownableThread</td><td>run</td><td>70</td></tr></table><p>发送线程发送请求：<br>代码如下： </p><pre><code class="hljs scala"><span class="hljs-comment">// ControllerChannelManager.scala class RequestSendThread</span>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doWork</span></span>(): <span class="hljs-type">Unit</span> = &#123;    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backoff</span></span>(): <span class="hljs-type">Unit</span> = <span class="hljs-type">CoreUtils</span>.swallowTrace(<span class="hljs-type">Thread</span>.sleep(<span class="hljs-number">100</span>))    <span class="hljs-keyword">val</span> <span class="hljs-type">QueueItem</span>(apiKey, requestBuilder, callback) = queue.take()    <span class="hljs-comment">//...</span>    <span class="hljs-keyword">while</span> (isRunning.get() &amp;&amp; !isSendSuccessful) &#123;        <span class="hljs-comment">// if a broker goes down for a long time, then at some point the controller's zookeeper listener will trigger a</span>        <span class="hljs-comment">// removeBroker which will invoke shutdown() on this thread. At that point, we will stop retrying.</span>        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">if</span> (!brokerReady()) &#123;            isSendSuccessful = <span class="hljs-literal">false</span>            backoff()          &#125;          <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">val</span> clientRequest = networkClient.newClientRequest(brokerNode.idString, requestBuilder,              time.milliseconds(), <span class="hljs-literal">true</span>)            clientResponse = <span class="hljs-type">NetworkClientUtils</span>.sendAndReceive(networkClient, clientRequest, time)            isSendSuccessful = <span class="hljs-literal">true</span>          &#125;        &#125; <span class="hljs-keyword">catch</span> &#123;          <span class="hljs-keyword">case</span> e: <span class="hljs-type">Throwable</span> =&gt; <span class="hljs-comment">// if the send was not successful, reconnect to broker and resend the message</span>            warn((<span class="hljs-string">"Controller %d epoch %d fails to send request %s to broker %s. "</span> +              <span class="hljs-string">"Reconnecting to broker."</span>).format(controllerId, controllerContext.epoch,                requestBuilder.toString, brokerNode.toString), e)            networkClient.close(brokerNode.idString)            isSendSuccessful = <span class="hljs-literal">false</span>            backoff()        &#125;      &#125;      <span class="hljs-comment">// ......</span>  &#125;</code></pre><h3 id="响应线程"><a href="#响应线程" class="headerlink" title="响应线程"></a>响应线程</h3><table><tr><td>CLASS_NAME</td><td>METHOD_NAME</td><td>LINE_NUM</td></tr><tr><td>kafka/server/MetadataCache</td><td>kafka$server$MetadataCache$$addOrUpdatePartitionInfo</td><td>150</td></tr><tr><td>kafka/utils/CoreUtils$</td><td>inLock</td><td>219</td></tr><tr><td>kafka/utils/CoreUtils$</td><td>inWriteLock</td><td>225</td></tr><tr><td>kafka/server/MetadataCache</td><td>updateCache</td><td>184</td></tr><tr><td>kafka/server/ReplicaManager</td><td>maybeUpdateMetadataCache</td><td>988</td></tr><tr><td>kafka/server/KafkaApis</td><td>handleUpdateMetadataRequest</td><td>212</td></tr><tr><td>kafka/server/KafkaApis</td><td>handle</td><td>142</td></tr><tr><td>kafka/server/KafkaRequestHandler</td><td>run</td><td>72</td></tr></table><p>线程信息：  kafka-request-handler-5<br>靠 <code>partitionMetadataLock</code>读写锁控制cache数据的读取与写入的线程安全。元数据信息在发送请求中已经构造好了。此处还涉live broker的更新等。    </p><p>应该还要补充：leader切换和isr变化等</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>kafka1.0源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>副本同步</title>
    <link href="/2020/04/22/kafka1-0-replica-sync/"/>
    <url>/2020/04/22/kafka1-0-replica-sync/</url>
    
    <content type="html"><![CDATA[<h2 id="几个概念的解释"><a href="#几个概念的解释" class="headerlink" title="几个概念的解释"></a>几个概念的解释</h2><ul><li>LEO 日志的结尾位置，也是最后写入(append)消息的位置+1。这个位置不代表消费者能看到，仅仅表示单机的日志写入位置，因为要考虑其他副本的写入情况。leader与follower都有此指标。</li><li>HW high water mark的简称，对外公开的消费者的非事务消息(即未提交读模式)的位置。这个值的更新过程比较复杂。leader与follower都有此指标。与LEO的区别<a href="https://stackoverflow.com/questions/39203215/kafka-difference-between-log-end-offsetleo-vs-high-watermarkhw" target="_blank" rel="noopener">参见这里</a>  </li><li>LSO 事务消息涉及。最后稳定offset。如果是事务消息(即已提交读模式)，这是消费者能看到的最大位置。可以参见《offset range查询》中 <code>查询最新offset</code> 段落。</li><li>epoch leader的年代。0.11版本引入这个概念，为了解决0，8版本在broker挂掉的过程中消息可能丢失和错乱的问题。具体可以参见huxi的<a href="https://www.cnblogs.com/huxi2b/p/7453543.html" target="_blank" rel="noopener">Kafka水位(high watermark)与leader epoch的讨论</a>  </li></ul><blockquote><p>The high watermark indicated the offset of messages that are fully replicated, while the end-of-log offset might be larger if there are newly appended records to the leader partition which are not replicated yet.</p></blockquote><h2 id="副本同步主要结构"><a href="#副本同步主要结构" class="headerlink" title="副本同步主要结构"></a>副本同步主要结构</h2><p>主要涉及的类有：<code>AbstractFetcherThread</code>,<code>ReplicaFetcherThread</code>,<code>PartitionFetchState</code>,<code>ReplicaFetcherManager</code>,<code>ShutdownableThread</code>,<code>ReplicaManager</code> , <code>ReplicaFetcherManager</code> </p><h2 id="Follower机器逻辑简述"><a href="#Follower机器逻辑简述" class="headerlink" title="Follower机器逻辑简述"></a>Follower机器逻辑简述</h2><h3 id="线程创建部分"><a href="#线程创建部分" class="headerlink" title="线程创建部分"></a>线程创建部分</h3><ol><li>handleLeaderAndIsrRequest是入口，在handleLeaderAndIsrRequest时会触发<code>ReplicaManager</code>的<code>becomeLeaderOrFollower</code>,<code>makeFollowers</code></li><li>触发<code>ReplicaFetcherManager</code>的<code>addFetcherForPartitions</code></li><li>用<code>ReplicaFetcherManager</code>的<code>createFetcherThread</code>方法创建fetcher线程。new ReplicaFetcherThread….    </li></ol><p>一些字段的赋值说明：  </p><ul><li>线程名 s”${prefix}ReplicaFetcherThread-$fetcherId-${sourceBroker.id}”  </li><li>clientId 就是线程名</li><li>isInterruptible 创建时用固定值是false</li><li>includeLogTruncation 创建时用固定值是true，<strong>这也就是意味着PartitionFetchState对象一开始建出来时truncatingLog字段是true</strong>  </li></ul><h3 id="Follower机器逻辑执行部分"><a href="#Follower机器逻辑执行部分" class="headerlink" title="Follower机器逻辑执行部分"></a>Follower机器逻辑执行部分</h3><p>ReplicaFetcherThread类的结构继承关系是：<br>ShutdownableThread<br>|– AbstractFetcherThread<br>|—|– ReplicaFetcherThread  </p><p>因为<code>ShutdownableThread</code>是个spin线程，子类实现doWork方法即可对接业务逻辑。<br><code>AbstractFetcherThread</code>中的doWork逻辑组织：  </p><ul><li>maybeTruncate 处理可能需要截断的日志，针对LEO大于HW(highwater mark的简称，下同)的，要截断到HW位置。  </li><li>构建<code>FetchRequest</code>请求拉数据。</li><li>处理<code>FetchRequest</code>请求的响应，<code>processFetchRequest</code>。注意：该请求不一定能请求到消息数据(Record)，而且该请求也不是仅仅请求消息，还请求leader的高水位等值。 </li></ul><p>maybeTruncate逻辑：  </p><ul><li>过滤出<code>PartitionFetchState</code>实例<code>isTruncatingLog</code>为true的分区。PartitionFetchState的truncatingLog字段什么时候为true，目前分析是ReplicaFetcherThread线程刚创建时，默认赋值了true，也就是一开始可能会截断。  ReplicaFetcherThread.buildLeaderEpochRequest。  </li><li>根据上步过滤出来的结果，构建根据epoch查询offset的请求<code>OffsetsForLeaderEpochRequest</code>。ReplicaFetcherThread.fetchEpochsFromLeader。 </li><li>根据查询回来的结果，设置(纠正)正确的offset。我理解成只要mark了正确的位置即可，后面写的时候覆盖写即可，不要真正删除。(待证实)  AbstractFetcherThread.markTruncationComplete 。  </li></ul><p>处理<code>FetchRequest</code>请求的响应的逻辑：  </p><ul><li>根据结果判断有误错误码</li><li>结果正常的 调用<code>processPartitionData</code>，并更新分区状态   partitionStates.updateAndMoveToEnd(topicPartition, new PartitionFetchState(newOffset))  <code>ReplicaFetcherThread.processPartitionData</code></li><li><code>processPartitionData</code>由<code>ReplicaFetcherThread</code>实现，主要逻辑有:   <ul><li>写副本日志 replica.log.get.appendAsFollower(records)</li><li>更新副本的HW。 highWatermark 可以理解成 大家都已经确认的offset，否则就没必要维护这个了，直接用LEO或者LSO好  与LEO的区别<a href="https://stackoverflow.com/questions/39203215/kafka-difference-between-log-end-offsetleo-vs-high-watermarkhw" target="_blank" rel="noopener">参见这里</a>. 要构建用例恰好在这行前挂掉follower。</li><li>维护到副本对象的元数据中。 一次fetch请求并不能更新副本的highWatermark，需要下一次fethc请求才能完成上一次的。replica.highWatermark = new LogOffsetMetadata(followerHighWatermark)    </li></ul></li></ul><h2 id="leader与follower的HW-LEO更新过程"><a href="#leader与follower的HW-LEO更新过程" class="headerlink" title="leader与follower的HW LEO更新过程"></a>leader与follower的HW LEO更新过程</h2><h3 id="Leader机器逻辑执行部分"><a href="#Leader机器逻辑执行部分" class="headerlink" title="Leader机器逻辑执行部分"></a>Leader机器逻辑执行部分</h3><p>处理fetch请求的调用栈，消费者客户端与follower同步的fetch请求走的是一个逻辑，靠是否是来自follower做了些逻辑上的差异处理  </p><pre><code class="hljs java">ReplicaManager.kafka$server$ReplicaManager$$read$<span class="hljs-number">1</span>(TopicPartition, FetchRequest$PartitionData, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>, ReplicaQuota, IsolationLevel) line: <span class="hljs-number">856</span>ReplicaManager$$anonfun$readFromLocalLog$<span class="hljs-number">1</span>.apply(Tuple2&lt;TopicPartition,PartitionData&gt;) line: <span class="hljs-number">962</span>ReplicaManager$$anonfun$readFromLocalLog$<span class="hljs-number">1</span>.apply(Object) line: <span class="hljs-number">961</span>ResizableArray$class.foreach(ResizableArray, Function1) line: 59ArrayBuffer&lt;A&gt;.foreach(Function1&lt;A,U&gt;) line: <span class="hljs-number">48</span>ReplicaManager.readFromLocalLog(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>, Seq&lt;Tuple2&lt;TopicPartition,PartitionData&gt;&gt;, ReplicaQuota, IsolationLevel) line: <span class="hljs-number">961</span>ReplicaManager.readFromLog$<span class="hljs-number">1</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>, Seq, ReplicaQuota, IsolationLevel, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>) line: <span class="hljs-number">790</span>ReplicaManager.fetchMessages(<span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>, Seq&lt;Tuple2&lt;TopicPartition,PartitionData&gt;&gt;, ReplicaQuota, Function1&lt;Seq&lt;Tuple2&lt;TopicPartition,FetchPartitionData&gt;&gt;,BoxedUnit&gt;, IsolationLevel) line: <span class="hljs-number">803</span>KafkaApis.handleFetchRequest(RequestChannel$Request) line: <span class="hljs-number">597</span>KafkaApis.handle(RequestChannel$Request) line: <span class="hljs-number">101</span></code></pre><p>涉及到的位点信息及更新逻辑：<br>fetchOffset  fetch开始位点，来自于fetch请求体<br>highWatermark 更新逻辑 </p><p>kafka.server.ReplicaManager.readFromLocalLog(…).read(…) 操作逻辑：<br>标志度量数据<br>获取副本对象localReplica 获取逻辑是根据replica id(即broker id)获取，发fetch请求的时候 请求体中会带上replica id<br>val initialHighWatermark = localReplica.highWatermark.messageOffset  </p><p><span style="font-weight:bold;color:red;">更新leader节点上维护远端副本的LEO信息</span><br>有点绕  就是<span style="font-weight:bold;color:red;">在leader节点上也 维护了 远端LEO的信息</span>  ，因为<span style="font-weight:bold;color:red;">leader节点高水位要靠远端的LEO来更新，leader节点高水位的更新逻辑就是 所有远端副本的LEO的最小值</span><br>调用栈如下：  </p><pre><code class="hljs java">Replica.logEndOffset_$eq(LogOffsetMetadata) line: <span class="hljs-number">98</span>Replica.updateLogReadResult(LogReadResult) line: <span class="hljs-number">83</span>Partition.updateReplicaLogReadResult(Replica, LogReadResult) line: <span class="hljs-number">276</span>ReplicaManager$$anonfun$updateFollowerLogReadResults$<span class="hljs-number">2</span>.apply(Tuple2&lt;TopicPartition,LogReadResult&gt;) line: <span class="hljs-number">1314</span>ReplicaManager$$anonfun$updateFollowerLogReadResults$<span class="hljs-number">2</span>.apply(Object) line: <span class="hljs-number">1308</span>TraversableLike$$anonfun$map$<span class="hljs-number">1</span>.apply(A) line: <span class="hljs-number">234</span>TraversableLike$$anonfun$map$<span class="hljs-number">1</span>.apply(Object) line: <span class="hljs-number">234</span>ResizableArray$class.foreach(ResizableArray, Function1) line: 59ArrayBuffer&lt;A&gt;.foreach(Function1&lt;A,U&gt;) line: <span class="hljs-number">48</span>TraversableLike$class.map(TraversableLike, Function1, CanBuildFrom) line: 234ArrayBuffer&lt;A&gt;(AbstractTraversable&lt;A&gt;).map(Function1&lt;A,B&gt;, CanBuildFrom&lt;Traversable&lt;A&gt;,B,That&gt;) line: <span class="hljs-number">104</span>ReplicaManager.updateFollowerLogReadResults(<span class="hljs-keyword">int</span>, Seq&lt;Tuple2&lt;TopicPartition,LogReadResult&gt;&gt;) line: <span class="hljs-number">1308</span>ReplicaManager.readFromLog$<span class="hljs-number">1</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>, Seq, ReplicaQuota, IsolationLevel, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>) line: <span class="hljs-number">799</span>ReplicaManager.fetchMessages(<span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>, Seq&lt;Tuple2&lt;TopicPartition,PartitionData&gt;&gt;, ReplicaQuota, Function1&lt;Seq&lt;Tuple2&lt;TopicPartition,FetchPartitionData&gt;&gt;,BoxedUnit&gt;, IsolationLevel) line: <span class="hljs-number">803</span>KafkaApis.handleFetchRequest(RequestChannel$Request) line: <span class="hljs-number">597</span></code></pre><p>可以看出来是在leader处理fetch请求的时候做的逻辑，fetch请求带上来fetch offset就当成了远端副本的LEO  </p><p><strong>TODO</strong> </p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ol><li>创建同步fetch线程<br>ReplicaFetcherManager.createFetcherThread(int, BrokerEndPoint) line: 30<br>ReplicaFetcherManager(AbstractFetcherManager).kafka$server$AbstractFetcherManager$$addAndStartFetcherThread$1(BrokerAndFetcherId, BrokerIdAndFetcherId) line: 80<br>AbstractFetcherManager$$anonfun$addFetcherForPartitions$2.apply(Tuple2&lt;BrokerAndFetcherId,Map&lt;TopicPartition,BrokerAndInitialOffset&gt;&gt;) line: 94<br>AbstractFetcherManager$$anonfun$addFetcherForPartitions$2.apply(Object) line: 85<br>TraversableLike$WithFilter$$anonfun$foreach$1.apply(A) line: 733<br>Map$Map1&lt;A,B&gt;.foreach(Function1&lt;Tuple2&lt;A,B&gt;,U&gt;) line: 116<br>TraversableLike$WithFilter.foreach(Function1&lt;A,U&gt;) line: 732<br>ReplicaFetcherManager(AbstractFetcherManager).addFetcherForPartitions(Map&lt;TopicPartition,BrokerAndInitialOffset&gt;) line: 85<br>ReplicaManager.makeFollowers(int, int, Map&lt;Partition,PartitionState&gt;, int, Map&lt;TopicPartition,Errors&gt;) line: 1272<br>ReplicaManager.becomeLeaderOrFollower(int, LeaderAndIsrRequest, Function2&lt;Iterable<Partition>,Iterable<Partition>,BoxedUnit&gt;) line: 1065<br>KafkaApis.handleLeaderAndIsrRequest(RequestChannel$Request) line: 173<br>KafkaApis.handle(RequestChannel$Request) line: 103<br>KafkaRequestHandler.run() line: 65<br>KafkaThread(Thread).run() line: 748    </li></ol><ol start="2"><li>构建请求<br>ReplicaFetcherThread.buildFetchRequest(Seq&lt;Tuple2&lt;TopicPartition,PartitionFetchState&gt;&gt;) line: 234<br>AbstractFetcherThread$$anonfun$2.apply() line: 104<br>AbstractFetcherThread$$anonfun$2.apply() line: 103<br>CoreUtils$.inLock(Lock, Function0<T>) line: 217<br>ReplicaFetcherThread(AbstractFetcherThread).doWork() line: 103<br>ReplicaFetcherThread(ShutdownableThread).run() line: 64      </li></ol><hr><hr><hr><p>看的过程中的临时记录：  </p><pre><code class="hljs java">[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">18</span>:<span class="hljs-number">07</span>:<span class="hljs-number">13</span>,<span class="hljs-number">787</span>] INFO Handling request:RequestHeader(apiKey=OFFSET_FOR_LEADER_EPOCH, apiVersion=<span class="hljs-number">0</span>, clientId=broker-<span class="hljs-number">0</span>-fetcher-<span class="hljs-number">0</span>, correlationId=<span class="hljs-number">0</span>) -- &#123;topics=[&#123;topic=test.vv19,partitions=[&#123;partition=<span class="hljs-number">0</span>,leader_epoch=<span class="hljs-number">25</span>&#125;]&#125;]&#125; from connection <span class="hljs-number">172.16</span><span class="hljs-number">.113</span><span class="hljs-number">.38</span>:<span class="hljs-number">9094</span>-<span class="hljs-number">172.16</span><span class="hljs-number">.113</span><span class="hljs-number">.38</span>:<span class="hljs-number">49385</span>-<span class="hljs-number">0</span>;securityProtocol:PLAINTEXT,principal:User:ANONYMOUS (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">22</span>:<span class="hljs-number">13</span>:<span class="hljs-number">02</span>,<span class="hljs-number">501</span>] INFO testEnter0002-<span class="hljs-number">001</span>topicPartition:test.vv19:<span class="hljs-number">0</span>hwm.messageOffset: [<span class="hljs-number">37</span>]lso.messageOffset: [<span class="hljs-number">37</span>] (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">22</span>:<span class="hljs-number">13</span>:<span class="hljs-number">02</span>,<span class="hljs-number">502</span>] INFO testEnter0002-<span class="hljs-number">002</span>topicPartition:test.vv19:<span class="hljs-number">0</span>hwm.messageOffset: [<span class="hljs-number">37</span>]lso.messageOffset: [<span class="hljs-number">37</span>] (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">22</span>:<span class="hljs-number">13</span>:<span class="hljs-number">03</span>,<span class="hljs-number">006</span>] INFO testEnter0005-Received response:apikey:FETCH correlationId <span class="hljs-number">24</span>; (com.code260.ss.KafkaTestUtils$)LeaderEpochFileCache$$anonfun$assign$<span class="hljs-number">1</span>.apply$mcV$sp() line: <span class="hljs-number">62</span>LeaderEpochFileCache$$anonfun$assign$<span class="hljs-number">1</span>.apply() line: <span class="hljs-number">61</span>LeaderEpochFileCache$$anonfun$assign$<span class="hljs-number">1</span>.apply() line: <span class="hljs-number">61</span>CoreUtils$.inLock(Lock, Function0&lt;T&gt;) line: <span class="hljs-number">217</span>CoreUtils$.inWriteLock(ReadWriteLock, Function0&lt;T&gt;) line: <span class="hljs-number">225</span>LeaderEpochFileCache.assign(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">long</span>) line: <span class="hljs-number">60</span>Log$$anonfun$append$<span class="hljs-number">2</span>$$anonfun$apply$<span class="hljs-number">9</span>.apply(MutableRecordBatch) line: <span class="hljs-number">689</span>Log$$anonfun$append$<span class="hljs-number">2</span>$$anonfun$apply$<span class="hljs-number">9</span>.apply(Object) line: <span class="hljs-number">687</span>Iterator$class.foreach(Iterator, Function1) line: 891Wrappers$JIteratorWrapper&lt;A&gt;(AbstractIterator&lt;A&gt;).foreach(Function1&lt;A,U&gt;) line: <span class="hljs-number">1334</span>IterableLike$class.foreach(IterableLike, Function1) line: 72Wrappers$JIterableWrapper&lt;A&gt;(AbstractIterable&lt;A&gt;).foreach(Function1&lt;A,U&gt;) line: <span class="hljs-number">54</span>Log$$anonfun$append$<span class="hljs-number">2</span>.apply() line: <span class="hljs-number">687</span>Log$$anonfun$append$<span class="hljs-number">2</span>.apply() line: <span class="hljs-number">624</span>Log.maybeHandleIOException(Function0&lt;String&gt;, Function0&lt;T&gt;) line: <span class="hljs-number">1669</span>Log.append(MemoryRecords, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">624</span>Log.appendAsLeader(MemoryRecords, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>) line: <span class="hljs-number">597</span>Partition$$anonfun$<span class="hljs-number">13</span>.apply() line: <span class="hljs-number">500</span>Partition$$anonfun$<span class="hljs-number">13</span>.apply() line: <span class="hljs-number">488</span>CoreUtils$.inLock(Lock, Function0&lt;T&gt;) line: <span class="hljs-number">217</span>CoreUtils$.inReadLock(ReadWriteLock, Function0&lt;T&gt;) line: <span class="hljs-number">223</span>Partition.appendRecordsToLeader(MemoryRecords, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">487</span>ReplicaManager$$anonfun$appendToLocalLog$<span class="hljs-number">2</span>.apply(Tuple2&lt;TopicPartition,MemoryRecords&gt;) line: <span class="hljs-number">724</span>ReplicaManager$$anonfun$appendToLocalLog$<span class="hljs-number">2</span>.apply(Object) line: <span class="hljs-number">708</span>TraversableLike$$anonfun$map$<span class="hljs-number">1</span>.apply(A) line: <span class="hljs-number">234</span>TraversableLike$$anonfun$map$<span class="hljs-number">1</span>.apply(Object) line: <span class="hljs-number">234</span>HashMap$$anonfun$foreach$<span class="hljs-number">1</span>.apply(DefaultEntry&lt;A,B&gt;) line: <span class="hljs-number">130</span>HashMap$$anonfun$foreach$<span class="hljs-number">1</span>.apply(Object) line: <span class="hljs-number">130</span>HashTable$class.foreachEntry(HashTable, Function1) line: 236HashMap&lt;A,B&gt;.foreachEntry(Function1&lt;DefaultEntry&lt;A,B&gt;,U&gt;) line: <span class="hljs-number">40</span>HashMap&lt;A,B&gt;.foreach(Function1&lt;Tuple2&lt;A,B&gt;,U&gt;) line: <span class="hljs-number">130</span>TraversableLike$class.map(TraversableLike, Function1, CanBuildFrom) line: 234HashMap&lt;A,B&gt;(AbstractTraversable&lt;A&gt;).map(Function1&lt;A,B&gt;, CanBuildFrom&lt;Traversable&lt;A&gt;,B,That&gt;) line: <span class="hljs-number">104</span>ReplicaManager.appendToLocalLog(<span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>, Map&lt;TopicPartition,MemoryRecords&gt;, <span class="hljs-keyword">short</span>) line: <span class="hljs-number">708</span>ReplicaManager.appendRecords(<span class="hljs-keyword">long</span>, <span class="hljs-keyword">short</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>, Map&lt;TopicPartition,MemoryRecords&gt;, Function1&lt;Map&lt;TopicPartition,PartitionResponse&gt;,BoxedUnit&gt;, Option&lt;Lock&gt;, Function1&lt;Map&lt;TopicPartition,RecordsProcessingStats&gt;,BoxedUnit&gt;) line: <span class="hljs-number">458</span>KafkaApis.handleProduceRequest(RequestChannel$Request) line: <span class="hljs-number">460</span>KafkaApis.handle(RequestChannel$Request) line: <span class="hljs-number">100</span>KafkaRequestHandler.run() line: <span class="hljs-number">65</span>KafkaThread(Thread).run() line: <span class="hljs-number">748</span>LeaderEpochFileCache$$anonfun$assign$<span class="hljs-number">1</span>.apply$mcV$sp() line: <span class="hljs-number">62</span>LeaderEpochFileCache$$anonfun$assign$<span class="hljs-number">1</span>.apply() line: <span class="hljs-number">61</span>LeaderEpochFileCache$$anonfun$assign$<span class="hljs-number">1</span>.apply() line: <span class="hljs-number">61</span>CoreUtils$.inLock(Lock, Function0&lt;T&gt;) line: <span class="hljs-number">217</span>CoreUtils$.inWriteLock(ReadWriteLock, Function0&lt;T&gt;) line: <span class="hljs-number">225</span>LeaderEpochFileCache.assign(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">long</span>) line: <span class="hljs-number">60</span>Log$$anonfun$append$<span class="hljs-number">2</span>$$anonfun$apply$<span class="hljs-number">9</span>.apply(MutableRecordBatch) line: <span class="hljs-number">689</span>Log$$anonfun$append$<span class="hljs-number">2</span>$$anonfun$apply$<span class="hljs-number">9</span>.apply(Object) line: <span class="hljs-number">687</span>Iterator$class.foreach(Iterator, Function1) line: 891Wrappers$JIteratorWrapper&lt;A&gt;(AbstractIterator&lt;A&gt;).foreach(Function1&lt;A,U&gt;) line: <span class="hljs-number">1334</span>IterableLike$class.foreach(IterableLike, Function1) line: 72Wrappers$JIterableWrapper&lt;A&gt;(AbstractIterable&lt;A&gt;).foreach(Function1&lt;A,U&gt;) line: <span class="hljs-number">54</span>Log$$anonfun$append$<span class="hljs-number">2</span>.apply() line: <span class="hljs-number">687</span>Log$$anonfun$append$<span class="hljs-number">2</span>.apply() line: <span class="hljs-number">624</span>Log.maybeHandleIOException(Function0&lt;String&gt;, Function0&lt;T&gt;) line: <span class="hljs-number">1669</span>Log.append(MemoryRecords, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">624</span>Log.appendAsFollower(MemoryRecords) line: <span class="hljs-number">607</span>ReplicaFetcherThread.processPartitionData(TopicPartition, <span class="hljs-keyword">long</span>, ReplicaFetcherThread$PartitionData) line: <span class="hljs-number">123</span>ReplicaFetcherThread.processPartitionData(TopicPartition, <span class="hljs-keyword">long</span>, AbstractFetcherThread$PartitionData) line: <span class="hljs-number">62</span>AbstractFetcherThread$$anonfun$processFetchRequest$<span class="hljs-number">2</span>$$anonfun$apply$mcV$sp$<span class="hljs-number">1</span>$$anonfun$apply$<span class="hljs-number">2</span>.apply(PartitionFetchState) line: <span class="hljs-number">184</span>AbstractFetcherThread$$anonfun$processFetchRequest$<span class="hljs-number">2</span>$$anonfun$apply$mcV$sp$<span class="hljs-number">1</span>$$anonfun$apply$<span class="hljs-number">2</span>.apply(Object) line: <span class="hljs-number">172</span>Some&lt;A&gt;(Option&lt;A&gt;).foreach(Function1&lt;A,U&gt;) line: <span class="hljs-number">257</span>AbstractFetcherThread$$anonfun$processFetchRequest$<span class="hljs-number">2</span>$$anonfun$apply$mcV$sp$<span class="hljs-number">1</span>.apply(Tuple2&lt;TopicPartition,PartitionData&gt;) line: <span class="hljs-number">172</span>AbstractFetcherThread$$anonfun$processFetchRequest$<span class="hljs-number">2</span>$$anonfun$apply$mcV$sp$<span class="hljs-number">1</span>.apply(Object) line: <span class="hljs-number">169</span>ResizableArray$class.foreach(ResizableArray, Function1) line: 59ArrayBuffer&lt;A&gt;.foreach(Function1&lt;A,U&gt;) line: <span class="hljs-number">48</span>AbstractFetcherThread$$anonfun$processFetchRequest$<span class="hljs-number">2</span>.apply$mcV$sp() line: <span class="hljs-number">169</span>AbstractFetcherThread$$anonfun$processFetchRequest$<span class="hljs-number">2</span>.apply() line: <span class="hljs-number">169</span>AbstractFetcherThread$$anonfun$processFetchRequest$<span class="hljs-number">2</span>.apply() line: <span class="hljs-number">169</span>CoreUtils$.inLock(Lock, Function0&lt;T&gt;) line: <span class="hljs-number">217</span>ReplicaFetcherThread(AbstractFetcherThread).processFetchRequest(AbstractFetcherThread$FetchRequest) line: <span class="hljs-number">167</span>ReplicaFetcherThread(AbstractFetcherThread).doWork() line: <span class="hljs-number">113</span>ReplicaFetcherThread(ShutdownableThread).run() line: <span class="hljs-number">64</span>ReplicaFetcherThread.fetchEpochsFromLeader(Map&lt;TopicPartition,Object&gt;) line: <span class="hljs-number">332</span>ReplicaFetcherThread(AbstractFetcherThread).maybeTruncate() line: <span class="hljs-number">130</span>ReplicaFetcherThread(AbstractFetcherThread).doWork() line: <span class="hljs-number">102</span>ReplicaFetcherThread(ShutdownableThread).run() line: <span class="hljs-number">64</span>   kafka.server.ReplicaManager.lastOffsetForLeaderEpoch    kafka.server.ReplicaFetcherThread.maybeTruncate(fetchedEpochs: Map[TopicPartition, EpochEndOffset])    kafka.server.ReplicaFetcherThread.handleOffsetOutOfRange(topicPartition: TopicPartition)    kafka.server.ReplicaFetcherThread.maybeTruncate(fetchedEpochs: Map[TopicPartition, EpochEndOffset])</code></pre>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>kafka1.0源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka-clients 1.0 高阶API消费消息(未完)</title>
    <link href="/2020/04/22/kafka1-0-clietns-consmer-high-level/"/>
    <url>/2020/04/22/kafka1-0-clietns-consmer-high-level/</url>
    
    <content type="html"><![CDATA[<h2 id="消费消息的请求-按序"><a href="#消费消息的请求-按序" class="headerlink" title="消费消息的请求(按序)"></a>消费消息的请求(按序)</h2><ul><li>org/apache/kafka/common/requests/RequestHeader  </li><li>org/apache/kafka/common/requests/ApiVersionsRequest  </li><li>org/apache/kafka/common/requests/MetadataRequest  批量查询topic的元数据信息  </li><li>org/apache/kafka/common/requests/FindCoordinatorRequest    从拿到的topic的元数据中取出leader节点 作为组协调者  </li><li>org/apache/kafka/common/requests/JoinGroupRequest  </li><li>org/apache/kafka/common/requests/SyncGroupRequest  </li><li>org/apache/kafka/common/requests/OffsetFetchRequest  </li><li>org/apache/kafka/common/requests/ListOffsetRequest  </li><li>org/apache/kafka/common/requests/FetchRequest  </li><li>org/apache/kafka/common/requests/HeartbeatRequest   </li></ul><p><a href="https://www.cnblogs.com/simoncook/p/11317367.html" target="_blank" rel="noopener">请求接口文档参考</a><br><a href="https://www.cnblogs.com/simoncook/p/11317477.html" target="_blank" rel="noopener">响应接口文档参考</a>  </p><h2 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="RequestHeader"></a>RequestHeader</h2><p>请求头  </p><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>api_key</td><td>INT16</td><td>null</td><td>请求接口编号</td></tr><tr><td>api_version</td><td>INT16</td><td>null</td><td>api版本</td></tr><tr><td>correlation_id</td><td>INT32</td><td>null</td><td>用户提供的一个整数id，用于响应时由响应体带回来</td></tr><tr><td>client_id</td><td>NULLABLE_STRING</td><td>null</td><td>用户提供的client id</td></tr></table>  <h2 id="ApiVersionsRequest"><a href="#ApiVersionsRequest" class="headerlink" title="ApiVersionsRequest"></a>ApiVersionsRequest</h2><p>查询API版本信息  </p><h3 id="请求-version-1"><a href="#请求-version-1" class="headerlink" title="请求 version:1"></a>请求 version:1</h3><p>仅仅有请求头  </p><h3 id="响应-version-1"><a href="#响应-version-1" class="headerlink" title="响应 version:1"></a>响应 version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>错误码</td></tr><tr><td>api_versions</td><td>ARRAY({api_key:INT16,min_version:INT16,max_version:INT16})</td><td>null</td><td>broker能支持的api各版本列表。含最低版本，最高版本.</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>由于配额冲突而阻止请求的持续时间（毫秒）（如果请求未违反任何配额，则为零</td></tr></table>  <p>虽是请求broker端，但是实际还是用的client中的API完成的逻辑：<br>ApiVersionsResponse.apiVersionsResponse<br>根据<code>messageFormatVersion</code> 消息格式版本推导出各API版本情况。<br>API版本 最小的是0 。写的固定的。  最大的是 requestSchemas的length -1 即requestSchemas最大版本。<br>此处不仅返回每个API的最小版本与最大版本，还返回能支持的API列表。如因版本问题不能支持的API是不会返回的。<br>能否支持的判断依据是，API依赖的最小消息格式版本小于当前的消息格式版本，那么就支持。  </p><pre><code class="hljs java"><span class="hljs-keyword">for</span> (ApiKeys apiKey : ApiKeys.values()) &#123;    <span class="hljs-keyword">if</span> (apiKey.minRequiredInterBrokerMagic &lt;= minMagic) &#123;        versionList.add(neApiVersionsResponse.ApiVersion(apiKey));    &#125;&#125;</code></pre><h2 id="MetadataRequest"><a href="#MetadataRequest" class="headerlink" title="MetadataRequest"></a>MetadataRequest</h2><p>批量查询topic的元数据信息  </p><h3 id="请求-version-5"><a href="#请求-version-5" class="headerlink" title="请求 version:5"></a>请求 version:5</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>topics</td><td>ARRAY(STRING)</td><td>null</td><td>需要查元数据的topic的列表，如果不送则查所有topic的元数据</td></tr><tr><td>allow_auto_topic_creation</td><td>BOOLEAN</td><td>null</td><td>在broker配置了允许自动创建topic时是否自动创建topic</td></tr></table>  <h3 id="响应-version-4"><a href="#响应-version-4" class="headerlink" title="响应 version:4"></a>响应 version:4</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>由于配额冲突而阻止请求的持续时间（毫秒）（如果请求未违反任何配额，则为零）</td></tr><tr><td>brokers</td><td>ARRAY({node_id:INT32,host:STRING,port:INT32,rack:NULLABLE_STRING})</td><td>null</td><td>所有 活着的 broker的id ip port的信息</td></tr><tr><td>cluster_id</td><td>NULLABLE_STRING</td><td>null</td><td>集群id</td></tr><tr><td>controller_id</td><td>INT32</td><td>null</td><td>controller角色的broker的id</td></tr><tr><td>topic_metadata</td><td>ARRAY({error_code:INT16,topic:STRING,is_internal:BOOLEAN,partition_metadata:ARRAY({error_code:INT16,partition:INT32,leader:INT32,replicas:ARRAY(INT32),isr:ARRAY(INT32)})})</td><td>null</td><td>topic元数据，分区数、leader broker的id、副本所在broker id列表、isr broker id列表</td></tr></table>  <p>broker端处理<br>在broker端   </p><ol><li>过滤出授权的topics KafkaApis.handleTopicMetadataRequest  </li><li>查询出授权topics的元数据  KafkaApis.getTopicMetadata  </li><li>1 从缓存中拿，拿到(跟topics的size相同)即返回  </li><li>2 处理没拿到的topic  </li><li>2.1 允许创建topic的，就按默认副本数和默认分区数创建，不能创建的或者创建出错的返回出错信息。创建topic前提是协调者可用。否则COORDINATOR_NOT_AVAILABLE。  </li><li>2.2 返回创建后的metadata<br>元数据信息有缓存 <code>kafka.server.MetadataCache.cache</code>：topic &lt;–&gt; [partitionNo &lt;–&gt; 分区状态封装]<br><code>MetadataCache</code>中一系列getxxx方法都是用来读取检索的。<br>元数据缓存的更新参见 《MetadataCache更新》  </li></ol><h2 id="FindCoordinatorRequest"><a href="#FindCoordinatorRequest" class="headerlink" title="FindCoordinatorRequest"></a>FindCoordinatorRequest</h2><p>查询协调者  </p><h3 id="请求-version-1-1"><a href="#请求-version-1-1" class="headerlink" title="请求 version:1"></a>请求 version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>coordinator_key</td><td>STRING</td><td>null</td><td>组协调时是组id<br>事务协调时是事务id</td></tr><tr><td>coordinator_type</td><td>INT8</td><td>null</td><td>协调类型(0 = group, 1 = transaction)</td></tr></table>  <h3 id="响应-version-1-1"><a href="#响应-version-1-1" class="headerlink" title="响应 version:1"></a>响应 version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>error_message</td><td>NULLABLE_STRING</td><td>null</td><td>Response error message</td></tr><tr><td>coordinator</td><td>{node_id:INT32,host:STRING,port:INT32}</td><td>null</td><td>协调者broker的id ip port</td></tr></table>  <p>组协调与事务协调都用这个请求<br>coordinatorKey 组协调是组id  事务协调时是事务id<br>分区对应的leader节点就是组协调者  </p><pre><code class="hljs scala"><span class="hljs-keyword">val</span> coordinatorEndpoint = topicMetadata.partitionMetadata.asScala   .find(_.partition == partition)   .map(_.leader) <span class="hljs-comment">// SimonNote: leader节点作为协调者</span></code></pre><p>这个请求的响应也就是将协调者信息(node_id，host，port)返回去  </p><h2 id="JoinGroupRequest"><a href="#JoinGroupRequest" class="headerlink" title="JoinGroupRequest"></a>JoinGroupRequest</h2><p>加入消费组的请求  </p><h3 id="请求-version-2"><a href="#请求-version-2" class="headerlink" title="请求 version:2"></a>请求 version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>唯一的组标志</td></tr><tr><td>session_timeout</td><td>INT32</td><td>null</td><td>会话时间，超过这个时间没收到心跳，协调者就认为这个消费者挂了</td></tr><tr><td>rebalance_timeout</td><td>INT32</td><td>null</td><td>协调者在重新平衡组时等待每个成员重新加入的最长时间</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>由组协调者分配的成员ID，如果是第一次加入，则为空。</td></tr><tr><td>protocol_type</td><td>STRING</td><td>null</td><td>组协调协议实现类的唯一名称</td></tr><tr><td>group_protocols</td><td>ARRAY({protocol_name:STRING,protocol_metadata:BYTES})</td><td>null</td><td>组成员能支持的组协调协议列表</td></tr></table>  <h3 id="响应-version-2"><a href="#响应-version-2" class="headerlink" title="响应 version:2"></a>响应 version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>generation_id</td><td>INT32</td><td>null</td><td>组的年代？</td></tr><tr><td>group_protocol</td><td>STRING</td><td>null</td><td>协调者选中的组协议</td></tr><tr><td>leader_id</td><td>STRING</td><td>null</td><td>组中的leader</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>第一次加入的时候组协调者给分的成员id</td></tr><tr><td>members</td><td>ARRAY({member_id:STRING,member_metadata:BYTES})</td><td>null</td><td>组内成员？</td></tr></table>  <h3 id="kafka-coordinator-group-GroupCoordinator-handleJoinGroup"><a href="#kafka-coordinator-group-GroupCoordinator-handleJoinGroup" class="headerlink" title="kafka.coordinator.group.GroupCoordinator.handleJoinGroup"></a>kafka.coordinator.group.GroupCoordinator.handleJoinGroup</h3><h4 id="一系列的check"><a href="#一系列的check" class="headerlink" title="一系列的check:"></a>一系列的check:</h4><ol><li>协调者是否可用   </li><li>是否是本分区的协调者   </li><li>消费组id是否合法(是否为空)    </li><li>是否协调者正在load中，<code>GroupMetadataManager</code>会管理当前partition是否在load中  </li><li>sessionTimeoutMs是否在组配置的最大最小范围内  </li></ol><p>向<code>groupManager</code>加入新建的<code>GroupMetadata</code>实例(如果没有的话，有就直接下一步了),<code>GroupMetadata</code>有哪些东西，下面注释写了一部分，但是还包含事务消息用一些offset   </p><pre><code class="hljs scala"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Group contains the following metadata:</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *  Membership metadata:</span><span class="hljs-comment"> *  1. Members registered in this group</span><span class="hljs-comment"> *  2. Current protocol assigned to the group (e.g. partition assignment strategy for consumers)</span><span class="hljs-comment"> *  3. Protocol metadata associated with group members</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *  State metadata:</span><span class="hljs-comment"> *  1. group state</span><span class="hljs-comment"> *  2. generation id</span><span class="hljs-comment"> *  3. leader id</span><span class="hljs-comment"> */</span></code></pre><h4 id="doJoinGroup"><a href="#doJoinGroup" class="headerlink" title="doJoinGroup"></a><code>doJoinGroup</code></h4><p>一系列的check后，根据<code>group.currentState</code>做相应处理<br><code>group.currentState</code>  </p><p><code>GroupMetadata.scala</code>中有对group状态定义及action及走向到哪的明确详细描述，<strong>非常重要</strong>     </p><h2 id="SyncGroupRequest"><a href="#SyncGroupRequest" class="headerlink" title="SyncGroupRequest"></a>SyncGroupRequest</h2><h3 id="请求-version-1-2"><a href="#请求-version-1-2" class="headerlink" title="请求 version:1"></a>请求 version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>group唯一标志</td></tr><tr><td>generation_id</td><td>INT32</td><td>null</td><td>代的标志？</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>第一次加入的时候组协调者给分的成员id</td></tr><tr><td>group_assignment</td><td>ARRAY({member_id:STRING,member_assignment:BYTES})</td><td>null</td><td>null</td></tr></table>  <h3 id="响应-version-1-2"><a href="#响应-version-1-2" class="headerlink" title="响应 version:1"></a>响应 version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>member_assignment</td><td>BYTES</td><td>null</td><td>null</td></tr></table>  <h2 id="OffsetFetchRequest"><a href="#OffsetFetchRequest" class="headerlink" title="OffsetFetchRequest"></a>OffsetFetchRequest</h2><h3 id="请求-version-3"><a href="#请求-version-3" class="headerlink" title="请求 version:3"></a>请求 version:3</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>group id</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32})})</td><td>null</td><td>topic列表，支持多个topic</td></tr></table>  <h3 id="响应-version-3"><a href="#响应-version-3" class="headerlink" title="响应 version:3"></a>响应 version:3</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition:INT32,offset:INT64,metadata:NULLABLE_STRING,error_code:INT16})})</td><td>null</td><td>列表：topic-[{分区号-offset，元数据信息}]</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr></table>  <h2 id="ListOffsetRequest"><a href="#ListOffsetRequest" class="headerlink" title="ListOffsetRequest"></a>ListOffsetRequest</h2><h3 id="请求-version-2-1"><a href="#请求-version-2-1" class="headerlink" title="请求 version:2"></a>请求 version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>replica_id</td><td>INT32</td><td>null</td><td>follower的broker的id. 正常消费用-1.</td></tr><tr><td>isolation_level</td><td>INT8</td><td>null</td><td>事务消息可见性设置。 使用 READ_UNCOMMITTED (isolation_level = 0)能看到所有消息. 使用 READ_COMMITTED (isolation_level = 1), 非事务消息和已经提交的消息能被看到. 更具体一点, READ_COMMITTED 返回比当前 LSO (last stable offset)小的offset, 并允许返回已经取消的事务</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,timestamp:INT64})})</td><td>null</td><td>列表：topic,partitions{分区号，时间戳}</td></tr></table>  <h3 id="响应-version-2-1"><a href="#响应-version-2-1" class="headerlink" title="响应 version:2"></a>响应 version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition:INT32,error_code:INT16,timestamp:INT64,offset:INT64})})</td><td>null</td><td>列表：topic 分区号 错误码 时间戳 offset</td></tr></table> <h2 id="FetchRequest"><a href="#FetchRequest" class="headerlink" title="FetchRequest"></a>FetchRequest</h2><h3 id="请求-version-6"><a href="#请求-version-6" class="headerlink" title="请求 version:6"></a>请求 version:6</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>replica_id</td><td>INT32</td><td>null</td><td>follower的broker的id. 正常消费用-1</td></tr><tr><td>max_wait_time</td><td>INT32</td><td>null</td><td>等待响应的最大时间 单位ms.</td></tr><tr><td>min_bytes</td><td>INT32</td><td>null</td><td>最小字节</td></tr><tr><td>max_bytes</td><td>INT32</td><td>null</td><td>最大字节. 单条消息如果超过这个大小也将返回</td></tr><tr><td>isolation_level</td><td>INT8</td><td>null</td><td>事务隔离级别</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,fetch_offset:INT64,log_start_offset:INT64,max_bytes:INT32})})</td><td>null</td><td>列表： topic 分区号 取的offset log开始的 offset？？ 最大字节.</td></tr></table>  <h3 id="响应-version-6"><a href="#响应-version-6" class="headerlink" title="响应 version:6"></a>响应 version:6</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition_header:{partition:INT32,error_code:INT16,high_watermark:INT64,last_stable_offset:INT64,log_start_offset:INT64,aborted_transactions:ARRAY({producer_id:INT64,first_offset:INT64})},record_set:RECORDS})})</td><td>null</td><td>列表： topic 分区头: 分区号 高水位值 LSO(上次稳定offset)， log开始offset，取消事务：生产者id 第一个offset。 消息记录集</td></tr></table>  <h2 id="HeartbeatRequest"><a href="#HeartbeatRequest" class="headerlink" title="HeartbeatRequest"></a>HeartbeatRequest</h2><h3 id="请求-version-1-3"><a href="#请求-version-1-3" class="headerlink" title="请求 version:1"></a>请求 version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>group id</td></tr><tr><td>generation_id</td><td>INT32</td><td>null</td><td>group的年代</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>第一次加入的时候组协调者给分的成员id</td></tr></table>  <h3 id="响应-version-1-3"><a href="#响应-version-1-3" class="headerlink" title="响应 version:1"></a>响应 version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>响应码</td></tr></table>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>kafka1.0源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clients-producer-组包发送消息</title>
    <link href="/2020/04/22/kafka1-0-clietns-producer-semd-message/"/>
    <url>/2020/04/22/kafka1-0-clietns-producer-semd-message/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img2018.cnblogs.com/blog/127449/201911/127449-20191106232751318-1568618563.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>kafka1.0源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clients-producer-网络处理与请求响应对接部分</title>
    <link href="/2020/04/22/kafka1-0-clietns-producer/"/>
    <url>/2020/04/22/kafka1-0-clietns-producer/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img2018.cnblogs.com/blog/127449/201911/127449-20191106232834484-481719301.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>kafka1.0源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JMX基本概念</title>
    <link href="/2020/04/22/jmx-basic/"/>
    <url>/2020/04/22/jmx-basic/</url>
    
    <content type="html"><![CDATA[<h3 id="Object-name的语法"><a href="#Object-name的语法" class="headerlink" title="Object name的语法"></a>Object name的语法</h3><ol><li>形似 com.sun.someapp:type=Whatsit,name=25  </li><li>com.sun.someapp 是domain，冒号后面的是key-property-list，每组kv的顺序随意，但是不能有空格，空格字符有特殊含义，不能有冒号。domain名不能含有冒号，不能含有/。  </li><li>key-property-list中的key支持<em>和？somedomain:type=Thread,</em>   </li><li>支持逗号连接多个值作为条件，com.sun.someapp:type=Whatsit,name=”25,26”  </li><li>整个Object name大小写敏感  </li><li>Object name预定之一 用java package的形式开头来命名  </li><li>每个对象名应该包含一个type= key 属性.<br>具体可以参见官方文档<a href="https://www.oracle.com/technetwork/java/javase/tech/best-practices-jsp-136021.html" target="_blank" rel="noopener">Java Management Extensions (JMX) - Best Practices</a></li></ol><h3 id="四种bean概念"><a href="#四种bean概念" class="headerlink" title="四种bean概念"></a>四种bean概念</h3><p>JMX标准提供了四种不同的 MBean：</p><ol><li>Standard MBean<br>Standard MBean是JMX管理构件中最简单的一种，只需要开发一个MBean接口（为了实现Standard MBean，必须遵循一套继承规范。必须<strong>每一个MBean定义一个接口</strong>，而且这个接口的名字必须是其被管理的资源的对象类的名称后面加上”MBean”），一个实现MBean接口的类，并且把它们注册到MBeanServer中就可以了。</li><li>Dynamic MBean<br>不再需要为没个bean定义接口了，可以实现javax.management.DynamicMBean做成通用的。tomcat大量使用。 用属性访问器动态地访问属性，并用一个一般化的 invoke() 方法调用方法。可用的方法是在 MBeanInfo 接口中指定的。这种方式更灵活，但是不具有像 Standard MBean 那样的类型安全性。它极大地降低了耦合性，可管理的 POJO（纯粹的老式 Java 对象）不需要实现特定的接口。</li><li>Model MBean<br>配合javax.management.modelmbean.RequiredModelMBean使用。提供了一个改进的抽象层，并扩展了 Dynamic MBean 模型以进一步减少对给定实现的依赖性。这对于可能使用多个版本的 JVM 或者需要用松散耦合管理第三方类的情况会有帮助。Dynamic MBean 与 Model MBean 之间的主要区别是，在 Model MBean 中有额外的元数据。</li><li>Open MBean<br>是受限的 Model MBean，它限制类型为固定的一组类型，以得到最大的可移植性。通过限制数据类型，可以使用更多的适配器，并且像 SMTP 这样的技术可以更容易适应 Java 应用程序的管理。这种变体还指定了数组和表等标准结构以改进复合对象的管理。</li></ol><h3 id="四种bean示例"><a href="#四种bean示例" class="headerlink" title="四种bean示例"></a>四种bean示例</h3><h4 id="Standard-MBean-示例"><a href="#Standard-MBean-示例" class="headerlink" title="Standard MBean 示例"></a>Standard MBean 示例</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> test;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.lang.management.ManagementFactory;<span class="hljs-keyword">import</span> javax.management.InstanceAlreadyExistsException;<span class="hljs-keyword">import</span> javax.management.MBeanRegistrationException;<span class="hljs-keyword">import</span> javax.management.MBeanServer;<span class="hljs-keyword">import</span> javax.management.MBeanServerFactory;<span class="hljs-keyword">import</span> javax.management.MalformedObjectNameException;<span class="hljs-keyword">import</span> javax.management.NotCompliantMBeanException;<span class="hljs-keyword">import</span> javax.management.ObjectName;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2019-11-16</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JMXMBeanTest</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> args</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> MalformedObjectNameException</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NotCompliantMBeanException</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> MBeanRegistrationException</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InstanceAlreadyExistsException</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MalformedObjectNameException, InstanceAlreadyExistsException,</span><span class="hljs-function">MBeanRegistrationException, NotCompliantMBeanException, IOException </span>&#123;MBeanServer mBeanServer = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (MBeanServerFactory.findMBeanServer(<span class="hljs-keyword">null</span>).size() &gt; <span class="hljs-number">0</span>) &#123;mBeanServer = MBeanServerFactory.findMBeanServer(<span class="hljs-keyword">null</span>).get(<span class="hljs-number">0</span>);&#125; <span class="hljs-keyword">else</span> &#123;mBeanServer = ManagementFactory.getPlatformMBeanServer();&#125;ObjectName jmxObjectName = <span class="hljs-keyword">new</span> ObjectName(<span class="hljs-string">"jxmstudy:name=HelloWord"</span>);Hello hello = <span class="hljs-keyword">new</span> Hello();hello.setName(<span class="hljs-string">"Simon"</span>);mBeanServer.registerMBean(hello, jmxObjectName);System.in.read();&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloMBean</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HelloMBean</span> </span>&#123;<span class="hljs-keyword">private</span> String name;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;&#125;&#125;</code></pre><h4 id="Dynamic-MBean示例"><a href="#Dynamic-MBean示例" class="headerlink" title="Dynamic MBean示例"></a>Dynamic MBean示例</h4><p>可以用 commons-modeler-2.0.1.jar完成，也可以参见tomcat的代码<br>具体做法是用配置文件描述mbean定义，然后走一个他自己开发的mbean公共机制完成注册，比如 org/apache/catalina/connector/mbeans-descriptors.xml 就是tomcat连接器jmx bean的描述。它有很多mbeans-descriptors.xml配置文件，针对不同组件各组件一个。<br><a href="https://www.iteye.com/blog/tyrion-2065129" target="_blank" rel="noopener">Tomcat7中的JMX使用（二）Dynamic MBean</a> 这篇文章分析了。  </p><h4 id="Model-MBean示例"><a href="#Model-MBean示例" class="headerlink" title="Model MBean示例"></a>Model MBean示例</h4><blockquote><p>————————————————<br>版权声明：本文为CSDN博主「朱小厮」的原创文章，遵循 CC 4.0 BY-SA   版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/u013256816/article/details/52817247" target="_blank" rel="noopener">https://blog.csdn.net/u013256816/article/details/52817247</a>  </p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.jmx.modelBean;<span class="hljs-keyword">import</span> javax.management.*;<span class="hljs-keyword">import</span> javax.management.modelmbean.*;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Created by hidden on 2016/10/9.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModelMBeanUtils</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> READABLE = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> WRITABLE = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> BOOLEAN = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String STRING_CLASS = <span class="hljs-string">"java.lang.String"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequiredModelMBean <span class="hljs-title">createModelerMBean</span><span class="hljs-params">()</span> </span>&#123;        RequiredModelMBean model = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            model = <span class="hljs-keyword">new</span> RequiredModelMBean();            model.setManagedResource(<span class="hljs-keyword">new</span> Hello(), <span class="hljs-string">"ObjectReference"</span>);            ModelMBeanInfo info = createModelMBeanInfo();            model.setModelMBeanInfo(info);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> model;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ModelMBeanInfo <span class="hljs-title">createModelMBeanInfo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//////////////////////////////////////////////////////////////////</span>        <span class="hljs-comment">//                        属性                                        //</span>        <span class="hljs-comment">//////////////////////////////////////////////////////////////////</span>        <span class="hljs-comment">// 构造name属性信息</span>        Descriptor portAttrDesc = <span class="hljs-keyword">new</span> DescriptorSupport();        portAttrDesc.setField(<span class="hljs-string">"name"</span>, <span class="hljs-string">"Name"</span>);        portAttrDesc.setField(<span class="hljs-string">"descriptorType"</span>, <span class="hljs-string">"attribute"</span>);        portAttrDesc.setField(<span class="hljs-string">"displayName"</span>, <span class="hljs-string">"Name"</span>);        portAttrDesc.setField(<span class="hljs-string">"getMethod"</span>, <span class="hljs-string">"getName"</span>);        portAttrDesc.setField(<span class="hljs-string">"setMethod"</span>, <span class="hljs-string">"setName"</span>);        ModelMBeanAttributeInfo nameAttrInfo = <span class="hljs-keyword">new</span> ModelMBeanAttributeInfo(<span class="hljs-comment">//</span>                <span class="hljs-string">"Name"</span>, <span class="hljs-comment">// 属性名</span>                STRING_CLASS, <span class="hljs-comment">//属性类型</span>                <span class="hljs-string">"people name"</span>, <span class="hljs-comment">// 描述文字</span>                READABLE, WRITABLE, !BOOLEAN, <span class="hljs-comment">// 读写</span>                portAttrDesc <span class="hljs-comment">// 属性描述</span>        );        <span class="hljs-comment">//////////////////////////////////////////////////////////////////</span>        <span class="hljs-comment">//                        方法                                        //</span>        <span class="hljs-comment">//////////////////////////////////////////////////////////////////</span>        <span class="hljs-comment">// 构造 getName操作描述符信息</span>        Descriptor getStateDesc = <span class="hljs-keyword">new</span> DescriptorSupport(<span class="hljs-keyword">new</span> String[] &#123;                <span class="hljs-string">"name=getName"</span>,                <span class="hljs-string">"descriptorType=operation"</span>,                <span class="hljs-string">"class=com.test.jmx.modelBean.Hello"</span>,                <span class="hljs-string">"role=operation"</span>        &#125;);        ModelMBeanOperationInfo getName = <span class="hljs-keyword">new</span> ModelMBeanOperationInfo(<span class="hljs-comment">//</span>                <span class="hljs-string">"getName"</span>, <span class="hljs-comment">//</span>                <span class="hljs-string">"get name attribute"</span>, <span class="hljs-comment">//</span>                <span class="hljs-keyword">null</span>, <span class="hljs-comment">//</span>                <span class="hljs-string">"java.lang.String"</span>, <span class="hljs-comment">//</span>                MBeanOperationInfo.ACTION, <span class="hljs-comment">//</span>                getStateDesc <span class="hljs-comment">//</span>        );        <span class="hljs-comment">// 构造 setName操作描述符信息</span>        Descriptor setStateDesc = <span class="hljs-keyword">new</span> DescriptorSupport(<span class="hljs-keyword">new</span> String[] &#123;                <span class="hljs-string">"name=setName"</span>, <span class="hljs-string">"descriptorType=operation"</span>, <span class="hljs-string">"class=com.test.jmx.modelBean.Hello"</span>,                <span class="hljs-string">"role=operation"</span> &#125;);        MBeanParameterInfo[] setStateParms = <span class="hljs-keyword">new</span> MBeanParameterInfo[] &#123; (<span class="hljs-keyword">new</span> MBeanParameterInfo(                <span class="hljs-string">"name"</span>, <span class="hljs-string">"java.lang.String"</span>, <span class="hljs-string">"new name value"</span>)) &#125;;        ModelMBeanOperationInfo setName = <span class="hljs-keyword">new</span> ModelMBeanOperationInfo(<span class="hljs-comment">//</span>                <span class="hljs-string">"setName"</span>, <span class="hljs-comment">//</span>                <span class="hljs-string">"set name attribute"</span>, <span class="hljs-comment">//</span>                setStateParms, <span class="hljs-comment">//</span>                <span class="hljs-string">"void"</span>, <span class="hljs-comment">//</span>                MBeanOperationInfo.ACTION, <span class="hljs-comment">//</span>                setStateDesc <span class="hljs-comment">//</span>        );        <span class="hljs-comment">//构造 printHello()操作的信息</span>        ModelMBeanOperationInfo print1Info = <span class="hljs-keyword">new</span> ModelMBeanOperationInfo(<span class="hljs-comment">//</span>                <span class="hljs-string">"printHello"</span>, <span class="hljs-comment">//</span>                <span class="hljs-keyword">null</span>, <span class="hljs-comment">//</span>                <span class="hljs-keyword">null</span>, <span class="hljs-comment">//</span>                <span class="hljs-string">"void"</span>, <span class="hljs-comment">//</span>                MBeanOperationInfo.INFO, <span class="hljs-comment">//</span>                <span class="hljs-keyword">null</span> <span class="hljs-comment">//</span>        );        <span class="hljs-comment">// 构造printHello(String whoName)操作信息</span>        ModelMBeanOperationInfo print2Info;        MBeanParameterInfo[] param2 = <span class="hljs-keyword">new</span> MBeanParameterInfo[<span class="hljs-number">1</span>];        param2[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> MBeanParameterInfo(<span class="hljs-string">"whoName"</span>, STRING_CLASS, <span class="hljs-string">"say hello to who"</span>);        print2Info = <span class="hljs-keyword">new</span> ModelMBeanOperationInfo(<span class="hljs-comment">//</span>                <span class="hljs-string">"printHello"</span>, <span class="hljs-comment">//</span>                <span class="hljs-keyword">null</span>,<span class="hljs-comment">//</span>                param2,<span class="hljs-comment">//</span>                <span class="hljs-string">"void"</span>, <span class="hljs-comment">//</span>                MBeanOperationInfo.INFO, <span class="hljs-comment">//</span>                <span class="hljs-keyword">null</span><span class="hljs-comment">//</span>        );        <span class="hljs-comment">//////////////////////////////////////////////////////////////////</span>        <span class="hljs-comment">//                        最后总合                                    //</span>        <span class="hljs-comment">//////////////////////////////////////////////////////////////////</span>        <span class="hljs-comment">// create ModelMBeanInfo</span>        ModelMBeanInfo mbeanInfo = <span class="hljs-keyword">new</span> ModelMBeanInfoSupport(<span class="hljs-comment">//</span>                RequiredModelMBean<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>(), // <span class="hljs-title">MBean</span>类</span><span class="hljs-class">                <span class="hljs-title">null</span>, // 描述文字</span>                new ModelMBeanAttributeInfo[] &#123; // 所有的属性信息（数组）                        nameAttrInfo &#125;,<span class="hljs-comment">//只有一个属性</span>                <span class="hljs-keyword">null</span>, <span class="hljs-comment">// 所有的构造函数信息</span>                <span class="hljs-keyword">new</span> ModelMBeanOperationInfo[] &#123; <span class="hljs-comment">// 所有的操作信息（数组）</span>                        getName,                        setName,                        print1Info,                        print2Info &#125;,<span class="hljs-comment">//</span>                <span class="hljs-keyword">null</span>, <span class="hljs-comment">// 所有的通知信息(本例无)</span>                <span class="hljs-keyword">null</span><span class="hljs-comment">//MBean描述</span>        );        <span class="hljs-keyword">return</span> mbeanInfo;    &#125;&#125;</code></pre><h3 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h3><p>简答配置如：<br>-Dcom.sun.management.jmxremote.port=8085<br>-Dcom.sun.management.jmxremote.ssl=false<br>-Dcom.sun.management.jmxremote.authenticate=false</p>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty之nio传输层</title>
    <link href="/2020/04/22/netty4-transport-nio/"/>
    <url>/2020/04/22/netty4-transport-nio/</url>
    
    <content type="html"><![CDATA[<h2 id="nio基本处理逻辑"><a href="#nio基本处理逻辑" class="headerlink" title="nio基本处理逻辑"></a>nio基本处理逻辑</h2><p><a href="https://images.cnblogs.com/cnblogs_com/simoncook/1602252/o_nio%E5%9F%BA%E6%9C%AC%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91.png" target="_blank" rel="noopener">查看这里</a><br><img src="https://images.cnblogs.com/cnblogs_com/simoncook/1602252/o_nio%E5%9F%BA%E6%9C%AC%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91.png" srcset="/img/loading.gif" alt="nio基本处理逻辑" />  </p><h2 id="Selector的处理"><a href="#Selector的处理" class="headerlink" title="Selector的处理"></a>Selector的处理</h2><h3 id="Selector实例构建"><a href="#Selector实例构建" class="headerlink" title="Selector实例构建"></a>Selector实例构建</h3><p>NioEventLoop.openSelector()方法先用JDK API构建出来的Selector再用反射将其中的selectedKeys、publicSelectedKeys替换成他优化过的SelectedSelectionKeySet实例。<br>JDK API构建出来的Selector 代码：  </p><pre><code class="hljs java"><span class="hljs-comment">// NioEventLoop</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SelectorProvider provider; <span class="hljs-comment">// SelectorProvider.provider() 直接用JDK提供的prodvider prodiver一下，在mac上返回值是sun.nio.ch.KQueueSelectorProvider@1b26f7b2 对应的selector实现是sun.nio.ch.KQueueSelectorImpl@23fe1d71</span>unwrappedSelector = provider.openSelector();<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SelectorTuple(unwrappedSelector,                                 <span class="hljs-keyword">new</span> SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));</code></pre><p>unwrappedSelector是指我们通常用JDK的API构建出来的Selector，实际netty使用的是经过他自己优化过的<code>SelectorTuple</code>。下面有分析<code>SelectorTuple</code>。 </p><p>用反射方法替换：<br>io.netty.channel.nio.NioEventLoop.openSelector() 用法反射的方式将netty声明的SelectedSelectionKeySet实例selectedKeySet (netty的SelectedSelectionKeySet类继承了java.util.AbstractSet)赋值给了selectorImplClass。因为SelectedSelectionKeySet更快，参见下面SelectorTuple分析部分。<br>selectorImplClass是什么呢？就是各平台的Selector的实现，netty是怎么获取的呢？<br>直接加载”sun.nio.ch.SelectorImpl”即可。<br>而且用这种方式替换完之后，每次select之后，只要处理(跌代理里面的key)刚才这个SelectedSelectionKeySet实例selectedKeys(selectedKeySet会赋值给selectedKeys)，这个实例也是NioEventLoop的实例变量。简单地说，每次select之后，选中的有事件的key就已经在<code>NioEventLoop</code>的实例变量<code>selectedKeys</code>字段中了。   </p><h3 id="SelectorTuple分析"><a href="#SelectorTuple分析" class="headerlink" title="SelectorTuple分析"></a>SelectorTuple分析</h3><p>SelectorTuple依靠<code>SelectedSelectionKeySetSelector</code>和<code>SelectedSelectionKeySet</code>完成优化，<code>SelectedSelectionKeySet</code>内部采用了==数组来替换了JDK实现中的hashset==来维护SelectionKey，提升了add reset 与迭代的效率。<strong>真是佩服</strong>！    </p><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectedSelectionKeySet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet</span>&lt;<span class="hljs-title">SelectionKey</span>&gt; </span>&#123;    SelectionKey[] keys;    <span class="hljs-keyword">int</span> size;<span class="hljs-comment">// ......</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(SelectionKey o)</span> </span>&#123;        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        keys[size++] = o;        <span class="hljs-keyword">if</span> (size == keys.length) &#123;            increaseCapacity();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;        Arrays.fill(keys, start, size, <span class="hljs-keyword">null</span>);        size = <span class="hljs-number">0</span>;    &#125;&#125;<span class="hljs-comment">// ...</span><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectedSelectionKeySetSelector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Selector</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SelectedSelectionKeySet selectionKeys;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Selector delegate;    SelectedSelectionKeySetSelector(Selector delegate, SelectedSelectionKeySet selectionKeys) &#123;        <span class="hljs-keyword">this</span>.delegate = delegate;        <span class="hljs-keyword">this</span>.selectionKeys = selectionKeys;    &#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectorTuple</span> </span>&#123;    <span class="hljs-keyword">final</span> Selector unwrappedSelector;    <span class="hljs-keyword">final</span> Selector selector;    SelectorTuple(Selector unwrappedSelector) &#123;        <span class="hljs-keyword">this</span>.unwrappedSelector = unwrappedSelector;        <span class="hljs-keyword">this</span>.selector = unwrappedSelector;    &#125;    SelectorTuple(Selector unwrappedSelector, Selector selector) &#123;        <span class="hljs-keyword">this</span>.unwrappedSelector = unwrappedSelector;        <span class="hljs-keyword">this</span>.selector = selector;    &#125;&#125;</code></pre><h2 id="ServerSocketChannel创建与初始化"><a href="#ServerSocketChannel创建与初始化" class="headerlink" title="ServerSocketChannel创建与初始化"></a>ServerSocketChannel创建与初始化</h2><h3 id="ServerSocketChannel创建过程"><a href="#ServerSocketChannel创建过程" class="headerlink" title="ServerSocketChannel创建过程"></a>ServerSocketChannel创建过程</h3><p>bind的时候会创建ServerSocketChannel，并丢给NioServerSocketChannel实例的ch字段<br>调用栈：  </p><pre><code class="hljs java">Thread [main] (Suspended (modification of field ch in AbstractNioChannel))io.netty.channel.socket.nio.NioServerSocketChannel(io.netty.channel.nio.AbstractNioChannel).&lt;init&gt;(io.netty.channel.Channel, java.nio.channels.SelectableChannel, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">85</span>io.netty.channel.socket.nio.NioServerSocketChannel(io.netty.channel.nio.AbstractNioMessageChannel).&lt;init&gt;(io.netty.channel.Channel, java.nio.channels.SelectableChannel, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">42</span>io.netty.channel.socket.nio.NioServerSocketChannel.&lt;init&gt;(java.nio.channels.ServerSocketChannel) line: <span class="hljs-number">88</span>io.netty.channel.socket.nio.NioServerSocketChannel.&lt;init&gt;() line: <span class="hljs-number">74</span>sun.reflect.NativeConstructorAccessorImpl.newInstance0(java.lang.reflect.Constructor&lt;?&gt;, java.lang.Object[]) line: not available [<span class="hljs-keyword">native</span> method]sun.reflect.NativeConstructorAccessorImpl.newInstance(java.lang.Object[]) line: <span class="hljs-number">62</span>sun.reflect.DelegatingConstructorAccessorImpl.newInstance(java.lang.Object[]) line: <span class="hljs-number">45</span>java.lang.reflect.Constructor&lt;T&gt;.newInstance(java.lang.Object...) line: <span class="hljs-number">423</span>io.netty.channel.ReflectiveChannelFactory&lt;T&gt;.newChannel() line: <span class="hljs-number">44</span>io.netty.bootstrap.ServerBootstrap(io.netty.bootstrap.AbstractBootstrap&lt;B,C&gt;).initAndRegister() line: <span class="hljs-number">320</span>io.netty.bootstrap.ServerBootstrap(io.netty.bootstrap.AbstractBootstrap&lt;B,C&gt;).doBind(java.net.SocketAddress) line: <span class="hljs-number">282</span>io.netty.bootstrap.ServerBootstrap(io.netty.bootstrap.AbstractBootstrap&lt;B,C&gt;).bind(java.net.SocketAddress) line: <span class="hljs-number">278</span>org.restexpress.RestExpress.bind(java.net.InetSocketAddress) line: <span class="hljs-number">709</span>org.restexpress.RestExpress.bind(java.lang.String, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">686</span>com.code260.ss.resetexpress.RestExpressApp1.main(java.lang.String[]) line: <span class="hljs-number">26</span></code></pre><h2 id="bind的处理"><a href="#bind的处理" class="headerlink" title="bind的处理"></a>bind的处理</h2><h3 id="AbstractBootstrap-doBind逻辑"><a href="#AbstractBootstrap-doBind逻辑" class="headerlink" title="AbstractBootstrap doBind逻辑"></a>AbstractBootstrap doBind逻辑</h3><p>NioServerSocketChannel类继承体系：  </p><pre><code class="hljs java"><span class="hljs-comment">// AttributeMap体系</span><span class="hljs-number">251</span> AttributeMap--<span class="hljs-number">251.2</span> DefaultAttributeMap----<span class="hljs-number">251.2</span><span class="hljs-number">.1</span> AbstractChannel------<span class="hljs-number">251.2</span><span class="hljs-number">.1</span><span class="hljs-number">.7</span> AbstractNioChannel--------<span class="hljs-number">251.2</span><span class="hljs-number">.1</span><span class="hljs-number">.7</span><span class="hljs-number">.1</span> AbstractNioMessageChannel----------<span class="hljs-number">251.2</span><span class="hljs-number">.1</span><span class="hljs-number">.7</span><span class="hljs-number">.1</span><span class="hljs-number">.5</span> NioServerSocketChannel<span class="hljs-comment">// Channel体系</span>--<span class="hljs-number">463.1</span> Channel----<span class="hljs-number">463.1</span><span class="hljs-number">.2</span> AbstractChannel  <span class="hljs-comment">// 与pipeline绑定。 构建时就会创建pipeline，newChannelPipeline。</span>------<span class="hljs-number">463.1</span><span class="hljs-number">.2</span><span class="hljs-number">.7</span> AbstractNioChannel  <span class="hljs-comment">// 支持多种不同实现的SelectableChannel，ServerSocketChannel与SocketChannel都是SelectableChannel的实现。支持构建AbstractNioChannel时指定感兴趣的事件(readInterestOp)并与该Channel实例绑定(会赋值给实例字段readInterestOp)，且在该类构造方法中将channel设置为非阻塞。可见，其意在Select的Channel与感兴趣的事件的封装  </span>--------<span class="hljs-number">463.1</span><span class="hljs-number">.2</span><span class="hljs-number">.7</span><span class="hljs-number">.1</span> AbstractNioMessageChannel <span class="hljs-comment">// 意在定义读写Message(其实就是消息对象，一个Object或者一组Object)接口。并对doWrite做了一些实现。</span>----------<span class="hljs-number">463.1</span><span class="hljs-number">.2</span><span class="hljs-number">.7</span><span class="hljs-number">.1</span><span class="hljs-number">.5</span> NioServerSocketChannel</code></pre><ol><li>initAndRegister并返回ChannelFuture实例，具体逻辑参见下面小节  </li><li>doBind0  交由boss线程去做真正bind动作</li></ol><h4 id="io-netty-bootstrap-AbstractBootstrap-initAndRegister-逻辑"><a href="#io-netty-bootstrap-AbstractBootstrap-initAndRegister-逻辑" class="headerlink" title="io.netty.bootstrap.AbstractBootstrap.initAndRegister()逻辑"></a>io.netty.bootstrap.AbstractBootstrap.initAndRegister()逻辑</h4><ol><li><strong>==创建Channel==</strong>，即<strong>==ServerSocketChannel==</strong>实例，并将值包装到netty自己封装的NioServerSocketChannel中。channel = channelFactory.newChannel();  </li><li><strong>==初始化channel==</strong>。init(channel);根据io.netty.bootstrap.AbstractBootstrap.options给Channel<strong>==配置一些参数==</strong>。server端chanel的参数有{SO_BACKLOG=1024, SO_REUSEADDR=true, CONNECT_TIMEOUT_MILLIS=10000, SO_RCVBUF=262140, RCVBUF_ALLOCATOR=io.netty.channel.AdaptiveRecvByteBufAllocator@17cdf2d0}。并在Channel对应的pipeline上<strong>==绑定ChannelInitializer==</strong>。  </li><li><strong>==注册Channel==</strong>，先 <strong>==选出一个Executor即NioEventLoop==</strong> ， 选的方法逻辑在io.netty.util.concurrent.DefaultEventExecutorChooserFactory$PowerOfTwoEventExecutorChooser@15cafec7  中 executors[idx.getAndIncrement() &amp; executors.length - 1]。然后用io.netty.channel.SingleThreadEventLoop.register(Channel)<strong>==注册Channel到Exceutor(即NioEventLoop)中==</strong>。注册时限看是否是当前EventLoop（对于单线程执行器来说就是看是否是本线程），如果是 直接注册，如果不是则new一个Runnbale出来把注册逻辑包进去 并交给当前eventLoop执行这个runnable。<br>注册的细节是： io.netty.channel.AbstractChannel.AbstractUnsafe.register(EventLoop, ChannelPromise)<br>执行的细节是： io.netty.util.concurrent.SingleThreadEventExecutor.execute(Runnable)<br>内部实现是将task放到io.netty.util.concurrent.SingleThreadEventExecutor.taskQueue这个队列中，这个队列目前实现是io.netty.util.internal.shaded.org.jctools.queues.MpscUnboundedArrayQueue。并在此时判断是否是本线程，如果不实现本线程就<strong>==把对应的线程给启动==</strong>了。<br>io.netty.channel.AbstractChannel.AbstractUnsafe.register0(ChannelPromise)  这是 <strong>==register的后处理==</strong> ：  </li></ol><ul><li>先设置ChannelPromise为成功</li><li>重要的事情之一：  就是会触发ChannelInboundHandler的channelRegistered事件，这是业务侧可以定制的，执行是在boss线程做的  </li><li>绑定成功了 然后 触发active事件，是否绑定成功的判断方式是：  <pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isActive</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">return</span> javaChannel().socket().isBound();   &#125;</code></pre>其实就是靠JDK的API isBound完成<br>register0的提交方式就是靠下面这种代码完成，netty中有好多这种代码，应该包装一下： <pre><code class="hljs java"><span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;    register0(promise);&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">try</span> &#123;        eventLoop.execute(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                register0(promise);            &#125;        &#125;);    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        logger.warn(                <span class="hljs-string">"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;"</span>,                AbstractChannel.<span class="hljs-keyword">this</span>, t);        closeForcibly();        closeFuture.setClosed();        safeSetFailure(promise, t);    &#125;&#125;</code></pre></li></ul><p>上述逻辑因为==是异步==的，所以==可能执行不完==，所以接下来要做出处理：  </p><pre><code class="hljs java"><span class="hljs-comment">// regFuture就是上面初始化并注册的返回的Future，此处先判断他是否完成  </span><span class="hljs-keyword">if</span> (regFuture.isDone()) &#123;    <span class="hljs-comment">// At this point we know that the registration was complete and successful.</span>    ChannelPromise promise = channel.newPromise();    doBind0(regFuture, channel, localAddress, promise); <span class="hljs-comment">// 真正的做bind，在boss线程。且此处是regFuture已经完成的情况下 那就不要用回调了就直接调用doBind0就行了。  </span>    <span class="hljs-keyword">return</span> promise;&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// Registration future is almost always fulfilled already, but just in case it's not.</span>    <span class="hljs-keyword">final</span> PendingRegistrationPromise promise = <span class="hljs-keyword">new</span> PendingRegistrationPromise(channel);    regFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123; <span class="hljs-comment">// 给regFuture注册监听器，等他完成后回调这里，妙啊</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            Throwable cause = future.cause();            <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span>                <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span>                promise.setFailure(cause);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span>                <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span>                promise.registered();                doBind0(regFuture, channel, localAddress, promise); <span class="hljs-comment">// 真正的做bind，在boss线程</span>            &#125;        &#125;    &#125;);    <span class="hljs-keyword">return</span> promise;&#125;</code></pre><p>io.netty.util.concurrent.SingleThreadEventExecutor.startThread() 启动线程的写法值得学习，确保正好启动一次。<br>addTaskWakesUp？？  </p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;           wakeup(inEventLoop);       &#125;</code></pre><ol start="4"><li>创建PendingRegistrationPromise。 对初始化和注册过的ChannelFuture增加监听器，监听ChannelFutureListener.operationComplete完成后回调。因为上面初始化并注册那事是异步的，可能这时还没完成。<br>// 3的wakeup和4要看下<br>以上都没涉及到真正bind端口的地方  </li></ol><h4 id="真正bind"><a href="#真正bind" class="headerlink" title="真正bind"></a>真正bind</h4><p>调用栈：  </p><pre><code class="hljs java"><span class="hljs-comment">// Thread [boss-0] (Suspended)</span>io.netty.channel.socket.nio.NioServerSocketChannel.doBind(java.net.SocketAddress) line: <span class="hljs-number">130</span>io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).bind(java.net.SocketAddress, io.netty.channel.ChannelPromise) line: <span class="hljs-number">562</span>io.netty.channel.DefaultChannelPipeline$HeadContext.bind(io.netty.channel.ChannelHandlerContext, java.net.SocketAddress, io.netty.channel.ChannelPromise) line: <span class="hljs-number">1332</span>io.netty.channel.DefaultChannelPipeline$HeadContext(io.netty.channel.AbstractChannelHandlerContext).invokeBind(java.net.SocketAddress, io.netty.channel.ChannelPromise) line: <span class="hljs-number">501</span>io.netty.channel.DefaultChannelPipeline$TailContext(io.netty.channel.AbstractChannelHandlerContext).bind(java.net.SocketAddress, io.netty.channel.ChannelPromise) line: <span class="hljs-number">486</span>io.netty.channel.DefaultChannelPipeline.bind(java.net.SocketAddress, io.netty.channel.ChannelPromise) line: <span class="hljs-number">984</span>io.netty.channel.socket.nio.NioServerSocketChannel(io.netty.channel.AbstractChannel).bind(java.net.SocketAddress, io.netty.channel.ChannelPromise) line: <span class="hljs-number">258</span>io.netty.bootstrap.AbstractBootstrap$<span class="hljs-number">2</span>.run() line: <span class="hljs-number">366</span>io.netty.util.concurrent.AbstractEventExecutor.safeExecute(java.lang.Runnable) line: <span class="hljs-number">163</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).runAllTasks(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">404</span>io.netty.channel.nio.NioEventLoop.run() line: <span class="hljs-number">495</span>io.netty.util.concurrent.SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>java.lang.Thread.run() line: <span class="hljs-number">748</span></code></pre><p>boss线程中NioServerSocketChannel.doBind这才是真正bind端口的地方，调用栈如上，代码如下：    </p><pre><code class="hljs java"><span class="hljs-comment">// NioServerSocketChannel</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind</span><span class="hljs-params">(SocketAddress localAddress)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="hljs-number">7</span>) &#123;            javaChannel().bind(localAddress, config.getBacklog());        &#125; <span class="hljs-keyword">else</span> &#123;            javaChannel().socket().bind(localAddress, config.getBacklog());        &#125;    &#125;</code></pre><h2 id="select和业务处理过程的抽象与逻辑组织"><a href="#select和业务处理过程的抽象与逻辑组织" class="headerlink" title="select和业务处理过程的抽象与逻辑组织"></a>select和业务处理过程的抽象与逻辑组织</h2><h3 id="NioEventLoop主要逻辑"><a href="#NioEventLoop主要逻辑" class="headerlink" title="NioEventLoop主要逻辑"></a>NioEventLoop主要逻辑</h3><ol><li>根据select策略处理select的事情，可能情况包括：  </li><li>根据ioRatio配比进行selectkey的处理(即IO事件)还是跑所有任务(业务逻辑、自定义事件等)。<br>关于selectkey的处理：<br>Field selectedKeysField = selectorImplClass.getDeclaredField(“selectedKeys”);<br>Field publicSelectedKeysField = selectorImplClass.getDeclaredField(“publicSelectedKeys”);</li></ol><p>sun.nio.ch.KQueueSelectorImpl@153cf15c<br>3. 处理异常，注意此处抓的是Throwable异常，这样能防止线程跑飞。目前的异常处理是打了警告日志并sleep 1s防止CPU被完全吃掉。   </p><h2 id="注册OP-ACCEPT事件"><a href="#注册OP-ACCEPT事件" class="headerlink" title="注册OP_ACCEPT事件"></a>注册OP_ACCEPT事件</h2><p>真正注册accept事件的地方：<br>先注册感兴趣的事件为0，注册出key：  </p><pre><code class="hljs java">Thread [boss-<span class="hljs-number">0</span>] (Suspended (breakpoint at line <span class="hljs-number">386</span> in io.netty.channel.nio.AbstractNioChannel))io.netty.channel.socket.nio.NioServerSocketChannel(io.netty.channel.nio.AbstractNioChannel).doRegister() line: <span class="hljs-number">386</span>io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).register0(io.netty.channel.ChannelPromise) line: <span class="hljs-number">508</span>io.netty.channel.AbstractChannel$AbstractUnsafe.access$<span class="hljs-number">200</span>(io.netty.channel.AbstractChannel$AbstractUnsafe, io.netty.channel.ChannelPromise) line: <span class="hljs-number">427</span>io.netty.channel.AbstractChannel$AbstractUnsafe$<span class="hljs-number">1</span>.run() line: <span class="hljs-number">486</span>io.netty.util.concurrent.AbstractEventExecutor.safeExecute(java.lang.Runnable) line: <span class="hljs-number">163</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).runAllTasks(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">404</span>io.netty.channel.nio.NioEventLoop.run() line: <span class="hljs-number">495</span>io.netty.util.concurrent.SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>java.lang.Thread.run() line: <span class="hljs-number">748</span></code></pre><p>代码</p><pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.nio.AbstractNioChannel.doRegister()</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">boolean</span> selected = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-keyword">try</span> &#123;            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);            <span class="hljs-keyword">return</span>;        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;            <span class="hljs-keyword">if</span> (!selected) &#123;                <span class="hljs-comment">// Force the Selector to select now as the "canceled" SelectionKey may still be</span>                <span class="hljs-comment">// cached and not removed because no Select.select(..) operation was called yet.</span>                eventLoop().selectNow();                selected = <span class="hljs-keyword">true</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// We forced a select operation on the selector before but the SelectionKey is still cached</span>                <span class="hljs-comment">// for whatever reason. JDK bug ?</span>                <span class="hljs-keyword">throw</span> e;            &#125;        &#125;    &#125;&#125;</code></pre><p>再在doBeginRead中注册16，真正注册：<br>boss调用栈：  </p><pre><code class="hljs java">Thread [boss-<span class="hljs-number">0</span>] (Suspended (breakpoint at line <span class="hljs-number">420</span> in io.netty.channel.nio.AbstractNioChannel))io.netty.channel.socket.nio.NioServerSocketChannel(io.netty.channel.nio.AbstractNioChannel).doBeginRead() line: <span class="hljs-number">420</span>io.netty.channel.socket.nio.NioServerSocketChannel(io.netty.channel.nio.AbstractNioMessageChannel).doBeginRead() line: <span class="hljs-number">55</span>io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).beginRead() line: <span class="hljs-number">851</span>io.netty.channel.DefaultChannelPipeline$HeadContext.read(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">1360</span>io.netty.channel.DefaultChannelPipeline$HeadContext(io.netty.channel.AbstractChannelHandlerContext).invokeRead() line: <span class="hljs-number">693</span>io.netty.channel.DefaultChannelPipeline$TailContext(io.netty.channel.AbstractChannelHandlerContext).read() line: <span class="hljs-number">673</span>io.netty.channel.DefaultChannelPipeline.read() line: <span class="hljs-number">1015</span>io.netty.channel.socket.nio.NioServerSocketChannel(io.netty.channel.AbstractChannel).read() line: <span class="hljs-number">288</span>io.netty.channel.DefaultChannelPipeline$HeadContext.readIfIsAutoRead() line: <span class="hljs-number">1420</span>io.netty.channel.DefaultChannelPipeline$HeadContext.channelActive(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">1398</span>io.netty.channel.DefaultChannelPipeline$HeadContext(io.netty.channel.AbstractChannelHandlerContext).invokeChannelActive() line: <span class="hljs-number">213</span>io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(io.netty.channel.AbstractChannelHandlerContext) line: <span class="hljs-number">199</span>io.netty.channel.DefaultChannelPipeline.fireChannelActive() line: <span class="hljs-number">906</span>io.netty.channel.AbstractChannel$AbstractUnsafe$<span class="hljs-number">2</span>.run() line: <span class="hljs-number">573</span>io.netty.util.concurrent.AbstractEventExecutor.safeExecute(java.lang.Runnable) line: <span class="hljs-number">163</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).runAllTasks(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">404</span>io.netty.channel.nio.NioEventLoop.run() line: <span class="hljs-number">495</span>io.netty.util.concurrent.SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>java.lang.Thread.run() line: <span class="hljs-number">748</span></code></pre><p>代码：  </p><pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.nio.AbstractNioChannel.doBeginRead()</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span>    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;        <span class="hljs-keyword">return</span>;    &#125;    readPending = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();    <span class="hljs-keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;        selectionKey.interestOps(interestOps | readInterestOp); <span class="hljs-comment">// accept的readInterestOp是16</span>    &#125;&#125;</code></pre><h2 id="select出OP-ACCEPT的处理与SocketChannel的创建"><a href="#select出OP-ACCEPT的处理与SocketChannel的创建" class="headerlink" title="select出OP_ACCEPT的处理与SocketChannel的创建"></a>select出OP_ACCEPT的处理与SocketChannel的创建</h2><p>也就是在run方法中select的逻辑：<br>在策略判断时如果<strong>有任务</strong>的情况下会做io.netty.channel.nio.NioEventLoop.selectNowSupplier的get方法调用，这个方法中会selectNow：<br>在策略判断时如果<strong>没有任务</strong>的话，策略判断则会返回-1即SelectStrategy.SELECT，并执行带超时时间参数的select：  </p><pre><code class="hljs java"><span class="hljs-keyword">case</span> SelectStrategy.SELECT:                       select(wakenUp.getAndSet(<span class="hljs-keyword">false</span>));</code></pre><p>此时会走下面的调用栈：  </p><pre><code class="hljs java">SelectedSelectionKeySetSelector.select(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">62</span>NioEventLoop.select(<span class="hljs-keyword">boolean</span>) line: <span class="hljs-number">786</span>NioEventLoop.run() line: <span class="hljs-number">434</span>SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>Thread.run() line: <span class="hljs-number">748</span></code></pre><p>关于io.netty.channel.SelectStrategy.calculateStrategy(IntSupplier, boolean)策略的返回值整理情况如下：<br>① -2，跳过本次处理；目前还未构造出这种场景。<br>② -3，忙等也是跳过；目前还未构造出这种场景。<br>③ -1，没有任务时需要select，并判断是否要wakeup；没有任务时就是这种这种场景。<br>④ &gt;=0的其他值，也就是default，啥都不干往下走，走处理selectkey(即IO事件)或者所有任务(业务逻辑等)。<br>io.netty.channel.DefaultSelectStrategy.calculateStrategy(IntSupplier, boolean)  计算逻辑分析：<br>如果没有任务了 就返回 SelectStrategy.SELECT<br>如果有任务  就io.netty.channel.nio.NioEventLoop.new IntSupplier() {…}.() selectNow一次，注意这个<code>selectNow</code>是NioEventLoop的selectNow方法，但是最终还会对应到JDK的Selector的selectNow上去。   </p><h3 id="io-netty-channel-nio-NioEventLoop-select-boolean-分析"><a href="#io-netty-channel-nio-NioEventLoop-select-boolean-分析" class="headerlink" title="io.netty.channel.nio.NioEventLoop.select(boolean)分析"></a>io.netty.channel.nio.NioEventLoop.select(boolean)分析</h3><ol><li><p>select时超时时间怎么定<br>这个有超时时间的select，超时时间这个值是怎么确定的？<br>deadline减去当前时间(这两个都是用纳秒计量)后四舍五入到毫秒粒度<br>deadline又是怎么计算的？<br>默认值是1s，如果scheduledTaskQueue中有调度任务，以优先级队列顶部的scheduledTask的调度时间结合当前时间算出deadline。  </p></li><li><p>该select(boolean)的逻辑和避免epoll select空转bug的规避<br>整体是一个spin循环包起来的逻辑<br>如果deadline已到，则selector.selectNow();并退出spin循环。<br>如果有任务且wakeup是false(是false要将其设置成true)，则selector.selectNow();并退出spin循环。<br>上面两种情况都没命中则selector.select(timeoutMillis);并计数。如果selected到key了或者oldWakenUp为true或者wakenUp字段为true或者有任务或者有调度任务都退出spin循环。<br>如果在这个spin循环中seletc次数大于SELECTOR_AUTO_REBUILD_THRESHOLD（默认值512），则重建这个方法内局部变量Selector实例，并将之前selector上的事件注册到这个新的上面来。这个处理就是为了规避linux上epoll的bug，epoll可能select方法会直接返回，即使没有超时并且也没有IO事件到达，这就是著名的epoll bug，这是一个比较严重的bug，它会导致线程陷入死循环，会让CPU飙到100%。<a href="https://www.cnblogs.com/devilwind/p/8351732.html" target="_blank" rel="noopener">参见这里</a><br>相关代码：  </p><pre><code class="hljs java">io.netty.channel.nio.NioEventLoop.rebuildSelector0()SelectionKey newKey = key.channel().register(newSelectorTuple.unwrappedSelector, interestOps, a);</code></pre></li></ol><h3 id="Selector到key之后的处理"><a href="#Selector到key之后的处理" class="headerlink" title="Selector到key之后的处理"></a>Selector到key之后的处理</h3><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ioRatio = <span class="hljs-keyword">this</span>.ioRatio;<span class="hljs-keyword">if</span> (ioRatio == <span class="hljs-number">100</span>) &#123;    <span class="hljs-keyword">try</span> &#123;        processSelectedKeys();    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// Ensure we always run tasks.</span>        runAllTasks();    &#125;&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioStartTime = System.nanoTime();    <span class="hljs-keyword">try</span> &#123;        processSelectedKeys();    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// Ensure we always run tasks.</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioTime = System.nanoTime() - ioStartTime;        runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);    &#125;&#125;</code></pre><h3 id="processSelectedKeys"><a href="#processSelectedKeys" class="headerlink" title="processSelectedKeys"></a>processSelectedKeys</h3><p>调用栈 ：  </p><pre><code class="hljs java">NioServerSocketChannel.doReadMessages(List&lt;Object&gt;) line: <span class="hljs-number">143</span>AbstractNioMessageChannel$NioMessageUnsafe.read() line: <span class="hljs-number">75</span>NioEventLoop.processSelectedKey(SelectionKey, AbstractNioChannel) line: <span class="hljs-number">677</span>NioEventLoop.processSelectedKeysOptimized() line: <span class="hljs-number">612</span>NioEventLoop.processSelectedKeys() line: <span class="hljs-number">529</span>NioEventLoop.run() line: <span class="hljs-number">491</span>SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>Thread.run() line: <span class="hljs-number">748</span></code></pre><p>涉及的部分代码：<br>有accept出SocketChannel的关键部分  </p><pre><code class="hljs java"><span class="hljs-comment">// NioEventLoop</span><span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;    unsafe.read(); <span class="hljs-comment">// unsafe是io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe</span>&#125;<span class="hljs-comment">//  NioServerSocketChannel</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doReadMessages</span><span class="hljs-params">(List&lt;Object&gt; buf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    SocketChannel ch = SocketUtils.accept(javaChannel());    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (ch != <span class="hljs-keyword">null</span>) &#123;            buf.add(<span class="hljs-keyword">new</span> NioSocketChannel(<span class="hljs-keyword">this</span>, ch));            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        logger.warn(<span class="hljs-string">"Failed to create a new channel from an accepted socket."</span>, t);        <span class="hljs-keyword">try</span> &#123;            ch.close();        &#125; <span class="hljs-keyword">catch</span> (Throwable t2) &#123;            logger.warn(<span class="hljs-string">"Failed to close a socket."</span>, t2);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="注册OP-READ事件"><a href="#注册OP-READ事件" class="headerlink" title="注册OP_READ事件"></a>注册OP_READ事件</h2><p>woker调用栈：<br>注册出key：</p><pre><code class="hljs java">Thread [worker-<span class="hljs-number">0</span>] (Suspended (breakpoint at line <span class="hljs-number">386</span> in io.netty.channel.nio.AbstractNioChannel))io.netty.channel.socket.nio.NioSocketChannel(io.netty.channel.nio.AbstractNioChannel).doRegister() line: <span class="hljs-number">386</span>io.netty.channel.socket.nio.NioSocketChannel$NioSocketChannelUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).register0(io.netty.channel.ChannelPromise) line: <span class="hljs-number">508</span>io.netty.channel.AbstractChannel$AbstractUnsafe.access$<span class="hljs-number">200</span>(io.netty.channel.AbstractChannel$AbstractUnsafe, io.netty.channel.ChannelPromise) line: <span class="hljs-number">427</span>io.netty.channel.AbstractChannel$AbstractUnsafe$<span class="hljs-number">1</span>.run() line: <span class="hljs-number">486</span>io.netty.util.concurrent.AbstractEventExecutor.safeExecute(java.lang.Runnable) line: <span class="hljs-number">163</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).runAllTasks(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">404</span>io.netty.channel.nio.NioEventLoop.run() line: <span class="hljs-number">495</span>io.netty.util.concurrent.SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>java.lang.Thread.run() line: <span class="hljs-number">748</span></code></pre><p>真正注册：  </p><pre><code class="hljs java">Thread [worker-<span class="hljs-number">0</span>] (Suspended (breakpoint at line <span class="hljs-number">420</span> in io.netty.channel.nio.AbstractNioChannel))io.netty.channel.socket.nio.NioSocketChannel(io.netty.channel.nio.AbstractNioChannel).doBeginRead() line: <span class="hljs-number">420</span>io.netty.channel.socket.nio.NioSocketChannel$NioSocketChannelUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).beginRead() line: <span class="hljs-number">851</span>io.netty.channel.DefaultChannelPipeline$HeadContext.read(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">1360</span>io.netty.channel.DefaultChannelPipeline$HeadContext(io.netty.channel.AbstractChannelHandlerContext).invokeRead() line: <span class="hljs-number">693</span>io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).read() line: <span class="hljs-number">673</span>io.netty.handler.timeout.ReadTimeoutHandler(io.netty.channel.ChannelDuplexHandler).read(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">95</span>io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).invokeRead() line: <span class="hljs-number">693</span>io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).read() line: <span class="hljs-number">673</span>io.netty.handler.codec.http.HttpResponseEncoder(io.netty.channel.ChannelOutboundHandlerAdapter).read(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">93</span>io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).invokeRead() line: <span class="hljs-number">693</span>io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).read() line: <span class="hljs-number">673</span>io.netty.handler.stream.ChunkedWriteHandler(io.netty.channel.ChannelDuplexHandler).read(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">95</span>io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).invokeRead() line: <span class="hljs-number">693</span>io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).read() line: <span class="hljs-number">673</span>io.netty.handler.codec.http.HttpContentCompressor(io.netty.channel.ChannelDuplexHandler).read(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">95</span>io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).invokeRead() line: <span class="hljs-number">693</span>io.netty.channel.DefaultChannelPipeline$TailContext(io.netty.channel.AbstractChannelHandlerContext).read() line: <span class="hljs-number">673</span>io.netty.channel.DefaultChannelPipeline.read() line: <span class="hljs-number">1015</span>io.netty.channel.socket.nio.NioSocketChannel(io.netty.channel.AbstractChannel).read() line: <span class="hljs-number">288</span>io.netty.channel.DefaultChannelPipeline$HeadContext.readIfIsAutoRead() line: <span class="hljs-number">1420</span>io.netty.channel.DefaultChannelPipeline$HeadContext.channelActive(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">1398</span>io.netty.channel.DefaultChannelPipeline$HeadContext(io.netty.channel.AbstractChannelHandlerContext).invokeChannelActive() line: <span class="hljs-number">213</span>io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(io.netty.channel.AbstractChannelHandlerContext) line: <span class="hljs-number">199</span>io.netty.channel.DefaultChannelPipeline.fireChannelActive() line: <span class="hljs-number">906</span>io.netty.channel.socket.nio.NioSocketChannel$NioSocketChannelUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).register0(io.netty.channel.ChannelPromise) line: <span class="hljs-number">522</span>io.netty.channel.AbstractChannel$AbstractUnsafe.access$<span class="hljs-number">200</span>(io.netty.channel.AbstractChannel$AbstractUnsafe, io.netty.channel.ChannelPromise) line: <span class="hljs-number">427</span>io.netty.channel.AbstractChannel$AbstractUnsafe$<span class="hljs-number">1</span>.run() line: <span class="hljs-number">486</span>io.netty.util.concurrent.AbstractEventExecutor.safeExecute(java.lang.Runnable) line: <span class="hljs-number">163</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).runAllTasks(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">404</span>io.netty.channel.nio.NioEventLoop.run() line: <span class="hljs-number">495</span>io.netty.util.concurrent.SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>java.lang.Thread.run() line: <span class="hljs-number">748</span></code></pre><h2 id="select出OP-READ的处理与buf的读取"><a href="#select出OP-READ的处理与buf的读取" class="headerlink" title="select出OP_READ的处理与buf的读取"></a>select出OP_READ的处理与buf的读取</h2><p>读取数据线程栈：  </p><pre><code class="hljs java">Thread [worker-<span class="hljs-number">2</span>] (Suspended (breakpoint at line <span class="hljs-number">57</span> in HttpContentDecoder))HttpContentDecompressor(HttpContentDecoder).decode(ChannelHandlerContext, HttpObject, List&lt;Object&gt;) line: <span class="hljs-number">57</span>HttpContentDecompressor(HttpContentDecoder).decode(ChannelHandlerContext, Object, List) line: <span class="hljs-number">47</span>HttpContentDecompressor(MessageToMessageDecoder&lt;I&gt;).channelRead(ChannelHandlerContext, Object) line: <span class="hljs-number">88</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelRead(Object) line: <span class="hljs-number">362</span>AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext, Object) line: <span class="hljs-number">348</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelRead(Object) line: <span class="hljs-number">340</span>ByteToMessageDecoder.fireChannelRead(ChannelHandlerContext, CodecOutputList, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">323</span>ByteToMessageDecoder.fireChannelRead(ChannelHandlerContext, List&lt;Object&gt;, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">310</span>HttpRequestDecoder(ByteToMessageDecoder).callDecode(ChannelHandlerContext, ByteBuf, List&lt;Object&gt;) line: <span class="hljs-number">426</span>HttpRequestDecoder(ByteToMessageDecoder).channelRead(ChannelHandlerContext, Object) line: <span class="hljs-number">278</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelRead(Object) line: <span class="hljs-number">362</span>AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext, Object) line: <span class="hljs-number">348</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelRead(Object) line: <span class="hljs-number">340</span>PipelineInitializer$ChannelActiveTester(ChannelInboundHandlerAdapter).channelRead(ChannelHandlerContext, Object) line: <span class="hljs-number">86</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelRead(Object) line: <span class="hljs-number">362</span>AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext, Object) line: <span class="hljs-number">348</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelRead(Object) line: <span class="hljs-number">340</span>ReadTimeoutHandler(IdleStateHandler).channelRead(ChannelHandlerContext, Object) line: <span class="hljs-number">286</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelRead(Object) line: <span class="hljs-number">362</span>AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext, Object) line: <span class="hljs-number">348</span>DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).fireChannelRead(Object) line: <span class="hljs-number">340</span>DefaultChannelPipeline$HeadContext.channelRead(ChannelHandlerContext, Object) line: <span class="hljs-number">1408</span>DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).invokeChannelRead(Object) line: <span class="hljs-number">362</span>AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext, Object) line: <span class="hljs-number">348</span>DefaultChannelPipeline.fireChannelRead(Object) line: <span class="hljs-number">930</span>NioSocketChannel$NioSocketChannelUnsafe(AbstractNioByteChannel$NioByteUnsafe).read() line: <span class="hljs-number">163</span>NioEventLoop.processSelectedKey(SelectionKey, AbstractNioChannel) line: <span class="hljs-number">677</span>NioEventLoop.processSelectedKeysOptimized() line: <span class="hljs-number">612</span>NioEventLoop.processSelectedKeys() line: <span class="hljs-number">529</span>NioEventLoop.run() line: <span class="hljs-number">491</span>SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>Thread.run() line: <span class="hljs-number">748</span></code></pre><p>在processSelectedKey之后会用 NioSocketChannelUnsafe将数据读到Buf中。再交给Pipeline触发后面的每一个handler。<br>此处要注意下读的时候 selectkey的attachment中放的是啥：  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKeysOptimized</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; selectedKeys.size; ++i) &#123;        <span class="hljs-keyword">final</span> SelectionKey k = selectedKeys.keys[i];        <span class="hljs-comment">// null out entry in the array to allow to have it GC'ed once the Channel close</span>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2363</span>        selectedKeys.keys[i] = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">final</span> Object a = k.attachment(); <span class="hljs-comment">// 附件中放的是AbstractNioChannel  AbstractNioChannel中有unsafe对象，unsafe中能关联读取用的buf。</span>        <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> AbstractNioChannel) &#123;            processSelectedKey(k, (AbstractNioChannel) a);            <span class="hljs-comment">// ...</span>        &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKey</span><span class="hljs-params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;    <span class="hljs-keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe(); <span class="hljs-comment">// AbstractNioChannel中有unsafe对象</span>    <span class="hljs-comment">// ...</span>     <span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;            unsafe.read();        &#125;</code></pre><h2 id="写出数据的处理"><a href="#写出数据的处理" class="headerlink" title="写出数据的处理"></a>写出数据的处理</h2><p>写数据的处理可以在SocketChannelImpl [entry] - write(ByteBuffer)    处打方法断点观察。<br>调用堆栈如下：  </p><pre><code class="hljs java">Thread [worker-<span class="hljs-number">3</span>] (Suspended (entry into method write in SocketChannelImpl))SocketChannelImpl.write(ByteBuffer) line: <span class="hljs-number">458</span>NioSocketChannel.doWrite(ChannelOutboundBuffer) line: <span class="hljs-number">405</span>NioSocketChannel$NioSocketChannelUnsafe(AbstractChannel$AbstractUnsafe).flush0() line: <span class="hljs-number">938</span>NioSocketChannel$NioSocketChannelUnsafe(AbstractNioChannel$AbstractNioUnsafe).flush0() line: <span class="hljs-number">360</span>NioSocketChannel$NioSocketChannelUnsafe(AbstractChannel$AbstractUnsafe).flush() line: <span class="hljs-number">905</span>DefaultChannelPipeline$HeadContext.flush(ChannelHandlerContext) line: <span class="hljs-number">1370</span>DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).invokeFlush0() line: <span class="hljs-number">776</span>DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).invokeFlush() line: <span class="hljs-number">768</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).flush() line: <span class="hljs-number">749</span>ReadTimeoutHandler(ChannelDuplexHandler).flush(ChannelHandlerContext) line: <span class="hljs-number">117</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush0() line: <span class="hljs-number">776</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush() line: <span class="hljs-number">768</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).flush() line: <span class="hljs-number">749</span>HttpResponseEncoder(ChannelOutboundHandlerAdapter).flush(ChannelHandlerContext) line: <span class="hljs-number">115</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush0() line: <span class="hljs-number">776</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush() line: <span class="hljs-number">768</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).flush() line: <span class="hljs-number">749</span>ChunkedWriteHandler.doFlush(ChannelHandlerContext) line: <span class="hljs-number">335</span>ChunkedWriteHandler.channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">148</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>HttpContentDecompressor(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>HttpRequestDecoder(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>PipelineInitializer$ChannelActiveTester(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>ReadTimeoutHandler(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>DefaultChannelPipeline$HeadContext.channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">1431</span>DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelPipeline.fireChannelWritabilityChanged() line: <span class="hljs-number">942</span>ChannelOutboundBuffer$<span class="hljs-number">2</span>.run() line: <span class="hljs-number">608</span>AbstractEventExecutor.safeExecute(Runnable) line: <span class="hljs-number">163</span>NioEventLoop(SingleThreadEventExecutor).runAllTasks(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">404</span>NioEventLoop.run() line: <span class="hljs-number">495</span>SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>Thread.run() line: <span class="hljs-number">748</span></code></pre><p>核心逻辑在：<br>io.netty.channel.socket.nio.NioSocketChannel.doWrite(ChannelOutboundBuffer)  </p><pre><code class="hljs java"> <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: &#123;    <span class="hljs-comment">// Only one ByteBuf so use non-gathering write</span>    <span class="hljs-comment">// Zero length buffers are not added to nioBuffers by ChannelOutboundBuffer, so there is no need</span>    <span class="hljs-comment">// to check if the total size of all the buffers is non-zero.</span>    ByteBuffer buffer = nioBuffers[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> attemptedBytes = buffer.remaining();    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> localWrittenBytes = ch.write(buffer);    <span class="hljs-keyword">if</span> (localWrittenBytes &lt;= <span class="hljs-number">0</span>) &#123;        incompleteWrite(<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span>;    &#125;    adjustMaxBytesPerGatheringWrite(attemptedBytes, localWrittenBytes, maxBytesPerGatheringWrite);    in.removeBytes(localWrittenBytes);    --writeSpinCount;    <span class="hljs-keyword">break</span>;&#125;</code></pre><p><strong>writeSpinCount</strong>默认是16，也就说说写出线程会尝试写16次，如果ch.write写不出去了再调用incompleteWrite，incompleteWrite里会注册OP_WRITE事件，此处是个优化，不是一上来就注册事件，是先尝试写，写不了再注册。  </p><h2 id="注册OP-WRITE事件"><a href="#注册OP-WRITE事件" class="headerlink" title="注册OP_WRITE事件"></a>注册OP_WRITE事件</h2><p>需要构造较大的响应包，在本地才能观察到。 我构造了将近200万字符，才达能目的。<br>注册的地方打断点在 SelectionKeyImpl [entry] - interestOps(int)    遍可以观察<br>堆栈如下：  </p><pre><code class="hljs java">Thread [worker-<span class="hljs-number">3</span>] (Suspended (entry into method interestOps in SelectionKeyImpl))SelectionKeyImpl.interestOps(<span class="hljs-keyword">int</span>) line: <span class="hljs-number">82</span>NioSocketChannel(AbstractNioByteChannel).setOpWrite() line: <span class="hljs-number">332</span>NioSocketChannel(AbstractNioByteChannel).incompleteWrite(<span class="hljs-keyword">boolean</span>) line: <span class="hljs-number">289</span>NioSocketChannel.doWrite(ChannelOutboundBuffer) line: <span class="hljs-number">407</span>NioSocketChannel$NioSocketChannelUnsafe(AbstractChannel$AbstractUnsafe).flush0() line: <span class="hljs-number">938</span>NioSocketChannel$NioSocketChannelUnsafe(AbstractNioChannel$AbstractNioUnsafe).flush0() line: <span class="hljs-number">360</span>NioSocketChannel$NioSocketChannelUnsafe(AbstractChannel$AbstractUnsafe).flush() line: <span class="hljs-number">905</span>DefaultChannelPipeline$HeadContext.flush(ChannelHandlerContext) line: <span class="hljs-number">1370</span>DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).invokeFlush0() line: <span class="hljs-number">776</span>DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).invokeFlush() line: <span class="hljs-number">768</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).flush() line: <span class="hljs-number">749</span>ReadTimeoutHandler(ChannelDuplexHandler).flush(ChannelHandlerContext) line: <span class="hljs-number">117</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush0() line: <span class="hljs-number">776</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush() line: <span class="hljs-number">768</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).flush() line: <span class="hljs-number">749</span>HttpResponseEncoder(ChannelOutboundHandlerAdapter).flush(ChannelHandlerContext) line: <span class="hljs-number">115</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush0() line: <span class="hljs-number">776</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush() line: <span class="hljs-number">768</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).flush() line: <span class="hljs-number">749</span>ChunkedWriteHandler.doFlush(ChannelHandlerContext) line: <span class="hljs-number">335</span>ChunkedWriteHandler.channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">148</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>HttpContentDecompressor(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>HttpRequestDecoder(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>PipelineInitializer$ChannelActiveTester(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>ReadTimeoutHandler(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>DefaultChannelPipeline$HeadContext.channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">1431</span>DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelPipeline.fireChannelWritabilityChanged() line: <span class="hljs-number">942</span>ChannelOutboundBuffer$<span class="hljs-number">2</span>.run() line: <span class="hljs-number">608</span>AbstractEventExecutor.safeExecute(Runnable) line: <span class="hljs-number">163</span>NioEventLoop(SingleThreadEventExecutor).runAllTasks(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">404</span>NioEventLoop.run() line: <span class="hljs-number">495</span>SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>Thread.run() line: <span class="hljs-number">748</span></code></pre><p>netty里核心代码在：  </p><pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.nio.AbstractNioByteChannel.setOpWrite()</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOpWrite</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> SelectionKey key = selectionKey();    <span class="hljs-comment">// Check first if the key is still valid as it may be canceled as part of the deregistration</span>    <span class="hljs-comment">// from the EventLoop</span>    <span class="hljs-comment">// See https://github.com/netty/netty/issues/2104</span>    <span class="hljs-keyword">if</span> (!key.isValid()) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = key.interestOps();    <span class="hljs-keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) == <span class="hljs-number">0</span>) &#123;        key.interestOps(interestOps | SelectionKey.OP_WRITE);    &#125;&#125;</code></pre><h2 id="select出OP-WRITE的处理与buf的写出"><a href="#select出OP-WRITE的处理与buf的写出" class="headerlink" title="select出OP_WRITE的处理与buf的写出"></a>select出OP_WRITE的处理与buf的写出</h2><p>注册完之后再select到的写逻辑复用io.netty.channel.socket.nio.NioSocketChannel.doWrite(ChannelOutboundBuffer)<br>调用栈如下：  </p><pre><code class="hljs java">Thread [worker-<span class="hljs-number">3</span>] (Suspended (entry into method write in SocketChannelImpl))SocketChannelImpl.write(ByteBuffer) line: <span class="hljs-number">458</span>NioSocketChannel.doWrite(ChannelOutboundBuffer) line: <span class="hljs-number">405</span>NioSocketChannel$NioSocketChannelUnsafe(AbstractChannel$AbstractUnsafe).flush0() line: <span class="hljs-number">938</span>NioSocketChannel$NioSocketChannelUnsafe(AbstractNioChannel$AbstractNioUnsafe).forceFlush() line: <span class="hljs-number">367</span>NioEventLoop.processSelectedKey(SelectionKey, AbstractNioChannel) line: <span class="hljs-number">671</span>NioEventLoop.processSelectedKeysOptimized() line: <span class="hljs-number">612</span>NioEventLoop.processSelectedKeys() line: <span class="hljs-number">529</span>NioEventLoop.run() line: <span class="hljs-number">491</span>SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>Thread.run() line: <span class="hljs-number">748</span></code></pre><h2 id="main线程与boss线程切换，boss线程与worker线程切换"><a href="#main线程与boss线程切换，boss线程与worker线程切换" class="headerlink" title="main线程与boss线程切换，boss线程与worker线程切换"></a>main线程与boss线程切换，boss线程与worker线程切换</h2><p>boss与worker的NioEventLoop的spin run是什么时候启动触发的<br>main启动boss  </p><pre><code class="hljs java">Thread [main] (Suspended (breakpoint at line <span class="hljs-number">707</span> in java.lang.Thread))owns: java.lang.Thread  (id=<span class="hljs-number">80</span>)java.lang.Thread.start() line: <span class="hljs-number">707</span>io.netty.util.concurrent.ThreadPerTaskExecutor.execute(java.lang.Runnable) line: <span class="hljs-number">33</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).doStartThread() line: <span class="hljs-number">894</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).startThread() line: <span class="hljs-number">865</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).execute(java.lang.Runnable) line: <span class="hljs-number">758</span>io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).register(io.netty.channel.EventLoop, io.netty.channel.ChannelPromise) line: <span class="hljs-number">483</span>io.netty.channel.nio.NioEventLoop(io.netty.channel.SingleThreadEventLoop).register(io.netty.channel.ChannelPromise) line: <span class="hljs-number">80</span>io.netty.channel.nio.NioEventLoop(io.netty.channel.SingleThreadEventLoop).register(io.netty.channel.Channel) line: <span class="hljs-number">74</span>io.netty.channel.nio.NioEventLoopGroup(io.netty.channel.MultithreadEventLoopGroup).register(io.netty.channel.Channel) line: <span class="hljs-number">86</span>io.netty.bootstrap.ServerBootstrap(io.netty.bootstrap.AbstractBootstrap&lt;B,C&gt;).initAndRegister() line: <span class="hljs-number">333</span>io.netty.bootstrap.ServerBootstrap(io.netty.bootstrap.AbstractBootstrap&lt;B,C&gt;).doBind(java.net.SocketAddress) line: <span class="hljs-number">282</span>io.netty.bootstrap.ServerBootstrap(io.netty.bootstrap.AbstractBootstrap&lt;B,C&gt;).bind(java.net.SocketAddress) line: <span class="hljs-number">278</span>org.restexpress.RestExpress.bind(java.net.InetSocketAddress) line: <span class="hljs-number">709</span>org.restexpress.RestExpress.bind(java.lang.String, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">686</span>com.code260.ss.resetexpress.RestExpressApp1.main(java.lang.String[]) line: <span class="hljs-number">26</span></code></pre><p>boss启动worker  </p><pre><code class="hljs java">Thread [boss-<span class="hljs-number">0</span>] (Suspended (breakpoint at line <span class="hljs-number">707</span> in java.lang.Thread))owns: java.lang.Thread  (id=<span class="hljs-number">102</span>)java.lang.Thread.start() line: <span class="hljs-number">707</span>io.netty.util.concurrent.ThreadPerTaskExecutor.execute(java.lang.Runnable) line: <span class="hljs-number">33</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).doStartThread() line: <span class="hljs-number">894</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).startThread() line: <span class="hljs-number">865</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).execute(java.lang.Runnable) line: <span class="hljs-number">758</span>io.netty.channel.socket.nio.NioSocketChannel$NioSocketChannelUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).register(io.netty.channel.EventLoop, io.netty.channel.ChannelPromise) line: <span class="hljs-number">483</span>io.netty.channel.nio.NioEventLoop(io.netty.channel.SingleThreadEventLoop).register(io.netty.channel.ChannelPromise) line: <span class="hljs-number">80</span>io.netty.channel.nio.NioEventLoop(io.netty.channel.SingleThreadEventLoop).register(io.netty.channel.Channel) line: <span class="hljs-number">74</span>io.netty.channel.nio.NioEventLoopGroup(io.netty.channel.MultithreadEventLoopGroup).register(io.netty.channel.Channel) line: <span class="hljs-number">86</span>io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor.channelRead(io.netty.channel.ChannelHandlerContext, java.lang.Object) line: <span class="hljs-number">255</span>io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).invokeChannelRead(java.lang.Object) line: <span class="hljs-number">362</span>io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(io.netty.channel.AbstractChannelHandlerContext, java.lang.Object) line: <span class="hljs-number">348</span>io.netty.channel.DefaultChannelPipeline$HeadContext(io.netty.channel.AbstractChannelHandlerContext).fireChannelRead(java.lang.Object) line: <span class="hljs-number">340</span>io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(io.netty.channel.ChannelHandlerContext, java.lang.Object) line: <span class="hljs-number">1408</span>io.netty.channel.DefaultChannelPipeline$HeadContext(io.netty.channel.AbstractChannelHandlerContext).invokeChannelRead(java.lang.Object) line: <span class="hljs-number">362</span>io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(io.netty.channel.AbstractChannelHandlerContext, java.lang.Object) line: <span class="hljs-number">348</span>io.netty.channel.DefaultChannelPipeline.fireChannelRead(java.lang.Object) line: <span class="hljs-number">930</span>io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe.read() line: <span class="hljs-number">93</span>io.netty.channel.nio.NioEventLoop.processSelectedKey(java.nio.channels.SelectionKey, io.netty.channel.nio.AbstractNioChannel) line: <span class="hljs-number">677</span>io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized() line: <span class="hljs-number">612</span>io.netty.channel.nio.NioEventLoop.processSelectedKeys() line: <span class="hljs-number">529</span>io.netty.channel.nio.NioEventLoop.run() line: <span class="hljs-number">491</span>io.netty.util.concurrent.SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>java.lang.Thread.run() line: <span class="hljs-number">748</span></code></pre><h2 id="selector与线程绑定的问题"><a href="#selector与线程绑定的问题" class="headerlink" title="selector与线程绑定的问题"></a>selector与线程绑定的问题</h2><p>一个selector对应一个channel，一个selector又对应固定的一个线程，所以一个channel上的数据<strong>多次读取不会在不同线程漂移</strong>。<br>当然，一个线程可以对应多个channel，但因为一个selector又对应固定的一个线程，所以这些channel用的同一个selector。  </p><h2 id="多boss问题也即多accept问题"><a href="#多boss问题也即多accept问题" class="headerlink" title="多boss问题也即多accept问题"></a>多boss问题也即多accept问题</h2><p>什么时候用多accept？<br>一般是用在多个端口bind，或者一个端口不同ip网卡平面bind时，多accept(即boss)线程才有意义。否则一个port通常只能bind出一个ServerSocketChannel出来，一个channel又对应一个Selector，一个Selector又对应一个线程在spin的方式去select，所以多个线程对一个bind也没用。如果把一个selector对应到多个线程去用问题在于，selector的方法线程不安全，对应到多个线程会有问题。<br>当然后来的JDK版本，包括linux开始支持一个port+ip可以被多个进程多次绑定，这样多accept就有意义了。参见 《NIO trick and trap》这个ppt的 题外:SO_REUSEPORT 关键字。 应用场景是 “适合大量短连接的web server”</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>netty4源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty之池化buffer</title>
    <link href="/2020/04/20/netty4-pooled-buffer/"/>
    <url>/2020/04/20/netty4-pooled-buffer/</url>
    
    <content type="html"><![CDATA[<h2 id="PooledByteBufAllocator-buffer分配"><a href="#PooledByteBufAllocator-buffer分配" class="headerlink" title="PooledByteBufAllocator buffer分配"></a>PooledByteBufAllocator buffer分配</h2><p>buffer分配的入口：<br>io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(int, int)<br>netty实际应用时分配调用栈：  </p><table><tr><td>CLASS_NAME</td><td>METHOD_NAME</td><td>LINE_NUM</td></tr><tr><td>io/netty/buffer/PooledByteBufAllocator</td><td>newDirectBuffer</td><td>339</td></tr><tr><td>io/netty/buffer/AbstractByteBufAllocator</td><td>directBuffer</td><td>185</td></tr><tr><td>io/netty/buffer/AbstractByteBufAllocator</td><td>directBuffer</td><td>176</td></tr><tr><td>io/netty/buffer/AbstractByteBufAllocator</td><td>ioBuffer</td><td>139</td></tr><tr><td>io/netty/channel/DefaultMaxMessagesRecvByteBufAllocator$MaxMessageHandle</td><td>allocate</td><td>114</td></tr><tr><td>io/netty/channel/nio/AbstractNioByteChannel$NioByteUnsafe</td><td>read</td><td>186</td></tr><tr><td>io/netty/channel/nio/NioEventLoop</td><td>processSelectedKey</td><td>682</td></tr><tr><td>io/netty/channel/nio/NioEventLoop</td><td>processSelectedKeysOptimized</td><td>628</td></tr><tr><td>io/netty/channel/nio/NioEventLoop</td><td>processSelectedKeys</td><td>533</td></tr><tr><td>io/netty/channel/nio/NioEventLoop</td><td>run</td><td>511</td></tr><tr><td>io/netty/util/concurrent/SingleThreadEventExecutor$5</td><td>run</td><td>956</td></tr></table><h3 id="测试case代码"><a href="#测试case代码" class="headerlink" title="测试case代码"></a>测试case代码</h3><pre><code class="hljs plain">package io.netty.buffer;import org.junit.Assert;public class PooledByteBufTest &#123;public static void main(String[] args) &#123;  final PooledByteBufAllocator allocator &#x3D; new PooledByteBufAllocator(                false,   &#x2F;&#x2F; preferDirect                0,      &#x2F;&#x2F; nHeapArena                1,      &#x2F;&#x2F; nDirectArena                8192,   &#x2F;&#x2F; pageSize                11,     &#x2F;&#x2F; maxOrder                3,      &#x2F;&#x2F; tinyCacheSize                3,      &#x2F;&#x2F; smallCacheSize                3,      &#x2F;&#x2F; normalCacheSize                true    &#x2F;&#x2F; useCacheForAllThreads                );        &#x2F;&#x2F; create tiny buffer        final ByteBuf b1 &#x3D; allocator.directBuffer(24);        &#x2F;&#x2F; create small buffer        final ByteBuf b2 &#x3D; allocator.directBuffer(800);        &#x2F;&#x2F; create normal buffer        final ByteBuf b3 &#x3D; allocator.directBuffer(8192 * 2);        Assert.assertNotNull(b1);        Assert.assertNotNull(b2);        Assert.assertNotNull(b3);        &#x2F;&#x2F; then release buffer to deallocated memory while threadlocal cache has been disabled        &#x2F;&#x2F; allocations counter value must equals deallocations counter value        Assert.assertTrue(b1.release());        Assert.assertTrue(b2.release());        Assert.assertTrue(b3.release());&#125;&#125;</code></pre><h3 id="PoolChunk"><a href="#PoolChunk" class="headerlink" title="PoolChunk"></a>PoolChunk</h3><p>PoolChunk本身数据结构与设计思路参见PoolChunk注释：       </p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Description of algorithm for PageRun/PoolSubpage allocation from PoolChunk</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Notation: The following terms are important to understand the code</span><span class="hljs-comment"> * &gt; page  - a page is the smallest unit of memory chunk that can be allocated</span><span class="hljs-comment"> * page是chunk中能分配的最小单元  </span><span class="hljs-comment"> * &gt; chunk - a chunk is a collection of pages</span><span class="hljs-comment"> * 一个chunk中有一组page  1对多  </span><span class="hljs-comment"> * &gt; in this code chunkSize = 2^&#123;maxOrder&#125; * pageSize</span><span class="hljs-comment"> * 代码中  chunksize大小计算如上  maxOrder 是啥？</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * To begin we allocate a byte array of size = chunkSize</span><span class="hljs-comment"> * Whenever a ByteBuf of given size needs to be created we search for the first position</span><span class="hljs-comment"> * in the byte array that has enough empty space to accommodate the requested size and</span><span class="hljs-comment"> * return a (long) handle that encodes this offset information, (this memory segment is then</span><span class="hljs-comment"> * marked as reserved so it is always used by exactly one ByteBuf and no more)</span><span class="hljs-comment"> * 首先，当需要创建给定大小的ByteBuf时，我们分配一个size=chunkSize的字节数组，</span><span class="hljs-comment"> * 在字节数组中搜索第一个有足够的空空间来容纳请求的大小的位置，</span><span class="hljs-comment"> * 并返回一个（长）句柄来编码该偏移量信息（然后将该内存段标记为保留，因此它总是仅由一个ByteBuf使用，不再使用）</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * For simplicity all sizes are normalized according to PoolArena#normalizeCapacity method</span><span class="hljs-comment"> * This ensures that when we request for memory segments of size &gt;= pageSize the normalizedCapacity</span><span class="hljs-comment"> * equals the next nearest power of 2</span><span class="hljs-comment"> * 为了简单起见，所有大小都按照PoolArena#normalizeCapacity方法进行规范化</span><span class="hljs-comment"> * 这确保当我们请求大小大于等于pageSize的内存段时，normalized容量等于下一个最接近的2的幂</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * To search for the first offset in chunk that has at least requested size available we construct a</span><span class="hljs-comment"> * complete balanced binary tree and store it in an array (just like heaps) - memoryMap</span><span class="hljs-comment"> * 为了搜索块中至少有请求大小可用的第一个偏移量，我们构造了一个完整的平衡二叉树，并将其存储在一个数组（就像堆一样）-内存映射中</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * The tree looks like this (the size of each node being mentioned in the parenthesis)</span><span class="hljs-comment"> * 树看起来是这样的（括号中提到的每个节点的大小）</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * depth=0        1 node (chunkSize)</span><span class="hljs-comment"> * depth=1        2 nodes (chunkSize/2)</span><span class="hljs-comment"> * ..</span><span class="hljs-comment"> * ..</span><span class="hljs-comment"> * depth=d        2^d nodes (chunkSize/2^d)</span><span class="hljs-comment"> * ..</span><span class="hljs-comment"> * depth=maxOrder 2^maxOrder nodes (chunkSize/2^&#123;maxOrder&#125; = pageSize)  pageSize 在最下一层  最顶层是chunksize 从上往下走，每过一层除以2  </span><span class="hljs-comment"> *</span><span class="hljs-comment"> * depth=maxOrder is the last level and the leafs consist of pages</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * With this tree available searching in chunkArray translates like this:</span><span class="hljs-comment"> * To allocate a memory segment of size chunkSize/2^k we search for the first node (from left) at height k</span><span class="hljs-comment"> * which is unused 要分配大小为chunkSize/2^k的内存段，我们在高度k处搜索第一个未使用的节点（从左开始）。 嗯嗯</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Algorithm:</span><span class="hljs-comment"> * ----------</span><span class="hljs-comment"> * Encode the tree in memoryMap with the notation  用符号将树编码在内存中</span><span class="hljs-comment"> *   memoryMap[id] = x =&gt; in the subtree rooted at id, the first node that is free to be allocated</span><span class="hljs-comment"> *   is at depth x (counted from depth=0) i.e., at depths [depth_of_id, x), there is no node that is free</span><span class="hljs-comment"> * 在以id为根的子树中，可自由分配的第一个节点在深度x（从深度=0开始计算），即在深度[深度id，x的深度]处，没有可自由分配的节点</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *  As we allocate &amp; free nodes, we update values stored in memoryMap so that the property is maintained</span><span class="hljs-comment"> * 当我们分配空闲节点时，我们更新存储在memoryMap中的值，以便维护属性</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Initialization -</span><span class="hljs-comment"> *   In the beginning we construct the memoryMap array by storing the depth of a node at each node</span><span class="hljs-comment"> * 首先，我们通过在每个节点上存储一个节点的深度来构造memoryMap数组</span><span class="hljs-comment"> *     i.e., memoryMap[id] = depth_of_id</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Observations:</span><span class="hljs-comment"> * -------------</span><span class="hljs-comment"> * 1) memoryMap[id] = depth_of_id  =&gt; it is free / unallocated</span><span class="hljs-comment"> * 2) memoryMap[id] &gt; depth_of_id  =&gt; at least one of its child nodes is allocated, so we cannot allocate it, but</span><span class="hljs-comment"> *                                    some of its children can still be allocated based on their availability</span><span class="hljs-comment"> * 3) memoryMap[id] = maxOrder + 1 =&gt; the node is fully allocated &amp; thus none of its children can be allocated, it</span><span class="hljs-comment"> *                                    is thus marked as unusable</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Algorithm: [allocateNode(d) =&gt; we want to find the first node (from left) at height h that can be allocated]</span><span class="hljs-comment"> * ----------</span><span class="hljs-comment"> * 1) start at root (i.e., depth = 0 or id = 1)</span><span class="hljs-comment"> * 2) if memoryMap[1] &gt; d =&gt; cannot be allocated from this chunk</span><span class="hljs-comment"> * 3) if left node value &lt;= h; we can allocate from left subtree so move to left and repeat until found</span><span class="hljs-comment"> * 4) else try in right subtree</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Algorithm: [allocateRun(size)]</span><span class="hljs-comment"> * ----------</span><span class="hljs-comment"> * 1) Compute d = log_2(chunkSize/size)</span><span class="hljs-comment"> * 2) Return allocateNode(d)</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Algorithm: [allocateSubpage(size)]</span><span class="hljs-comment"> * ----------</span><span class="hljs-comment"> * 1) use allocateNode(maxOrder) to find an empty (i.e., unused) leaf (i.e., page)</span><span class="hljs-comment"> * 2) use this handle to construct the PoolSubpage object or if it already exists just call init(normCapacity)</span><span class="hljs-comment"> *    note that this PoolSubpage object is added to subpagesPool in the PoolArena when we init() it</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Note:</span><span class="hljs-comment"> * -----</span><span class="hljs-comment"> * In the implementation for improving cache coherence,</span><span class="hljs-comment"> * we store 2 pieces of information depth_of_id and x as two byte values in memoryMap and depthMap respectively</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * memoryMap[id]= depth_of_id  is defined above</span><span class="hljs-comment"> * depthMap[id]= x  indicates that the first node which is free to be allocated is at depth x (from root)</span><span class="hljs-comment"> */</span><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PoolChunk</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">PoolChunkMetric</span> </span>&#123;</code></pre><p>io.netty.buffer.PoolArena.findSubpagePoolHead(int)  算出page header在page table中的index，小的page在前面    </p><p>// trace 库地址 jdbc:h2:/Users/simon/twice-cooked-pork/trace-data/基于netty4做的resetserver的一次http请求trace/tracer.data.h2db  </p><p>PoolChunk要解决的问题有：  </p><ol><li>快速查找未分配的地方并分配</li><li>尽量不要有碎片，可以理解成尽量挨着紧凑的分配</li></ol><p>整个chunk的结构如下：  </p><pre><code class="hljs html">                                                    +------+   chunksize 当L=11时，是16ML=0                                                 |   0  |                                   +----------------+------+------------------+                                   |                                          |                                   |                                          |                                   |                                          |                               +---v--+                                   +---v--+L=1                            |   1  |                                   |   2  |                        +------+------+------+                     +------+------+-------+                        |                    |                     |                     |                        |                    |                     |                     |                        |                    |                     |                     |                    +---v--+             +---v--+              +---v--+              +---v--+L=2                 |   3  |             |   4  |              |   5  |              |   6  |                 +--+------+-+         +-+------+--+        +--+------+--+         +-+------+--+                 |           |         |           |        |            |         |           |                 |           |         |           |        |            |         |           |                 |           |         |           |        |            |         |           |              +--v---+   +---v--+   +--v---+   +---v--+   +-v----+   +---v--+   +--v---+   +---v--+L=3           |  7   |   |   8  |   |  9   |   |  10  |   |  11  |   |  12  |   |  13  |   |  14  |              +------+   +------+   +------+   +------+   +------+   +------+   +------+   +------+               8K大小即page size</code></pre><p>是一个完全二叉树，树的层高可以自定义，目前限制在14层内，默认是11层。<br>最底层是真正的chunk描述，最底层每个叶子是一个paage，大小为8K。那么当层数是11层时，chunk的size是16M。因为11层的话，最下面一层叶子是2的11次方，再乘以8K正好是16MB。<br>这棵树中每个节点还对对应其相应的大小是否被分配。什么叫其相应的大小？是这样的，每一层代表需要分配的大小的档次。暂且用档次这个词吧。最上面是16MB档次，最下面是8K档次，从最上面开始往下走一层，档次就除以2。<br>每次申请内存时，netty会先对其做规格化，所谓规格化就是最接近申请内存值的2de整数次幂。比如我申请900byte，那么规格化后就是1K。在规格化后，netty会在树上标志 0 1 3 7被使用了。下次要再申请8K内存时就要避开这个路径了，只能是 0 1 3 8 了，因为7那边已经不够了。其他大小同理。所以树上的节点是为了标志是否被使用过，以使得内存碎片减少尽量靠左紧凑分配。   对于单page内的内存使用浪费问题，netty又做了一层位图结构使其得以利用。对于chunk对象的查找，netty还做了缓存机制，下面有讲。 </p><p>真正数据存放在 io.netty.buffer.PoolChunk.memory 这个字段中，调试时为：java.nio.DirectByteBuffer[pos=0 lim=16777216 cap=16777216]<br>16777216是16M  </p><h4 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h4><p>仔细调试 1K 2k 3K 8K 11K 内存的多次分配与回收。</p><h4 id="分配24byte过程"><a href="#分配24byte过程" class="headerlink" title="分配24byte过程"></a>分配24byte过程</h4><p>PooledUnsafeDirectByteBuf是用了对象池特性io.netty.buffer.PooledUnsafeDirectByteBuf.RECYCLER  </p><h3 id="PoolArena"><a href="#PoolArena" class="headerlink" title="PoolArena"></a>PoolArena</h3><p><code>PoolArena</code> 这一层负责创建与维护PoolChunk，维护的方式是将用到的正在分配中的PoolChunk放到PoolChunkList这个列表中。<br>PoolChunkList是一个链是结构。<br>而且，PoolArena还<strong>按PoolChunk的使用量</strong>来<strong>分别维护到相对应</strong>的PoolChunkList中。  </p><pre><code class="hljs java"><span class="hljs-comment">// abstract class PoolArena&lt;T&gt; implements PoolArenaMetric &#123;</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PoolChunkList&lt;T&gt; q050;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PoolChunkList&lt;T&gt; q025;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PoolChunkList&lt;T&gt; q000;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PoolChunkList&lt;T&gt; qInit;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PoolChunkList&lt;T&gt; q075;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PoolChunkList&lt;T&gt; q100;</code></pre><p>这些PoolChunkList也是<strong>按使用量大小有序的链式的串在一起</strong>(参见PoolArena构造方法中初始化这些list字段的代码)，当使用量达到本级别时，会加入到下一级别的list中，比如达到25%了，那么就会加到50%列表中了。(参见io.netty.buffer.PoolChunkList.add(PoolChunk<T>))   </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(PoolChunk&lt;T&gt; chunk)</span> </span>&#123;    <span class="hljs-keyword">if</span> (chunk.usage() &gt;= maxUsage) &#123;        nextList.add(chunk);        <span class="hljs-keyword">return</span>;    &#125;    add0(chunk);&#125;</code></pre><p>PoolArena中还维护了两个PoolSubpage数组，每个数组里面的实例在PoolArena构造时初始化，刚初始化后每个PoolSubpage元素的前继与后继元素都是指向自己(PoolSubpage是支持链表式的一个结构)<br>在io.netty.buffer.PoolSubpage.addToPool(PoolSubpage<T>)时 会将io.netty.buffer.PoolChunk.allocateSubpage(int)过程中新构建出来的PoolSubpage实例<strong>加到head的next节点上(即后继节点)</strong>。 具体代码如下：  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-title">allocateSubpage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> normCapacity)</span> </span>&#123;    <span class="hljs-comment">// Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.</span>    <span class="hljs-comment">// This is need as we may add it back and so alter the linked-list structure.</span>    PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(normCapacity); <span class="hljs-comment">// 这个是查找PoolArena的PoolSubpage数组</span>    <span class="hljs-keyword">int</span> d = maxOrder; <span class="hljs-comment">// subpages are only be allocated from pages i.e., leaves</span>    <span class="hljs-keyword">synchronized</span> (head) &#123;        <span class="hljs-keyword">int</span> id = allocateNode(d);        <span class="hljs-keyword">if</span> (id &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> id;        &#125;        <span class="hljs-keyword">final</span> PoolSubpage&lt;T&gt;[] subpages = <span class="hljs-keyword">this</span>.subpages;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> pageSize = <span class="hljs-keyword">this</span>.pageSize;        freeBytes -= pageSize;        <span class="hljs-keyword">int</span> subpageIdx = subpageIdx(id);        PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx];        <span class="hljs-keyword">if</span> (subpage == <span class="hljs-keyword">null</span>) &#123;            subpage = <span class="hljs-keyword">new</span> PoolSubpage&lt;T&gt;(head, <span class="hljs-keyword">this</span>, id, runOffset(id), pageSize, normCapacity); <span class="hljs-comment">// 此处会将新新构建出来的PoolSubpage实例加到head的next节点</span>            subpages[subpageIdx] = subpage;        &#125; <span class="hljs-keyword">else</span> &#123;            subpage.init(head, normCapacity);        &#125;        <span class="hljs-keyword">return</span> subpage.allocate();    &#125;&#125;</code></pre><h3 id="PoolArenad的cache与Recycler对象池"><a href="#PoolArenad的cache与Recycler对象池" class="headerlink" title="PoolArenad的cache与Recycler对象池"></a>PoolArenad的cache与Recycler对象池</h3><p>PooledByteBuf依赖PoolThreadCache做了一层对PoolChunk的缓存,PoolThreadCache靠MemoryRegionCache实现缓存。MemoryRegionCache靠队列来实现对PoolChunk的缓存(参见下面代码1)，MemoryRegionCache在buf释放时会调用其add接口将释放的PoolChunk对象和nioBuffer对象通过io.netty.buffer.PoolThreadCache.MemoryRegionCache.Entry<T>对象包装后加入(offer)到队列(参见下面堆栈1)。在io.netty.buffer.PoolThreadCache.MemoryRegionCache.allocate(PooledByteBuf<T>, int)时再从队列中直接poll出来，达成cache的目的。优化还没有结束，包装PoolChunk用的Entry对象是通过<code>Recycler</code>对象池完成分配(获取)已释放的。对象是本质上一个通过FastThreadLocal的Stack的数据结构，分配对应出栈，释放对象入栈。具体参见下面代码2。<br>Recycler<PooledUnsafeDirectByteBuf><br>是一个基于ThreadLocal结合stack玩起来的一个对象池数据结构，像上述这种就是PooledUnsafeDirectByteBuf的对象pool。回收的时候压栈，要用的时候出栈。<br>获取对象  io.netty.util.Recycler.get()<br>回收对象  io.netty.util.Recycler.DefaultHandle.recycle(Object)   </p><p>代码1： 队列初始化  </p><pre><code class="hljs java">Queue&lt;Entry&lt;T&gt;&gt; queue = PlatformDependent.newFixedMpscQueue(<span class="hljs-keyword">this</span>.size);</code></pre><p>堆栈1：buf释放时会调用MemoryRegionCache add接口将释放的PoolChunk对象包装后入队：  </p><pre><code class="hljs java">Thread [main] (Suspended (breakpoint at line <span class="hljs-number">393</span> in PoolThreadCache$MemoryRegionCache))PoolThreadCache$SubPageMemoryRegionCache&lt;T&gt;(PoolThreadCache$MemoryRegionCache&lt;T&gt;).add(PoolChunk&lt;T&gt;, ByteBuffer, <span class="hljs-keyword">long</span>) line: <span class="hljs-number">393</span>PoolThreadCache.add(PoolArena&lt;?&gt;, PoolChunk, ByteBuffer, <span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>, SizeClass) line: <span class="hljs-number">209</span>PoolArena$DirectArena(PoolArena&lt;T&gt;).free(PoolChunk&lt;T&gt;, ByteBuffer, <span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>, PoolThreadCache) line: <span class="hljs-number">273</span>PooledUnsafeDirectByteBuf(PooledByteBuf&lt;T&gt;).deallocate() line: <span class="hljs-number">171</span>PooledUnsafeDirectByteBuf(AbstractReferenceCountedByteBuf).release0(<span class="hljs-keyword">int</span>) line: <span class="hljs-number">136</span>PooledUnsafeDirectByteBuf(AbstractReferenceCountedByteBuf).release() line: <span class="hljs-number">124</span>PooledByteBufTest.main(String[]) line: <span class="hljs-number">43</span></code></pre><p>代码2：Entry对象使用对象池    </p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Recycler&lt;Entry&gt; RECYCLER = <span class="hljs-keyword">new</span> Recycler&lt;Entry&gt;() &#123;    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Entry <span class="hljs-title">newObject</span><span class="hljs-params">(Handle&lt;Entry&gt; handle)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Entry(handle);    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Entry <span class="hljs-title">newEntry</span><span class="hljs-params">(PoolChunk&lt;?&gt; chunk, ByteBuffer nioBuffer, <span class="hljs-keyword">long</span> handle)</span> </span>&#123;    Entry entry = RECYCLER.get();    entry.chunk = chunk;    entry.nioBuffer = nioBuffer;    entry.handle = handle;    <span class="hljs-keyword">return</span> entry;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recycle</span><span class="hljs-params">(Object object)</span> </span>&#123;    <span class="hljs-keyword">if</span> (object != value) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"object does not belong to handle"</span>);    &#125;    Stack&lt;?&gt; stack = <span class="hljs-keyword">this</span>.stack;    <span class="hljs-keyword">if</span> (lastRecycledId != recycleId || stack == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"recycled already"</span>);    &#125;    stack.push(<span class="hljs-keyword">this</span>);&#125;</code></pre><h3 id="PooledByteBufAllocator创建及其关联细节"><a href="#PooledByteBufAllocator创建及其关联细节" class="headerlink" title="PooledByteBufAllocator创建及其关联细节"></a>PooledByteBufAllocator创建及其关联细节</h3><ol><li>PooledByteBufAllocator validateAndCalculateChunkSize 校验树高度不能超过14，且根据pageSize(可以外部指定)和树高计算出chunksize</li><li>PooledByteBufAllocator validateAndCalculatePageShifts 校验pageSize最小不能小于4K，且pageSize必须是2的整数次方((pageSize &amp; pageSize - 1) != 0) （为什么(pageSize &amp; pageSize - 1) != 0能判断？因为2的n次方的二进制形式一定是第一位1后面接n个0，减1后就变成第一位0后面接n个1，相与之后一定是0；如果不是2的n次方的数的二进制形式一定是第一位是1，且，这个数减去1后，第一位一定还是1，因为第一位是1且后面全接0的数一定是2的整数次方的，那么不是2的整数次方的数后面一定不全是0，所以减去1后第一位肯定还是1，所以不管后面接的这些数相与是怎样的结果，第一位两个1相与出来肯定是1，肯定不为0，所以能用这个办法判断）</li><li>创建tinySubpagePools数组并初始化里面的元素，默认数组大小32个，里面的元素是PoolSubpage，PoolSubpage还支持链式形式连接(他有前继和后继)</li></ol><h3 id="PoolChunk-分配与释放小于pagesize的buf"><a href="#PoolChunk-分配与释放小于pagesize的buf" class="headerlink" title="PoolChunk 分配与释放小于pagesize的buf"></a>PoolChunk 分配与释放小于pagesize的buf</h3><p>io.netty.buffer.PoolArena.free(PoolChunk<T>, ByteBuffer, long, int, PoolThreadCache)<br>位图相关：  </p><pre><code class="hljs java"><span class="hljs-comment">// long64位 取 高32位转成整数</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bitmapIdx</span><span class="hljs-params">(<span class="hljs-keyword">long</span> handle)</span> </span>&#123;        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (handle &gt;&gt;&gt; Integer.SIZE);    &#125;</code></pre><p>PoolSubpage 支持位图<br>一个page 8192大小 一个块(element)大小32，那么一个page可以拆成256个，每申请一次numAvail减去1。<br>long型位图数组中有个8个元素，8192/16/64=8, 64是long的位数,。</p><p>分配时bitmap中元素，以第一个元素为例子，按1 3 7 15 31 63 127网上涨，释放的时候按对应数据往下减，并且在释放时记录nextAvail值，便于下次申请时优先使用。<br>bitmap中的4个(bitmapLength)long来维护256个（maxNumElems=pageSize/elemSize）块是否使用的情况。  </p><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PoolSubpage</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">PoolSubpageMetric</span> </span>&#123;    <span class="hljs-keyword">final</span> PoolChunk&lt;T&gt; chunk;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> memoryMapIdx;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> runOffset;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> pageSize;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span>[] bitmap;  <span class="hljs-comment">// 位图...,默认有8个元素 个数= pagesize &gt;&gt;&gt; 10 （pagesize / 16 / 64）64应该是long的位数，16是啥？一个element算256。 实际这个数组默认只用4个元素</span>    PoolSubpage&lt;T&gt; prev;    PoolSubpage&lt;T&gt; next;    <span class="hljs-keyword">boolean</span> doNotDestroy;    <span class="hljs-keyword">int</span> elemSize;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxNumElems; <span class="hljs-comment">// 一个page再分maxNumElems分  默认是256</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> bitmapLength; <span class="hljs-comment">// 默认是4  256 &gt;&gt;&gt; 6 = 4</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> nextAvail; <span class="hljs-comment">// 在有buf释放时会设置这个值，以使得他们在下次分配时优先使用这个</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numAvail;        <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">allocate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (elemSize == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> toHandle(<span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">if</span> (numAvail == <span class="hljs-number">0</span> || !doNotDestroy) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bitmapIdx = getNextAvail();        <span class="hljs-keyword">int</span> q = bitmapIdx &gt;&gt;&gt; <span class="hljs-number">6</span>;        <span class="hljs-keyword">int</span> r = bitmapIdx &amp; <span class="hljs-number">63</span>;        <span class="hljs-keyword">assert</span> (bitmap[q] &gt;&gt;&gt; r &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>;        bitmap[q] |= <span class="hljs-number">1L</span> &lt;&lt; r;  <span class="hljs-comment">// 按1 3 7 15 31 63 127往上涨</span>        <span class="hljs-keyword">if</span> (-- numAvail == <span class="hljs-number">0</span>) &#123;            removeFromPool();        &#125;        <span class="hljs-keyword">return</span> toHandle(bitmapIdx);    &#125;            <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNextAvail</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span>[] bitmap = <span class="hljs-keyword">this</span>.bitmap;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bitmapLength = <span class="hljs-keyword">this</span>.bitmapLength;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bitmapLength; i ++) &#123;            <span class="hljs-keyword">long</span> bits = bitmap[i];            <span class="hljs-keyword">if</span> (~bits != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 这个表示这个long上是否所有的位都用完了。。</span>                <span class="hljs-keyword">return</span> findNextAvail0(i, bits);            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNextAvail0</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">long</span> bits)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxNumElems = <span class="hljs-keyword">this</span>.maxNumElems;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> baseVal = i &lt;&lt; <span class="hljs-number">6</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">64</span>; j ++) &#123;            <span class="hljs-keyword">if</span> ((bits &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 判断是否是偶数</span>                <span class="hljs-keyword">int</span> val = baseVal | j;                <span class="hljs-keyword">if</span> (val &lt; maxNumElems) &#123;                    <span class="hljs-keyword">return</span> val;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            bits &gt;&gt;&gt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// 除以2 并向靠近的2的整数次幂对齐</span>        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;</code></pre><p>free时不是每次都会真正释放，在下面会先加入到MemoryRegionCache的queue中cache起来，当queue中放不下时才真正free，代码如下：  </p><pre><code class="hljs java"><span class="hljs-comment">// PoolArena.class</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">free</span><span class="hljs-params">(PoolChunk&lt;T&gt; chunk, ByteBuffer nioBuffer, <span class="hljs-keyword">long</span> handle, <span class="hljs-keyword">int</span> normCapacity, PoolThreadCache cache)</span> </span>&#123;    <span class="hljs-keyword">if</span> (chunk.unpooled) &#123;        <span class="hljs-keyword">int</span> size = chunk.chunkSize();        destroyChunk(chunk);        activeBytesHuge.add(-size);        deallocationsHuge.increment();    &#125; <span class="hljs-keyword">else</span> &#123;        SizeClass sizeClass = sizeClass(normCapacity);        <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span> &amp;&amp; cache.add(<span class="hljs-keyword">this</span>, chunk, nioBuffer, handle, normCapacity, sizeClass)) &#123;            <span class="hljs-comment">// cached so not free it.</span>            <span class="hljs-keyword">return</span>;        &#125;        freeChunk(chunk, handle, sizeClass, nioBuffer);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>netty4源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty之ResourceLeakDetector的使用与实现</title>
    <link href="/2020/04/20/netty4-resource-leak-detector-impl/"/>
    <url>/2020/04/20/netty4-resource-leak-detector-impl/</url>
    
    <content type="html"><![CDATA[<p>通过<strong>WeakReference和ReferenceQueue</strong>做针对<strong>需要手动释放</strong>的资源的侦测  </p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>设置日志级别：  <pre><code class="hljs java">ServerBootstrap b =<span class="hljs-keyword">new</span> ServerBootstrap();b.group(bossGroup,workerGroup).channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">.<span class="hljs-title">option</span>(<span class="hljs-title">ChannelOption</span>.<span class="hljs-title">SO_BACKLOG</span>, 2048)</span><span class="hljs-class">.<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">LoggingHandler</span>(<span class="hljs-title">LogLevel</span>.<span class="hljs-title">DEBUG</span>))</span><span class="hljs-class">.<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChildChannelHandler</span>())</span>;<span class="hljs-number">2017</span>-<span class="hljs-number">01</span>-<span class="hljs-number">19</span> <span class="hljs-number">10</span>:<span class="hljs-number">04</span>:<span class="hljs-number">49</span>  [ nioEventLoopGroup-<span class="hljs-number">1</span>-<span class="hljs-number">0</span>:<span class="hljs-number">1628830</span> ] - [ ERROR ]  LEAK: ByteBuf.release() was not called before it<span class="hljs-string">'s garbage-coll...</span></code></pre></li><li>ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.ADVANCED);或者通过JVM参数配置<br>日志：  <pre><code class="hljs java"><span class="hljs-number">2017</span>-<span class="hljs-number">01</span>-<span class="hljs-number">19</span> <span class="hljs-number">10</span>:<span class="hljs-number">35</span>:<span class="hljs-number">59</span>  [ nioEventLoopGroup-<span class="hljs-number">1</span>-<span class="hljs-number">0</span>:<span class="hljs-number">665092</span> ] - [ ERROR ]  LEAK: ByteBuf.release() was not called before it<span class="hljs-string">'s garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for more information.</span><span class="hljs-string">Recent access records: 5</span><span class="hljs-string">#5:</span><span class="hljs-string">    io.netty.buffer.AdvancedLeakAwareByteBuf.readBytes(AdvancedLeakAwareByteBuf.java:435)</span></code></pre></li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>[ ERROR ]  LEAK:   </p><pre><code class="hljs java"><span class="hljs-comment">// ResourceLeakDetector</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reportTracedLeak</span><span class="hljs-params">(String resourceType, String records)</span> </span>&#123;    logger.error(            <span class="hljs-string">"LEAK: &#123;&#125;.release() was not called before it's garbage-collected. "</span> +            <span class="hljs-string">"See http://netty.io/wiki/reference-counted-objects.html for more information.&#123;&#125;"</span>,            resourceType, records);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reportLeak</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (!logger.isErrorEnabled()) &#123;        clearRefQueue();        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// Detect and report previous leaks.</span>    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)        DefaultResourceLeak ref = (DefaultResourceLeak) refQueue.poll(); <span class="hljs-comment">// 为什么能拿到？什么时候 放进去的？是weakreference回收过程中放进去的，相当于GC过程让你插入hook。那为什么被GC了还有资源泄露呢？这个问题其实是这样的，泄露是池化内存等那些需要手动释放资源。</span>        <span class="hljs-keyword">if</span> (ref == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">if</span> (!ref.dispose()) &#123; <span class="hljs-comment">// return allLeaks.remove(this); 所以当有人显式释放过，那么此处就返回false 就不会往下走report了</span>            <span class="hljs-keyword">continue</span>;        &#125;        String records = ref.toString();        <span class="hljs-keyword">if</span> (reportedLeaks.putIfAbsent(records, Boolean.TRUE) == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (records.isEmpty()) &#123;                reportUntracedLeak(resourceType);            &#125; <span class="hljs-keyword">else</span> &#123;                reportTracedLeak(resourceType, records);            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="基本实现原理"><a href="#基本实现原理" class="headerlink" title="基本实现原理"></a>基本实现原理</h3><ol><li>通过DefaultResourceLeak继承自WeakReference，借助WeakReference的GC特性完成。WeakReference的GC特性是当这个对象没有被其他强引用对象引用时，仅仅被WeakReference引用(或者其他weak引用)时，会在下一次GC时回收，回收过程中会将被回收的引用放到ReferenceQueue中。此处的ReferenceQueue又是在创建DefaultResourceLeak时通过构造参数传入的。</li><li>不时poll那个ReferenceQueue队列，当拿到对象时看起dispose是否被调用过，如果没有则证明没有显示释放，则report出来。  </li><li>每次创建池化buf对象时，便会创建DefaultResourceLeak，并在touch等API中调用其record方法，追踪其申请使用的地方。在开启了泄露追踪后，buf会被包装，比如包装成AdvancedLeakAwareByteBuf。    </li><li>侦测reportLeak不是每次都调用，当小雨PARANOID级别是在申请buf时按随机数比例调。PARANOID级别是全调。</li></ol><p>此处资源泄露，是指那种需要手动释放的资源，因为引用他的对象已经不在程序逻辑中使用了，那么最终会被GC回收，但是那种需要手动释放的资源不显式释放就泄露了。比如内存池，比方说里面有5个杯子，你用的buf指向一个杯子被你占着，你不用时没显式告诉内存池说这个杯子不用了，那么就一直占着，但是buf对象不用了会被GC回收，那么此时内存池资源就泄露了。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>netty4源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty之idle handler处理</title>
    <link href="/2020/04/20/netty4-idle-handler/"/>
    <url>/2020/04/20/netty4-idle-handler/</url>
    
    <content type="html"><![CDATA[<ol><li>初始化时记录idle时间，并启动一个延时任务，延时时间为idle时间，延时任务是io.netty.handler.timeout.IdleStateHandler.AllIdleTimeoutTask  </li><li>channelReadComplete 会更新lastReadTime，lastWriteTime是在write操作返回的ChannelFuture实例上挂上listener监听operationComplete动作来更新的，详细参见io.netty.handler.timeout.IdleStateHandler.writeListener</li><li>AllIdleTimeoutTask 任务逻辑中会取lastReadTime, lastWriteTime大值，并拿nextDelay减去他们，这样就能得到下次任务要延期多就检查执行。    </li></ol><p>比如一开始是10：00，5分钟idle时间，那么会在10：05时检查(延迟5分钟)，如果在10：04发生了读写，那么在10：05检查时算出下一次延迟启动任务是4分钟后即10：09分。 </p><p>读写超时是基于此做的事件，检查机制类似。<br>且在netty4中未使用 HashedWheelTimer，而是在线NioEventLoop的spin loop中完成触发。在spin loop中会从io.netty.util.concurrent.AbstractScheduledEventExecutor.scheduledTaskQueue中peek出最前面(也是最早到达的定时任务)的看其deadline是否小于当前时间，如果是则执行。<br>HashedWheelTimer是在netty3中用来做idle检测的。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>netty4源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可以用命令行控制eclipse断点增加删除、远程调试创建与启动的插件</title>
    <link href="/2020/04/20/use-curl-to-manage-breakpoint-on-eclipse/"/>
    <url>/2020/04/20/use-curl-to-manage-breakpoint-on-eclipse/</url>
    
    <content type="html"><![CDATA[<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><pre><code class="hljs bash"><span class="hljs-comment"># 创建断点(支持条件断点)</span>curl  -X PUT -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"language":"java","condition":"i == 1","charStart":283,"charEnd":307,"lineNumber":16,"typeName":"com.code260.tools.redstar.dp.java.TestStub","hitCount":-1,"projectName":"test-debug","filePath":"/src/com/code260/tools/redstar/dp/java/TestStub.java"&#125;'</span> http://127.0.0.1:8884/redstar/breakpoint/java<span class="hljs-comment"># 删除断点</span>curl  -X DELETE -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"language":"java","condition":"i == 1","charStart":283,"charEnd":307,"lineNumber":16,"typeName":"com.code260.tools.redstar.dp.java.TestStub","hitCount":-1,"projectName":"test-debug","filePath":"/src/com/code260/tools/redstar/dp/java/TestStub.java"&#125;'</span> http://127.0.0.1:8884/redstar/breakpoint/java<span class="hljs-comment"># 创建远程调试</span>curl  -X PUT -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"name":"tes-debug-001","hostname":"127.0.0.1","port":8501,"projectName":"test-debug","vmConnector":"org.eclipse.jdt.launching.socketAttachConnector","allowTerminal":false&#125;'</span> http://127.0.0.1:8884/redstar/launch-debug/java<span class="hljs-comment"># 启动远程调试</span>curl  -X POST -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"name":"tes-debug-001"&#125;'</span> http://127.0.0.1:8884/redstar/launch-debug/java<span class="hljs-comment"># 查询所有断点</span>curl http://127.0.0.1:8884/redstar/breakpoint/java<span class="hljs-comment"># 监听断点事件</span>curl http://127.0.0.1:8884/redstar/debug-event/java/watch<span class="hljs-comment"># 放掉一个断点</span>curl  -X POST -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"launchName":"tes-debug-001", "threadName":"main"&#125;'</span> http://127.0.0.1:8884/redstar/breakpoint/java/resume<span class="hljs-comment"># inspect一个表达式</span>curl  -X POST -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"launchName":"tes-debug-001", "threadName":"main", "expression":"i=i+5","projectName":"test-debug"&#125;'</span> http://127.0.0.1:8884/redstar/debug-event/java/inspect</code></pre><h2 id="scala"><a href="#scala" class="headerlink" title="scala"></a>scala</h2><pre><code class="hljs bash"><span class="hljs-comment"># 创建断点(支持条件断点)</span>curl  -X PUT -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"language":"scala","condition":"","charStart":-1,"charEnd":-1,"lineNumber":6,"typeName":"testpkg.TestObject","hitCount":-1,"projectName":"test-scala","filePath":"/src/testpkg/TestObject.scala"&#125;'</span> http://127.0.0.1:8884/redstar/breakpoint/java<span class="hljs-comment"># 删除断点</span>curl  -X DELETE -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"language":"scala","condition":"i == 1","charStart":-1,"charEnd":-1,"lineNumber":6,"typeName":"testpkg.TestObject","hitCount":-1,"projectName":"test-scala","filePath":"/src/testpkg/TestObject.scala"&#125;'</span> http://127.0.0.1:8884/redstar/breakpoint/java<span class="hljs-comment"># 创建远程调试</span>curl  -X PUT -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"name":"tes-debug-001","hostname":"127.0.0.1","port":8500,"projectName":"test-scala","vmConnector":"org.scala-ide.sdt.debug.socketAttachConnector","allowTerminal":false&#125;'</span> http://127.0.0.1:8884/redstar/launch-debug/java<span class="hljs-comment"># 启动远程调试</span>curl  -X POST -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"name":"tes-debug-001"&#125;'</span> http://127.0.0.1:8884/redstar/launch-debug/java<span class="hljs-comment"># 查询所有断点</span>curl http://127.0.0.1:8884/redstar/breakpoint/java<span class="hljs-comment"># 监听断点事件</span>curl http://127.0.0.1:8884/redstar/debug-event/java/watch<span class="hljs-comment"># 放掉一个断点</span>curl  -X POST -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"launchName":"tes-debug-001", "threadName":"main"&#125;'</span> http://127.0.0.1:8884/redstar/breakpoint/java/resume<span class="hljs-comment"># inspect一个表达式</span>curl  -X POST -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"launchName":"tes-debug-001", "threadName":"main", "expression":"i=i+5","projectName":"test-debug"&#125;'</span> http://127.0.0.1:8884/redstar/debug-event/java/inspect</code></pre><p><a href="https://files.cnblogs.com/files/simoncook/redstar-dp-java-eclipse-site.zip" target="_blank" rel="noopener">插件下载地址</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>dev-tools</tag>
      
      <tag>eclipse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu开发机所需工具，做个记录，不断补充</title>
    <link href="/2020/04/20/dev-tools-on-ubuntu/"/>
    <url>/2020/04/20/dev-tools-on-ubuntu/</url>
    
    <content type="html"><![CDATA[<h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><p>FSearch 用了下可以， 类似windows下的Everything 或者mac的cmd+空格<br><a href="https://github.com/cboxdoerfer/fsearch" target="_blank" rel="noopener">地址</a><br>安装：  </p><blockquote><p>sudo add-apt-repository ppa:christian-boxdoerfer/fsearch-daily<br>sudo apt-get update<br>sudo apt install fsearch-trunk  </p></blockquote><p>subl 1.txt   sublime比自带gedit顺手  </p><p>nautilus ./ 启动文件浏览器  </p>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dev-tools</tag>
      
      <tag>ubutnu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于dubbo扩展点的一点分析</title>
    <link href="/2020/04/20/about-dubbo-extension-loader/"/>
    <url>/2020/04/20/about-dubbo-extension-loader/</url>
    
    <content type="html"><![CDATA[<h2 id="扩展点能力"><a href="#扩展点能力" class="headerlink" title="扩展点能力"></a>扩展点能力</h2><ol><li>能load class，这个class除了顶层接口class（在ExtensionLoader中对应type字段），还能load各实现类的class。</li><li>能创建instance。</li><li>能指定这个顶层接口的默认实现类的beanName。做法参见SPI注解部分。</li><li>能把创建出来的instance的字段注入。set开头的且有一个参数且是public的，注入。  </li><li>能adaptive。根据url上对该接口配置的实现类，将该接口的事情交给这个实现类去做(我更多的理解成委托)。此能力采用代码生成再编译的方式。代码生成示例可以参见adaptive类代码示例。 adaptive只会生成一个adaptive实现类。生成代码的逻辑在com.alibaba.dubbo.common.extension.ExtensionLoader.createAdaptiveExtensionClassCode()  </li><li>能wrapper。wrapper是指这个顶层接口的实现类的构造函数的入参是这个顶层接口类型。那么这个实现类称之为wrapper类，可以有多个，构建instance时不分多个之间的顺序。因为用来给构造函数传参的instance是这个顶层类的默认实现。比如com.alibaba.dubbo.rpc.Protocol接口，有实现类 com.alibaba.dubbo.rpc.protocol.injvm.InjvmProtocol beanName是injvm，QosProtocolWrapper、ProtocolListenerWrapper、ProtocolFilterWrapper是其三个wrapper类。创建warpper instance的代码逻辑在com.alibaba.dubbo.common.extension.ExtensionLoader.createExtension(String)中。  </li><li>能active。实现类加了Activate注解的。在ExtensionLoader.getActivateExtension时会根据当前的url(配置信息)中值来匹配Activate注解中指定的值是否能match，能match的表示是activate，意思是命中的。在过滤器扩展点中用到。比如这个过滤器是给CONSUMER group用。示例有ExceptionFilter等。同时该注解还能支持order属性来定义bean的顺序。     </li></ol><h2 id="扩展点使用"><a href="#扩展点使用" class="headerlink" title="扩展点使用"></a>扩展点使用</h2><h3 id="配置文件相关"><a href="#配置文件相关" class="headerlink" title="配置文件相关"></a>配置文件相关</h3><p>配置文件放在哪里？</p><ol><li>META-INF/dubbo/internal/配置文件  </li><li>META-INF/dubbo/配置文件  </li><li>META-INF/services/配置文件  </li></ol><p>配置文件名是顶层接口全限定名，比如：com.alibaba.dubbo.rpc.Protocol  </p><p>配置文件中内容：<br>一行是一个实现类的定义，大致是<br>beanName=实现类的class的全限定名，这个后面还可以接上#xxx（这个能力实际使用少）。beanName=这部分不是必须的。可以仅仅写实现类的全限定名。   </p><h3 id="注解相关"><a href="#注解相关" class="headerlink" title="注解相关"></a>注解相关</h3><h4 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h4><p>SPI注解用在顶层接口上，其值表示这个接口的默认实现类的beanName，也即是说指定一个顶层接口的默认实现通过SPI注解加载顶层接口上指定即可。  </p><h4 id="Adaptive"><a href="#Adaptive" class="headerlink" title="Adaptive"></a>Adaptive</h4><p>Adaptive注解用在顶层接口或者接口的方法上，其表示这个接口或者这个方法需要有adaptive的类委托完成，未加注解的会生成不支持的操作的方式实现。    </p><h4 id="Activate"><a href="#Activate" class="headerlink" title="Activate"></a>Activate</h4><p>Activate注解用在实现类上，其表示实现类在rpc时根据url参数中以及注解中指定的key 目标value是否能匹配来决定此bean是否被选中(一般用在过滤器的命中判断上)。  </p><h2 id="生成的代码"><a href="#生成的代码" class="headerlink" title="生成的代码"></a>生成的代码</h2><h3 id="adaptive类代码示例"><a href="#adaptive类代码示例" class="headerlink" title="adaptive类代码示例"></a>adaptive类代码示例</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.alibaba.dubbo.registry;<span class="hljs-keyword">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegistryFactory</span>$<span class="hljs-title">Adaptive</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">com</span>.<span class="hljs-title">alibaba</span>.<span class="hljs-title">dubbo</span>.<span class="hljs-title">registry</span>.<span class="hljs-title">RegistryFactory</span> </span>&#123;<span class="hljs-keyword">public</span> com.alibaba.dubbo.registry.<span class="hljs-function">Registry <span class="hljs-title">getRegistry</span><span class="hljs-params">(com.alibaba.dubbo.common.URL arg0)</span> </span>&#123;<span class="hljs-keyword">if</span> (arg0 == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"url == null"</span>);com.alibaba.dubbo.common.URL url = arg0;String extName = (url.getProtocol() == <span class="hljs-keyword">null</span> ? <span class="hljs-string">"dubbo"</span> : url.getProtocol());<span class="hljs-keyword">if</span> (extName == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Fail to get extension(com.alibaba.dubbo.registry.RegistryFactory) name from url("</span> + url.toString()+ <span class="hljs-string">") use keys([protocol])"</span>);com.alibaba.dubbo.registry.RegistryFactory extension = (com.alibaba.dubbo.registry.RegistryFactory) ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.registry.RegistryFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getExtension</span>(<span class="hljs-title">extName</span>)</span>;<span class="hljs-keyword">return</span> extension.getRegistry(arg0);&#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.alibaba.dubbo.rpc.cluster;<span class="hljs-keyword">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cluster</span>$<span class="hljs-title">Adaptive</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">com</span>.<span class="hljs-title">alibaba</span>.<span class="hljs-title">dubbo</span>.<span class="hljs-title">rpc</span>.<span class="hljs-title">cluster</span>.<span class="hljs-title">Cluster</span> </span>&#123;<span class="hljs-keyword">public</span> com.alibaba.dubbo.rpc.<span class="hljs-function">Invoker <span class="hljs-title">join</span><span class="hljs-params">(com.alibaba.dubbo.rpc.cluster.Directory arg0)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> com.alibaba.dubbo.rpc.RpcException </span>&#123;<span class="hljs-keyword">if</span> (arg0 == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"com.alibaba.dubbo.rpc.cluster.Directory argument == null"</span>);<span class="hljs-keyword">if</span> (arg0.getUrl() == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"com.alibaba.dubbo.rpc.cluster.Directory argument getUrl() == null"</span>);com.alibaba.dubbo.common.URL url = arg0.getUrl();String extName = url.getParameter(<span class="hljs-string">"cluster"</span>, <span class="hljs-string">"failover"</span>);<span class="hljs-keyword">if</span> (extName == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Fail to get extension(com.alibaba.dubbo.rpc.cluster.Cluster) name from url("</span> + url.toString()+ <span class="hljs-string">") use keys([cluster])"</span>);com.alibaba.dubbo.rpc.cluster.Cluster extension = (com.alibaba.dubbo.rpc.cluster.Cluster) ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.cluster.Cluster<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getExtension</span>(<span class="hljs-title">extName</span>)</span>;<span class="hljs-keyword">return</span> extension.join(arg0);&#125;&#125;</code></pre><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>查找所有的dubbo扩展点形式的配置文件  </p><pre><code class="hljs shell">find ./ -type f -name "com.alibaba.dubbo*"|grep -v "/target/"|grep -v "/bin/"|grep -v "/test/"</code></pre><p>另：<br>关于代理模式，dubbo未实现通用的，只是rpc语义实现里rpc调用的代理，借助扩展点机器加动态代理完成。<br>具体其顶层接口是com.alibaba.dubbo.rpc.ProxyFactory。用在比如将EchoService编织进每次RPC调用中。  </p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>guice的能力简述</title>
    <link href="/2020/04/20/guice-features-brief-introducting/"/>
    <url>/2020/04/20/guice-features-brief-introducting/</url>
    
    <content type="html"><![CDATA[<p>guice这个google出的bean容器框架，ES有用到他。  </p><h2 id="能干什么"><a href="#能干什么" class="headerlink" title="能干什么"></a>能干什么</h2><ol><li>是一个bean容器</li><li>能AOPa</li></ol><h2 id="能力细分与使用方式"><a href="#能力细分与使用方式" class="headerlink" title="能力细分与使用方式"></a>能力细分与使用方式</h2><ol><li>以module创建injector。可以看成是一个容器。Module需要自定义且继承自他的AbstractModule。覆写config方法完成装配关系的确定。详细参见<a href="https://gitee.com/xiaguangme/guice-demo/blob/master/src/main/java/com/code260/ss/guice/demo/bill/BillingModule.java" target="_blank" rel="noopener">这里</a>  </li><li>绑定顶层接口到具体实现类。bind(TransactionLog.class).to(DatabaseTransactionLog.class); 支持bind(A).to(B) 然后链式的 bind(B).to(C)</li><li>支持在构造函数上打上Inject注解标签，用于注入字段</li><li>支持自定义注解用于标志装配目标，比如自定义注解Paypal。  对于加了PayPal注解的参数，注入PaypalCreditCardProcessor实现，其余的注入GoogleCheckoutProcessor实现。bind(CreditCardProcessor.class).annotatedWith(PayPal.class).to(PaypalCreditCardProcessor.class);</li><li>对于加了Named注解 其值为testnamed的地方注入TestNamedCreditCardProcessor实现。bind(CreditCardProcessor.class).annotatedWith(Names.named(“testnamed”)).to(TestNamedCreditCardProcessor.class);</li><li>结合Named注解 可以将一个参数绑定一个特定的instance 而不是一个实现类。bind(Integer.class).annotatedWith(Names.named(“chargeTimeout”)).toInstance(200);</li><li>可以使用Provides注解 主动对外提供创建的bean 有点类似 Spring的@Bean注解，这种方式可以对bean做自定义加工。相当于反转了bind的那个动作  同时也可以结合 自定义注解 使用 比如上面的@Paypal 效果相同。但是这种方式创建的bean不能参与AOP 因为instance是用户创建的嘛,所以任何额外逻辑编编织不进去了。那怎么解决这个问题，guice在bind后提供了toConstructor方法去指定实现类。这样就连Inject注解都不需要了。因为这个实现类可能是三方提供的。</li><li>用自定义注解的方式结合bindInterceptor方式完成 本质上是个拦截器 AOP这些接口遵循AOP联盟约定。 有点类似jfinal的理念。</li></ol><h2 id="部分示例代码"><a href="#部分示例代码" class="headerlink" title="部分示例代码"></a>部分示例代码</h2><p>全部的参见<a href="https://gitee.com/xiaguangme/guice-demo" target="_blank" rel="noopener">这里</a>  </p><h3 id="测试主类"><a href="#测试主类" class="headerlink" title="测试主类"></a>测试主类</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code260.ss.guice.demo.bill;<span class="hljs-keyword">import</span> com.google.inject.Guice;<span class="hljs-keyword">import</span> com.google.inject.Injector;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 1. 以module创建injector</span><span class="hljs-comment">         */</span>        Injector injector = Guice.createInjector(<span class="hljs-keyword">new</span> BillingModule());        RealBillingService billingService = injector.getInstance(RealBillingService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        billingService.chargeOrder(<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);        TestCustomAnnotationBillingService testCustomAnnotationBillingService = injector.getInstance(TestCustomAnnotationBillingService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        testCustomAnnotationBillingService.chargeOrder(<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);        TestNamedBillingService testNamedBillingService = injector.getInstance(TestNamedBillingService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        testNamedBillingService.chargeOrder(<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);    &#125;&#125;</code></pre><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code260.ss.guice.demo.bill;<span class="hljs-keyword">import</span> com.google.inject.AbstractModule;<span class="hljs-keyword">import</span> com.google.inject.Provides;<span class="hljs-keyword">import</span> com.google.inject.matcher.Matcher;<span class="hljs-keyword">import</span> com.google.inject.matcher.Matchers;<span class="hljs-keyword">import</span> com.google.inject.name.Names;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BillingModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractModule</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 2. 绑定接口到实现类</span><span class="hljs-comment">         */</span>        <span class="hljs-comment">/**</span><span class="hljs-comment">         * LinkedBindings</span><span class="hljs-comment">         * 支持 bind(A).to(B) 然后链式的 bind(B).to(C)</span><span class="hljs-comment">         * to完之后 还支持in in后面接的是Scope 有Singleton</span><span class="hljs-comment">         */</span>        bind(TransactionLog<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">to</span>(<span class="hljs-title">DatabaseTransactionLog</span>.<span class="hljs-title">class</span>)</span>;        bind(CreditCardProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">to</span>(<span class="hljs-title">GoogleCheckoutProcessor</span>.<span class="hljs-title">class</span>)</span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 6. 结合Named注解 可以将一个参数绑定一个特定的instance 而不是一个实现类</span><span class="hljs-comment">         */</span>        bind(Integer.class).annotatedWith(Names.named("chargeTimeout")).toInstance(200);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 4. 对于加了PayPal注解的参数，注入PaypalCreditCardProcessor实现，其余的注入GoogleCheckoutProcessor实现</span><span class="hljs-comment">         */</span>        bind(CreditCardProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">annotatedWith</span>(<span class="hljs-title">PayPal</span>.<span class="hljs-title">class</span>).<span class="hljs-title">to</span>(<span class="hljs-title">PaypalCreditCardProcessor</span>.<span class="hljs-title">class</span>)</span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 5. 对于加了Named注解 其值为testnamed的地方注入TestNamedCreditCardProcessor实现</span><span class="hljs-comment">         */</span>        bind(CreditCardProcessor.class).annotatedWith(Names.named("testnamed")).to(TestNamedCreditCardProcessor.class);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 8. 用自定义注解的方式结合bindInterceptor方式完成 本质上是个拦截器 有点类似jfinal的理念</span><span class="hljs-comment">         */</span>        bindInterceptor(Matchers.any(), Matchers.annotatedWith(NonWeekend<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">new</span> <span class="hljs-title">NotOnWeekendsInterceptor</span>())</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 7. 可以使用Provides注解 主动对外提供创建的bean 有点类似 Spring的<span class="hljs-doctag">@Bean</span>注解，这种方式可以对bean做自定义加工</span><span class="hljs-comment">     * 相当于反转了bind的那个动作  同时也可以结合 自定义注解 使用 比如上面的<span class="hljs-doctag">@Paypal</span> 效果相同</span><span class="hljs-comment">     * 但是这种方式创建的bean不能参与AOP 因为instance是用户创建的嘛,所以任何额外逻辑编编织不进去了。</span><span class="hljs-comment">     * 那怎么解决这个问题，guice在bind后提供了toConstructor方法去指定实现类。</span><span class="hljs-comment">     * 这样就连Inject注解都不需要了。因为这个实现类可能是三方提供的</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Provides</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AlertService <span class="hljs-title">provideAlertService</span><span class="hljs-params">()</span> </span>&#123;        RedAlertService redAlertService = <span class="hljs-keyword">new</span> RedAlertService();        redAlertService.setTestAttribute();        <span class="hljs-keyword">return</span> redAlertService;    &#125;&#125;</code></pre><h3 id="用于AOP的拦截器类"><a href="#用于AOP的拦截器类" class="headerlink" title="用于AOP的拦截器类"></a>用于AOP的拦截器类</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code260.ss.guice.demo.bill;<span class="hljs-keyword">import</span> org.aopalliance.intercept.MethodInterceptor;<span class="hljs-keyword">import</span> org.aopalliance.intercept.MethodInvocation;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotOnWeekendsInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation methodInvocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        System.out.println(<span class="hljs-string">"do something before NotOnWeekendsInterceptor invoke"</span>);        Object result =  methodInvocation.proceed();        System.out.println(<span class="hljs-string">"do something after NotOnWeekendsInterceptor invoke"</span>);        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>guice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用部分函数时并未include其所在头文件，但是能编译成功且能运行，为什么？</title>
    <link href="/2020/04/20/not-include-but-why-successfully/"/>
    <url>/2020/04/20/not-include-but-why-successfully/</url>
    
    <content type="html"><![CDATA[<p>最近在看APUE，试了上面的一些例子，其中有个例子是使用getpid函数获取进程id，但是在我写demo时，并未引入其所在的头文件unistd.h，结果也能编译成功，也能运行，于是就琢磨下为啥。<br>Environment info: Ubuntu 18.04.2 LTS, gcc (Ubuntu 4.8.5-4ubuntu8) 4.8.5<br>示意代码如下：  </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;    <span class="hljs-keyword">long</span> pid = (<span class="hljs-keyword">long</span>)getpid();    <span class="hljs-keyword">long</span> test = pid + <span class="hljs-number">1</span>;&#125;</code></pre><p>在satckoverflow上有人告诉我，因为我用的是GCC4系列，使用是的C90标准且自带GUN扩展，所以对这种问题不给出警告，且能成功运行。<br>如果是C99标准就会编译时有警告。<br>同时指出即使能成功运行但是这是一个不好的习惯，所以还是要严格include  </p><p>我意外试了下 在CDT中可以一样使用ctrl+shift+o 进行自动include<br>也可以使用  ctrl+shift+T 进行库查找…  </p>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c cpp编程用到的系统边角与其拾遗</title>
    <link href="/2020/04/20/cpp-programming-scraps/"/>
    <url>/2020/04/20/cpp-programming-scraps/</url>
    
    <content type="html"><![CDATA[<h2 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h2><p>Q：unix编程怎么查一个函数在哪个头文件中<br>A: 可以用诸如 man 3 printf  </p><p>Q: man后面接个数字什么意思，如man 3 printf<br>A：如下 man man中的引用</p><blockquote><p>下表显示了手册的 章节 号及其包含的手册页类型。<br>1   可执行程序或 shell 命令<br>2   系统调用(内核提供的函数)<br>3   库调用(程序库中的函数)<br>4   特殊文件(通常位于 /dev)<br>5   文件格式和规范，如 /etc/passwd<br>6   游戏<br>7   杂项(包括宏包和规范，如 man(7)，groff(7))<br>8   系统管理命令(通常只针对 root 用户)<br>9   内核例程 [非标准  </p></blockquote><p>Q: 怎么在man的所有章节中搜索<br>A： man -k printf   </p><pre><code class="hljs shell">appweb@simon-ububtu18-desk-2:~/600.self/03.code/01.cpp/03.APUE$ man -k printfasprintf (3)         - print to allocated stringdprintf (3)          - formatted output conversionfprintf (3)          - formatted output conversionfwprintf (3)         - formatted wide-character output conversionprintf (1)           - format and print dataprintf (3)           - formatted output conversionsnprintf (3)         - formatted output conversionsprintf (3)          - formatted output conversionswprintf (3)         - formatted wide-character output conversionvasprintf (3)        - print to allocated stringvdprintf (3)         - formatted output conversionvfprintf (3)         - formatted output conversionvfwprintf (3)        - formatted wide-character output conversionvprintf (3)          - formatted output conversionvsnprintf (3)        - formatted output conversionvsprintf (3)         - formatted output conversionvswprintf (3)        - formatted wide-character output conversionvwprintf (3)         - formatted wide-character output conversionwprintf (3)          - formatted wide-character output conversionXtAsprintf (3)       - memory management functions</code></pre><p>可以看到1和3中都有  1中是对应shell的 3中对应的是程序库中的    </p><p>Q: 怎么查看编译器在哪些路径中搜索头文件<br>A：如下：<br>可以参见 <a href="https://stackoverflow.com/questions/344317/where-does-gcc-look-for-c-and-c-header-files" target="_blank" rel="noopener">https://stackoverflow.com/questions/344317/where-does-gcc-look-for-c-and-c-header-files</a><br>大意与验证如下：  </p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 对于c++的如下： </span>appweb@simon-ububtu18-desk-2:~/600.self/03.code/01.cpp/03.APUE$ `gcc -print-prog-name=cc1plus` -vignoring nonexistent directory "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../x86_64-linux-gnu/include"<span class="hljs-meta">#</span><span class="bash">include <span class="hljs-string">"..."</span> search starts here:</span><span class="hljs-meta">#</span><span class="bash">include &lt;...&gt; search starts here:</span> /usr/include/c++/4.8 /usr/include/x86_64-linux-gnu/c++/4.8 /usr/include/c++/4.8/backward /usr/lib/gcc/x86_64-linux-gnu/4.8/include /usr/local/include /usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed /usr/includeEnd of search list.^C<span class="hljs-meta">#</span><span class="bash"> 对于c的如下：  </span>appweb@simon-ububtu18-desk-2:~/600.self/03.code/01.cpp/03.APUE$ `gcc -print-prog-name=cpp` -vUsing built-in specs.COLLECT_GCC=cppOFFLOAD_TARGET_NAMES=nvptx-noneOFFLOAD_TARGET_DEFAULT=1Target: x86_64-linux-gnuConfigured with: ../src/configure -v --with-pkgversion='Ubuntu 7.4.0-1ubuntu1~18.04.1' --with-bugurl=file:///usr/share/doc/gcc-7/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-7 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-libmpx --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnuThread model: posixgcc version 7.4.0 (Ubuntu 7.4.0-1ubuntu1~18.04.1) COLLECT_GCC_OPTIONS='-E' '-v' '-mtune=generic' '-march=x86-64' /usr/lib/gcc/x86_64-linux-gnu/7/cc1 -E -quiet -v -imultiarch x86_64-linux-gnu - -mtune=generic -march=x86-64 -fstack-protector-strong -Wformat -Wformat-securityignoring nonexistent directory "/usr/local/include/x86_64-linux-gnu"ignoring nonexistent directory "/usr/lib/gcc/x86_64-linux-gnu/7/../../../../x86_64-linux-gnu/include"<span class="hljs-meta">#</span><span class="bash">include <span class="hljs-string">"..."</span> search starts here:</span><span class="hljs-meta">#</span><span class="bash">include &lt;...&gt; search starts here:</span> /usr/lib/gcc/x86_64-linux-gnu/7/include /usr/local/include /usr/lib/gcc/x86_64-linux-gnu/7/include-fixed /usr/include/x86_64-linux-gnu /usr/includeEnd of search list.</code></pre>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>白菜油渣</title>
    <link href="/2020/04/19/cabbage-residue/"/>
    <url>/2020/04/19/cabbage-residue/</url>
    
    <content type="html"><![CDATA[<p>白菜炒猪油渣，朴素的美食</p><p><img src="/img/food/WechatIMG317.jpeg" srcset="/img/loading.gif" alt="白菜炒猪油渣"></p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>food</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JVM G1源码分析和调优》读书笔记</title>
    <link href="/2020/04/19/jvm-g1-gc-book/"/>
    <url>/2020/04/19/jvm-g1-gc-book/</url>
    
    <content type="html"><![CDATA[<h2 id="GC的相关算法与JVM的垃圾收集器"><a href="#GC的相关算法与JVM的垃圾收集器" class="headerlink" title="GC的相关算法与JVM的垃圾收集器"></a>GC的相关算法与JVM的垃圾收集器</h2><h3 id="GC的相关算法"><a href="#GC的相关算法" class="headerlink" title="GC的相关算法"></a>GC的相关算法</h3><ul><li>分代管理</li><li>复制算法</li><li>标记清除</li><li>标记压缩</li></ul><h3 id="JVM垃圾收集器"><a href="#JVM垃圾收集器" class="headerlink" title="JVM垃圾收集器"></a>JVM垃圾收集器</h3><p>P242 表11-1 不同类型垃圾回收期比较  </p><ul><li>串行收集器 Serial。  Serial GC用于新生代，用了复制算法；Serial Old GC作用于老年代，用的是标记-压缩算法。STW</li><li>并行收集器 Parallel。Parallel new作用于新生代，使用了复制算法；Parallel old作用于老年代，用了标记-压缩算法。STW。并发收集是准确收集，不会产生浮动垃圾。</li><li>并发收集器 Concurrent-Mark-Sweep。老年代垃圾回收器。使用了标记-清除算法。分为初始标记(Initial-Mark,STW)、并发标记(Concurrent-Mark)、再次标记(Remark,STW)、并发清除(Concurrent-Sweep)。CMS因为需要存储代际的引用关系，所以有额外的存储空间的消耗。CMS不是准确收集，会产生浮动垃圾。</li><li>垃圾优先收集器 G1。按照分区进行收集，新生代的分区总是会回收，老生代则是并发标记后选择部分回收效果最好的分区。G1分为三种回收方式：<code>新生代回收</code>young、<code>混合回收</code>(mixed，既收集新生代也收集部分老年代)、<code>FUll GC</code>。<code>新生代回收</code>仅仅在开始前需要STW。<code>混合回收</code>分成两个阶段：并发标记阶段与垃圾回收阶段。并发标记阶段又分四个步骤：初始标记子阶段(initital-mark)、并发标记子阶段(concurrent-mark)、再标记子阶段(remark,STW)、清理子阶段(cleanup,STW)。因分区设计，G1引用关系的存储占用额外空间的消耗较大。G1不是准确收集，会产生浮动垃圾。</li></ul><h2 id="G1基本概念"><a href="#G1基本概念" class="headerlink" title="G1基本概念"></a>G1基本概念</h2><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>G1是将内存分成一个个小区域使用。这些区域称之为Heap Region。扩展的有<code>YHR</code>(新生代分区)，<code>OHR</code>(老生代分区)，<code>HHR</code>(大对象分区)等等<br>为了达到分配效率与清理效率的平衡，HR的大小有上下限值，即1MB-32MB。结合整个堆空间分为2048个HR，那么通常G1管理的最大的堆是32MB*2048=64G。  </p><h3 id="新生代大小"><a href="#新生代大小" class="headerlink" title="新生代大小"></a>新生代大小</h3><h4 id="用参数设置使得G1能推断出最大值与最小值"><a href="#用参数设置使得G1能推断出最大值与最小值" class="headerlink" title="用参数设置使得G1能推断出最大值与最小值"></a>用参数设置使得G1能推断出最大值与最小值</h4><p>涉及的参数有:</p><ul><li>新生代最大值MaxNewSize、最小值NewSize、Xmn(等价于MaxNewSize和NewSize，且MaxNewSize=NewSize)</li><li>NewRatio，如果上条参数设置了，则忽略本参数</li><li>如果仅仅设置了NewRatio，则新生代最大值与最小值相同：整个堆空间/(newRatio+1)</li><li>如果没有设置最大值和最小值，或者只设置了其中一个，那么G1将根据参数G1MaxNewSizePercent(默认60)和G1NewSizePercent(默认是5)占整个堆空间的比例来计算。</li></ul><p><strong>如果G1推断出的新生代的最大值与最小值相等，则说明新生代不会动态变化，不会动态变化则可能导致后续新生代GC时不能满足期望的停顿时间</strong>，所以有文章提到G1不建议设置Xmn参数。  </p><p>相关代码在 share/vm/gc_implementation/g1/g1collectorPolicy.cpp  </p><h3 id="G1启发式推断新生代大小"><a href="#G1启发式推断新生代大小" class="headerlink" title="G1启发式推断新生代大小"></a>G1启发式推断新生代大小</h3><p>G1有一个线程专门抽样处理预测新生代列表的长度应该多大，并动态调整。  </p><p>何时扩展以及一次扩展多少内存？<br>参数-XX:GCTimeRatio 表示GC与应用的耗费时间的比，G1默认是9。也就是说GC的耗时与应用耗时占比超过10%时，进行动态扩展。扩展大小的参数是G1ExpandByPercentOfAvailable，同时至少大于1MB，至多不能超过当前已经分配的大小的一倍。<br>代码在 size_t G1CollectorPolicy::expansion_amount()….<br>该书在第五章讲refine线程时对此点有更详细的阐述  </p><h3 id="G1停顿预测模型"><a href="#G1停顿预测模型" class="headerlink" title="G1停顿预测模型"></a>G1停顿预测模型</h3><p>比较偏数学 我就很快跳过去了<br>G1的预测逻辑是基于衰减平均(Decaying Average)和衰减标准差。  </p><h3 id="卡表和位图"><a href="#卡表和位图" class="headerlink" title="卡表和位图"></a>卡表和位图</h3><p>卡表(CardTable)是CMS中中常见概念之一。我理解成分区间对象引用关系的描述 的存放处或者说存放的数据结构。此书也是讲的较为简略，细节可以参见《垃圾回收算法手册：自动内存管理的艺术》  </p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>讲JVM内存模型必讲对象头。可以参见我写的<a href="cnblogs.com/simoncook/p/11804427.html">JVM中对象模型及相应名词概念</a>  </p><h3 id="栈帧、线程等"><a href="#栈帧、线程等" class="headerlink" title="栈帧、线程等"></a>栈帧、线程等</h3><p>栈帧可以参见 封亚飞 写的《揭秘Java虚拟机》第七章 Java栈帧，写的更详细。此书只是一笔带过，看了跟没看没啥差别。  </p><h2 id="G1的对象分配"><a href="#G1的对象分配" class="headerlink" title="G1的对象分配"></a>G1的对象分配</h2><ul><li>快速分配与慢速分配</li><li>快速分配通过TLAB(Thread Local Allocation Buffer)实现。TLAB自己的分配是CAS操作。TLAB内部给对象分配是无锁的，因为只有自己线程用嘛。  </li><li>TLAB机制或产生内存浪费，因为一个对象不会分配在两个TLAB区域，所以TLAB最末端的尾巴区域可能会残留空着。可以通过TLABRefillWasteFraction参数调整，表示允许产生浪费的比例。默认值是64，即表示1/64空间可以浪费。</li><li>TLAB大小可以自动调整，但是上限不会超过HR的一半。、</li><li>可以使用参数-XX:-ResizeTLAB禁用ResizeTLAB，并使用参数-XX:TLABSize指定一个大小。-XX:+PrintTLAB可以跟踪TLAB工作情况。</li><li><strong>一般不建议修改TLAB参数，建议使用默认值</strong></li></ul><p>TLAB快速分配的代码在 HeapWord* CollectedHeap::allocate_from_tlab…  </p><h2 id="G1的Refine线程"><a href="#G1的Refine线程" class="headerlink" title="G1的Refine线程"></a>G1的Refine线程</h2><p>先讲Rset</p><h3 id="Rset"><a href="#Rset" class="headerlink" title="Rset"></a>Rset</h3><p>Rset是干什么用的？  </p><ul><li>Rset是一种抽象概念，记录了在不同代际之间的引用关系，目的是为了加速GC。</li><li>通俗地说，可以用Rset记录从非收集部分指向收集部分的指针集合。对于这种记录述求，有两种方式，一是<code>我引用了谁</code>，称为<code>Point Out</code>；一是<code>谁引用了我</code>，称为<code>Point In</code>。G1采用后者。</li><li>G1中需要记录代际之间的引用关系包括：老生代分区到新生代分区之间的引用关系(YGC时，这个引用关系是GC Roots的一部分，老生代引用过来的不能被回收掉嘛…)；老生代分区到老生代分区之间的引用关系(混合GC时用)</li><li>Rset与卡表的关系参见P68图4-1</li><li>G1引入了PRT，TODO：没看太懂</li><li>DCQ与Refinemnet zone的四色区域没看太懂</li></ul><h3 id="Rset写屏障"><a href="#Rset写屏障" class="headerlink" title="Rset写屏障"></a>Rset写屏障</h3><p>为啥谈到写屏障，因为Refine是线程关注的是应用关系的变更，但是他是如何识别引用关系的变更的呢？就是靠写屏障完成。下面讲写屏障相关要点：  </p><ul><li>写屏障这个词我不知道为啥这样命名，直觉上不好理解。  </li><li>我对其的理解就是，写操作前后的拦截器处理。比如我对字段赋值putfield，在赋值前我要告诉DCQ这个对象被我引用了，这就是写屏障动作。  </li><li>书上的说法：<code>写屏障</code>是指在改变特定内存的值时，额外执行的一些动作。  </li><li>CMS是通过写屏障记录引用刮不洗，G1也是。  </li><li>写屏障会有优化，不是所有的引用关系变更都会被记录。  <ul><li>不记录新生代到新生代的引用，或者新生代到老生代的引用，在写屏障时过滤</li><li>过滤掉同一个分区内部引用，在Rset处理时过滤</li><li>过滤掉空引用，在Rset处理时过滤</li></ul></li></ul><h3 id="Refine线程"><a href="#Refine线程" class="headerlink" title="Refine线程"></a>Refine线程</h3><ul><li>Refine线程是一组，是一个线程池，不是一个。</li><li>我对他的理解是，一个线程用于抽样，主要作用设置新生代分区的个数。其余线程用于管理Rset，Rset的更新不是同步完成的，是靠Refine线程异步完成的，异步又是靠DCQ dirty card queue队列暂存过渡的。 </li><li>Refine涉及的JVM比较复杂，未细细研究</li><li>相关参数：可以通过-XX:+G1TraceConcRefinement观察Refine线程工作情况。通过-XX:+G1SummarizeRSetStats观察Rset更新。</li></ul><h2 id="新生代回收"><a href="#新生代回收" class="headerlink" title="新生代回收"></a>新生代回收</h2><p>上面已经讲了，G1 GC分三种： <code>新生代回收</code>young、<code>混合回收</code>(mixed，既收集新生代也收集部分老年代)、<code>FUll GC</code>  </p><p>步骤：  </p><ol><li>选择CSet</li><li>根处理</li><li>Rset处理</li><li>复制</li><li>Redirty 重构Rset</li><li>释放空间  </li></ol><h3 id="相关日志"><a href="#相关日志" class="headerlink" title="相关日志"></a>相关日志</h3><p>可以用-XX:G1LogLevel=finest 打开更详细的日志<br>关键字 GC pause (G1 Evacuation Pause) (young)， 0.0182341 secs…  </p><h3 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h3><h2 id="混合回收"><a href="#混合回收" class="headerlink" title="混合回收"></a>混合回收</h2><p><code>混合回收</code>分成两个阶段：</p><ul><li>并发标记阶段</li><li>垃圾回收阶段(与新生代回收一致)  </li></ul><p>并发标记阶段又分四个步骤：</p><ol><li>初始标记子阶段(initital-mark)</li><li>并发标记子阶段(concurrent-mark)</li><li>再标记子阶段(remark,STW)</li><li>清理子阶段(cleanup,STW</li></ol><p>并发标记的难点：<br>正在标记过程中的对象引用关系发生了改变。<br>通过三色标记法与STAB算法结合写屏障完成。<br>写屏障代码在 oop_store中,oop.inline.hpp  </p><h3 id="相关日志-1"><a href="#相关日志-1" class="headerlink" title="相关日志"></a>相关日志</h3><p>关键字 GC pause (G1 Evacuation Pause) (mixed)， 0.0106341 secs…<br> GC pause (G1 Evacuation Pause) (young) (initial-mark),….  // 初始标记借用了YGC<br>[GC concurrent-mark-start]…<br>[GC concurrent-mark-end]…<br>[GC remark …]…<br>[GC cleanup …]…  </p><h3 id="参数调优-1"><a href="#参数调优-1" class="headerlink" title="参数调优"></a>参数调优</h3><h2 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h2><p>JDK10之前FGC是串行的，JDK10之后支持并行。<br>代码在 G1CollectedHeap::do_collection<br>串行回收采用标记清除算法，步骤：  </p><ol><li>标记活跃对象</li><li>计算新对象地址</li><li>把所有对象都更新到新地址上</li><li>移动对象完成压缩</li></ol><h3 id="相关日志-2"><a href="#相关日志-2" class="headerlink" title="相关日志"></a>相关日志</h3><p>[Full GC (Allocation Failure) …..  0.2036229 secs]….  </p><h2 id="G1调优"><a href="#G1调优" class="headerlink" title="G1调优"></a>G1调优</h2><p>主要涉及的指标有： 吞吐量最大、停段时间尽量端、GC频率尽量低和堆空间的有效利用率高。<br>主要调优参数 参见P244 表11-2，主要涉及堆、RSet、标记和GC四个方面的参数。</p>]]></content>
    
    
    <categories>
      
      <category>book-paper-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty4 FastThreadLocal及CPU cacheline padding补齐</title>
    <link href="/2020/04/19/netty4-fastthhreadlocal/"/>
    <url>/2020/04/19/netty4-fastthhreadlocal/</url>
    
    <content type="html"><![CDATA[<h2 id="FastThreadLocal"><a href="#FastThreadLocal" class="headerlink" title="FastThreadLocal"></a>FastThreadLocal</h2><p>概述： ThreadLocal的一个特定变种改善，有更好的存取性能。<br>内部采用一个数组来代替ThreadLocal内部的hash表来存放变量。虽然这看起来是微不足道的，但是他确实比hash表性能好那么一点，在频繁存取时会更明显。 如果用DefaultThreadFactory创建线程，那么默认创建出来的就是FastThreadLocalThread，就会用FastThreadLocal。  </p><p>set数据靠InternalThreadLocalMap维护，InternalThreadLocalMap内部靠一个数组(就是上面说的)维护变量数据。  </p><p>扩展了什么:<br>按ThreadLocal API的约定行为，依赖InternalThreadLocalMap实现了这些行为，诸如get、set、remove等。<br>remove支持onRemoval回调。  </p><h2 id="InternalThreadLocalMap"><a href="#InternalThreadLocalMap" class="headerlink" title="InternalThreadLocalMap"></a>InternalThreadLocalMap</h2><h3 id="自身实例获取"><a href="#自身实例获取" class="headerlink" title="自身实例获取"></a>自身实例获取</h3><p>get方法是对外暴露去自身实例的，有两种方式取到InternalThreadLocalMap实例：</p><ul><li>如果当前线程是FastThreadLocalThreadInternal，直接取其实例变量ThreadLocalMap，内部称之为fastGet。  </li><li>如果是JDK的Thread，那么靠JDK的TheadLocal取到ThreadLocalMap，内部称之为slowGet。  </li></ul><h3 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a>数据存取</h3><p>真正的存取变量是靠<code>indexedVariable</code>和<code>setIndexedVariable</code>方法完成。<br>阅读代码不难发现，是靠Object[]  indexedVariables这个数组达成数据存储的目的。  </p><h3 id="存放数据的数组扩容"><a href="#存放数据的数组扩容" class="headerlink" title="存放数据的数组扩容"></a>存放数据的数组扩容</h3><p>indexedVariables数组靠expandIndexedVariableTableAndSet动态扩容。初始长度是32。<br>扩容算法有点意思，是比当前index小的最大的2的n次方的值扩一倍，比如当前index是132，那么就会扩成256长度的数组。  </p><pre><code class="hljs java">Object[] oldArray = indexedVariables;<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> oldCapacity = oldArray.length;<span class="hljs-keyword">int</span> newCapacity = index;newCapacity |= newCapacity &gt;&gt;&gt;  <span class="hljs-number">1</span>;newCapacity |= newCapacity &gt;&gt;&gt;  <span class="hljs-number">2</span>;newCapacity |= newCapacity &gt;&gt;&gt;  <span class="hljs-number">4</span>;newCapacity |= newCapacity &gt;&gt;&gt;  <span class="hljs-number">8</span>;newCapacity |= newCapacity &gt;&gt;&gt; <span class="hljs-number">16</span>;newCapacity ++;</code></pre><h3 id="是否完全用数组存放数据？"><a href="#是否完全用数组存放数据？" class="headerlink" title="是否完全用数组存放数据？"></a>是否完全用数组存放数据？</h3><p>不完全是。因为<code>InternalThreadLocalMap</code>的父类<code>UnpaddedInternalThreadLocalMap</code>自带了一些常用的字段：  </p><ul><li>futureListenerStackDepth</li><li>localChannelReaderStackDepth</li><li>handlerSharableCache  </li><li>counterHashCode</li><li>random</li><li>typeParameterMatcherGetCache</li><li>typeParameterMatcherFindCache</li><li>stringBuilder</li><li>charsetEncoderCache</li><li>charsetDecoderCache</li><li>arrayList<br>这个11个是靠实例字段直接存储。<br>另外此类，还用了padding补齐的手段优化了CPU cacheline伪共享的问题。我猜测性能提升主要来源于此。  </li></ul><pre><code class="hljs java"><span class="hljs-comment">// Cache line padding (must be public)</span><span class="hljs-comment">// With CompressedOops enabled, an instance of this class should occupy at least 128 bytes.</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> rp1, rp2, rp3, rp4, rp5, rp6, rp7, rp8, rp9;</code></pre><h3 id="关于padding补齐"><a href="#关于padding补齐" class="headerlink" title="关于padding补齐"></a>关于padding补齐</h3><p>该类为了解决cache line伪共享的问题，采用了padding补齐。<br>该类(4.1.32.Final版本)补齐后通过<a href="https://gitee.com/xiaguangme/sizeofobject" target="_blank" rel="noopener">sizeOfObject</a>(也可以用jol)算出来大小是136。  jol针对idea是有插件的，不像JDK带的jol要运行起来才能计算对象大小。idea那个插件是针对语法树分析后算的，因为就算你的类有编译错误，他也能算出来。使用时注意选择相应的压缩模式，右上角。<br>关于jol<a href="http://hg.openjdk.java.net/code-tools/jol/file/833f68a6ba34/jol-samples/src/main/java/org/openjdk/jol/samples/JOLSample_02_Alignment.java" target="_blank" rel="noopener">有官方的sample</a>是很不错的，还<a href="http://zhongmingmao.me/2016/07/01/jvm-jol-tutorial-1/" target="_blank" rel="noopener">有个博客</a>写的还行，包括字段重排等都有。   </p><p><strong>为什么是136？按说128就行啊</strong>？ 这个事情我之前也思索了好久没有答案。直至翦哥今天跟我提到了一个别人前几天<a href="https://github.com/netty/netty/issues/9284" target="_blank" rel="noopener">提的issue</a>，才翻到原来有人和我们有一样的困惑，而且答案竟然是在netty版本迭代过程中InternalThreadLocalMap的父类加了个字段：ArrayList<Object> arrayList;，导致变成了136，之前4.0.33Final版本就是128，我确实使用了这个版本进行了验证，确实是。…. 竟然是这样，不可思议。  </p><blockquote><p>jiangxinlingdu commented 2 days ago<br>I have checked the code in old version and found that the size of InternalThreadLocalMap is 128Bytes in version 4.0.33. And now in latest code in github the size of InternalThreadLocalMap is 136. And the reason is that some has added two parameters: cleanerFlags (in class InternalThreadLocalMap) and arrayList (in parent class UnpaddedInternalThreadLocalMap).<br>In my view, the contributors has pushed the two parameters ignoring the Cache line padding. So it is a problem!  </p></blockquote><blockquote><p>My doubt is solved by you, thank you!!!</p></blockquote><h2 id="FastThreadLocalThread与FastThreadLocalRunnable"><a href="#FastThreadLocalThread与FastThreadLocalRunnable" class="headerlink" title="FastThreadLocalThread与FastThreadLocalRunnable"></a>FastThreadLocalThread与FastThreadLocalRunnable</h2><p>FastThreadLocalThread概述：绑定了<code>InternalThreadLocalMap</code>的线程类。继承于JDK的<code>Thread</code>。<br>FastThreadLocalThread扩展了什么：  </p><ul><li>主要对外暴露了获取与设置<code>InternalThreadLocalMap</code>字段的接口。  </li><li>增加cleanupFastThreadLocals字段并在有Runnable参数的构造函数里，会将<code>cleanupFastThreadLocals</code>字段设置成true。</li></ul><p>因为如果通过FastThreadnLocalThread的有Runnable参数的构造函数构造的FastThreadLocalThread实例时，会将Runnable实例wrap成<code>FastThreadLocalRunnable</code>实例。  FastThreadLocalRunnable又会在其run方法中以finally的方式进行清理当前线程上所有的<code>FastThreadLocal</code>实例中的数据。  </p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        runnable.run();    &#125; <span class="hljs-keyword">finally</span> &#123;        FastThreadLocal.removeAll();    &#125;&#125;</code></pre><p>所以<code>cleanupFastThreadLocals</code>字段意思是此线程<code>会</code>在执行完成时清理当前线程上所有的<code>FastThreadLocal</code>实例中的数据。  </p><p>FastThreadLocalRunnable扩展了什么：  </p><ul><li>如上面所说，会在run方法中用finally清理当前线程上所有的<code>FastThreadLocal</code>实例中的数据。  </li></ul><h2 id="DefaultThreadFactory"><a href="#DefaultThreadFactory" class="headerlink" title="DefaultThreadFactory"></a>DefaultThreadFactory</h2><p>扩展了什么：  </p><ul><li>实现了线程名前缀+自增线程号的模式 </li><li>实现了创建线程时默认使用<code>FastThreadLocalThread</code>实现</li></ul>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>netty4源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几个递进的make file</title>
    <link href="/2020/04/19/some-make-files/"/>
    <url>/2020/04/19/some-make-files/</url>
    
    <content type="html"><![CDATA[<h2 id="几个递进的make-file"><a href="#几个递进的make-file" class="headerlink" title="几个递进的make file"></a>几个递进的make file</h2><p>春节在家写的几个递进的make file，部分有点问题。接下来 有空我要把GNU make的手册看完。不然这方面太菜了。  </p><p><a href="https://files.cnblogs.com/files/simoncook/gun-make-manual%E4%B8%AD%E8%8B%B1%E6%96%87.zip" target="_blank" rel="noopener">GNU make手册</a><br>都需要make先设置环境变量BUILD_MODE为run或者debug</p><h3 id="1-源文件名-目标都hard-code，且一次编译多个目标"><a href="#1-源文件名-目标都hard-code，且一次编译多个目标" class="headerlink" title="1 源文件名 目标都hard code，且一次编译多个目标"></a>1 源文件名 目标都hard code，且一次编译多个目标</h3><pre><code class="hljs shell">PROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))OBJS = lsdemo.o test.oifeq ($(BUILD_MODE),debug)CFLAGS += -gelse ifeq ($(BUILD_MODE),run)CFLAGS += -O2else<span class="hljs-meta">$</span><span class="bash">(error Build mode $(BUILD_MODE) not supported by this Makefile)</span>endifall:lsdemo testlsdemo:lsdemo.o<span class="hljs-meta">$</span><span class="bash">(CXX) -o <span class="hljs-variable">$@</span> $^</span>lsdemo.o:$(PROJECT_ROOT)/ch01/lsdemo.c<span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span>test:test.o<span class="hljs-meta">$</span><span class="bash">(CXX) -o <span class="hljs-variable">$@</span> $^</span>test.o:$(PROJECT_ROOT)/ch01/test.c<span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span>clean:rm -fr lsdemo test  $(OBJS)</code></pre><h3 id="2-通过OBJS变量定义多个目标文件-通过遍历ch01-目录下所有c文件作为源文件"><a href="#2-通过OBJS变量定义多个目标文件-通过遍历ch01-目录下所有c文件作为源文件" class="headerlink" title="2 通过OBJS变量定义多个目标文件 通过遍历ch01/目录下所有c文件作为源文件"></a>2 通过OBJS变量定义多个目标文件 通过遍历ch01/目录下所有c文件作为源文件</h3><pre><code class="hljs shell">PROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))OBJS = lsdemo.o test.oifeq ($(BUILD_MODE),debug)CFLAGS += -gelse ifeq ($(BUILD_MODE),run)CFLAGS += -O2else<span class="hljs-meta">$</span><span class="bash">(error Build mode $(BUILD_MODE) not supported by this Makefile)</span>endifall:lsdemo lsdemo:$(OBJS)<span class="hljs-meta">$</span><span class="bash">(CXX) -o <span class="hljs-variable">$@</span> $^</span><span class="hljs-meta">%</span><span class="bash">.o:$(PROJECT_ROOT)/ch01/%.c</span><span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">test</span>:test.o</span><span class="hljs-meta">#</span><span class="bash">$(CXX) -o <span class="hljs-variable">$@</span> $^</span><span class="hljs-meta">#</span><span class="hljs-meta">#</span><span class="bash">test.o:$(PROJECT_ROOT)/ch01/test.c</span><span class="hljs-meta">#</span><span class="bash">$(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span><span class="hljs-meta">#</span><span class="bash"></span>clean:rm -fr lsdemo test  $(OBJS)</code></pre><h3 id="3-ch01-ch02-多个子目录下多目标编译"><a href="#3-ch01-ch02-多个子目录下多目标编译" class="headerlink" title="3 ch01 ch02 多个子目录下多目标编译"></a>3 ch01 ch02 多个子目录下多目标编译</h3><pre><code class="hljs shell">PROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))CH01OBJS = lsdemo.o test.oCH02OBJS = test21.o test22.oifeq ($(BUILD_MODE),debug)CFLAGS += -gelse ifeq ($(BUILD_MODE),run)CFLAGS += -O2else<span class="hljs-meta">$</span><span class="bash">(error Build mode $(BUILD_MODE) not supported by this Makefile)</span>endifall:lsdemo ch02lsdemo:$(CH01OBJS)<span class="hljs-meta">$</span><span class="bash">(CXX) -o <span class="hljs-variable">$@</span> $^</span><span class="hljs-meta">%</span><span class="bash">.o:$(PROJECT_ROOT)/ch01/%.c</span><span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span>ch02:$(CH02OBJS)<span class="hljs-meta">$</span><span class="bash">(CXX) -o <span class="hljs-variable">$@</span> $^</span><span class="hljs-meta">%</span><span class="bash">.o:$(PROJECT_ROOT)/ch02/%.c</span><span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">test</span>:test.o</span><span class="hljs-meta">#</span><span class="bash">$(CXX) -o <span class="hljs-variable">$@</span> $^</span><span class="hljs-meta">#</span><span class="hljs-meta">#</span><span class="bash">test.o:$(PROJECT_ROOT)/ch01/test.c</span><span class="hljs-meta">#</span><span class="bash">$(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span><span class="hljs-meta">#</span><span class="bash"></span>clean:rm -fr lsdemo test  $(OBJS)</code></pre><h3 id="4-通过修改CH-NO和APP-NAME切换到底编译哪个子目录下的应用，编译到指定路径下，适用于APUE学习时例程序编写"><a href="#4-通过修改CH-NO和APP-NAME切换到底编译哪个子目录下的应用，编译到指定路径下，适用于APUE学习时例程序编写" class="headerlink" title="4 通过修改CH_NO和APP_NAME切换到底编译哪个子目录下的应用，编译到指定路径下，适用于APUE学习时例程序编写"></a>4 通过修改CH_NO和APP_NAME切换到底编译哪个子目录下的应用，编译到指定路径下，适用于APUE学习时例程序编写</h3><pre><code class="hljs shell">CH_NO = ch01APP_NAME = lsdemo<span class="hljs-meta">#</span><span class="bash"> 获取makefile路径</span>PROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))<span class="hljs-meta">$</span><span class="bash">(info MAKEFILE_LIST is: $(MAKEFILE_LIST))</span><span class="hljs-meta">$</span><span class="bash">(info PROJECT_ROOT is: $(PROJECT_ROOT))</span><span class="hljs-meta">#</span><span class="bash"> 拼接路径</span>SOURCE_FRAGMENT :=$(CH_NO)/$(APP_NAME)SOURCE_ROOT := $(PROJECT_ROOT)$(SOURCE_FRAGMENT)<span class="hljs-meta">$</span><span class="bash">(info SOURCE_ROOT is: $(SOURCE_ROOT))</span>BUILD_ROOT := $(PROJECT_ROOT)build/make.debug.linux.x86_64/$(SOURCE_FRAGMENT)/<span class="hljs-meta">$</span><span class="bash">(info BUILD_ROOT is: $(BUILD_ROOT))</span>ifeq ($(BUILD_MODE),debug)CFLAGS += -gelse ifeq ($(BUILD_MODE),run)CFLAGS += -O2else<span class="hljs-meta">$</span><span class="bash">(error Build mode $(BUILD_MODE) not supported by this Makefile)</span>endif<span class="hljs-meta">$</span><span class="bash">(shell <span class="hljs-keyword">if</span> [ ! -d $(BUILD_ROOT) ]; <span class="hljs-keyword">then</span> mkdir -p $(BUILD_ROOT); <span class="hljs-keyword">fi</span>;)</span>SOURCE := $(shell find $(SOURCE_ROOT) -name '*.c' |xargs -n1 basename)OBJS := $(SOURCE:.c=.o)<span class="hljs-meta">$</span><span class="bash">(info SOURCE is: $(SOURCE))</span><span class="hljs-meta">$</span><span class="bash">(info OBJS is: $(OBJS))</span>all: $(APP_NAME)<span class="hljs-meta">#</span><span class="hljs-meta">$</span><span class="bash">(APP_NAME):$(OBJS)</span><span class="hljs-meta">$</span><span class="bash">(CXX) -o $(BUILD_ROOT)/<span class="hljs-variable">$@</span> $(addprefix $(BUILD_ROOT), $^)</span><span class="hljs-meta">%</span><span class="bash">.o:$(SOURCE_ROOT)/%.c</span><span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o $(BUILD_ROOT)/<span class="hljs-variable">$@</span> $&lt;</span>clean:rm -fr $(BUILD_ROOT)</code></pre><p>附上第四种情况的目录结构：</p><pre><code class="hljs shell">appweb@simon-ububtu18-desk-2:~/600.self/03.code/01.cpp/03.APUE$ tree .├── build│   └── make.debug.linux.x86_64│       └── ch01│           └── lsdemo│               ├── lsdemo│               ├── lsdemo.o│               └── test.o├── ch01│   └── lsdemo│       ├── lsdemo.c│       └── test.c└── Makefile</code></pre>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我的价值观</title>
    <link href="/2020/04/19/MySenseOfWorth/"/>
    <url>/2020/04/19/MySenseOfWorth/</url>
    
    <content type="html"><![CDATA[<h2 id="我的价值观"><a href="#我的价值观" class="headerlink" title="我的价值观"></a>我的价值观</h2><ol><li>一个底线：遵纪守法，远离黄赌毒。</li><li>一个标准：感恩上进，持续努力，享受尽职。</li><li>一个方法论：三人行必有我师，三人行我亦能成师。</li><li>一个技巧：顺势而为。</li><li>一个兜底：凡事有最坏的打算。</li></ol>]]></content>
    
    
    <categories>
      
      <category>think</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
