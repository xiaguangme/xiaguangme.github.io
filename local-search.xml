<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>白菜油渣</title>
    <link href="/2020/04/19/cabbage-residue/"/>
    <url>/2020/04/19/cabbage-residue/</url>
    
    <content type="html"><![CDATA[<p>白菜炒猪油渣，朴素的美食</p><p><img src="/img/food/WechatIMG317.jpeg" srcset="/img/loading.gif" alt="白菜炒猪油渣"></p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>food</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JVM G1源码分析和调优》读书笔记</title>
    <link href="/2020/04/19/jvm-g1-gc-book/"/>
    <url>/2020/04/19/jvm-g1-gc-book/</url>
    
    <content type="html"><![CDATA[<h2 id="GC的相关算法与JVM的垃圾收集器"><a href="#GC的相关算法与JVM的垃圾收集器" class="headerlink" title="GC的相关算法与JVM的垃圾收集器"></a>GC的相关算法与JVM的垃圾收集器</h2><h3 id="GC的相关算法"><a href="#GC的相关算法" class="headerlink" title="GC的相关算法"></a>GC的相关算法</h3><ul><li>分代管理</li><li>复制算法</li><li>标记清除</li><li>标记压缩</li></ul><h3 id="JVM垃圾收集器"><a href="#JVM垃圾收集器" class="headerlink" title="JVM垃圾收集器"></a>JVM垃圾收集器</h3><p>P242 表11-1 不同类型垃圾回收期比较  </p><ul><li>串行收集器 Serial。  Serial GC用于新生代，用了复制算法；Serial Old GC作用于老年代，用的是标记-压缩算法。STW</li><li>并行收集器 Parallel。Parallel new作用于新生代，使用了复制算法；Parallel old作用于老年代，用了标记-压缩算法。STW。并发收集是准确收集，不会产生浮动垃圾。</li><li>并发收集器 Concurrent-Mark-Sweep。老年代垃圾回收器。使用了标记-清除算法。分为初始标记(Initial-Mark,STW)、并发标记(Concurrent-Mark)、再次标记(Remark,STW)、并发清除(Concurrent-Sweep)。CMS因为需要存储代际的引用关系，所以有额外的存储空间的消耗。CMS不是准确收集，会产生浮动垃圾。</li><li>垃圾优先收集器 G1。按照分区进行收集，新生代的分区总是会回收，老生代则是并发标记后选择部分回收效果最好的分区。G1分为三种回收方式：<code>新生代回收</code>young、<code>混合回收</code>(mixed，既收集新生代也收集部分老年代)、<code>FUll GC</code>。<code>新生代回收</code>仅仅在开始前需要STW。<code>混合回收</code>分成两个阶段：并发标记阶段与垃圾回收阶段。并发标记阶段又分四个步骤：初始标记子阶段(initital-mark)、并发标记子阶段(concurrent-mark)、再标记子阶段(remark,STW)、清理子阶段(cleanup,STW)。因分区设计，G1引用关系的存储占用额外空间的消耗较大。G1不是准确收集，会产生浮动垃圾。</li></ul><h2 id="G1基本概念"><a href="#G1基本概念" class="headerlink" title="G1基本概念"></a>G1基本概念</h2><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>G1是将内存分成一个个小区域使用。这些区域称之为Heap Region。扩展的有<code>YHR</code>(新生代分区)，<code>OHR</code>(老生代分区)，<code>HHR</code>(大对象分区)等等<br>为了达到分配效率与清理效率的平衡，HR的大小有上下限值，即1MB-32MB。结合整个堆空间分为2048个HR，那么通常G1管理的最大的堆是32MB*2048=64G。  </p><h3 id="新生代大小"><a href="#新生代大小" class="headerlink" title="新生代大小"></a>新生代大小</h3><h4 id="用参数设置使得G1能推断出最大值与最小值"><a href="#用参数设置使得G1能推断出最大值与最小值" class="headerlink" title="用参数设置使得G1能推断出最大值与最小值"></a>用参数设置使得G1能推断出最大值与最小值</h4><p>涉及的参数有:</p><ul><li>新生代最大值MaxNewSize、最小值NewSize、Xmn(等价于MaxNewSize和NewSize，且MaxNewSize=NewSize)</li><li>NewRatio，如果上条参数设置了，则忽略本参数</li><li>如果仅仅设置了NewRatio，则新生代最大值与最小值相同：整个堆空间/(newRatio+1)</li><li>如果没有设置最大值和最小值，或者只设置了其中一个，那么G1将根据参数G1MaxNewSizePercent(默认60)和G1NewSizePercent(默认是5)占整个堆空间的比例来计算。</li></ul><p><strong>如果G1推断出的新生代的最大值与最小值相等，则说明新生代不会动态变化，不会动态变化则可能导致后续新生代GC时不能满足期望的停顿时间</strong>，所以有文章提到G1不建议设置Xmn参数。  </p><p>相关代码在 share/vm/gc_implementation/g1/g1collectorPolicy.cpp  </p><h3 id="G1启发式推断新生代大小"><a href="#G1启发式推断新生代大小" class="headerlink" title="G1启发式推断新生代大小"></a>G1启发式推断新生代大小</h3><p>G1有一个线程专门抽样处理预测新生代列表的长度应该多大，并动态调整。  </p><p>何时扩展以及一次扩展多少内存？<br>参数-XX:GCTimeRatio 表示GC与应用的耗费时间的比，G1默认是9。也就是说GC的耗时与应用耗时占比超过10%时，进行动态扩展。扩展大小的参数是G1ExpandByPercentOfAvailable，同时至少大于1MB，至多不能超过当前已经分配的大小的一倍。<br>代码在 size_t G1CollectorPolicy::expansion_amount()….<br>该书在第五章讲refine线程时对此点有更详细的阐述  </p><h3 id="G1停顿预测模型"><a href="#G1停顿预测模型" class="headerlink" title="G1停顿预测模型"></a>G1停顿预测模型</h3><p>比较偏数学 我就很快跳过去了<br>G1的预测逻辑是基于衰减平均(Decaying Average)和衰减标准差。  </p><h3 id="卡表和位图"><a href="#卡表和位图" class="headerlink" title="卡表和位图"></a>卡表和位图</h3><p>卡表(CardTable)是CMS中中常见概念之一。我理解成分区间对象引用关系的描述 的存放处或者说存放的数据结构。此书也是讲的较为简略，细节可以参见《垃圾回收算法手册：自动内存管理的艺术》  </p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>讲JVM内存模型必讲对象头。可以参见我写的<a href="cnblogs.com/simoncook/p/11804427.html">JVM中对象模型及相应名词概念</a>  </p><h3 id="栈帧、线程等"><a href="#栈帧、线程等" class="headerlink" title="栈帧、线程等"></a>栈帧、线程等</h3><p>栈帧可以参见 封亚飞 写的《揭秘Java虚拟机》第七章 Java栈帧，写的更详细。此书只是一笔带过，看了跟没看没啥差别。  </p><h2 id="G1的对象分配"><a href="#G1的对象分配" class="headerlink" title="G1的对象分配"></a>G1的对象分配</h2><ul><li>快速分配与慢速分配</li><li>快速分配通过TLAB(Thread Local Allocation Buffer)实现。TLAB自己的分配是CAS操作。TLAB内部给对象分配是无锁的，因为只有自己线程用嘛。  </li><li>TLAB机制或产生内存浪费，因为一个对象不会分配在两个TLAB区域，所以TLAB最末端的尾巴区域可能会残留空着。可以通过TLABRefillWasteFraction参数调整，表示允许产生浪费的比例。默认值是64，即表示1/64空间可以浪费。</li><li>TLAB大小可以自动调整，但是上限不会超过HR的一半。、</li><li>可以使用参数-XX:-ResizeTLAB禁用ResizeTLAB，并使用参数-XX:TLABSize指定一个大小。-XX:+PrintTLAB可以跟踪TLAB工作情况。</li><li><strong>一般不建议修改TLAB参数，建议使用默认值</strong></li></ul><p>TLAB快速分配的代码在 HeapWord* CollectedHeap::allocate_from_tlab…  </p><h2 id="G1的Refine线程"><a href="#G1的Refine线程" class="headerlink" title="G1的Refine线程"></a>G1的Refine线程</h2><p>先讲Rset</p><h3 id="Rset"><a href="#Rset" class="headerlink" title="Rset"></a>Rset</h3><p>Rset是干什么用的？  </p><ul><li>Rset是一种抽象概念，记录了在不同代际之间的引用关系，目的是为了加速GC。</li><li>通俗地说，可以用Rset记录从非收集部分指向收集部分的指针集合。对于这种记录述求，有两种方式，一是<code>我引用了谁</code>，称为<code>Point Out</code>；一是<code>谁引用了我</code>，称为<code>Point In</code>。G1采用后者。</li><li>G1中需要记录代际之间的引用关系包括：老生代分区到新生代分区之间的引用关系(YGC时，这个引用关系是GC Roots的一部分，老生代引用过来的不能被回收掉嘛…)；老生代分区到老生代分区之间的引用关系(混合GC时用)</li><li>Rset与卡表的关系参见P68图4-1</li><li>G1引入了PRT，TODO：没看太懂</li><li>DCQ与Refinemnet zone的四色区域没看太懂</li></ul><h3 id="Rset写屏障"><a href="#Rset写屏障" class="headerlink" title="Rset写屏障"></a>Rset写屏障</h3><p>为啥谈到写屏障，因为Refine是线程关注的是应用关系的变更，但是他是如何识别引用关系的变更的呢？就是靠写屏障完成。下面讲写屏障相关要点：  </p><ul><li>写屏障这个词我不知道为啥这样命名，直觉上不好理解。  </li><li>我对其的理解就是，写操作前后的拦截器处理。比如我对字段赋值putfield，在赋值前我要告诉DCQ这个对象被我引用了，这就是写屏障动作。  </li><li>书上的说法：<code>写屏障</code>是指在改变特定内存的值时，额外执行的一些动作。  </li><li>CMS是通过写屏障记录引用刮不洗，G1也是。  </li><li>写屏障会有优化，不是所有的引用关系变更都会被记录。  <ul><li>不记录新生代到新生代的引用，或者新生代到老生代的引用，在写屏障时过滤</li><li>过滤掉同一个分区内部引用，在Rset处理时过滤</li><li>过滤掉空引用，在Rset处理时过滤</li></ul></li></ul><h3 id="Refine线程"><a href="#Refine线程" class="headerlink" title="Refine线程"></a>Refine线程</h3><ul><li>Refine线程是一组，是一个线程池，不是一个。</li><li>我对他的理解是，一个线程用于抽样，主要作用设置新生代分区的个数。其余线程用于管理Rset，Rset的更新不是同步完成的，是靠Refine线程异步完成的，异步又是靠DCQ dirty card queue队列暂存过渡的。 </li><li>Refine涉及的JVM比较复杂，未细细研究</li><li>相关参数：可以通过-XX:+G1TraceConcRefinement观察Refine线程工作情况。通过-XX:+G1SummarizeRSetStats观察Rset更新。</li></ul><h2 id="新生代回收"><a href="#新生代回收" class="headerlink" title="新生代回收"></a>新生代回收</h2><p>上面已经讲了，G1 GC分三种： <code>新生代回收</code>young、<code>混合回收</code>(mixed，既收集新生代也收集部分老年代)、<code>FUll GC</code>  </p><p>步骤：  </p><ol><li>选择CSet</li><li>根处理</li><li>Rset处理</li><li>复制</li><li>Redirty 重构Rset</li><li>释放空间  </li></ol><h3 id="相关日志"><a href="#相关日志" class="headerlink" title="相关日志"></a>相关日志</h3><p>可以用-XX:G1LogLevel=finest 打开更详细的日志<br>关键字 GC pause (G1 Evacuation Pause) (young)， 0.0182341 secs…  </p><h3 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h3><h2 id="混合回收"><a href="#混合回收" class="headerlink" title="混合回收"></a>混合回收</h2><p><code>混合回收</code>分成两个阶段：</p><ul><li>并发标记阶段</li><li>垃圾回收阶段(与新生代回收一致)  </li></ul><p>并发标记阶段又分四个步骤：</p><ol><li>初始标记子阶段(initital-mark)</li><li>并发标记子阶段(concurrent-mark)</li><li>再标记子阶段(remark,STW)</li><li>清理子阶段(cleanup,STW</li></ol><p>并发标记的难点：<br>正在标记过程中的对象引用关系发生了改变。<br>通过三色标记法与STAB算法结合写屏障完成。<br>写屏障代码在 oop_store中,oop.inline.hpp  </p><h3 id="相关日志-1"><a href="#相关日志-1" class="headerlink" title="相关日志"></a>相关日志</h3><p>关键字 GC pause (G1 Evacuation Pause) (mixed)， 0.0106341 secs…<br> GC pause (G1 Evacuation Pause) (young) (initial-mark),….  // 初始标记借用了YGC<br>[GC concurrent-mark-start]…<br>[GC concurrent-mark-end]…<br>[GC remark …]…<br>[GC cleanup …]…  </p><h3 id="参数调优-1"><a href="#参数调优-1" class="headerlink" title="参数调优"></a>参数调优</h3><h2 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h2><p>JDK10之前FGC是串行的，JDK10之后支持并行。<br>代码在 G1CollectedHeap::do_collection<br>串行回收采用标记清除算法，步骤：  </p><ol><li>标记活跃对象</li><li>计算新对象地址</li><li>把所有对象都更新到新地址上</li><li>移动对象完成压缩</li></ol><h3 id="相关日志-2"><a href="#相关日志-2" class="headerlink" title="相关日志"></a>相关日志</h3><p>[Full GC (Allocation Failure) …..  0.2036229 secs]….  </p><h2 id="G1调优"><a href="#G1调优" class="headerlink" title="G1调优"></a>G1调优</h2><p>主要涉及的指标有： 吞吐量最大、停段时间尽量端、GC频率尽量低和堆空间的有效利用率高。<br>主要调优参数 参见P244 表11-2，主要涉及堆、RSet、标记和GC四个方面的参数。</p>]]></content>
    
    
    <categories>
      
      <category>book-paper-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty4 FastThreadLocal及其相关类系列以及CPU cacheline padding补齐优化的相关知识</title>
    <link href="/2020/04/19/netty4-fastthhreadlocal/"/>
    <url>/2020/04/19/netty4-fastthhreadlocal/</url>
    
    <content type="html"><![CDATA[<h2 id="FastThreadLocal"><a href="#FastThreadLocal" class="headerlink" title="FastThreadLocal"></a>FastThreadLocal</h2><p>概述： ThreadLocal的一个特定变种改善，有更好的存取性能。<br>内部采用一个数组来代替ThreadLocal内部的hash表来存放变量。虽然这看起来是微不足道的，但是他确实比hash表性能好那么一点，在频繁存取时会更明显。 如果用DefaultThreadFactory创建线程，那么默认创建出来的就是FastThreadLocalThread，就会用FastThreadLocal。  </p><p>set数据靠InternalThreadLocalMap维护，InternalThreadLocalMap内部靠一个数组(就是上面说的)维护变量数据。  </p><p>扩展了什么:<br>按ThreadLocal API的约定行为，依赖InternalThreadLocalMap实现了这些行为，诸如get、set、remove等。<br>remove支持onRemoval回调。  </p><h2 id="InternalThreadLocalMap"><a href="#InternalThreadLocalMap" class="headerlink" title="InternalThreadLocalMap"></a>InternalThreadLocalMap</h2><h3 id="自身实例获取"><a href="#自身实例获取" class="headerlink" title="自身实例获取"></a>自身实例获取</h3><p>get方法是对外暴露去自身实例的，有两种方式取到InternalThreadLocalMap实例：</p><ul><li>如果当前线程是FastThreadLocalThreadInternal，直接取其实例变量ThreadLocalMap，内部称之为fastGet。  </li><li>如果是JDK的Thread，那么靠JDK的TheadLocal取到ThreadLocalMap，内部称之为slowGet。  </li></ul><h3 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a>数据存取</h3><p>真正的存取变量是靠<code>indexedVariable</code>和<code>setIndexedVariable</code>方法完成。<br>阅读代码不难发现，是靠Object[]  indexedVariables这个数组达成数据存储的目的。  </p><h3 id="存放数据的数组扩容"><a href="#存放数据的数组扩容" class="headerlink" title="存放数据的数组扩容"></a>存放数据的数组扩容</h3><p>indexedVariables数组靠expandIndexedVariableTableAndSet动态扩容。初始长度是32。<br>扩容算法有点意思，是比当前index小的最大的2的n次方的值扩一倍，比如当前index是132，那么就会扩成256长度的数组。  </p><pre><code class="hljs java">Object[] oldArray = indexedVariables;<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> oldCapacity = oldArray.length;<span class="hljs-keyword">int</span> newCapacity = index;newCapacity |= newCapacity &gt;&gt;&gt;  <span class="hljs-number">1</span>;newCapacity |= newCapacity &gt;&gt;&gt;  <span class="hljs-number">2</span>;newCapacity |= newCapacity &gt;&gt;&gt;  <span class="hljs-number">4</span>;newCapacity |= newCapacity &gt;&gt;&gt;  <span class="hljs-number">8</span>;newCapacity |= newCapacity &gt;&gt;&gt; <span class="hljs-number">16</span>;newCapacity ++;</code></pre><h3 id="是否完全用数组存放数据？"><a href="#是否完全用数组存放数据？" class="headerlink" title="是否完全用数组存放数据？"></a>是否完全用数组存放数据？</h3><p>不完全是。因为<code>InternalThreadLocalMap</code>的父类<code>UnpaddedInternalThreadLocalMap</code>自带了一些常用的字段：  </p><ul><li>futureListenerStackDepth</li><li>localChannelReaderStackDepth</li><li>handlerSharableCache  </li><li>counterHashCode</li><li>random</li><li>typeParameterMatcherGetCache</li><li>typeParameterMatcherFindCache</li><li>stringBuilder</li><li>charsetEncoderCache</li><li>charsetDecoderCache</li><li>arrayList<br>这个11个是靠实例字段直接存储。<br>另外此类，还用了padding补齐的手段优化了CPU cacheline伪共享的问题。我猜测性能提升主要来源于此。  <pre><code class="hljs java"><span class="hljs-comment">// Cache line padding (must be public)</span><span class="hljs-comment">// With CompressedOops enabled, an instance of this class should occupy at least 128 bytes.</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> rp1, rp2, rp3, rp4, rp5, rp6, rp7, rp8, rp9;</code></pre><h3 id="关于padding补齐"><a href="#关于padding补齐" class="headerlink" title="关于padding补齐"></a>关于padding补齐</h3>该类为了解决cache line伪共享的问题，采用了padding补齐。<br>该类(4.1.32.Final版本)补齐后通过<a href="https://gitee.com/xiaguangme/sizeofobject" target="_blank" rel="noopener">sizeOfObject</a>(也可以用jol)算出来大小是136。  jol针对idea是有插件的，不像JDK带的jol要运行起来才能计算对象大小。idea那个插件是针对语法树分析后算的，因为就算你的类有编译错误，他也能算出来。使用时注意选择相应的压缩模式，右上角。<br>关于jol<a href="http://hg.openjdk.java.net/code-tools/jol/file/833f68a6ba34/jol-samples/src/main/java/org/openjdk/jol/samples/JOLSample_02_Alignment.java" target="_blank" rel="noopener">有官方的sample</a>是很不错的，还<a href="http://zhongmingmao.me/2016/07/01/jvm-jol-tutorial-1/" target="_blank" rel="noopener">有个博客</a>写的还行，包括字段重排等都有。   </li></ul><p><strong>为什么是136？按说128就行啊</strong>？ 这个事情我之前也思索了好久没有答案。直至翦哥今天跟我提到了一个别人前几天<a href="https://github.com/netty/netty/issues/9284" target="_blank" rel="noopener">提的issue</a>，才翻到原来有人和我们有一样的困惑，而且答案竟然是在netty版本迭代过程中InternalThreadLocalMap的父类加了个字段：ArrayList<Object> arrayList;，导致变成了136，之前4.0.33Final版本就是128，我确实使用了这个版本进行了验证，确实是。…. 竟然是这样，不可思议。  </p><blockquote><p>jiangxinlingdu commented 2 days ago<br>I have checked the code in old version and found that the size of InternalThreadLocalMap is 128Bytes in version 4.0.33. And now in latest code in github the size of InternalThreadLocalMap is 136. And the reason is that some has added two parameters: cleanerFlags (in class InternalThreadLocalMap) and arrayList (in parent class UnpaddedInternalThreadLocalMap).<br>In my view, the contributors has pushed the two parameters ignoring the Cache line padding. So it is a problem!  </p></blockquote><blockquote><p>My doubt is solved by you, thank you!!!</p></blockquote><h2 id="FastThreadLocalThread与FastThreadLocalRunnable"><a href="#FastThreadLocalThread与FastThreadLocalRunnable" class="headerlink" title="FastThreadLocalThread与FastThreadLocalRunnable"></a>FastThreadLocalThread与FastThreadLocalRunnable</h2><p>FastThreadLocalThread概述：绑定了<code>InternalThreadLocalMap</code>的线程类。继承于JDK的<code>Thread</code>。<br>FastThreadLocalThread扩展了什么：  </p><ul><li>主要对外暴露了获取与设置<code>InternalThreadLocalMap</code>字段的接口。  </li><li>增加cleanupFastThreadLocals字段并在有Runnable参数的构造函数里，会将<code>cleanupFastThreadLocals</code>字段设置成true。</li></ul><p>因为如果通过FastThreadnLocalThread的有Runnable参数的构造函数构造的FastThreadLocalThread实例时，会将Runnable实例wrap成<code>FastThreadLocalRunnable</code>实例。  FastThreadLocalRunnable又会在其run方法中以finally的方式进行清理当前线程上所有的<code>FastThreadLocal</code>实例中的数据。  </p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        runnable.run();    &#125; <span class="hljs-keyword">finally</span> &#123;        FastThreadLocal.removeAll();    &#125;&#125;</code></pre><p>所以<code>cleanupFastThreadLocals</code>字段意思是此线程<code>会</code>在执行完成时清理当前线程上所有的<code>FastThreadLocal</code>实例中的数据。  </p><p>FastThreadLocalRunnable扩展了什么：  </p><ul><li>如上面所说，会在run方法中用finally清理当前线程上所有的<code>FastThreadLocal</code>实例中的数据。  </li></ul><h2 id="DefaultThreadFactory"><a href="#DefaultThreadFactory" class="headerlink" title="DefaultThreadFactory"></a>DefaultThreadFactory</h2><p>扩展了什么：  </p><ul><li>实现了线程名前缀+自增线程号的模式 </li><li>实现了创建线程时默认使用<code>FastThreadLocalThread</code>实现</li></ul>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>几个递进的make file</title>
    <link href="/2020/04/19/some-make-files/"/>
    <url>/2020/04/19/some-make-files/</url>
    
    <content type="html"><![CDATA[<h2 id="几个递进的make-file"><a href="#几个递进的make-file" class="headerlink" title="几个递进的make file"></a>几个递进的make file</h2><p>春节在家写的几个递进的make file，部分有点问题。接下来 有空我要把GNU make的手册看完。不然这方面太菜了。  </p><p><a href="https://files.cnblogs.com/files/simoncook/gun-make-manual%E4%B8%AD%E8%8B%B1%E6%96%87.zip" target="_blank" rel="noopener">GNU make手册</a><br>都需要make先设置环境变量BUILD_MODE为run或者debug</p><h3 id="1-源文件名-目标都hard-code，且一次编译多个目标"><a href="#1-源文件名-目标都hard-code，且一次编译多个目标" class="headerlink" title="1 源文件名 目标都hard code，且一次编译多个目标"></a>1 源文件名 目标都hard code，且一次编译多个目标</h3><pre><code class="hljs shell">PROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))OBJS = lsdemo.o test.oifeq ($(BUILD_MODE),debug)CFLAGS += -gelse ifeq ($(BUILD_MODE),run)CFLAGS += -O2else<span class="hljs-meta">$</span><span class="bash">(error Build mode $(BUILD_MODE) not supported by this Makefile)</span>endifall:lsdemo testlsdemo:lsdemo.o<span class="hljs-meta">$</span><span class="bash">(CXX) -o <span class="hljs-variable">$@</span> $^</span>lsdemo.o:$(PROJECT_ROOT)/ch01/lsdemo.c<span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span>test:test.o<span class="hljs-meta">$</span><span class="bash">(CXX) -o <span class="hljs-variable">$@</span> $^</span>test.o:$(PROJECT_ROOT)/ch01/test.c<span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span>clean:rm -fr lsdemo test  $(OBJS)</code></pre><h3 id="2-通过OBJS变量定义多个目标文件-通过遍历ch01-目录下所有c文件作为源文件"><a href="#2-通过OBJS变量定义多个目标文件-通过遍历ch01-目录下所有c文件作为源文件" class="headerlink" title="2 通过OBJS变量定义多个目标文件 通过遍历ch01/目录下所有c文件作为源文件"></a>2 通过OBJS变量定义多个目标文件 通过遍历ch01/目录下所有c文件作为源文件</h3><pre><code class="hljs shell">PROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))OBJS = lsdemo.o test.oifeq ($(BUILD_MODE),debug)CFLAGS += -gelse ifeq ($(BUILD_MODE),run)CFLAGS += -O2else<span class="hljs-meta">$</span><span class="bash">(error Build mode $(BUILD_MODE) not supported by this Makefile)</span>endifall:lsdemo lsdemo:$(OBJS)<span class="hljs-meta">$</span><span class="bash">(CXX) -o <span class="hljs-variable">$@</span> $^</span><span class="hljs-meta">%</span><span class="bash">.o:$(PROJECT_ROOT)/ch01/%.c</span><span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">test</span>:test.o</span><span class="hljs-meta">#</span><span class="bash">$(CXX) -o <span class="hljs-variable">$@</span> $^</span><span class="hljs-meta">#</span><span class="hljs-meta">#</span><span class="bash">test.o:$(PROJECT_ROOT)/ch01/test.c</span><span class="hljs-meta">#</span><span class="bash">$(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span><span class="hljs-meta">#</span><span class="bash"></span>clean:rm -fr lsdemo test  $(OBJS)</code></pre><h3 id="3-ch01-ch02-多个子目录下多目标编译"><a href="#3-ch01-ch02-多个子目录下多目标编译" class="headerlink" title="3 ch01 ch02 多个子目录下多目标编译"></a>3 ch01 ch02 多个子目录下多目标编译</h3><pre><code class="hljs shell">PROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))CH01OBJS = lsdemo.o test.oCH02OBJS = test21.o test22.oifeq ($(BUILD_MODE),debug)CFLAGS += -gelse ifeq ($(BUILD_MODE),run)CFLAGS += -O2else<span class="hljs-meta">$</span><span class="bash">(error Build mode $(BUILD_MODE) not supported by this Makefile)</span>endifall:lsdemo ch02lsdemo:$(CH01OBJS)<span class="hljs-meta">$</span><span class="bash">(CXX) -o <span class="hljs-variable">$@</span> $^</span><span class="hljs-meta">%</span><span class="bash">.o:$(PROJECT_ROOT)/ch01/%.c</span><span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span>ch02:$(CH02OBJS)<span class="hljs-meta">$</span><span class="bash">(CXX) -o <span class="hljs-variable">$@</span> $^</span><span class="hljs-meta">%</span><span class="bash">.o:$(PROJECT_ROOT)/ch02/%.c</span><span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">test</span>:test.o</span><span class="hljs-meta">#</span><span class="bash">$(CXX) -o <span class="hljs-variable">$@</span> $^</span><span class="hljs-meta">#</span><span class="hljs-meta">#</span><span class="bash">test.o:$(PROJECT_ROOT)/ch01/test.c</span><span class="hljs-meta">#</span><span class="bash">$(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span><span class="hljs-meta">#</span><span class="bash"></span>clean:rm -fr lsdemo test  $(OBJS)</code></pre><h3 id="4-通过修改CH-NO和APP-NAME切换到底编译哪个子目录下的应用，编译到指定路径下，适用于APUE学习时例程序编写"><a href="#4-通过修改CH-NO和APP-NAME切换到底编译哪个子目录下的应用，编译到指定路径下，适用于APUE学习时例程序编写" class="headerlink" title="4 通过修改CH_NO和APP_NAME切换到底编译哪个子目录下的应用，编译到指定路径下，适用于APUE学习时例程序编写"></a>4 通过修改CH_NO和APP_NAME切换到底编译哪个子目录下的应用，编译到指定路径下，适用于APUE学习时例程序编写</h3><pre><code class="hljs shell">CH_NO = ch01APP_NAME = lsdemo<span class="hljs-meta">#</span><span class="bash"> 获取makefile路径</span>PROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))<span class="hljs-meta">$</span><span class="bash">(info MAKEFILE_LIST is: $(MAKEFILE_LIST))</span><span class="hljs-meta">$</span><span class="bash">(info PROJECT_ROOT is: $(PROJECT_ROOT))</span><span class="hljs-meta">#</span><span class="bash"> 拼接路径</span>SOURCE_FRAGMENT :=$(CH_NO)/$(APP_NAME)SOURCE_ROOT := $(PROJECT_ROOT)$(SOURCE_FRAGMENT)<span class="hljs-meta">$</span><span class="bash">(info SOURCE_ROOT is: $(SOURCE_ROOT))</span>BUILD_ROOT := $(PROJECT_ROOT)build/make.debug.linux.x86_64/$(SOURCE_FRAGMENT)/<span class="hljs-meta">$</span><span class="bash">(info BUILD_ROOT is: $(BUILD_ROOT))</span>ifeq ($(BUILD_MODE),debug)CFLAGS += -gelse ifeq ($(BUILD_MODE),run)CFLAGS += -O2else<span class="hljs-meta">$</span><span class="bash">(error Build mode $(BUILD_MODE) not supported by this Makefile)</span>endif<span class="hljs-meta">$</span><span class="bash">(shell <span class="hljs-keyword">if</span> [ ! -d $(BUILD_ROOT) ]; <span class="hljs-keyword">then</span> mkdir -p $(BUILD_ROOT); <span class="hljs-keyword">fi</span>;)</span>SOURCE := $(shell find $(SOURCE_ROOT) -name '*.c' |xargs -n1 basename)OBJS := $(SOURCE:.c=.o)<span class="hljs-meta">$</span><span class="bash">(info SOURCE is: $(SOURCE))</span><span class="hljs-meta">$</span><span class="bash">(info OBJS is: $(OBJS))</span>all: $(APP_NAME)<span class="hljs-meta">#</span><span class="hljs-meta">$</span><span class="bash">(APP_NAME):$(OBJS)</span><span class="hljs-meta">$</span><span class="bash">(CXX) -o $(BUILD_ROOT)/<span class="hljs-variable">$@</span> $(addprefix $(BUILD_ROOT), $^)</span><span class="hljs-meta">%</span><span class="bash">.o:$(SOURCE_ROOT)/%.c</span><span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o $(BUILD_ROOT)/<span class="hljs-variable">$@</span> $&lt;</span>clean:rm -fr $(BUILD_ROOT)</code></pre><p>附上第四种情况的目录结构：</p><pre><code class="hljs shell">appweb@simon-ububtu18-desk-2:~/600.self/03.code/01.cpp/03.APUE$ tree .├── build│   └── make.debug.linux.x86_64│       └── ch01│           └── lsdemo│               ├── lsdemo│               ├── lsdemo.o│               └── test.o├── ch01│   └── lsdemo│       ├── lsdemo.c│       └── test.c└── Makefile</code></pre>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我的价值观</title>
    <link href="/2020/04/19/MySenseOfWorth/"/>
    <url>/2020/04/19/MySenseOfWorth/</url>
    
    <content type="html"><![CDATA[<h2 id="我的价值观"><a href="#我的价值观" class="headerlink" title="我的价值观"></a>我的价值观</h2><ol><li>一个底线：遵纪守法，远离黄赌毒。</li><li>一个标准：感恩上进，持续努力，享受尽职。</li><li>一个方法论：三人行必有我师，三人行我亦能成师。</li><li>一个技巧：顺势而为。</li><li>一个兜底：凡事有最坏的打算。</li></ol>]]></content>
    
    
    <categories>
      
      <category>think</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
