<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>netty之池化buffer</title>
    <link href="/2020/04/20/netty4-pooled-buffer/"/>
    <url>/2020/04/20/netty4-pooled-buffer/</url>
    
    <content type="html"><![CDATA[<h2 id="PooledByteBufAllocator-buffer分配"><a href="#PooledByteBufAllocator-buffer分配" class="headerlink" title="PooledByteBufAllocator buffer分配"></a>PooledByteBufAllocator buffer分配</h2><p>buffer分配的入口：<br>io.netty.buffer.PooledByteBufAllocator.newDirectBuffer(int, int)<br>netty实际应用时分配调用栈：  </p><table><tr><td>CLASS_NAME</td><td>METHOD_NAME</td><td>LINE_NUM</td></tr><tr><td>io/netty/buffer/PooledByteBufAllocator</td><td>newDirectBuffer</td><td>339</td></tr><tr><td>io/netty/buffer/AbstractByteBufAllocator</td><td>directBuffer</td><td>185</td></tr><tr><td>io/netty/buffer/AbstractByteBufAllocator</td><td>directBuffer</td><td>176</td></tr><tr><td>io/netty/buffer/AbstractByteBufAllocator</td><td>ioBuffer</td><td>139</td></tr><tr><td>io/netty/channel/DefaultMaxMessagesRecvByteBufAllocator$MaxMessageHandle</td><td>allocate</td><td>114</td></tr><tr><td>io/netty/channel/nio/AbstractNioByteChannel$NioByteUnsafe</td><td>read</td><td>186</td></tr><tr><td>io/netty/channel/nio/NioEventLoop</td><td>processSelectedKey</td><td>682</td></tr><tr><td>io/netty/channel/nio/NioEventLoop</td><td>processSelectedKeysOptimized</td><td>628</td></tr><tr><td>io/netty/channel/nio/NioEventLoop</td><td>processSelectedKeys</td><td>533</td></tr><tr><td>io/netty/channel/nio/NioEventLoop</td><td>run</td><td>511</td></tr><tr><td>io/netty/util/concurrent/SingleThreadEventExecutor$5</td><td>run</td><td>956</td></tr></table><h3 id="测试case代码"><a href="#测试case代码" class="headerlink" title="测试case代码"></a>测试case代码</h3><pre><code class="hljs plain">package io.netty.buffer;import org.junit.Assert;public class PooledByteBufTest &#123;public static void main(String[] args) &#123;  final PooledByteBufAllocator allocator &#x3D; new PooledByteBufAllocator(                false,   &#x2F;&#x2F; preferDirect                0,      &#x2F;&#x2F; nHeapArena                1,      &#x2F;&#x2F; nDirectArena                8192,   &#x2F;&#x2F; pageSize                11,     &#x2F;&#x2F; maxOrder                3,      &#x2F;&#x2F; tinyCacheSize                3,      &#x2F;&#x2F; smallCacheSize                3,      &#x2F;&#x2F; normalCacheSize                true    &#x2F;&#x2F; useCacheForAllThreads                );        &#x2F;&#x2F; create tiny buffer        final ByteBuf b1 &#x3D; allocator.directBuffer(24);        &#x2F;&#x2F; create small buffer        final ByteBuf b2 &#x3D; allocator.directBuffer(800);        &#x2F;&#x2F; create normal buffer        final ByteBuf b3 &#x3D; allocator.directBuffer(8192 * 2);        Assert.assertNotNull(b1);        Assert.assertNotNull(b2);        Assert.assertNotNull(b3);        &#x2F;&#x2F; then release buffer to deallocated memory while threadlocal cache has been disabled        &#x2F;&#x2F; allocations counter value must equals deallocations counter value        Assert.assertTrue(b1.release());        Assert.assertTrue(b2.release());        Assert.assertTrue(b3.release());&#125;&#125;</code></pre><h3 id="PoolChunk"><a href="#PoolChunk" class="headerlink" title="PoolChunk"></a>PoolChunk</h3><p>PoolChunk本身数据结构与设计思路参见PoolChunk注释：       </p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Description of algorithm for PageRun/PoolSubpage allocation from PoolChunk</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Notation: The following terms are important to understand the code</span><span class="hljs-comment"> * &gt; page  - a page is the smallest unit of memory chunk that can be allocated</span><span class="hljs-comment"> * page是chunk中能分配的最小单元  </span><span class="hljs-comment"> * &gt; chunk - a chunk is a collection of pages</span><span class="hljs-comment"> * 一个chunk中有一组page  1对多  </span><span class="hljs-comment"> * &gt; in this code chunkSize = 2^&#123;maxOrder&#125; * pageSize</span><span class="hljs-comment"> * 代码中  chunksize大小计算如上  maxOrder 是啥？</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * To begin we allocate a byte array of size = chunkSize</span><span class="hljs-comment"> * Whenever a ByteBuf of given size needs to be created we search for the first position</span><span class="hljs-comment"> * in the byte array that has enough empty space to accommodate the requested size and</span><span class="hljs-comment"> * return a (long) handle that encodes this offset information, (this memory segment is then</span><span class="hljs-comment"> * marked as reserved so it is always used by exactly one ByteBuf and no more)</span><span class="hljs-comment"> * 首先，当需要创建给定大小的ByteBuf时，我们分配一个size=chunkSize的字节数组，</span><span class="hljs-comment"> * 在字节数组中搜索第一个有足够的空空间来容纳请求的大小的位置，</span><span class="hljs-comment"> * 并返回一个（长）句柄来编码该偏移量信息（然后将该内存段标记为保留，因此它总是仅由一个ByteBuf使用，不再使用）</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * For simplicity all sizes are normalized according to PoolArena#normalizeCapacity method</span><span class="hljs-comment"> * This ensures that when we request for memory segments of size &gt;= pageSize the normalizedCapacity</span><span class="hljs-comment"> * equals the next nearest power of 2</span><span class="hljs-comment"> * 为了简单起见，所有大小都按照PoolArena#normalizeCapacity方法进行规范化</span><span class="hljs-comment"> * 这确保当我们请求大小大于等于pageSize的内存段时，normalized容量等于下一个最接近的2的幂</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * To search for the first offset in chunk that has at least requested size available we construct a</span><span class="hljs-comment"> * complete balanced binary tree and store it in an array (just like heaps) - memoryMap</span><span class="hljs-comment"> * 为了搜索块中至少有请求大小可用的第一个偏移量，我们构造了一个完整的平衡二叉树，并将其存储在一个数组（就像堆一样）-内存映射中</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * The tree looks like this (the size of each node being mentioned in the parenthesis)</span><span class="hljs-comment"> * 树看起来是这样的（括号中提到的每个节点的大小）</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * depth=0        1 node (chunkSize)</span><span class="hljs-comment"> * depth=1        2 nodes (chunkSize/2)</span><span class="hljs-comment"> * ..</span><span class="hljs-comment"> * ..</span><span class="hljs-comment"> * depth=d        2^d nodes (chunkSize/2^d)</span><span class="hljs-comment"> * ..</span><span class="hljs-comment"> * depth=maxOrder 2^maxOrder nodes (chunkSize/2^&#123;maxOrder&#125; = pageSize)  pageSize 在最下一层  最顶层是chunksize 从上往下走，每过一层除以2  </span><span class="hljs-comment"> *</span><span class="hljs-comment"> * depth=maxOrder is the last level and the leafs consist of pages</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * With this tree available searching in chunkArray translates like this:</span><span class="hljs-comment"> * To allocate a memory segment of size chunkSize/2^k we search for the first node (from left) at height k</span><span class="hljs-comment"> * which is unused 要分配大小为chunkSize/2^k的内存段，我们在高度k处搜索第一个未使用的节点（从左开始）。 嗯嗯</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Algorithm:</span><span class="hljs-comment"> * ----------</span><span class="hljs-comment"> * Encode the tree in memoryMap with the notation  用符号将树编码在内存中</span><span class="hljs-comment"> *   memoryMap[id] = x =&gt; in the subtree rooted at id, the first node that is free to be allocated</span><span class="hljs-comment"> *   is at depth x (counted from depth=0) i.e., at depths [depth_of_id, x), there is no node that is free</span><span class="hljs-comment"> * 在以id为根的子树中，可自由分配的第一个节点在深度x（从深度=0开始计算），即在深度[深度id，x的深度]处，没有可自由分配的节点</span><span class="hljs-comment"> *</span><span class="hljs-comment"> *  As we allocate &amp; free nodes, we update values stored in memoryMap so that the property is maintained</span><span class="hljs-comment"> * 当我们分配空闲节点时，我们更新存储在memoryMap中的值，以便维护属性</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Initialization -</span><span class="hljs-comment"> *   In the beginning we construct the memoryMap array by storing the depth of a node at each node</span><span class="hljs-comment"> * 首先，我们通过在每个节点上存储一个节点的深度来构造memoryMap数组</span><span class="hljs-comment"> *     i.e., memoryMap[id] = depth_of_id</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Observations:</span><span class="hljs-comment"> * -------------</span><span class="hljs-comment"> * 1) memoryMap[id] = depth_of_id  =&gt; it is free / unallocated</span><span class="hljs-comment"> * 2) memoryMap[id] &gt; depth_of_id  =&gt; at least one of its child nodes is allocated, so we cannot allocate it, but</span><span class="hljs-comment"> *                                    some of its children can still be allocated based on their availability</span><span class="hljs-comment"> * 3) memoryMap[id] = maxOrder + 1 =&gt; the node is fully allocated &amp; thus none of its children can be allocated, it</span><span class="hljs-comment"> *                                    is thus marked as unusable</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Algorithm: [allocateNode(d) =&gt; we want to find the first node (from left) at height h that can be allocated]</span><span class="hljs-comment"> * ----------</span><span class="hljs-comment"> * 1) start at root (i.e., depth = 0 or id = 1)</span><span class="hljs-comment"> * 2) if memoryMap[1] &gt; d =&gt; cannot be allocated from this chunk</span><span class="hljs-comment"> * 3) if left node value &lt;= h; we can allocate from left subtree so move to left and repeat until found</span><span class="hljs-comment"> * 4) else try in right subtree</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Algorithm: [allocateRun(size)]</span><span class="hljs-comment"> * ----------</span><span class="hljs-comment"> * 1) Compute d = log_2(chunkSize/size)</span><span class="hljs-comment"> * 2) Return allocateNode(d)</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Algorithm: [allocateSubpage(size)]</span><span class="hljs-comment"> * ----------</span><span class="hljs-comment"> * 1) use allocateNode(maxOrder) to find an empty (i.e., unused) leaf (i.e., page)</span><span class="hljs-comment"> * 2) use this handle to construct the PoolSubpage object or if it already exists just call init(normCapacity)</span><span class="hljs-comment"> *    note that this PoolSubpage object is added to subpagesPool in the PoolArena when we init() it</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * Note:</span><span class="hljs-comment"> * -----</span><span class="hljs-comment"> * In the implementation for improving cache coherence,</span><span class="hljs-comment"> * we store 2 pieces of information depth_of_id and x as two byte values in memoryMap and depthMap respectively</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * memoryMap[id]= depth_of_id  is defined above</span><span class="hljs-comment"> * depthMap[id]= x  indicates that the first node which is free to be allocated is at depth x (from root)</span><span class="hljs-comment"> */</span><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PoolChunk</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">PoolChunkMetric</span> </span>&#123;</code></pre><p>io.netty.buffer.PoolArena.findSubpagePoolHead(int)  算出page header在page table中的index，小的page在前面    </p><p>// trace 库地址 jdbc:h2:/Users/simon/twice-cooked-pork/trace-data/基于netty4做的resetserver的一次http请求trace/tracer.data.h2db  </p><p>PoolChunk要解决的问题有：  </p><ol><li>快速查找未分配的地方并分配</li><li>尽量不要有碎片，可以理解成尽量挨着紧凑的分配</li></ol><p>整个chunk的结构如下：  </p><pre><code class="hljs html">                                                    +------+   chunksize 当L=11时，是16ML=0                                                 |   0  |                                   +----------------+------+------------------+                                   |                                          |                                   |                                          |                                   |                                          |                               +---v--+                                   +---v--+L=1                            |   1  |                                   |   2  |                        +------+------+------+                     +------+------+-------+                        |                    |                     |                     |                        |                    |                     |                     |                        |                    |                     |                     |                    +---v--+             +---v--+              +---v--+              +---v--+L=2                 |   3  |             |   4  |              |   5  |              |   6  |                 +--+------+-+         +-+------+--+        +--+------+--+         +-+------+--+                 |           |         |           |        |            |         |           |                 |           |         |           |        |            |         |           |                 |           |         |           |        |            |         |           |              +--v---+   +---v--+   +--v---+   +---v--+   +-v----+   +---v--+   +--v---+   +---v--+L=3           |  7   |   |   8  |   |  9   |   |  10  |   |  11  |   |  12  |   |  13  |   |  14  |              +------+   +------+   +------+   +------+   +------+   +------+   +------+   +------+               8K大小即page size</code></pre><p>是一个完全二叉树，树的层高可以自定义，目前限制在14层内，默认是11层。<br>最底层是真正的chunk描述，最底层每个叶子是一个paage，大小为8K。那么当层数是11层时，chunk的size是16M。因为11层的话，最下面一层叶子是2的11次方，再乘以8K正好是16MB。<br>这棵树中每个节点还对对应其相应的大小是否被分配。什么叫其相应的大小？是这样的，每一层代表需要分配的大小的档次。暂且用档次这个词吧。最上面是16MB档次，最下面是8K档次，从最上面开始往下走一层，档次就除以2。<br>每次申请内存时，netty会先对其做规格化，所谓规格化就是最接近申请内存值的2de整数次幂。比如我申请900byte，那么规格化后就是1K。在规格化后，netty会在树上标志 0 1 3 7被使用了。下次要再申请8K内存时就要避开这个路径了，只能是 0 1 3 8 了，因为7那边已经不够了。其他大小同理。所以树上的节点是为了标志是否被使用过，以使得内存碎片减少尽量靠左紧凑分配。   对于单page内的内存使用浪费问题，netty又做了一层位图结构使其得以利用。对于chunk对象的查找，netty还做了缓存机制，下面有讲。 </p><p>真正数据存放在 io.netty.buffer.PoolChunk.memory 这个字段中，调试时为：java.nio.DirectByteBuffer[pos=0 lim=16777216 cap=16777216]<br>16777216是16M  </p><h4 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h4><p>仔细调试 1K 2k 3K 8K 11K 内存的多次分配与回收。</p><h4 id="分配24byte过程"><a href="#分配24byte过程" class="headerlink" title="分配24byte过程"></a>分配24byte过程</h4><p>PooledUnsafeDirectByteBuf是用了对象池特性io.netty.buffer.PooledUnsafeDirectByteBuf.RECYCLER  </p><h3 id="PoolArena"><a href="#PoolArena" class="headerlink" title="PoolArena"></a>PoolArena</h3><p><code>PoolArena</code> 这一层负责创建与维护PoolChunk，维护的方式是将用到的正在分配中的PoolChunk放到PoolChunkList这个列表中。<br>PoolChunkList是一个链是结构。<br>而且，PoolArena还<strong>按PoolChunk的使用量</strong>来<strong>分别维护到相对应</strong>的PoolChunkList中。  </p><pre><code class="hljs java"><span class="hljs-comment">// abstract class PoolArena&lt;T&gt; implements PoolArenaMetric &#123;</span><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PoolChunkList&lt;T&gt; q050;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PoolChunkList&lt;T&gt; q025;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PoolChunkList&lt;T&gt; q000;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PoolChunkList&lt;T&gt; qInit;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PoolChunkList&lt;T&gt; q075;<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PoolChunkList&lt;T&gt; q100;</code></pre><p>这些PoolChunkList也是<strong>按使用量大小有序的链式的串在一起</strong>(参见PoolArena构造方法中初始化这些list字段的代码)，当使用量达到本级别时，会加入到下一级别的list中，比如达到25%了，那么就会加到50%列表中了。(参见io.netty.buffer.PoolChunkList.add(PoolChunk<T>))   </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(PoolChunk&lt;T&gt; chunk)</span> </span>&#123;    <span class="hljs-keyword">if</span> (chunk.usage() &gt;= maxUsage) &#123;        nextList.add(chunk);        <span class="hljs-keyword">return</span>;    &#125;    add0(chunk);&#125;</code></pre><p>PoolArena中还维护了两个PoolSubpage数组，每个数组里面的实例在PoolArena构造时初始化，刚初始化后每个PoolSubpage元素的前继与后继元素都是指向自己(PoolSubpage是支持链表式的一个结构)<br>在io.netty.buffer.PoolSubpage.addToPool(PoolSubpage<T>)时 会将io.netty.buffer.PoolChunk.allocateSubpage(int)过程中新构建出来的PoolSubpage实例<strong>加到head的next节点上(即后继节点)</strong>。 具体代码如下：  </p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-title">allocateSubpage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> normCapacity)</span> </span>&#123;    <span class="hljs-comment">// Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.</span>    <span class="hljs-comment">// This is need as we may add it back and so alter the linked-list structure.</span>    PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(normCapacity); <span class="hljs-comment">// 这个是查找PoolArena的PoolSubpage数组</span>    <span class="hljs-keyword">int</span> d = maxOrder; <span class="hljs-comment">// subpages are only be allocated from pages i.e., leaves</span>    <span class="hljs-keyword">synchronized</span> (head) &#123;        <span class="hljs-keyword">int</span> id = allocateNode(d);        <span class="hljs-keyword">if</span> (id &lt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> id;        &#125;        <span class="hljs-keyword">final</span> PoolSubpage&lt;T&gt;[] subpages = <span class="hljs-keyword">this</span>.subpages;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> pageSize = <span class="hljs-keyword">this</span>.pageSize;        freeBytes -= pageSize;        <span class="hljs-keyword">int</span> subpageIdx = subpageIdx(id);        PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx];        <span class="hljs-keyword">if</span> (subpage == <span class="hljs-keyword">null</span>) &#123;            subpage = <span class="hljs-keyword">new</span> PoolSubpage&lt;T&gt;(head, <span class="hljs-keyword">this</span>, id, runOffset(id), pageSize, normCapacity); <span class="hljs-comment">// 此处会将新新构建出来的PoolSubpage实例加到head的next节点</span>            subpages[subpageIdx] = subpage;        &#125; <span class="hljs-keyword">else</span> &#123;            subpage.init(head, normCapacity);        &#125;        <span class="hljs-keyword">return</span> subpage.allocate();    &#125;&#125;</code></pre><h3 id="PoolArenad的cache与Recycler对象池"><a href="#PoolArenad的cache与Recycler对象池" class="headerlink" title="PoolArenad的cache与Recycler对象池"></a>PoolArenad的cache与Recycler对象池</h3><p>PooledByteBuf依赖PoolThreadCache做了一层对PoolChunk的缓存,PoolThreadCache靠MemoryRegionCache实现缓存。MemoryRegionCache靠队列来实现对PoolChunk的缓存(参见下面代码1)，MemoryRegionCache在buf释放时会调用其add接口将释放的PoolChunk对象和nioBuffer对象通过io.netty.buffer.PoolThreadCache.MemoryRegionCache.Entry<T>对象包装后加入(offer)到队列(参见下面堆栈1)。在io.netty.buffer.PoolThreadCache.MemoryRegionCache.allocate(PooledByteBuf<T>, int)时再从队列中直接poll出来，达成cache的目的。优化还没有结束，包装PoolChunk用的Entry对象是通过<code>Recycler</code>对象池完成分配(获取)已释放的。对象是本质上一个通过FastThreadLocal的Stack的数据结构，分配对应出栈，释放对象入栈。具体参见下面代码2。<br>Recycler<PooledUnsafeDirectByteBuf><br>是一个基于ThreadLocal结合stack玩起来的一个对象池数据结构，像上述这种就是PooledUnsafeDirectByteBuf的对象pool。回收的时候压栈，要用的时候出栈。<br>获取对象  io.netty.util.Recycler.get()<br>回收对象  io.netty.util.Recycler.DefaultHandle.recycle(Object)   </p><p>代码1： 队列初始化  </p><pre><code class="hljs java">Queue&lt;Entry&lt;T&gt;&gt; queue = PlatformDependent.newFixedMpscQueue(<span class="hljs-keyword">this</span>.size);</code></pre><p>堆栈1：buf释放时会调用MemoryRegionCache add接口将释放的PoolChunk对象包装后入队：  </p><pre><code class="hljs java">Thread [main] (Suspended (breakpoint at line <span class="hljs-number">393</span> in PoolThreadCache$MemoryRegionCache))PoolThreadCache$SubPageMemoryRegionCache&lt;T&gt;(PoolThreadCache$MemoryRegionCache&lt;T&gt;).add(PoolChunk&lt;T&gt;, ByteBuffer, <span class="hljs-keyword">long</span>) line: <span class="hljs-number">393</span>PoolThreadCache.add(PoolArena&lt;?&gt;, PoolChunk, ByteBuffer, <span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>, SizeClass) line: <span class="hljs-number">209</span>PoolArena$DirectArena(PoolArena&lt;T&gt;).free(PoolChunk&lt;T&gt;, ByteBuffer, <span class="hljs-keyword">long</span>, <span class="hljs-keyword">int</span>, PoolThreadCache) line: <span class="hljs-number">273</span>PooledUnsafeDirectByteBuf(PooledByteBuf&lt;T&gt;).deallocate() line: <span class="hljs-number">171</span>PooledUnsafeDirectByteBuf(AbstractReferenceCountedByteBuf).release0(<span class="hljs-keyword">int</span>) line: <span class="hljs-number">136</span>PooledUnsafeDirectByteBuf(AbstractReferenceCountedByteBuf).release() line: <span class="hljs-number">124</span>PooledByteBufTest.main(String[]) line: <span class="hljs-number">43</span></code></pre><p>代码2：Entry对象使用对象池    </p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Recycler&lt;Entry&gt; RECYCLER = <span class="hljs-keyword">new</span> Recycler&lt;Entry&gt;() &#123;    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Entry <span class="hljs-title">newObject</span><span class="hljs-params">(Handle&lt;Entry&gt; handle)</span> </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Entry(handle);    &#125;&#125;;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Entry <span class="hljs-title">newEntry</span><span class="hljs-params">(PoolChunk&lt;?&gt; chunk, ByteBuffer nioBuffer, <span class="hljs-keyword">long</span> handle)</span> </span>&#123;    Entry entry = RECYCLER.get();    entry.chunk = chunk;    entry.nioBuffer = nioBuffer;    entry.handle = handle;    <span class="hljs-keyword">return</span> entry;&#125;<span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recycle</span><span class="hljs-params">(Object object)</span> </span>&#123;    <span class="hljs-keyword">if</span> (object != value) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"object does not belong to handle"</span>);    &#125;    Stack&lt;?&gt; stack = <span class="hljs-keyword">this</span>.stack;    <span class="hljs-keyword">if</span> (lastRecycledId != recycleId || stack == <span class="hljs-keyword">null</span>) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"recycled already"</span>);    &#125;    stack.push(<span class="hljs-keyword">this</span>);&#125;</code></pre><h3 id="PooledByteBufAllocator创建及其关联细节"><a href="#PooledByteBufAllocator创建及其关联细节" class="headerlink" title="PooledByteBufAllocator创建及其关联细节"></a>PooledByteBufAllocator创建及其关联细节</h3><ol><li>PooledByteBufAllocator validateAndCalculateChunkSize 校验树高度不能超过14，且根据pageSize(可以外部指定)和树高计算出chunksize</li><li>PooledByteBufAllocator validateAndCalculatePageShifts 校验pageSize最小不能小于4K，且pageSize必须是2的整数次方((pageSize &amp; pageSize - 1) != 0) （为什么(pageSize &amp; pageSize - 1) != 0能判断？因为2的n次方的二进制形式一定是第一位1后面接n个0，减1后就变成第一位0后面接n个1，相与之后一定是0；如果不是2的n次方的数的二进制形式一定是第一位是1，且，这个数减去1后，第一位一定还是1，因为第一位是1且后面全接0的数一定是2的整数次方的，那么不是2的整数次方的数后面一定不全是0，所以减去1后第一位肯定还是1，所以不管后面接的这些数相与是怎样的结果，第一位两个1相与出来肯定是1，肯定不为0，所以能用这个办法判断）</li><li>创建tinySubpagePools数组并初始化里面的元素，默认数组大小32个，里面的元素是PoolSubpage，PoolSubpage还支持链式形式连接(他有前继和后继)</li></ol><h3 id="PoolChunk-分配与释放小于pagesize的buf"><a href="#PoolChunk-分配与释放小于pagesize的buf" class="headerlink" title="PoolChunk 分配与释放小于pagesize的buf"></a>PoolChunk 分配与释放小于pagesize的buf</h3><p>io.netty.buffer.PoolArena.free(PoolChunk<T>, ByteBuffer, long, int, PoolThreadCache)<br>位图相关：  </p><pre><code class="hljs java"><span class="hljs-comment">// long64位 取 高32位转成整数</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">bitmapIdx</span><span class="hljs-params">(<span class="hljs-keyword">long</span> handle)</span> </span>&#123;        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (handle &gt;&gt;&gt; Integer.SIZE);    &#125;</code></pre><p>PoolSubpage 支持位图<br>一个page 8192大小 一个块(element)大小32，那么一个page可以拆成256个，每申请一次numAvail减去1。<br>long型位图数组中有个8个元素，8192/16/64=8, 64是long的位数,。</p><p>分配时bitmap中元素，以第一个元素为例子，按1 3 7 15 31 63 127网上涨，释放的时候按对应数据往下减，并且在释放时记录nextAvail值，便于下次申请时优先使用。<br>bitmap中的4个(bitmapLength)long来维护256个（maxNumElems=pageSize/elemSize）块是否使用的情况。  </p><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PoolSubpage</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">PoolSubpageMetric</span> </span>&#123;    <span class="hljs-keyword">final</span> PoolChunk&lt;T&gt; chunk;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> memoryMapIdx;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> runOffset;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> pageSize;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span>[] bitmap;  <span class="hljs-comment">// 位图...,默认有8个元素 个数= pagesize &gt;&gt;&gt; 10 （pagesize / 16 / 64）64应该是long的位数，16是啥？一个element算256。 实际这个数组默认只用4个元素</span>    PoolSubpage&lt;T&gt; prev;    PoolSubpage&lt;T&gt; next;    <span class="hljs-keyword">boolean</span> doNotDestroy;    <span class="hljs-keyword">int</span> elemSize;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxNumElems; <span class="hljs-comment">// 一个page再分maxNumElems分  默认是256</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> bitmapLength; <span class="hljs-comment">// 默认是4  256 &gt;&gt;&gt; 6 = 4</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> nextAvail; <span class="hljs-comment">// 在有buf释放时会设置这个值，以使得他们在下次分配时优先使用这个</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numAvail;        <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">allocate</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">if</span> (elemSize == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">return</span> toHandle(<span class="hljs-number">0</span>);        &#125;        <span class="hljs-keyword">if</span> (numAvail == <span class="hljs-number">0</span> || !doNotDestroy) &#123;            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;        &#125;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bitmapIdx = getNextAvail();        <span class="hljs-keyword">int</span> q = bitmapIdx &gt;&gt;&gt; <span class="hljs-number">6</span>;        <span class="hljs-keyword">int</span> r = bitmapIdx &amp; <span class="hljs-number">63</span>;        <span class="hljs-keyword">assert</span> (bitmap[q] &gt;&gt;&gt; r &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>;        bitmap[q] |= <span class="hljs-number">1L</span> &lt;&lt; r;  <span class="hljs-comment">// 按1 3 7 15 31 63 127往上涨</span>        <span class="hljs-keyword">if</span> (-- numAvail == <span class="hljs-number">0</span>) &#123;            removeFromPool();        &#125;        <span class="hljs-keyword">return</span> toHandle(bitmapIdx);    &#125;            <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNextAvail</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span>[] bitmap = <span class="hljs-keyword">this</span>.bitmap;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> bitmapLength = <span class="hljs-keyword">this</span>.bitmapLength;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; bitmapLength; i ++) &#123;            <span class="hljs-keyword">long</span> bits = bitmap[i];            <span class="hljs-keyword">if</span> (~bits != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 这个表示这个long上是否所有的位都用完了。。</span>                <span class="hljs-keyword">return</span> findNextAvail0(i, bits);            &#125;        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findNextAvail0</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">long</span> bits)</span> </span>&#123;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxNumElems = <span class="hljs-keyword">this</span>.maxNumElems;        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> baseVal = i &lt;&lt; <span class="hljs-number">6</span>;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">64</span>; j ++) &#123;            <span class="hljs-keyword">if</span> ((bits &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 判断是否是偶数</span>                <span class="hljs-keyword">int</span> val = baseVal | j;                <span class="hljs-keyword">if</span> (val &lt; maxNumElems) &#123;                    <span class="hljs-keyword">return</span> val;                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-keyword">break</span>;                &#125;            &#125;            bits &gt;&gt;&gt;= <span class="hljs-number">1</span>; <span class="hljs-comment">// 除以2 并向靠近的2的整数次幂对齐</span>        &#125;        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;    &#125;</code></pre><p>free时不是每次都会真正释放，在下面会先加入到MemoryRegionCache的queue中cache起来，当queue中放不下时才真正free，代码如下：  </p><pre><code class="hljs java"><span class="hljs-comment">// PoolArena.class</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">free</span><span class="hljs-params">(PoolChunk&lt;T&gt; chunk, ByteBuffer nioBuffer, <span class="hljs-keyword">long</span> handle, <span class="hljs-keyword">int</span> normCapacity, PoolThreadCache cache)</span> </span>&#123;    <span class="hljs-keyword">if</span> (chunk.unpooled) &#123;        <span class="hljs-keyword">int</span> size = chunk.chunkSize();        destroyChunk(chunk);        activeBytesHuge.add(-size);        deallocationsHuge.increment();    &#125; <span class="hljs-keyword">else</span> &#123;        SizeClass sizeClass = sizeClass(normCapacity);        <span class="hljs-keyword">if</span> (cache != <span class="hljs-keyword">null</span> &amp;&amp; cache.add(<span class="hljs-keyword">this</span>, chunk, nioBuffer, handle, normCapacity, sizeClass)) &#123;            <span class="hljs-comment">// cached so not free it.</span>            <span class="hljs-keyword">return</span>;        &#125;        freeChunk(chunk, handle, sizeClass, nioBuffer);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>netty之ResourceLeakDetector的使用与实现</title>
    <link href="/2020/04/20/netty4-resource-leak-detector-impl/"/>
    <url>/2020/04/20/netty4-resource-leak-detector-impl/</url>
    
    <content type="html"><![CDATA[<h1 id="netty之ResourceLeakDetector的使用与实现"><a href="#netty之ResourceLeakDetector的使用与实现" class="headerlink" title="netty之ResourceLeakDetector的使用与实现"></a>netty之ResourceLeakDetector的使用与实现</h1><p>通过<strong>WeakReference和ReferenceQueue</strong>做针对<strong>需要手动释放</strong>的资源的侦测  </p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol><li>设置日志级别：  <pre><code class="hljs java">ServerBootstrap b =<span class="hljs-keyword">new</span> ServerBootstrap();b.group(bossGroup,workerGroup).channel(NioServerSocketChannel<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span><span class="hljs-class">.<span class="hljs-title">option</span>(<span class="hljs-title">ChannelOption</span>.<span class="hljs-title">SO_BACKLOG</span>, 2048)</span><span class="hljs-class">.<span class="hljs-title">handler</span>(<span class="hljs-title">new</span> <span class="hljs-title">LoggingHandler</span>(<span class="hljs-title">LogLevel</span>.<span class="hljs-title">DEBUG</span>))</span><span class="hljs-class">.<span class="hljs-title">childHandler</span>(<span class="hljs-title">new</span> <span class="hljs-title">ChildChannelHandler</span>())</span>;<span class="hljs-number">2017</span>-<span class="hljs-number">01</span>-<span class="hljs-number">19</span> <span class="hljs-number">10</span>:<span class="hljs-number">04</span>:<span class="hljs-number">49</span>  [ nioEventLoopGroup-<span class="hljs-number">1</span>-<span class="hljs-number">0</span>:<span class="hljs-number">1628830</span> ] - [ ERROR ]  LEAK: ByteBuf.release() was not called before it<span class="hljs-string">'s garbage-coll...</span></code></pre></li><li>ResourceLeakDetector.setLevel(ResourceLeakDetector.Level.ADVANCED);或者通过JVM参数配置<br>日志：  <pre><code class="hljs java"><span class="hljs-number">2017</span>-<span class="hljs-number">01</span>-<span class="hljs-number">19</span> <span class="hljs-number">10</span>:<span class="hljs-number">35</span>:<span class="hljs-number">59</span>  [ nioEventLoopGroup-<span class="hljs-number">1</span>-<span class="hljs-number">0</span>:<span class="hljs-number">665092</span> ] - [ ERROR ]  LEAK: ByteBuf.release() was not called before it<span class="hljs-string">'s garbage-collected. See http://netty.io/wiki/reference-counted-objects.html for more information.</span><span class="hljs-string">Recent access records: 5</span><span class="hljs-string">#5:</span><span class="hljs-string">    io.netty.buffer.AdvancedLeakAwareByteBuf.readBytes(AdvancedLeakAwareByteBuf.java:435)</span></code></pre></li></ol><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>[ ERROR ]  LEAK:   </p><pre><code class="hljs java"><span class="hljs-comment">// ResourceLeakDetector</span><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reportTracedLeak</span><span class="hljs-params">(String resourceType, String records)</span> </span>&#123;    logger.error(            <span class="hljs-string">"LEAK: &#123;&#125;.release() was not called before it's garbage-collected. "</span> +            <span class="hljs-string">"See http://netty.io/wiki/reference-counted-objects.html for more information.&#123;&#125;"</span>,            resourceType, records);&#125;<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">reportLeak</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">if</span> (!logger.isErrorEnabled()) &#123;        clearRefQueue();        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// Detect and report previous leaks.</span>    <span class="hljs-keyword">for</span> (;;) &#123;        <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"unchecked"</span>)        DefaultResourceLeak ref = (DefaultResourceLeak) refQueue.poll(); <span class="hljs-comment">// 为什么能拿到？什么时候 放进去的？是weakreference回收过程中放进去的，相当于GC过程让你插入hook。那为什么被GC了还有资源泄露呢？这个问题其实是这样的，泄露是池化内存等那些需要手动释放资源。</span>        <span class="hljs-keyword">if</span> (ref == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">break</span>;        &#125;        <span class="hljs-keyword">if</span> (!ref.dispose()) &#123; <span class="hljs-comment">// return allLeaks.remove(this); 所以当有人显式释放过，那么此处就返回false 就不会往下走report了</span>            <span class="hljs-keyword">continue</span>;        &#125;        String records = ref.toString();        <span class="hljs-keyword">if</span> (reportedLeaks.putIfAbsent(records, Boolean.TRUE) == <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-keyword">if</span> (records.isEmpty()) &#123;                reportUntracedLeak(resourceType);            &#125; <span class="hljs-keyword">else</span> &#123;                reportTracedLeak(resourceType, records);            &#125;        &#125;    &#125;&#125;</code></pre><h3 id="基本实现原理"><a href="#基本实现原理" class="headerlink" title="基本实现原理"></a>基本实现原理</h3><ol><li>通过DefaultResourceLeak继承自WeakReference，借助WeakReference的GC特性完成。WeakReference的GC特性是当这个对象没有被其他强引用对象引用时，仅仅被WeakReference引用(或者其他weak引用)时，会在下一次GC时回收，回收过程中会将被回收的引用放到ReferenceQueue中。此处的ReferenceQueue又是在创建DefaultResourceLeak时通过构造参数传入的。</li><li>不时poll那个ReferenceQueue队列，当拿到对象时看起dispose是否被调用过，如果没有则证明没有显示释放，则report出来。  </li><li>每次创建池化buf对象时，便会创建DefaultResourceLeak，并在touch等API中调用其record方法，追踪其申请使用的地方。在开启了泄露追踪后，buf会被包装，比如包装成AdvancedLeakAwareByteBuf。    </li><li>侦测reportLeak不是每次都调用，当小雨PARANOID级别是在申请buf时按随机数比例调。PARANOID级别是全调。</li></ol><p>此处资源泄露，是指那种需要手动释放的资源，因为引用他的对象已经不在程序逻辑中使用了，那么最终会被GC回收，但是那种需要手动释放的资源不显式释放就泄露了。比如内存池，比方说里面有5个杯子，你用的buf指向一个杯子被你占着，你不用时没显式告诉内存池说这个杯子不用了，那么就一直占着，但是buf对象不用了会被GC回收，那么此时内存池资源就泄露了。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>netty之idle handler处理</title>
    <link href="/2020/04/20/netty4-idle-handler/"/>
    <url>/2020/04/20/netty4-idle-handler/</url>
    
    <content type="html"><![CDATA[<ol><li>初始化时记录idle时间，并启动一个延时任务，延时时间为idle时间，延时任务是io.netty.handler.timeout.IdleStateHandler.AllIdleTimeoutTask  </li><li>channelReadComplete 会更新lastReadTime，lastWriteTime是在write操作返回的ChannelFuture实例上挂上listener监听operationComplete动作来更新的，详细参见io.netty.handler.timeout.IdleStateHandler.writeListener</li><li>AllIdleTimeoutTask 任务逻辑中会取lastReadTime, lastWriteTime大值，并拿nextDelay减去他们，这样就能得到下次任务要延期多就检查执行。    </li></ol><p>比如一开始是10：00，5分钟idle时间，那么会在10：05时检查(延迟5分钟)，如果在10：04发生了读写，那么在10：05检查时算出下一次延迟启动任务是4分钟后即10：09分。 </p><p>读写超时是基于此做的事件，检查机制类似。<br>且在netty4中未使用 HashedWheelTimer，而是在线NioEventLoop的spin loop中完成触发。在spin loop中会从io.netty.util.concurrent.AbstractScheduledEventExecutor.scheduledTaskQueue中peek出最前面(也是最早到达的定时任务)的看其deadline是否小于当前时间，如果是则执行。<br>HashedWheelTimer是在netty3中用来做idle检测的。</p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>可以用命令行控制eclipse断点增加删除、远程调试创建与启动的插件</title>
    <link href="/2020/04/20/use-curl-to-manage-breakpoint-on-eclipse/"/>
    <url>/2020/04/20/use-curl-to-manage-breakpoint-on-eclipse/</url>
    
    <content type="html"><![CDATA[<h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><pre><code class="hljs bash"><span class="hljs-comment"># 创建断点(支持条件断点)</span>curl  -X PUT -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"language":"java","condition":"i == 1","charStart":283,"charEnd":307,"lineNumber":16,"typeName":"com.code260.tools.redstar.dp.java.TestStub","hitCount":-1,"projectName":"test-debug","filePath":"/src/com/code260/tools/redstar/dp/java/TestStub.java"&#125;'</span> http://127.0.0.1:8884/redstar/breakpoint/java<span class="hljs-comment"># 删除断点</span>curl  -X DELETE -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"language":"java","condition":"i == 1","charStart":283,"charEnd":307,"lineNumber":16,"typeName":"com.code260.tools.redstar.dp.java.TestStub","hitCount":-1,"projectName":"test-debug","filePath":"/src/com/code260/tools/redstar/dp/java/TestStub.java"&#125;'</span> http://127.0.0.1:8884/redstar/breakpoint/java<span class="hljs-comment"># 创建远程调试</span>curl  -X PUT -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"name":"tes-debug-001","hostname":"127.0.0.1","port":8501,"projectName":"test-debug","vmConnector":"org.eclipse.jdt.launching.socketAttachConnector","allowTerminal":false&#125;'</span> http://127.0.0.1:8884/redstar/launch-debug/java<span class="hljs-comment"># 启动远程调试</span>curl  -X POST -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"name":"tes-debug-001"&#125;'</span> http://127.0.0.1:8884/redstar/launch-debug/java<span class="hljs-comment"># 查询所有断点</span>curl http://127.0.0.1:8884/redstar/breakpoint/java<span class="hljs-comment"># 监听断点事件</span>curl http://127.0.0.1:8884/redstar/debug-event/java/watch<span class="hljs-comment"># 放掉一个断点</span>curl  -X POST -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"launchName":"tes-debug-001", "threadName":"main"&#125;'</span> http://127.0.0.1:8884/redstar/breakpoint/java/resume<span class="hljs-comment"># inspect一个表达式</span>curl  -X POST -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"launchName":"tes-debug-001", "threadName":"main", "expression":"i=i+5","projectName":"test-debug"&#125;'</span> http://127.0.0.1:8884/redstar/debug-event/java/inspect</code></pre><h2 id="scala"><a href="#scala" class="headerlink" title="scala"></a>scala</h2><pre><code class="hljs bash"><span class="hljs-comment"># 创建断点(支持条件断点)</span>curl  -X PUT -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"language":"scala","condition":"","charStart":-1,"charEnd":-1,"lineNumber":6,"typeName":"testpkg.TestObject","hitCount":-1,"projectName":"test-scala","filePath":"/src/testpkg/TestObject.scala"&#125;'</span> http://127.0.0.1:8884/redstar/breakpoint/java<span class="hljs-comment"># 删除断点</span>curl  -X DELETE -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"language":"scala","condition":"i == 1","charStart":-1,"charEnd":-1,"lineNumber":6,"typeName":"testpkg.TestObject","hitCount":-1,"projectName":"test-scala","filePath":"/src/testpkg/TestObject.scala"&#125;'</span> http://127.0.0.1:8884/redstar/breakpoint/java<span class="hljs-comment"># 创建远程调试</span>curl  -X PUT -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"name":"tes-debug-001","hostname":"127.0.0.1","port":8500,"projectName":"test-scala","vmConnector":"org.scala-ide.sdt.debug.socketAttachConnector","allowTerminal":false&#125;'</span> http://127.0.0.1:8884/redstar/launch-debug/java<span class="hljs-comment"># 启动远程调试</span>curl  -X POST -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"name":"tes-debug-001"&#125;'</span> http://127.0.0.1:8884/redstar/launch-debug/java<span class="hljs-comment"># 查询所有断点</span>curl http://127.0.0.1:8884/redstar/breakpoint/java<span class="hljs-comment"># 监听断点事件</span>curl http://127.0.0.1:8884/redstar/debug-event/java/watch<span class="hljs-comment"># 放掉一个断点</span>curl  -X POST -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"launchName":"tes-debug-001", "threadName":"main"&#125;'</span> http://127.0.0.1:8884/redstar/breakpoint/java/resume<span class="hljs-comment"># inspect一个表达式</span>curl  -X POST -H <span class="hljs-string">"Content-Type:application/json"</span> --data <span class="hljs-string">'&#123;"launchName":"tes-debug-001", "threadName":"main", "expression":"i=i+5","projectName":"test-debug"&#125;'</span> http://127.0.0.1:8884/redstar/debug-event/java/inspect</code></pre><p><a href="https://files.cnblogs.com/files/simoncook/redstar-dp-java-eclipse-site.zip" target="_blank" rel="noopener">插件下载地址</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>dev-tools</tag>
      
      <tag>eclipse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu开发机所需工具，做个记录，不断补充</title>
    <link href="/2020/04/20/dev-tools-on-ubuntu/"/>
    <url>/2020/04/20/dev-tools-on-ubuntu/</url>
    
    <content type="html"><![CDATA[<h3 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h3><p>FSearch 用了下可以， 类似windows下的Everything 或者mac的cmd+空格<br><a href="https://github.com/cboxdoerfer/fsearch" target="_blank" rel="noopener">地址</a><br>安装：  </p><blockquote><p>sudo add-apt-repository ppa:christian-boxdoerfer/fsearch-daily<br>sudo apt-get update<br>sudo apt install fsearch-trunk  </p></blockquote><p>subl 1.txt   sublime比自带gedit顺手  </p><p>nautilus ./ 启动文件浏览器  </p>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dev-tools</tag>
      
      <tag>ubutnu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于dubbo扩展点的一点分析</title>
    <link href="/2020/04/20/about-dubbo-extension-loader/"/>
    <url>/2020/04/20/about-dubbo-extension-loader/</url>
    
    <content type="html"><![CDATA[<h2 id="扩展点能力"><a href="#扩展点能力" class="headerlink" title="扩展点能力"></a>扩展点能力</h2><ol><li>能load class，这个class除了顶层接口class（在ExtensionLoader中对应type字段），还能load各实现类的class。</li><li>能创建instance。</li><li>能指定这个顶层接口的默认实现类的beanName。做法参见SPI注解部分。</li><li>能把创建出来的instance的字段注入。set开头的且有一个参数且是public的，注入。  </li><li>能adaptive。根据url上对该接口配置的实现类，将该接口的事情交给这个实现类去做(我更多的理解成委托)。此能力采用代码生成再编译的方式。代码生成示例可以参见adaptive类代码示例。 adaptive只会生成一个adaptive实现类。生成代码的逻辑在com.alibaba.dubbo.common.extension.ExtensionLoader.createAdaptiveExtensionClassCode()  </li><li>能wrapper。wrapper是指这个顶层接口的实现类的构造函数的入参是这个顶层接口类型。那么这个实现类称之为wrapper类，可以有多个，构建instance时不分多个之间的顺序。因为用来给构造函数传参的instance是这个顶层类的默认实现。比如com.alibaba.dubbo.rpc.Protocol接口，有实现类 com.alibaba.dubbo.rpc.protocol.injvm.InjvmProtocol beanName是injvm，QosProtocolWrapper、ProtocolListenerWrapper、ProtocolFilterWrapper是其三个wrapper类。创建warpper instance的代码逻辑在com.alibaba.dubbo.common.extension.ExtensionLoader.createExtension(String)中。  </li><li>能active。实现类加了Activate注解的。在ExtensionLoader.getActivateExtension时会根据当前的url(配置信息)中值来匹配Activate注解中指定的值是否能match，能match的表示是activate，意思是命中的。在过滤器扩展点中用到。比如这个过滤器是给CONSUMER group用。示例有ExceptionFilter等。同时该注解还能支持order属性来定义bean的顺序。     </li></ol><h2 id="扩展点使用"><a href="#扩展点使用" class="headerlink" title="扩展点使用"></a>扩展点使用</h2><h3 id="配置文件相关"><a href="#配置文件相关" class="headerlink" title="配置文件相关"></a>配置文件相关</h3><p>配置文件放在哪里？</p><ol><li>META-INF/dubbo/internal/配置文件  </li><li>META-INF/dubbo/配置文件  </li><li>META-INF/services/配置文件  </li></ol><p>配置文件名是顶层接口全限定名，比如：com.alibaba.dubbo.rpc.Protocol  </p><p>配置文件中内容：<br>一行是一个实现类的定义，大致是<br>beanName=实现类的class的全限定名，这个后面还可以接上#xxx（这个能力实际使用少）。beanName=这部分不是必须的。可以仅仅写实现类的全限定名。   </p><h3 id="注解相关"><a href="#注解相关" class="headerlink" title="注解相关"></a>注解相关</h3><h4 id="SPI"><a href="#SPI" class="headerlink" title="SPI"></a>SPI</h4><p>SPI注解用在顶层接口上，其值表示这个接口的默认实现类的beanName，也即是说指定一个顶层接口的默认实现通过SPI注解加载顶层接口上指定即可。  </p><h4 id="Adaptive"><a href="#Adaptive" class="headerlink" title="Adaptive"></a>Adaptive</h4><p>Adaptive注解用在顶层接口或者接口的方法上，其表示这个接口或者这个方法需要有adaptive的类委托完成，未加注解的会生成不支持的操作的方式实现。    </p><h4 id="Activate"><a href="#Activate" class="headerlink" title="Activate"></a>Activate</h4><p>Activate注解用在实现类上，其表示实现类在rpc时根据url参数中以及注解中指定的key 目标value是否能匹配来决定此bean是否被选中(一般用在过滤器的命中判断上)。  </p><h2 id="生成的代码"><a href="#生成的代码" class="headerlink" title="生成的代码"></a>生成的代码</h2><h3 id="adaptive类代码示例"><a href="#adaptive类代码示例" class="headerlink" title="adaptive类代码示例"></a>adaptive类代码示例</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.alibaba.dubbo.registry;<span class="hljs-keyword">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RegistryFactory</span>$<span class="hljs-title">Adaptive</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">com</span>.<span class="hljs-title">alibaba</span>.<span class="hljs-title">dubbo</span>.<span class="hljs-title">registry</span>.<span class="hljs-title">RegistryFactory</span> </span>&#123;<span class="hljs-keyword">public</span> com.alibaba.dubbo.registry.<span class="hljs-function">Registry <span class="hljs-title">getRegistry</span><span class="hljs-params">(com.alibaba.dubbo.common.URL arg0)</span> </span>&#123;<span class="hljs-keyword">if</span> (arg0 == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"url == null"</span>);com.alibaba.dubbo.common.URL url = arg0;String extName = (url.getProtocol() == <span class="hljs-keyword">null</span> ? <span class="hljs-string">"dubbo"</span> : url.getProtocol());<span class="hljs-keyword">if</span> (extName == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Fail to get extension(com.alibaba.dubbo.registry.RegistryFactory) name from url("</span> + url.toString()+ <span class="hljs-string">") use keys([protocol])"</span>);com.alibaba.dubbo.registry.RegistryFactory extension = (com.alibaba.dubbo.registry.RegistryFactory) ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.registry.RegistryFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getExtension</span>(<span class="hljs-title">extName</span>)</span>;<span class="hljs-keyword">return</span> extension.getRegistry(arg0);&#125;&#125;</code></pre><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.alibaba.dubbo.rpc.cluster;<span class="hljs-keyword">import</span> com.alibaba.dubbo.common.extension.ExtensionLoader;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cluster</span>$<span class="hljs-title">Adaptive</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">com</span>.<span class="hljs-title">alibaba</span>.<span class="hljs-title">dubbo</span>.<span class="hljs-title">rpc</span>.<span class="hljs-title">cluster</span>.<span class="hljs-title">Cluster</span> </span>&#123;<span class="hljs-keyword">public</span> com.alibaba.dubbo.rpc.<span class="hljs-function">Invoker <span class="hljs-title">join</span><span class="hljs-params">(com.alibaba.dubbo.rpc.cluster.Directory arg0)</span></span><span class="hljs-function"><span class="hljs-keyword">throws</span> com.alibaba.dubbo.rpc.RpcException </span>&#123;<span class="hljs-keyword">if</span> (arg0 == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"com.alibaba.dubbo.rpc.cluster.Directory argument == null"</span>);<span class="hljs-keyword">if</span> (arg0.getUrl() == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"com.alibaba.dubbo.rpc.cluster.Directory argument getUrl() == null"</span>);com.alibaba.dubbo.common.URL url = arg0.getUrl();String extName = url.getParameter(<span class="hljs-string">"cluster"</span>, <span class="hljs-string">"failover"</span>);<span class="hljs-keyword">if</span> (extName == <span class="hljs-keyword">null</span>)<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Fail to get extension(com.alibaba.dubbo.rpc.cluster.Cluster) name from url("</span> + url.toString()+ <span class="hljs-string">") use keys([cluster])"</span>);com.alibaba.dubbo.rpc.cluster.Cluster extension = (com.alibaba.dubbo.rpc.cluster.Cluster) ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.rpc.cluster.Cluster<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">getExtension</span>(<span class="hljs-title">extName</span>)</span>;<span class="hljs-keyword">return</span> extension.join(arg0);&#125;&#125;</code></pre><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><p>查找所有的dubbo扩展点形式的配置文件  </p><pre><code class="hljs shell">find ./ -type f -name "com.alibaba.dubbo*"|grep -v "/target/"|grep -v "/bin/"|grep -v "/test/"</code></pre><p>另：<br>关于代理模式，dubbo未实现通用的，只是rpc语义实现里rpc调用的代理，借助扩展点机器加动态代理完成。<br>具体其顶层接口是com.alibaba.dubbo.rpc.ProxyFactory。用在比如将EchoService编织进每次RPC调用中。  </p>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>guice的能力简述</title>
    <link href="/2020/04/20/guice-features-brief-introducting/"/>
    <url>/2020/04/20/guice-features-brief-introducting/</url>
    
    <content type="html"><![CDATA[<p>guice这个google出的bean容器框架，ES有用到他。  </p><h2 id="能干什么"><a href="#能干什么" class="headerlink" title="能干什么"></a>能干什么</h2><ol><li>是一个bean容器</li><li>能AOPa</li></ol><h2 id="能力细分与使用方式"><a href="#能力细分与使用方式" class="headerlink" title="能力细分与使用方式"></a>能力细分与使用方式</h2><ol><li>以module创建injector。可以看成是一个容器。Module需要自定义且继承自他的AbstractModule。覆写config方法完成装配关系的确定。详细参见<a href="https://gitee.com/xiaguangme/guice-demo/blob/master/src/main/java/com/code260/ss/guice/demo/bill/BillingModule.java" target="_blank" rel="noopener">这里</a>  </li><li>绑定顶层接口到具体实现类。bind(TransactionLog.class).to(DatabaseTransactionLog.class); 支持bind(A).to(B) 然后链式的 bind(B).to(C)</li><li>支持在构造函数上打上Inject注解标签，用于注入字段</li><li>支持自定义注解用于标志装配目标，比如自定义注解Paypal。  对于加了PayPal注解的参数，注入PaypalCreditCardProcessor实现，其余的注入GoogleCheckoutProcessor实现。bind(CreditCardProcessor.class).annotatedWith(PayPal.class).to(PaypalCreditCardProcessor.class);</li><li>对于加了Named注解 其值为testnamed的地方注入TestNamedCreditCardProcessor实现。bind(CreditCardProcessor.class).annotatedWith(Names.named(“testnamed”)).to(TestNamedCreditCardProcessor.class);</li><li>结合Named注解 可以将一个参数绑定一个特定的instance 而不是一个实现类。bind(Integer.class).annotatedWith(Names.named(“chargeTimeout”)).toInstance(200);</li><li>可以使用Provides注解 主动对外提供创建的bean 有点类似 Spring的@Bean注解，这种方式可以对bean做自定义加工。相当于反转了bind的那个动作  同时也可以结合 自定义注解 使用 比如上面的@Paypal 效果相同。但是这种方式创建的bean不能参与AOP 因为instance是用户创建的嘛,所以任何额外逻辑编编织不进去了。那怎么解决这个问题，guice在bind后提供了toConstructor方法去指定实现类。这样就连Inject注解都不需要了。因为这个实现类可能是三方提供的。</li><li>用自定义注解的方式结合bindInterceptor方式完成 本质上是个拦截器 AOP这些接口遵循AOP联盟约定。 有点类似jfinal的理念。</li></ol><h2 id="部分示例代码"><a href="#部分示例代码" class="headerlink" title="部分示例代码"></a>部分示例代码</h2><p>全部的参见<a href="https://gitee.com/xiaguangme/guice-demo" target="_blank" rel="noopener">这里</a>  </p><h3 id="测试主类"><a href="#测试主类" class="headerlink" title="测试主类"></a>测试主类</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code260.ss.guice.demo.bill;<span class="hljs-keyword">import</span> com.google.inject.Guice;<span class="hljs-keyword">import</span> com.google.inject.Injector;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMain</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 1. 以module创建injector</span><span class="hljs-comment">         */</span>        Injector injector = Guice.createInjector(<span class="hljs-keyword">new</span> BillingModule());        RealBillingService billingService = injector.getInstance(RealBillingService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        billingService.chargeOrder(<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);        TestCustomAnnotationBillingService testCustomAnnotationBillingService = injector.getInstance(TestCustomAnnotationBillingService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        testCustomAnnotationBillingService.chargeOrder(<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);        TestNamedBillingService testNamedBillingService = injector.getInstance(TestNamedBillingService<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;        testNamedBillingService.chargeOrder(<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);    &#125;&#125;</code></pre><h3 id="module"><a href="#module" class="headerlink" title="module"></a>module</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code260.ss.guice.demo.bill;<span class="hljs-keyword">import</span> com.google.inject.AbstractModule;<span class="hljs-keyword">import</span> com.google.inject.Provides;<span class="hljs-keyword">import</span> com.google.inject.matcher.Matcher;<span class="hljs-keyword">import</span> com.google.inject.matcher.Matchers;<span class="hljs-keyword">import</span> com.google.inject.name.Names;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BillingModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractModule</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configure</span><span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 2. 绑定接口到实现类</span><span class="hljs-comment">         */</span>        <span class="hljs-comment">/**</span><span class="hljs-comment">         * LinkedBindings</span><span class="hljs-comment">         * 支持 bind(A).to(B) 然后链式的 bind(B).to(C)</span><span class="hljs-comment">         * to完之后 还支持in in后面接的是Scope 有Singleton</span><span class="hljs-comment">         */</span>        bind(TransactionLog<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">to</span>(<span class="hljs-title">DatabaseTransactionLog</span>.<span class="hljs-title">class</span>)</span>;        bind(CreditCardProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">to</span>(<span class="hljs-title">GoogleCheckoutProcessor</span>.<span class="hljs-title">class</span>)</span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 6. 结合Named注解 可以将一个参数绑定一个特定的instance 而不是一个实现类</span><span class="hljs-comment">         */</span>        bind(Integer.class).annotatedWith(Names.named("chargeTimeout")).toInstance(200);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 4. 对于加了PayPal注解的参数，注入PaypalCreditCardProcessor实现，其余的注入GoogleCheckoutProcessor实现</span><span class="hljs-comment">         */</span>        bind(CreditCardProcessor<span class="hljs-class">.<span class="hljs-keyword">class</span>).<span class="hljs-title">annotatedWith</span>(<span class="hljs-title">PayPal</span>.<span class="hljs-title">class</span>).<span class="hljs-title">to</span>(<span class="hljs-title">PaypalCreditCardProcessor</span>.<span class="hljs-title">class</span>)</span>;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 5. 对于加了Named注解 其值为testnamed的地方注入TestNamedCreditCardProcessor实现</span><span class="hljs-comment">         */</span>        bind(CreditCardProcessor.class).annotatedWith(Names.named("testnamed")).to(TestNamedCreditCardProcessor.class);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 8. 用自定义注解的方式结合bindInterceptor方式完成 本质上是个拦截器 有点类似jfinal的理念</span><span class="hljs-comment">         */</span>        bindInterceptor(Matchers.any(), Matchers.annotatedWith(NonWeekend<span class="hljs-class">.<span class="hljs-keyword">class</span>), <span class="hljs-title">new</span> <span class="hljs-title">NotOnWeekendsInterceptor</span>())</span>;    &#125;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 7. 可以使用Provides注解 主动对外提供创建的bean 有点类似 Spring的<span class="hljs-doctag">@Bean</span>注解，这种方式可以对bean做自定义加工</span><span class="hljs-comment">     * 相当于反转了bind的那个动作  同时也可以结合 自定义注解 使用 比如上面的<span class="hljs-doctag">@Paypal</span> 效果相同</span><span class="hljs-comment">     * 但是这种方式创建的bean不能参与AOP 因为instance是用户创建的嘛,所以任何额外逻辑编编织不进去了。</span><span class="hljs-comment">     * 那怎么解决这个问题，guice在bind后提供了toConstructor方法去指定实现类。</span><span class="hljs-comment">     * 这样就连Inject注解都不需要了。因为这个实现类可能是三方提供的</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Provides</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> AlertService <span class="hljs-title">provideAlertService</span><span class="hljs-params">()</span> </span>&#123;        RedAlertService redAlertService = <span class="hljs-keyword">new</span> RedAlertService();        redAlertService.setTestAttribute();        <span class="hljs-keyword">return</span> redAlertService;    &#125;&#125;</code></pre><h3 id="用于AOP的拦截器类"><a href="#用于AOP的拦截器类" class="headerlink" title="用于AOP的拦截器类"></a>用于AOP的拦截器类</h3><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.code260.ss.guice.demo.bill;<span class="hljs-keyword">import</span> org.aopalliance.intercept.MethodInterceptor;<span class="hljs-keyword">import</span> org.aopalliance.intercept.MethodInvocation;<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotOnWeekendsInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation methodInvocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;        System.out.println(<span class="hljs-string">"do something before NotOnWeekendsInterceptor invoke"</span>);        Object result =  methodInvocation.proceed();        System.out.println(<span class="hljs-string">"do something after NotOnWeekendsInterceptor invoke"</span>);        <span class="hljs-keyword">return</span> result;    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>guice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用部分函数时并未include其所在头文件，但是能编译成功且能运行，为什么？</title>
    <link href="/2020/04/20/not-include-but-why-successfully/"/>
    <url>/2020/04/20/not-include-but-why-successfully/</url>
    
    <content type="html"><![CDATA[<p>最近在看APUE，试了上面的一些例子，其中有个例子是使用getpid函数获取进程id，但是在我写demo时，并未引入其所在的头文件unistd.h，结果也能编译成功，也能运行，于是就琢磨下为啥。<br>Environment info: Ubuntu 18.04.2 LTS, gcc (Ubuntu 4.8.5-4ubuntu8) 4.8.5<br>示意代码如下：  </p><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span> </span>&#123;    <span class="hljs-keyword">long</span> pid = (<span class="hljs-keyword">long</span>)getpid();    <span class="hljs-keyword">long</span> test = pid + <span class="hljs-number">1</span>;&#125;</code></pre><p>在satckoverflow上有人告诉我，因为我用的是GCC4系列，使用是的C90标准且自带GUN扩展，所以对这种问题不给出警告，且能成功运行。<br>如果是C99标准就会编译时有警告。<br>同时指出即使能成功运行但是这是一个不好的习惯，所以还是要严格include  </p><p>我意外试了下 在CDT中可以一样使用ctrl+shift+o 进行自动include<br>也可以使用  ctrl+shift+T 进行库查找…  </p>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c cpp编程用到的系统边角与其拾遗</title>
    <link href="/2020/04/20/cpp-programming-scraps/"/>
    <url>/2020/04/20/cpp-programming-scraps/</url>
    
    <content type="html"><![CDATA[<h2 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h2><p>Q：unix编程怎么查一个函数在哪个头文件中<br>A: 可以用诸如 man 3 printf  </p><p>Q: man后面接个数字什么意思，如man 3 printf<br>A：如下 man man中的引用</p><blockquote><p>下表显示了手册的 章节 号及其包含的手册页类型。<br>1   可执行程序或 shell 命令<br>2   系统调用(内核提供的函数)<br>3   库调用(程序库中的函数)<br>4   特殊文件(通常位于 /dev)<br>5   文件格式和规范，如 /etc/passwd<br>6   游戏<br>7   杂项(包括宏包和规范，如 man(7)，groff(7))<br>8   系统管理命令(通常只针对 root 用户)<br>9   内核例程 [非标准  </p></blockquote><p>Q: 怎么在man的所有章节中搜索<br>A： man -k printf   </p><pre><code class="hljs shell">appweb@simon-ububtu18-desk-2:~/600.self/03.code/01.cpp/03.APUE$ man -k printfasprintf (3)         - print to allocated stringdprintf (3)          - formatted output conversionfprintf (3)          - formatted output conversionfwprintf (3)         - formatted wide-character output conversionprintf (1)           - format and print dataprintf (3)           - formatted output conversionsnprintf (3)         - formatted output conversionsprintf (3)          - formatted output conversionswprintf (3)         - formatted wide-character output conversionvasprintf (3)        - print to allocated stringvdprintf (3)         - formatted output conversionvfprintf (3)         - formatted output conversionvfwprintf (3)        - formatted wide-character output conversionvprintf (3)          - formatted output conversionvsnprintf (3)        - formatted output conversionvsprintf (3)         - formatted output conversionvswprintf (3)        - formatted wide-character output conversionvwprintf (3)         - formatted wide-character output conversionwprintf (3)          - formatted wide-character output conversionXtAsprintf (3)       - memory management functions</code></pre><p>可以看到1和3中都有  1中是对应shell的 3中对应的是程序库中的    </p><p>Q: 怎么查看编译器在哪些路径中搜索头文件<br>A：如下：<br>可以参见 <a href="https://stackoverflow.com/questions/344317/where-does-gcc-look-for-c-and-c-header-files" target="_blank" rel="noopener">https://stackoverflow.com/questions/344317/where-does-gcc-look-for-c-and-c-header-files</a><br>大意与验证如下：  </p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 对于c++的如下： </span>appweb@simon-ububtu18-desk-2:~/600.self/03.code/01.cpp/03.APUE$ `gcc -print-prog-name=cc1plus` -vignoring nonexistent directory "/usr/lib/gcc/x86_64-linux-gnu/4.8/../../../../x86_64-linux-gnu/include"<span class="hljs-meta">#</span><span class="bash">include <span class="hljs-string">"..."</span> search starts here:</span><span class="hljs-meta">#</span><span class="bash">include &lt;...&gt; search starts here:</span> /usr/include/c++/4.8 /usr/include/x86_64-linux-gnu/c++/4.8 /usr/include/c++/4.8/backward /usr/lib/gcc/x86_64-linux-gnu/4.8/include /usr/local/include /usr/lib/gcc/x86_64-linux-gnu/4.8/include-fixed /usr/includeEnd of search list.^C<span class="hljs-meta">#</span><span class="bash"> 对于c的如下：  </span>appweb@simon-ububtu18-desk-2:~/600.self/03.code/01.cpp/03.APUE$ `gcc -print-prog-name=cpp` -vUsing built-in specs.COLLECT_GCC=cppOFFLOAD_TARGET_NAMES=nvptx-noneOFFLOAD_TARGET_DEFAULT=1Target: x86_64-linux-gnuConfigured with: ../src/configure -v --with-pkgversion='Ubuntu 7.4.0-1ubuntu1~18.04.1' --with-bugurl=file:///usr/share/doc/gcc-7/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-7 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-libmpx --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnuThread model: posixgcc version 7.4.0 (Ubuntu 7.4.0-1ubuntu1~18.04.1) COLLECT_GCC_OPTIONS='-E' '-v' '-mtune=generic' '-march=x86-64' /usr/lib/gcc/x86_64-linux-gnu/7/cc1 -E -quiet -v -imultiarch x86_64-linux-gnu - -mtune=generic -march=x86-64 -fstack-protector-strong -Wformat -Wformat-securityignoring nonexistent directory "/usr/local/include/x86_64-linux-gnu"ignoring nonexistent directory "/usr/lib/gcc/x86_64-linux-gnu/7/../../../../x86_64-linux-gnu/include"<span class="hljs-meta">#</span><span class="bash">include <span class="hljs-string">"..."</span> search starts here:</span><span class="hljs-meta">#</span><span class="bash">include &lt;...&gt; search starts here:</span> /usr/lib/gcc/x86_64-linux-gnu/7/include /usr/local/include /usr/lib/gcc/x86_64-linux-gnu/7/include-fixed /usr/include/x86_64-linux-gnu /usr/includeEnd of search list.</code></pre>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cpp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>白菜油渣</title>
    <link href="/2020/04/19/cabbage-residue/"/>
    <url>/2020/04/19/cabbage-residue/</url>
    
    <content type="html"><![CDATA[<p>白菜炒猪油渣，朴素的美食</p><p><img src="/img/food/WechatIMG317.jpeg" srcset="/img/loading.gif" alt="白菜炒猪油渣"></p>]]></content>
    
    
    <categories>
      
      <category>life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>food</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JVM G1源码分析和调优》读书笔记</title>
    <link href="/2020/04/19/jvm-g1-gc-book/"/>
    <url>/2020/04/19/jvm-g1-gc-book/</url>
    
    <content type="html"><![CDATA[<h2 id="GC的相关算法与JVM的垃圾收集器"><a href="#GC的相关算法与JVM的垃圾收集器" class="headerlink" title="GC的相关算法与JVM的垃圾收集器"></a>GC的相关算法与JVM的垃圾收集器</h2><h3 id="GC的相关算法"><a href="#GC的相关算法" class="headerlink" title="GC的相关算法"></a>GC的相关算法</h3><ul><li>分代管理</li><li>复制算法</li><li>标记清除</li><li>标记压缩</li></ul><h3 id="JVM垃圾收集器"><a href="#JVM垃圾收集器" class="headerlink" title="JVM垃圾收集器"></a>JVM垃圾收集器</h3><p>P242 表11-1 不同类型垃圾回收期比较  </p><ul><li>串行收集器 Serial。  Serial GC用于新生代，用了复制算法；Serial Old GC作用于老年代，用的是标记-压缩算法。STW</li><li>并行收集器 Parallel。Parallel new作用于新生代，使用了复制算法；Parallel old作用于老年代，用了标记-压缩算法。STW。并发收集是准确收集，不会产生浮动垃圾。</li><li>并发收集器 Concurrent-Mark-Sweep。老年代垃圾回收器。使用了标记-清除算法。分为初始标记(Initial-Mark,STW)、并发标记(Concurrent-Mark)、再次标记(Remark,STW)、并发清除(Concurrent-Sweep)。CMS因为需要存储代际的引用关系，所以有额外的存储空间的消耗。CMS不是准确收集，会产生浮动垃圾。</li><li>垃圾优先收集器 G1。按照分区进行收集，新生代的分区总是会回收，老生代则是并发标记后选择部分回收效果最好的分区。G1分为三种回收方式：<code>新生代回收</code>young、<code>混合回收</code>(mixed，既收集新生代也收集部分老年代)、<code>FUll GC</code>。<code>新生代回收</code>仅仅在开始前需要STW。<code>混合回收</code>分成两个阶段：并发标记阶段与垃圾回收阶段。并发标记阶段又分四个步骤：初始标记子阶段(initital-mark)、并发标记子阶段(concurrent-mark)、再标记子阶段(remark,STW)、清理子阶段(cleanup,STW)。因分区设计，G1引用关系的存储占用额外空间的消耗较大。G1不是准确收集，会产生浮动垃圾。</li></ul><h2 id="G1基本概念"><a href="#G1基本概念" class="headerlink" title="G1基本概念"></a>G1基本概念</h2><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>G1是将内存分成一个个小区域使用。这些区域称之为Heap Region。扩展的有<code>YHR</code>(新生代分区)，<code>OHR</code>(老生代分区)，<code>HHR</code>(大对象分区)等等<br>为了达到分配效率与清理效率的平衡，HR的大小有上下限值，即1MB-32MB。结合整个堆空间分为2048个HR，那么通常G1管理的最大的堆是32MB*2048=64G。  </p><h3 id="新生代大小"><a href="#新生代大小" class="headerlink" title="新生代大小"></a>新生代大小</h3><h4 id="用参数设置使得G1能推断出最大值与最小值"><a href="#用参数设置使得G1能推断出最大值与最小值" class="headerlink" title="用参数设置使得G1能推断出最大值与最小值"></a>用参数设置使得G1能推断出最大值与最小值</h4><p>涉及的参数有:</p><ul><li>新生代最大值MaxNewSize、最小值NewSize、Xmn(等价于MaxNewSize和NewSize，且MaxNewSize=NewSize)</li><li>NewRatio，如果上条参数设置了，则忽略本参数</li><li>如果仅仅设置了NewRatio，则新生代最大值与最小值相同：整个堆空间/(newRatio+1)</li><li>如果没有设置最大值和最小值，或者只设置了其中一个，那么G1将根据参数G1MaxNewSizePercent(默认60)和G1NewSizePercent(默认是5)占整个堆空间的比例来计算。</li></ul><p><strong>如果G1推断出的新生代的最大值与最小值相等，则说明新生代不会动态变化，不会动态变化则可能导致后续新生代GC时不能满足期望的停顿时间</strong>，所以有文章提到G1不建议设置Xmn参数。  </p><p>相关代码在 share/vm/gc_implementation/g1/g1collectorPolicy.cpp  </p><h3 id="G1启发式推断新生代大小"><a href="#G1启发式推断新生代大小" class="headerlink" title="G1启发式推断新生代大小"></a>G1启发式推断新生代大小</h3><p>G1有一个线程专门抽样处理预测新生代列表的长度应该多大，并动态调整。  </p><p>何时扩展以及一次扩展多少内存？<br>参数-XX:GCTimeRatio 表示GC与应用的耗费时间的比，G1默认是9。也就是说GC的耗时与应用耗时占比超过10%时，进行动态扩展。扩展大小的参数是G1ExpandByPercentOfAvailable，同时至少大于1MB，至多不能超过当前已经分配的大小的一倍。<br>代码在 size_t G1CollectorPolicy::expansion_amount()….<br>该书在第五章讲refine线程时对此点有更详细的阐述  </p><h3 id="G1停顿预测模型"><a href="#G1停顿预测模型" class="headerlink" title="G1停顿预测模型"></a>G1停顿预测模型</h3><p>比较偏数学 我就很快跳过去了<br>G1的预测逻辑是基于衰减平均(Decaying Average)和衰减标准差。  </p><h3 id="卡表和位图"><a href="#卡表和位图" class="headerlink" title="卡表和位图"></a>卡表和位图</h3><p>卡表(CardTable)是CMS中中常见概念之一。我理解成分区间对象引用关系的描述 的存放处或者说存放的数据结构。此书也是讲的较为简略，细节可以参见《垃圾回收算法手册：自动内存管理的艺术》  </p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>讲JVM内存模型必讲对象头。可以参见我写的<a href="cnblogs.com/simoncook/p/11804427.html">JVM中对象模型及相应名词概念</a>  </p><h3 id="栈帧、线程等"><a href="#栈帧、线程等" class="headerlink" title="栈帧、线程等"></a>栈帧、线程等</h3><p>栈帧可以参见 封亚飞 写的《揭秘Java虚拟机》第七章 Java栈帧，写的更详细。此书只是一笔带过，看了跟没看没啥差别。  </p><h2 id="G1的对象分配"><a href="#G1的对象分配" class="headerlink" title="G1的对象分配"></a>G1的对象分配</h2><ul><li>快速分配与慢速分配</li><li>快速分配通过TLAB(Thread Local Allocation Buffer)实现。TLAB自己的分配是CAS操作。TLAB内部给对象分配是无锁的，因为只有自己线程用嘛。  </li><li>TLAB机制或产生内存浪费，因为一个对象不会分配在两个TLAB区域，所以TLAB最末端的尾巴区域可能会残留空着。可以通过TLABRefillWasteFraction参数调整，表示允许产生浪费的比例。默认值是64，即表示1/64空间可以浪费。</li><li>TLAB大小可以自动调整，但是上限不会超过HR的一半。、</li><li>可以使用参数-XX:-ResizeTLAB禁用ResizeTLAB，并使用参数-XX:TLABSize指定一个大小。-XX:+PrintTLAB可以跟踪TLAB工作情况。</li><li><strong>一般不建议修改TLAB参数，建议使用默认值</strong></li></ul><p>TLAB快速分配的代码在 HeapWord* CollectedHeap::allocate_from_tlab…  </p><h2 id="G1的Refine线程"><a href="#G1的Refine线程" class="headerlink" title="G1的Refine线程"></a>G1的Refine线程</h2><p>先讲Rset</p><h3 id="Rset"><a href="#Rset" class="headerlink" title="Rset"></a>Rset</h3><p>Rset是干什么用的？  </p><ul><li>Rset是一种抽象概念，记录了在不同代际之间的引用关系，目的是为了加速GC。</li><li>通俗地说，可以用Rset记录从非收集部分指向收集部分的指针集合。对于这种记录述求，有两种方式，一是<code>我引用了谁</code>，称为<code>Point Out</code>；一是<code>谁引用了我</code>，称为<code>Point In</code>。G1采用后者。</li><li>G1中需要记录代际之间的引用关系包括：老生代分区到新生代分区之间的引用关系(YGC时，这个引用关系是GC Roots的一部分，老生代引用过来的不能被回收掉嘛…)；老生代分区到老生代分区之间的引用关系(混合GC时用)</li><li>Rset与卡表的关系参见P68图4-1</li><li>G1引入了PRT，TODO：没看太懂</li><li>DCQ与Refinemnet zone的四色区域没看太懂</li></ul><h3 id="Rset写屏障"><a href="#Rset写屏障" class="headerlink" title="Rset写屏障"></a>Rset写屏障</h3><p>为啥谈到写屏障，因为Refine是线程关注的是应用关系的变更，但是他是如何识别引用关系的变更的呢？就是靠写屏障完成。下面讲写屏障相关要点：  </p><ul><li>写屏障这个词我不知道为啥这样命名，直觉上不好理解。  </li><li>我对其的理解就是，写操作前后的拦截器处理。比如我对字段赋值putfield，在赋值前我要告诉DCQ这个对象被我引用了，这就是写屏障动作。  </li><li>书上的说法：<code>写屏障</code>是指在改变特定内存的值时，额外执行的一些动作。  </li><li>CMS是通过写屏障记录引用刮不洗，G1也是。  </li><li>写屏障会有优化，不是所有的引用关系变更都会被记录。  <ul><li>不记录新生代到新生代的引用，或者新生代到老生代的引用，在写屏障时过滤</li><li>过滤掉同一个分区内部引用，在Rset处理时过滤</li><li>过滤掉空引用，在Rset处理时过滤</li></ul></li></ul><h3 id="Refine线程"><a href="#Refine线程" class="headerlink" title="Refine线程"></a>Refine线程</h3><ul><li>Refine线程是一组，是一个线程池，不是一个。</li><li>我对他的理解是，一个线程用于抽样，主要作用设置新生代分区的个数。其余线程用于管理Rset，Rset的更新不是同步完成的，是靠Refine线程异步完成的，异步又是靠DCQ dirty card queue队列暂存过渡的。 </li><li>Refine涉及的JVM比较复杂，未细细研究</li><li>相关参数：可以通过-XX:+G1TraceConcRefinement观察Refine线程工作情况。通过-XX:+G1SummarizeRSetStats观察Rset更新。</li></ul><h2 id="新生代回收"><a href="#新生代回收" class="headerlink" title="新生代回收"></a>新生代回收</h2><p>上面已经讲了，G1 GC分三种： <code>新生代回收</code>young、<code>混合回收</code>(mixed，既收集新生代也收集部分老年代)、<code>FUll GC</code>  </p><p>步骤：  </p><ol><li>选择CSet</li><li>根处理</li><li>Rset处理</li><li>复制</li><li>Redirty 重构Rset</li><li>释放空间  </li></ol><h3 id="相关日志"><a href="#相关日志" class="headerlink" title="相关日志"></a>相关日志</h3><p>可以用-XX:G1LogLevel=finest 打开更详细的日志<br>关键字 GC pause (G1 Evacuation Pause) (young)， 0.0182341 secs…  </p><h3 id="参数调优"><a href="#参数调优" class="headerlink" title="参数调优"></a>参数调优</h3><h2 id="混合回收"><a href="#混合回收" class="headerlink" title="混合回收"></a>混合回收</h2><p><code>混合回收</code>分成两个阶段：</p><ul><li>并发标记阶段</li><li>垃圾回收阶段(与新生代回收一致)  </li></ul><p>并发标记阶段又分四个步骤：</p><ol><li>初始标记子阶段(initital-mark)</li><li>并发标记子阶段(concurrent-mark)</li><li>再标记子阶段(remark,STW)</li><li>清理子阶段(cleanup,STW</li></ol><p>并发标记的难点：<br>正在标记过程中的对象引用关系发生了改变。<br>通过三色标记法与STAB算法结合写屏障完成。<br>写屏障代码在 oop_store中,oop.inline.hpp  </p><h3 id="相关日志-1"><a href="#相关日志-1" class="headerlink" title="相关日志"></a>相关日志</h3><p>关键字 GC pause (G1 Evacuation Pause) (mixed)， 0.0106341 secs…<br> GC pause (G1 Evacuation Pause) (young) (initial-mark),….  // 初始标记借用了YGC<br>[GC concurrent-mark-start]…<br>[GC concurrent-mark-end]…<br>[GC remark …]…<br>[GC cleanup …]…  </p><h3 id="参数调优-1"><a href="#参数调优-1" class="headerlink" title="参数调优"></a>参数调优</h3><h2 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h2><p>JDK10之前FGC是串行的，JDK10之后支持并行。<br>代码在 G1CollectedHeap::do_collection<br>串行回收采用标记清除算法，步骤：  </p><ol><li>标记活跃对象</li><li>计算新对象地址</li><li>把所有对象都更新到新地址上</li><li>移动对象完成压缩</li></ol><h3 id="相关日志-2"><a href="#相关日志-2" class="headerlink" title="相关日志"></a>相关日志</h3><p>[Full GC (Allocation Failure) …..  0.2036229 secs]….  </p><h2 id="G1调优"><a href="#G1调优" class="headerlink" title="G1调优"></a>G1调优</h2><p>主要涉及的指标有： 吞吐量最大、停段时间尽量端、GC频率尽量低和堆空间的有效利用率高。<br>主要调优参数 参见P244 表11-2，主要涉及堆、RSet、标记和GC四个方面的参数。</p>]]></content>
    
    
    <categories>
      
      <category>book-paper-study</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty4 FastThreadLocal及CPU cacheline padding补齐</title>
    <link href="/2020/04/19/netty4-fastthhreadlocal/"/>
    <url>/2020/04/19/netty4-fastthhreadlocal/</url>
    
    <content type="html"><![CDATA[<h2 id="FastThreadLocal"><a href="#FastThreadLocal" class="headerlink" title="FastThreadLocal"></a>FastThreadLocal</h2><p>概述： ThreadLocal的一个特定变种改善，有更好的存取性能。<br>内部采用一个数组来代替ThreadLocal内部的hash表来存放变量。虽然这看起来是微不足道的，但是他确实比hash表性能好那么一点，在频繁存取时会更明显。 如果用DefaultThreadFactory创建线程，那么默认创建出来的就是FastThreadLocalThread，就会用FastThreadLocal。  </p><p>set数据靠InternalThreadLocalMap维护，InternalThreadLocalMap内部靠一个数组(就是上面说的)维护变量数据。  </p><p>扩展了什么:<br>按ThreadLocal API的约定行为，依赖InternalThreadLocalMap实现了这些行为，诸如get、set、remove等。<br>remove支持onRemoval回调。  </p><h2 id="InternalThreadLocalMap"><a href="#InternalThreadLocalMap" class="headerlink" title="InternalThreadLocalMap"></a>InternalThreadLocalMap</h2><h3 id="自身实例获取"><a href="#自身实例获取" class="headerlink" title="自身实例获取"></a>自身实例获取</h3><p>get方法是对外暴露去自身实例的，有两种方式取到InternalThreadLocalMap实例：</p><ul><li>如果当前线程是FastThreadLocalThreadInternal，直接取其实例变量ThreadLocalMap，内部称之为fastGet。  </li><li>如果是JDK的Thread，那么靠JDK的TheadLocal取到ThreadLocalMap，内部称之为slowGet。  </li></ul><h3 id="数据存取"><a href="#数据存取" class="headerlink" title="数据存取"></a>数据存取</h3><p>真正的存取变量是靠<code>indexedVariable</code>和<code>setIndexedVariable</code>方法完成。<br>阅读代码不难发现，是靠Object[]  indexedVariables这个数组达成数据存储的目的。  </p><h3 id="存放数据的数组扩容"><a href="#存放数据的数组扩容" class="headerlink" title="存放数据的数组扩容"></a>存放数据的数组扩容</h3><p>indexedVariables数组靠expandIndexedVariableTableAndSet动态扩容。初始长度是32。<br>扩容算法有点意思，是比当前index小的最大的2的n次方的值扩一倍，比如当前index是132，那么就会扩成256长度的数组。  </p><pre><code class="hljs java">Object[] oldArray = indexedVariables;<span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> oldCapacity = oldArray.length;<span class="hljs-keyword">int</span> newCapacity = index;newCapacity |= newCapacity &gt;&gt;&gt;  <span class="hljs-number">1</span>;newCapacity |= newCapacity &gt;&gt;&gt;  <span class="hljs-number">2</span>;newCapacity |= newCapacity &gt;&gt;&gt;  <span class="hljs-number">4</span>;newCapacity |= newCapacity &gt;&gt;&gt;  <span class="hljs-number">8</span>;newCapacity |= newCapacity &gt;&gt;&gt; <span class="hljs-number">16</span>;newCapacity ++;</code></pre><h3 id="是否完全用数组存放数据？"><a href="#是否完全用数组存放数据？" class="headerlink" title="是否完全用数组存放数据？"></a>是否完全用数组存放数据？</h3><p>不完全是。因为<code>InternalThreadLocalMap</code>的父类<code>UnpaddedInternalThreadLocalMap</code>自带了一些常用的字段：  </p><ul><li>futureListenerStackDepth</li><li>localChannelReaderStackDepth</li><li>handlerSharableCache  </li><li>counterHashCode</li><li>random</li><li>typeParameterMatcherGetCache</li><li>typeParameterMatcherFindCache</li><li>stringBuilder</li><li>charsetEncoderCache</li><li>charsetDecoderCache</li><li>arrayList<br>这个11个是靠实例字段直接存储。<br>另外此类，还用了padding补齐的手段优化了CPU cacheline伪共享的问题。我猜测性能提升主要来源于此。  <pre><code class="hljs java"><span class="hljs-comment">// Cache line padding (must be public)</span><span class="hljs-comment">// With CompressedOops enabled, an instance of this class should occupy at least 128 bytes.</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> rp1, rp2, rp3, rp4, rp5, rp6, rp7, rp8, rp9;</code></pre><h3 id="关于padding补齐"><a href="#关于padding补齐" class="headerlink" title="关于padding补齐"></a>关于padding补齐</h3>该类为了解决cache line伪共享的问题，采用了padding补齐。<br>该类(4.1.32.Final版本)补齐后通过<a href="https://gitee.com/xiaguangme/sizeofobject" target="_blank" rel="noopener">sizeOfObject</a>(也可以用jol)算出来大小是136。  jol针对idea是有插件的，不像JDK带的jol要运行起来才能计算对象大小。idea那个插件是针对语法树分析后算的，因为就算你的类有编译错误，他也能算出来。使用时注意选择相应的压缩模式，右上角。<br>关于jol<a href="http://hg.openjdk.java.net/code-tools/jol/file/833f68a6ba34/jol-samples/src/main/java/org/openjdk/jol/samples/JOLSample_02_Alignment.java" target="_blank" rel="noopener">有官方的sample</a>是很不错的，还<a href="http://zhongmingmao.me/2016/07/01/jvm-jol-tutorial-1/" target="_blank" rel="noopener">有个博客</a>写的还行，包括字段重排等都有。   </li></ul><p><strong>为什么是136？按说128就行啊</strong>？ 这个事情我之前也思索了好久没有答案。直至翦哥今天跟我提到了一个别人前几天<a href="https://github.com/netty/netty/issues/9284" target="_blank" rel="noopener">提的issue</a>，才翻到原来有人和我们有一样的困惑，而且答案竟然是在netty版本迭代过程中InternalThreadLocalMap的父类加了个字段：ArrayList<Object> arrayList;，导致变成了136，之前4.0.33Final版本就是128，我确实使用了这个版本进行了验证，确实是。…. 竟然是这样，不可思议。  </p><blockquote><p>jiangxinlingdu commented 2 days ago<br>I have checked the code in old version and found that the size of InternalThreadLocalMap is 128Bytes in version 4.0.33. And now in latest code in github the size of InternalThreadLocalMap is 136. And the reason is that some has added two parameters: cleanerFlags (in class InternalThreadLocalMap) and arrayList (in parent class UnpaddedInternalThreadLocalMap).<br>In my view, the contributors has pushed the two parameters ignoring the Cache line padding. So it is a problem!  </p></blockquote><blockquote><p>My doubt is solved by you, thank you!!!</p></blockquote><h2 id="FastThreadLocalThread与FastThreadLocalRunnable"><a href="#FastThreadLocalThread与FastThreadLocalRunnable" class="headerlink" title="FastThreadLocalThread与FastThreadLocalRunnable"></a>FastThreadLocalThread与FastThreadLocalRunnable</h2><p>FastThreadLocalThread概述：绑定了<code>InternalThreadLocalMap</code>的线程类。继承于JDK的<code>Thread</code>。<br>FastThreadLocalThread扩展了什么：  </p><ul><li>主要对外暴露了获取与设置<code>InternalThreadLocalMap</code>字段的接口。  </li><li>增加cleanupFastThreadLocals字段并在有Runnable参数的构造函数里，会将<code>cleanupFastThreadLocals</code>字段设置成true。</li></ul><p>因为如果通过FastThreadnLocalThread的有Runnable参数的构造函数构造的FastThreadLocalThread实例时，会将Runnable实例wrap成<code>FastThreadLocalRunnable</code>实例。  FastThreadLocalRunnable又会在其run方法中以finally的方式进行清理当前线程上所有的<code>FastThreadLocal</code>实例中的数据。  </p><pre><code class="hljs java"><span class="hljs-meta">@Override</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">try</span> &#123;        runnable.run();    &#125; <span class="hljs-keyword">finally</span> &#123;        FastThreadLocal.removeAll();    &#125;&#125;</code></pre><p>所以<code>cleanupFastThreadLocals</code>字段意思是此线程<code>会</code>在执行完成时清理当前线程上所有的<code>FastThreadLocal</code>实例中的数据。  </p><p>FastThreadLocalRunnable扩展了什么：  </p><ul><li>如上面所说，会在run方法中用finally清理当前线程上所有的<code>FastThreadLocal</code>实例中的数据。  </li></ul><h2 id="DefaultThreadFactory"><a href="#DefaultThreadFactory" class="headerlink" title="DefaultThreadFactory"></a>DefaultThreadFactory</h2><p>扩展了什么：  </p><ul><li>实现了线程名前缀+自增线程号的模式 </li><li>实现了创建线程时默认使用<code>FastThreadLocalThread</code>实现</li></ul>]]></content>
    
    
    <categories>
      
      <category>opensource-code-study</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>几个递进的make file</title>
    <link href="/2020/04/19/some-make-files/"/>
    <url>/2020/04/19/some-make-files/</url>
    
    <content type="html"><![CDATA[<h2 id="几个递进的make-file"><a href="#几个递进的make-file" class="headerlink" title="几个递进的make file"></a>几个递进的make file</h2><p>春节在家写的几个递进的make file，部分有点问题。接下来 有空我要把GNU make的手册看完。不然这方面太菜了。  </p><p><a href="https://files.cnblogs.com/files/simoncook/gun-make-manual%E4%B8%AD%E8%8B%B1%E6%96%87.zip" target="_blank" rel="noopener">GNU make手册</a><br>都需要make先设置环境变量BUILD_MODE为run或者debug</p><h3 id="1-源文件名-目标都hard-code，且一次编译多个目标"><a href="#1-源文件名-目标都hard-code，且一次编译多个目标" class="headerlink" title="1 源文件名 目标都hard code，且一次编译多个目标"></a>1 源文件名 目标都hard code，且一次编译多个目标</h3><pre><code class="hljs shell">PROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))OBJS = lsdemo.o test.oifeq ($(BUILD_MODE),debug)CFLAGS += -gelse ifeq ($(BUILD_MODE),run)CFLAGS += -O2else<span class="hljs-meta">$</span><span class="bash">(error Build mode $(BUILD_MODE) not supported by this Makefile)</span>endifall:lsdemo testlsdemo:lsdemo.o<span class="hljs-meta">$</span><span class="bash">(CXX) -o <span class="hljs-variable">$@</span> $^</span>lsdemo.o:$(PROJECT_ROOT)/ch01/lsdemo.c<span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span>test:test.o<span class="hljs-meta">$</span><span class="bash">(CXX) -o <span class="hljs-variable">$@</span> $^</span>test.o:$(PROJECT_ROOT)/ch01/test.c<span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span>clean:rm -fr lsdemo test  $(OBJS)</code></pre><h3 id="2-通过OBJS变量定义多个目标文件-通过遍历ch01-目录下所有c文件作为源文件"><a href="#2-通过OBJS变量定义多个目标文件-通过遍历ch01-目录下所有c文件作为源文件" class="headerlink" title="2 通过OBJS变量定义多个目标文件 通过遍历ch01/目录下所有c文件作为源文件"></a>2 通过OBJS变量定义多个目标文件 通过遍历ch01/目录下所有c文件作为源文件</h3><pre><code class="hljs shell">PROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))OBJS = lsdemo.o test.oifeq ($(BUILD_MODE),debug)CFLAGS += -gelse ifeq ($(BUILD_MODE),run)CFLAGS += -O2else<span class="hljs-meta">$</span><span class="bash">(error Build mode $(BUILD_MODE) not supported by this Makefile)</span>endifall:lsdemo lsdemo:$(OBJS)<span class="hljs-meta">$</span><span class="bash">(CXX) -o <span class="hljs-variable">$@</span> $^</span><span class="hljs-meta">%</span><span class="bash">.o:$(PROJECT_ROOT)/ch01/%.c</span><span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">test</span>:test.o</span><span class="hljs-meta">#</span><span class="bash">$(CXX) -o <span class="hljs-variable">$@</span> $^</span><span class="hljs-meta">#</span><span class="hljs-meta">#</span><span class="bash">test.o:$(PROJECT_ROOT)/ch01/test.c</span><span class="hljs-meta">#</span><span class="bash">$(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span><span class="hljs-meta">#</span><span class="bash"></span>clean:rm -fr lsdemo test  $(OBJS)</code></pre><h3 id="3-ch01-ch02-多个子目录下多目标编译"><a href="#3-ch01-ch02-多个子目录下多目标编译" class="headerlink" title="3 ch01 ch02 多个子目录下多目标编译"></a>3 ch01 ch02 多个子目录下多目标编译</h3><pre><code class="hljs shell">PROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))CH01OBJS = lsdemo.o test.oCH02OBJS = test21.o test22.oifeq ($(BUILD_MODE),debug)CFLAGS += -gelse ifeq ($(BUILD_MODE),run)CFLAGS += -O2else<span class="hljs-meta">$</span><span class="bash">(error Build mode $(BUILD_MODE) not supported by this Makefile)</span>endifall:lsdemo ch02lsdemo:$(CH01OBJS)<span class="hljs-meta">$</span><span class="bash">(CXX) -o <span class="hljs-variable">$@</span> $^</span><span class="hljs-meta">%</span><span class="bash">.o:$(PROJECT_ROOT)/ch01/%.c</span><span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span>ch02:$(CH02OBJS)<span class="hljs-meta">$</span><span class="bash">(CXX) -o <span class="hljs-variable">$@</span> $^</span><span class="hljs-meta">%</span><span class="bash">.o:$(PROJECT_ROOT)/ch02/%.c</span><span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">test</span>:test.o</span><span class="hljs-meta">#</span><span class="bash">$(CXX) -o <span class="hljs-variable">$@</span> $^</span><span class="hljs-meta">#</span><span class="hljs-meta">#</span><span class="bash">test.o:$(PROJECT_ROOT)/ch01/test.c</span><span class="hljs-meta">#</span><span class="bash">$(CC) -c $(CFLAGS) $(CPPFLAGS) -o <span class="hljs-variable">$@</span> $&lt;</span><span class="hljs-meta">#</span><span class="bash"></span>clean:rm -fr lsdemo test  $(OBJS)</code></pre><h3 id="4-通过修改CH-NO和APP-NAME切换到底编译哪个子目录下的应用，编译到指定路径下，适用于APUE学习时例程序编写"><a href="#4-通过修改CH-NO和APP-NAME切换到底编译哪个子目录下的应用，编译到指定路径下，适用于APUE学习时例程序编写" class="headerlink" title="4 通过修改CH_NO和APP_NAME切换到底编译哪个子目录下的应用，编译到指定路径下，适用于APUE学习时例程序编写"></a>4 通过修改CH_NO和APP_NAME切换到底编译哪个子目录下的应用，编译到指定路径下，适用于APUE学习时例程序编写</h3><pre><code class="hljs shell">CH_NO = ch01APP_NAME = lsdemo<span class="hljs-meta">#</span><span class="bash"> 获取makefile路径</span>PROJECT_ROOT = $(dir $(abspath $(lastword $(MAKEFILE_LIST))))<span class="hljs-meta">$</span><span class="bash">(info MAKEFILE_LIST is: $(MAKEFILE_LIST))</span><span class="hljs-meta">$</span><span class="bash">(info PROJECT_ROOT is: $(PROJECT_ROOT))</span><span class="hljs-meta">#</span><span class="bash"> 拼接路径</span>SOURCE_FRAGMENT :=$(CH_NO)/$(APP_NAME)SOURCE_ROOT := $(PROJECT_ROOT)$(SOURCE_FRAGMENT)<span class="hljs-meta">$</span><span class="bash">(info SOURCE_ROOT is: $(SOURCE_ROOT))</span>BUILD_ROOT := $(PROJECT_ROOT)build/make.debug.linux.x86_64/$(SOURCE_FRAGMENT)/<span class="hljs-meta">$</span><span class="bash">(info BUILD_ROOT is: $(BUILD_ROOT))</span>ifeq ($(BUILD_MODE),debug)CFLAGS += -gelse ifeq ($(BUILD_MODE),run)CFLAGS += -O2else<span class="hljs-meta">$</span><span class="bash">(error Build mode $(BUILD_MODE) not supported by this Makefile)</span>endif<span class="hljs-meta">$</span><span class="bash">(shell <span class="hljs-keyword">if</span> [ ! -d $(BUILD_ROOT) ]; <span class="hljs-keyword">then</span> mkdir -p $(BUILD_ROOT); <span class="hljs-keyword">fi</span>;)</span>SOURCE := $(shell find $(SOURCE_ROOT) -name '*.c' |xargs -n1 basename)OBJS := $(SOURCE:.c=.o)<span class="hljs-meta">$</span><span class="bash">(info SOURCE is: $(SOURCE))</span><span class="hljs-meta">$</span><span class="bash">(info OBJS is: $(OBJS))</span>all: $(APP_NAME)<span class="hljs-meta">#</span><span class="hljs-meta">$</span><span class="bash">(APP_NAME):$(OBJS)</span><span class="hljs-meta">$</span><span class="bash">(CXX) -o $(BUILD_ROOT)/<span class="hljs-variable">$@</span> $(addprefix $(BUILD_ROOT), $^)</span><span class="hljs-meta">%</span><span class="bash">.o:$(SOURCE_ROOT)/%.c</span><span class="hljs-meta">$</span><span class="bash">(CC) -c $(CFLAGS) $(CPPFLAGS) -o $(BUILD_ROOT)/<span class="hljs-variable">$@</span> $&lt;</span>clean:rm -fr $(BUILD_ROOT)</code></pre><p>附上第四种情况的目录结构：</p><pre><code class="hljs shell">appweb@simon-ububtu18-desk-2:~/600.self/03.code/01.cpp/03.APUE$ tree .├── build│   └── make.debug.linux.x86_64│       └── ch01│           └── lsdemo│               ├── lsdemo│               ├── lsdemo.o│               └── test.o├── ch01│   └── lsdemo│       ├── lsdemo.c│       └── test.c└── Makefile</code></pre>]]></content>
    
    
    <categories>
      
      <category>program-language-practice</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>我的价值观</title>
    <link href="/2020/04/19/MySenseOfWorth/"/>
    <url>/2020/04/19/MySenseOfWorth/</url>
    
    <content type="html"><![CDATA[<h2 id="我的价值观"><a href="#我的价值观" class="headerlink" title="我的价值观"></a>我的价值观</h2><ol><li>一个底线：遵纪守法，远离黄赌毒。</li><li>一个标准：感恩上进，持续努力，享受尽职。</li><li>一个方法论：三人行必有我师，三人行我亦能成师。</li><li>一个技巧：顺势而为。</li><li>一个兜底：凡事有最坏的打算。</li></ol>]]></content>
    
    
    <categories>
      
      <category>think</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
